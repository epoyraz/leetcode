{
  "931_14631217_python": "\"from collections import defaultdict\\n\\nclass FreqStack(object):\\n    def __init__(self):\\n        self.freq = defaultdict(int)       # Maps val -> frequency\\n        self.group = defaultdict(list)     # Maps frequency -> list of values\\n        self.maxfreq = 0                   # Current maximum frequency\\n\\n    def push(self, val):\\n        f = self.freq[val] + 1\\n        self.freq[val] = f\\n        self.group[f].append(val)\\n        if f > self.maxfreq:\\n            self.maxfreq = f\\n\\n    def pop(self):\\n        val = self.group[self.maxfreq].pop()\\n        self.freq[val] -= 1\\n        if not self.group[self.maxfreq]:\\n            self.maxfreq -= 1\\n        return val\\n\"",
  "1620_14631217_python-updated-time": "1746433073131",
  "2139_14631217_python": "\"from collections import defaultdict\\n\\nclass DetectSquares:\\n    def __init__(self):\\n        # count of each point (x,y)\\n        self.pointCount = defaultdict(int)\\n        # for each x, a map y -> count of points at (x,y)\\n        self.colPoints = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point):\\n        x, y = point\\n        self.pointCount[(x, y)] += 1\\n        self.colPoints[x][y] += 1\\n\\n    def count(self, point):\\n        qx, qy = point\\n        res = 0\\n        # iterate over all points (qx, y) sharing x = qx\\n        colMap = self.colPoints[qx]\\n        for y, cnt_y in colMap.items():\\n            if y == qy:\\n                continue\\n            # side length of potential square\\n            d = y - qy\\n            # two candidate x-coordinates for the other corners\\n            for x in (qx + d, qx - d):\\n                cnt1 = self.pointCount.get((x, qy), 0)\\n                cnt2 = self.pointCount.get((x, y), 0)\\n                if cnt1 > 0 and cnt2 > 0:\\n                    # multiply counts for all combinations of duplicates\\n                    res += cnt_y * cnt1 * cnt2\\n        return res\\n\"",
  "1309_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def sortItems(self, n, m, group, beforeItems):\\n        # Assign unique group ID to ungrouped items\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = m\\n                m += 1\\n\\n        # Build graphs\\n        item_graph = defaultdict(list)\\n        item_indegree = [0] * n\\n\\n        group_graph = defaultdict(list)\\n        group_indegree = [0] * m\\n\\n        for curr in range(n):\\n            for prev in beforeItems[curr]:\\n                item_graph[prev].append(curr)\\n                item_indegree[curr] += 1\\n                if group[prev] != group[curr]:\\n                    group_graph[group[prev]].append(group[curr])\\n                    group_indegree[group[curr]] += 1\\n\\n        def topo_sort(nodes, graph, indegree):\\n            res = []\\n            q = deque([node for node in nodes if indegree[node] == 0])\\n            while q:\\n                u = q.popleft()\\n                res.append(u)\\n                for v in graph[u]:\\n                    indegree[v] -= 1\\n                    if indegree[v] == 0:\\n                        q.append(v)\\n            return res if len(res) == len(nodes) else []\\n\\n        # Topo sort all items and all groups\\n        all_items = list(range(n))\\n        item_order = topo_sort(all_items, item_graph, item_indegree[:])\\n        if not item_order:\\n            return []\\n\\n        all_groups = list(range(m))\\n        group_order = topo_sort(all_groups, group_graph, group_indegree[:])\\n        if not group_order:\\n            return []\\n\\n        # Map group to items in topological order\\n        group_to_items = defaultdict(list)\\n        for item in item_order:\\n            group_to_items[group[item]].append(item)\\n\\n        # Assemble final result based on group order\\n        res = []\\n        for g in group_order:\\n            res.extend(group_to_items[g])\\n\\n        return res\\n\"",
  "3716_14631217_python-updated-time": "1747653390122",
  "801_14631217_python-updated-time": "1745877492877",
  "3508_14631217_python-updated-time": "1747487853388",
  "1058_14631217_python": "\"class Solution(object):\\n    def smallestEquivalentString(self, s1, s2, baseStr):\\n        \\\"\\\"\\\"\\n        :type s1: str\\n        :type s2: str\\n        :type baseStr: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        parent = [i for i in range(26)]  # one for each lowercase letter\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            px = find(x)\\n            py = find(y)\\n            if px == py:\\n                return\\n            # always attach the larger root to the smaller one (lex order)\\n            if px < py:\\n                parent[py] = px\\n            else:\\n                parent[px] = py\\n\\n        for a, b in zip(s1, s2):\\n            union(ord(a) - ord('a'), ord(b) - ord('a'))\\n\\n        result = []\\n        for ch in baseStr:\\n            smallest = find(ord(ch) - ord('a'))\\n            result.append(chr(smallest + ord('a')))\\n\\n        return ''.join(result)\\n\"",
  "1778_14631217_python": "\"class Solution:\\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\\n        # 1) Enumerate all base‑3 masks of length n\\n        masks = []\\n        cntIntro = {}\\n        cntExtro = {}\\n        innerScore = {}\\n        \\n        for mask in range(3**n):\\n            arr = []\\n            x = mask\\n            i_count = e_count = 0\\n            for _ in range(n):\\n                d = x % 3\\n                arr.append(d)\\n                if d == 1:\\n                    i_count += 1\\n                elif d == 2:\\n                    e_count += 1\\n                x //= 3\\n            if i_count > introvertsCount or e_count > extrovertsCount:\\n                continue\\n            score = 0\\n            for j, d in enumerate(arr):\\n                if d == 1:\\n                    score += 120\\n                elif d == 2:\\n                    score += 40\\n                if j > 0 and arr[j-1] and d:\\n                    # horizontal neighbor effect\\n                    score += (-30 if arr[j-1]==1 else 20)\\n                    score += (-30 if d==1 else 20)\\n            masks.append(mask)\\n            cntIntro[mask] = i_count\\n            cntExtro[mask] = e_count\\n            innerScore[mask] = score\\n        \\n        # 2) Precompute vertical cross‐row scores\\n        crossScore = {pm: {} for pm in masks}\\n        power3 = [3**i for i in range(n)]\\n        for pm in masks:\\n            for cm in masks:\\n                s = 0\\n                for j in range(n):\\n                    d0 = (pm // power3[j]) % 3\\n                    d1 = (cm // power3[j]) % 3\\n                    if d0 and d1:\\n                        s += (-30 if d0==1 else 20)\\n                        s += (-30 if d1==1 else 20)\\n                crossScore[pm][cm] = s\\n        \\n        # 3) Memoized recursion without functools\\n        memo = {}\\n        full_mask = 0  # not used but placeholder\\n        \\n        def dp(r, ic, ec, pmask):\\n            key = (r, ic, ec, pmask)\\n            if key in memo:\\n                return memo[key]\\n            if r == m:\\n                return 0\\n            best = 0\\n            for cm in masks:\\n                ci = cntIntro[cm]\\n                ce = cntExtro[cm]\\n                if ci <= ic and ce <= ec:\\n                    val = innerScore[cm] + crossScore[pmask][cm] + dp(r+1, ic-ci, ec-ce, cm)\\n                    if val > best:\\n                        best = val\\n            memo[key] = best\\n            return best\\n        \\n        return dp(0, introvertsCount, extrovertsCount, 0)\\n\"",
  "3495_14631217_python-updated-time": "1747570505776",
  "2392_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        # Sort the potions to allow binary search\\n        potions.sort()\\n        m = len(potions)\\n        result = []\\n        \\n        for s in spells:\\n            # Minimum potion strength needed so that s * p >= success\\n            # i.e. p >= ceil(success / s)\\n            need = (success + s - 1) // s\\n            # Find first index in potions with value >= need\\n            idx = bisect.bisect_left(potions, need)\\n            # All potions from idx..end will work\\n            result.append(m - idx)\\n        \\n        return result\\n\"",
  "1307_14631217_python-updated-time": "1746127346117",
  "1962_14631217_python-updated-time": "1746544333938",
  "59_14631217_python-updated-time": "1745014446301",
  "2404_14631217_python": "\"class Solution:\\n    def distinctSequences(self, n):\\n        MOD = 10**9 + 7\\n        \\n        # Inline gcd\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n        \\n        # allowed[b][a] = True if we can go from previous=a to current=b\\n        allowed = [[False]*7 for _ in range(7)]\\n        for a in range(1,7):\\n            for b in range(1,7):\\n                if b != a and gcd(a, b) == 1:\\n                    allowed[b][a] = True\\n        \\n        # dp_prev[a][b] = number of sequences ending with [..., b, a]\\n        dp_prev = [[0]*7 for _ in range(7)]\\n        # Base case: length=1, we have last=a, second_last=0\\n        for a in range(1,7):\\n            dp_prev[a][0] = 1\\n        \\n        for _ in range(2, n+1):\\n            dp_cur = [[0]*7 for _ in range(7)]\\n            for a in range(1,7):\\n                for b in range(7):\\n                    cnt = dp_prev[a][b]\\n                    if cnt:\\n                        for c in range(1,7):\\n                            # c must be coprime with a, different from a and from b\\n                            if allowed[c][a] and c != b:\\n                                dp_cur[c][a] = (dp_cur[c][a] + cnt) % MOD\\n            dp_prev = dp_cur\\n        \\n        ans = 0\\n        for a in range(1,7):\\n            for b in range(7):\\n                ans = (ans + dp_prev[a][b]) % MOD\\n        \\n        return ans\\n\"",
  "3265_14631217_python": "\"class Solution(object):\\n    def maximumSubarraySum(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # prefix = sum of nums[0..j-1]\\n        prefix = 0\\n        # for each value v, min_prefix[v] = minimum prefix sum P[i] seen so far at positions i with nums[i] == v\\n        min_prefix = {}\\n        ans = float('-inf')\\n        \\n        for v in nums:\\n            # Check both possibilities: nums[i] == v + k or v - k\\n            for target in (v + k, v - k):\\n                if target in min_prefix:\\n                    # sum(nums[i..j]) = (prefix + v) - min_prefix[target]\\n                    ans = max(ans, prefix + v - min_prefix[target])\\n            \\n            # Now record/update prefix sum at this position for future j's\\n            if v in min_prefix:\\n                min_prefix[v] = min(min_prefix[v], prefix)\\n            else:\\n                min_prefix[v] = prefix\\n            \\n            # Add current value to prefix sum\\n            prefix += v\\n        \\n        # If we never found any good subarray, return 0\\n        return ans if ans != float('-inf') else 0\\n\"",
  "1558_14631217_python-updated-time": "1746348023330",
  "2086_14631217_python-updated-time": "1746638896492",
  "1557_14631217_python-updated-time": "1746347992514",
  "611_14631217_python": "\"class Solution(object):\\n    def triangleNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        count = 0\\n        \\n        # k is the index of the largest side in the potential triangle\\n        for k in range(n-1, 1, -1):\\n            i, j = 0, k - 1\\n            # find all pairs (i, j) with nums[i] + nums[j] > nums[k]\\n            while i < j:\\n                if nums[i] + nums[j] > nums[k]:\\n                    # all elements from i to j-1 paired with j work\\n                    count += (j - i)\\n                    j -= 1\\n                else:\\n                    i += 1\\n        return count\\n\"",
  "3688_14631217_python-updated-time": "1747654512229",
  "3705_14631217_python-updated-time": "1747681300887",
  "2797_14631217_javascript": "\"class EventEmitter {\\n  constructor() {\\n    this.events = new Map();\\n  }\\n\\n  subscribe(event, callback) {\\n    if (!this.events.has(event)) {\\n      this.events.set(event, []);\\n    }\\n\\n    const subscription = { callback };\\n\\n    this.events.get(event).push(subscription);\\n\\n    return {\\n      unsubscribe: () => {\\n        const subs = this.events.get(event);\\n        const index = subs.indexOf(subscription);\\n        if (index !== -1) {\\n          subs.splice(index, 1);\\n        }\\n        if (subs.length === 0) {\\n          this.events.delete(event);\\n        }\\n        return undefined;\\n      }\\n    };\\n  }\\n\\n  emit(event, args = []) {\\n    if (!this.events.has(event)) return [];\\n\\n    const results = [];\\n    for (const { callback } of this.events.get(event)) {\\n      results.push(callback(...args));\\n    }\\n    return results;\\n  }\\n}\\n\"",
  "2694_14631217_python": "\"class Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        best_score = -1\\n        best_div = None\\n        \\n        for d in divisors:\\n            score = 0\\n            for x in nums:\\n                if x % d == 0:\\n                    score += 1\\n            # Update if strictly better score, or same score but smaller divisor\\n            if score > best_score or (score == best_score and (best_div is None or d < best_div)):\\n                best_score = score\\n                best_div = d\\n        \\n        return best_div\\n\"",
  "3153_14631217_python": "\"class Solution(object):\\n    def maxSum(self, nums, k):\\n        MOD = 10**9 + 7\\n        # Count how many times each bit appears across all numbers\\n        max_num = max(nums)\\n        B = max_num.bit_length()  # up to ~30\\n        cnt = [0] * B\\n        for v in nums:\\n            for b in range(B):\\n                if (v >> b) & 1:\\n                    cnt[b] += 1\\n\\n        # For i = 1..k, build Xi = OR of bits b where cnt[b] >= i\\n        ans = 0\\n        # We'll accumulate ans mod MOD\\n        for i in range(1, k + 1):\\n            x = 0\\n            for b in range(B):\\n                if cnt[b] >= i:\\n                    x |= (1 << b)\\n            ans = (ans + x * x) % MOD\\n\\n        return ans\\n\"",
  "413_14631217_python-updated-time": "1745356187247",
  "3779_14631217_python-updated-time": "1747739006933",
  "1409_14631217_python-updated-time": "1746260248836",
  "127_14631217_python": "\"class Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \\\"\\\"\\\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If endWord is not in wordList, no valid transformation sequence exists\\n        if endWord not in wordList:\\n            return 0\\n        \\n        # Convert wordList to a set for O(1) lookups\\n        word_set = set(wordList)\\n        \\n        # Initialize queue with beginWord and the current sequence length\\n        queue = [(beginWord, 1)]\\n        visited = set([beginWord])\\n        \\n        # BFS to find the shortest path\\n        while queue:\\n            current_word, path_length = queue.pop(0)\\n            \\n            # Try changing each character position\\n            for i in range(len(current_word)):\\n                # Try each possible letter\\n                for c in 'abcdefghijklmnopqrstuvwxyz':\\n                    # Create new word with the character at position i changed\\n                    next_word = current_word[:i] + c + current_word[i+1:]\\n                    \\n                    # If we found the endWord, return the path length + 1\\n                    if next_word == endWord:\\n                        return path_length + 1\\n                    \\n                    # If the word is in our wordList and hasn't been visited yet\\n                    if next_word in word_set and next_word not in visited:\\n                        visited.add(next_word)\\n                        queue.append((next_word, path_length + 1))\\n                        \\n                        # Optional optimization: remove from word_set to avoid checking again\\n                        word_set.remove(next_word)\\n        \\n        # No path found\\n        return 0\"",
  "764_14631217_python": "\"\\\"\\\"\\\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\\"\\\"\\\"\\n\\nclass Solution:\\n    def levelOrder(self, root):\\n        if not root:\\n            return []\\n        \\n        res = []\\n        queue = [root]\\n        \\n        while queue:\\n            level = []\\n            next_queue = []\\n            for node in queue:\\n                level.append(node.val)\\n                next_queue.extend(node.children)\\n            res.append(level)\\n            queue = next_queue\\n        \\n        return res\"",
  "2547_14631217_python": "\"class Solution:\\n    def oddString(self, words):\\n        def diff_sig(w):\\n            # Compute the tuple of differences for word w\\n            return tuple(ord(w[i+1]) - ord(w[i]) for i in range(len(w)-1))\\n        \\n        # Compute signatures for the first three words\\n        sig0 = diff_sig(words[0])\\n        sig1 = diff_sig(words[1])\\n        sig2 = diff_sig(words[2])\\n        \\n        # Determine the common signature by majority among the first three\\n        if sig0 == sig1 or sig0 == sig2:\\n            common = sig0\\n        else:\\n            common = sig1\\n        \\n        # Find and return the word whose signature differs\\n        for w in words:\\n            if diff_sig(w) != common:\\n                return w\\n        # Problem guarantees one exists, so we never reach here\\n\"",
  "2085_14631217_python-updated-time": "1746639411907",
  "3770_14631217_python-updated-time": "1747759393481",
  "2155_14631217_python": "\"class Solution(object):\\n    def missingRolls(self, rolls, mean, n):\\n        \\\"\\\"\\\"\\n        :type rolls: List[int]\\n        :type mean: int\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        m = len(rolls)\\n        total_sum = mean * (n + m)\\n        current_sum = sum(rolls)\\n        missing_sum = total_sum - current_sum\\n\\n        if missing_sum < n or missing_sum > 6 * n:\\n            return []\\n\\n        # Distribute the missing sum as evenly as possible\\n        base = missing_sum // n\\n        extra = missing_sum % n\\n\\n        result = [base] * n\\n        for i in range(extra):\\n            result[i] += 1\\n\\n        return result\\n\"",
  "3617_14631217_python-updated-time": "1747581807050",
  "345_14631217_python": "\"class Solution(object):\\n    def reverseVowels(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        vowels = set('aeiouAEIOU')\\n        s = list(s)\\n        left, right = 0, len(s) - 1\\n        \\n        while left < right:\\n            if s[left] not in vowels:\\n                left += 1\\n            elif s[right] not in vowels:\\n                right -= 1\\n            else:\\n                s[left], s[right] = s[right], s[left]\\n                left += 1\\n                right -= 1\\n        \\n        return ''.join(s)\\n\"",
  "1895_14631217_python": "\"class Solution(object):\\n    def minOperations(self, boxes):\\n        \\\"\\\"\\\"\\n        :type boxes: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(boxes)\\n        answer = [0] * n\\n        \\n        # Left to right pass\\n        moves = 0\\n        balls = 0\\n        for i in range(n):\\n            answer[i] += moves\\n            balls += int(boxes[i])\\n            moves += balls\\n        \\n        # Right to left pass\\n        moves = 0\\n        balls = 0\\n        for i in range(n - 1, -1, -1):\\n            answer[i] += moves\\n            balls += int(boxes[i])\\n            moves += balls\\n        \\n        return answer\\n\"",
  "3194_14631217_python": "\"class Solution(object):\\n    def findWordsContaining(self, words, x):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type x: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        return [i for i, word in enumerate(words) if x in word]\\n        \"",
  "2726_14631217_python": "\"import bisect\\nfrom collections import deque\\n\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned, k):\\n        # Initialize\\n        banned_set = set(banned)\\n        dist = [-1] * n\\n        dist[p] = 0\\n        # Prepare available targets by parity, excluding start and banned\\n        available = [[], []]\\n        for i in range(n):\\n            if i != p and i not in banned_set:\\n                available[i & 1].append(i)\\n        for arr in available:\\n            arr.sort()\\n\\n        q = deque([p])\\n        # BFS\\n        while q:\\n            u = q.popleft()\\n            # Compute valid start range s in [u-k+1, u] ∩ [0, n-k]\\n            s_min = max(0, u - k + 1)\\n            s_max = min(u, n - k)\\n            if s_min > s_max:\\n                continue\\n            # Map s to new positions v = 2*s + k - 1 - u\\n            new_low = 2 * s_min + k - 1 - u\\n            new_high = 2 * s_max + k - 1 - u\\n            mod = new_low & 1\\n            arr = available[mod]\\n            # Collect all v in [new_low, new_high]\\n            l = bisect.bisect_left(arr, new_low)\\n            i = l\\n            while i < len(arr) and arr[i] <= new_high:\\n                v = arr[i]\\n                dist[v] = dist[u] + 1\\n                q.append(v)\\n                i += 1\\n            # Remove visited slice\\n            del arr[l:i]\\n\\n        return dist\"",
  "927_14631217_python-updated-time": "1746002060615",
  "2217_14631217_python-updated-time": "1746729732412",
  "2597_14631217_python-updated-time": "1747059228160",
  "278_14631217_python-updated-time": "1745248349778",
  "3186_14631217_python": "\"class Solution(object):\\n    def minimumSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        INF = float('inf')\\n        \\n        # prefix_min[i]: minimum value in nums[0..i]\\n        prefix_min = [0] * n\\n        prefix_min[0] = nums[0]\\n        for i in range(1, n):\\n            prefix_min[i] = min(prefix_min[i-1], nums[i])\\n        \\n        # suffix_min[i]: minimum value in nums[i..n-1]\\n        suffix_min = [0] * n\\n        suffix_min[-1] = nums[-1]\\n        for i in range(n-2, -1, -1):\\n            suffix_min[i] = min(suffix_min[i+1], nums[i])\\n        \\n        ans = INF\\n        # consider each j as the mountain peak\\n        for j in range(1, n-1):\\n            left = prefix_min[j-1]\\n            right = suffix_min[j+1]\\n            if left < nums[j] and right < nums[j]:\\n                ans = min(ans, left + nums[j] + right)\\n        \\n        return ans if ans < INF else -1\\n\"",
  "3389_14631217_python-updated-time": "1747423645860",
  "2002_14631217_python-updated-time": "1746626041488",
  "1187_14631217_java": "\"import java.util.concurrent.Semaphore;\\n\\nclass FooBar {\\n    private int n;\\n    private Semaphore fooSem = new Semaphore(1);\\n    private Semaphore barSem = new Semaphore(0);\\n\\n    public FooBar(int n) {\\n        this.n = n;\\n    }\\n\\n    public void foo(Runnable printFoo) throws InterruptedException {\\n        for (int i = 0; i < n; i++) {\\n            fooSem.acquire();\\n            printFoo.run(); // prints \\\"foo\\\"\\n            barSem.release();\\n        }\\n    }\\n\\n    public void bar(Runnable printBar) throws InterruptedException {\\n        for (int i = 0; i < n; i++) {\\n            barSem.acquire();\\n            printBar.run(); // prints \\\"bar\\\"\\n            fooSem.release();\\n        }\\n    }\\n}\\n\"",
  "2512_14631217_python-updated-time": "1746966819549",
  "1756_14631217_python-updated-time": "1746445326409",
  "1658_14631217_python": "\"class Solution(object):\\n    def minSwaps(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        rightmost_one = []\\n\\n        for row in grid:\\n            pos = -1\\n            for j in reversed(range(n)):\\n                if row[j] == 1:\\n                    pos = j\\n                    break\\n            rightmost_one.append(pos)\\n\\n        swaps = 0\\n        for i in range(n):\\n            j = i\\n            while j < n and rightmost_one[j] > i:\\n                j += 1\\n            if j == n:\\n                return -1\\n            # Bubble the row up\\n            while j > i:\\n                rightmost_one[j], rightmost_one[j - 1] = rightmost_one[j - 1], rightmost_one[j]\\n                swaps += 1\\n                j -= 1\\n\\n        return swaps\\n\"",
  "813_14631217_python-updated-time": "1745878003502",
  "3533_14631217_python-updated-time": "1747501192424",
  "2905_14631217_python": "\"class Solution(object):\\n    def countPalindromePaths(self, parent, s):\\n        n = len(parent)\\n\\n        # build adjacency with the character on each edge\\n        adj = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            p = parent[i]\\n            adj[p].append((i, ord(s[i]) - 97))     # store child and letter-index (0‒25)\\n\\n        # depth-first traversal to compute parity-masks from root to every node\\n        masks = [0] * n\\n        stack = [(0, 0)]                            # (node, mask)\\n        while stack:\\n            node, mask = stack.pop()\\n            masks[node] = mask\\n            for child, ch_idx in adj[node]:\\n                stack.append((child, mask ^ (1 << ch_idx)))\\n\\n        # count pairs whose XOR of masks has ≤1 bit set\\n        from collections import defaultdict\\n        freq = defaultdict(int)                     # mask -> how many times seen so far\\n        ans = 0\\n        for m in masks:\\n            ans += freq[m]                          # XOR == 0  ➜ all counts even\\n            for j in range(26):                     # XOR differs in exactly one bit\\n                ans += freq[m ^ (1 << j)]\\n            freq[m] += 1\\n\\n        return ans\\n\"",
  "1507_14631217_python": "\"class Solution(object):\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        # Mapping from street type to possible directions\\n        directions = {\\n            1: [(0, -1), (0, 1)],     # left, right\\n            2: [(-1, 0), (1, 0)],     # up, down\\n            3: [(0, -1), (1, 0)],     # left, down\\n            4: [(0, 1), (1, 0)],      # right, down\\n            5: [(0, -1), (-1, 0)],    # left, up\\n            6: [(0, 1), (-1, 0)],     # right, up\\n        }\\n\\n        # Reverse direction check\\n        opposite = {\\n            (0, -1): (0, 1),\\n            (0, 1): (0, -1),\\n            (-1, 0): (1, 0),\\n            (1, 0): (-1, 0)\\n        }\\n\\n        from collections import deque\\n        visited = [[False] * n for _ in range(m)]\\n        queue = deque([(0, 0)])\\n        visited[0][0] = True\\n\\n        while queue:\\n            x, y = queue.popleft()\\n            if x == m - 1 and y == n - 1:\\n                return True\\n            for dx, dy in directions[grid[x][y]]:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\\n                    if opposite[(dx, dy)] in directions[grid[nx][ny]]:\\n                        visited[nx][ny] = True\\n                        queue.append((nx, ny))\\n\\n        return False\\n\"",
  "595_14631217_mysql-updated-time": "1745448448035",
  "773_14631217_python": "\"# Definition for a QuadTree node.\\n# class Node(object):\\n#     def __init__(self, val, isLeaf, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):\\n#         self.val = val\\n#         self.isLeaf = isLeaf\\n#         self.topLeft = topLeft\\n#         self.topRight = topRight\\n#         self.bottomLeft = bottomLeft\\n#         self.bottomRight = bottomRight\\n\\nclass Solution(object):\\n    def intersect(self, q1, q2):\\n        # if either is a leaf:\\n        if q1.isLeaf:\\n            # if q1 is leaf 1, OR is all 1s\\n            if q1.val:\\n                return Node(True, True)\\n            # else result is q2\\n            return q2\\n        if q2.isLeaf:\\n            if q2.val:\\n                return Node(True, True)\\n            return q1\\n\\n        # both internal: recurse on children\\n        tl = self.intersect(q1.topLeft, q2.topLeft)\\n        tr = self.intersect(q1.topRight, q2.topRight)\\n        bl = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n        br = self.intersect(q1.bottomRight, q2.bottomRight)\\n\\n        # if all four children are leaves and have same value, merge\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and \\\\\\n           tl.val == tr.val == bl.val == br.val:\\n            return Node(tl.val, True)\\n\\n        # otherwise return internal node (val can be anything)\\n        return Node(False, False, tl, tr, bl, br)\\n\"",
  "779_14631217_python-updated-time": "1745876233448",
  "2811_14631217_python": "\"class Solution(object):\\n    def minimumSum(self, n, k):\\n        used = set()\\n        res = 0\\n        i = 1\\n        while len(used) < n:\\n            if k - i not in used:\\n                used.add(i)\\n                res += i\\n            i += 1\\n        return res\\n\"",
  "1803_14631217_python": "\"class Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \\\"\\\"\\\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        current_time = 0\\n        total_wait = 0\\n        \\n        for arrival, prep in customers:\\n            if current_time <= arrival:\\n                current_time = arrival + prep\\n                total_wait += prep\\n            else:\\n                total_wait += (current_time + prep - arrival)\\n                current_time += prep\\n        \\n        # ensure float division even in Python2\\n        return total_wait * 1.0 / len(customers)\\n\"",
  "2375_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        # dist[r][c] = min obstacles removed to reach (r,c)\\n        dist = [ [float('inf')] * n for _ in range(m) ]\\n        dist[0][0] = 0\\n        \\n        dq = deque([(0, 0)])\\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        while dq:\\n            r, c = dq.popleft()\\n            d = dist[r][c]\\n            # Early exit if we've reached the goal\\n            if r == m-1 and c == n-1:\\n                return d\\n            for dr, dc in dirs:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and 0 <= nc < n:\\n                    nd = d + grid[nr][nc]\\n                    if nd < dist[nr][nc]:\\n                        dist[nr][nc] = nd\\n                        # 0-1 BFS: zero‐cost edge to front, cost‐1 edge to back\\n                        if grid[nr][nc] == 0:\\n                            dq.appendleft((nr, nc))\\n                        else:\\n                            dq.append((nr, nc))\\n        \\n        # In case the loop ends without early return\\n        return dist[m-1][n-1]\\n\"",
  "2488_14631217_python-updated-time": "1746965977293",
  "126_14631217_python": "\"class Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \\\"\\\"\\\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \\\"\\\"\\\"\\n        # If endWord is not in wordList, no valid transformation sequence exists\\n        if endWord not in wordList:\\n            return []\\n        \\n        # Convert wordList to a set for O(1) lookups\\n        word_set = set(wordList)\\n        \\n        # Store the level at which each word is first visited\\n        level_map = {beginWord: 0}\\n        \\n        # Keep track of all possible parents for each word\\n        parents = collections.defaultdict(list)\\n        \\n        # BFS to find all words and their minimum levels\\n        queue = collections.deque([beginWord])\\n        found = False\\n        level = 0\\n        \\n        # Only process until we find endWord (minimum level)\\n        while queue and not found:\\n            size = len(queue)\\n            level += 1\\n            \\n            # For words being visited at current level\\n            curr_level_visited = set()\\n            \\n            for _ in range(size):\\n                word = queue.popleft()\\n                \\n                # Try changing each character and check if it's a valid next word\\n                for i in range(len(word)):\\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\\n                        next_word = word[:i] + c + word[i+1:]\\n                        \\n                        # Skip if it's the same word or not in our word set\\n                        if next_word == word or next_word not in word_set:\\n                            continue\\n                        \\n                        # If we haven't seen this word before, add to queue\\n                        if next_word not in level_map:\\n                            level_map[next_word] = level\\n                            curr_level_visited.add(next_word)\\n                            queue.append(next_word)\\n                            parents[next_word].append(word)\\n                        # If we've seen this word at the current level, update its parents\\n                        elif level_map[next_word] == level:\\n                            parents[next_word].append(word)\\n                        \\n                        # Check if we've reached endWord\\n                        if next_word == endWord:\\n                            found = True\\n            \\n            # Remove words visited at current level to avoid cycles\\n            for word in curr_level_visited:\\n                if word in word_set:\\n                    word_set.remove(word)\\n        \\n        # If endWord is not found, return empty list\\n        if endWord not in level_map:\\n            return []\\n        \\n        # Use DFS to build all paths from endWord back to beginWord\\n        result = []\\n        \\n        def dfs(word, path):\\n            if word == beginWord:\\n                result.append(path[::-1])\\n                return\\n            \\n            for parent in parents[word]:\\n                dfs(parent, path + [parent])\\n        \\n        dfs(endWord, [endWord])\\n        return result\"",
  "2866_14631217_python-updated-time": "1747221821722",
  "331_14631217_python": "\"class Solution(object):\\n    def isValidSerialization(self, preorder):\\n        \\\"\\\"\\\"\\n        :type preorder: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        nodes = preorder.split(',')\\n        slots = 1\\n        for node in nodes:\\n            slots -= 1\\n            if slots < 0:\\n                return False\\n            if node != '#':\\n                slots += 2\\n        return slots == 0\\n\"",
  "1447_14631217_python-updated-time": "1746261982481",
  "2055_14631217_python": "\"class Solution(object):\\n    def splitPainting(self, segments):\\n        # Build sweep-line events: +color at start, -color at end\\n        events = []\\n        for start, end, color in segments:\\n            events.append((start, color))\\n            events.append((end, -color))\\n        # Sort by position\\n        events.sort()\\n        \\n        res = []\\n        curr_sum = 0\\n        prev_pos = None\\n        i = 0\\n        n = len(events)\\n        \\n        # Sweep through events\\n        while i < n:\\n            pos = events[i][0]\\n            # Before processing events at pos, record segment from prev_pos to pos\\n            if prev_pos is not None and prev_pos < pos and curr_sum > 0:\\n                res.append([prev_pos, pos, curr_sum])\\n            # Process all events at this position\\n            while i < n and events[i][0] == pos:\\n                _, delta = events[i]\\n                curr_sum += delta\\n                i += 1\\n            prev_pos = pos\\n        \\n        return res\\n\"",
  "1765_14631217_python": "\"\\nclass Solution:\\n    def mergeInBetween(self, list1, a, b, list2):\\n        # 1) Find node just before index a\\n        prev = list1\\n        for _ in range(a - 1):\\n            prev = prev.next\\n\\n        # 2) Find node just after index b\\n        post = prev\\n        for _ in range(b - a + 2):\\n            post = post.next\\n\\n        # 3) Splice in list2\\n        prev.next = list2\\n\\n        # 4) Find tail of list2\\n        tail = list2\\n        while tail.next:\\n            tail = tail.next\\n\\n        # 5) Connect tail of list2 to post\\n        tail.next = post\\n\\n        return list1\"",
  "953_14631217_python-updated-time": "1746003484293",
  "816_14631217_python-updated-time": "1745786360090",
  "1293_14631217_python": "\"class Solution(object):\\n    def threeConsecutiveOdds(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        count = 0\\n        for num in arr:\\n            if num % 2 == 1:\\n                count += 1\\n                if count == 3:\\n                    return True\\n            else:\\n                count = 0\\n        return False\\n\"",
  "328_14631217_python-updated-time": "1745256421893",
  "1057_14631217_python": "\"import math\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n):\\n        def perm(a, b):\\n            res = 1\\n            for i in range(b):\\n                res *= a - i\\n            return res\\n\\n        def countUniqueDigits(x):\\n            s = list(map(int, str(x)))\\n            n_digits = len(s)\\n            res = 0\\n\\n            # Count numbers with digits less than n_digits\\n            for i in range(1, n_digits):\\n                res += 9 * perm(9, i - 1)\\n\\n            # Count numbers with digits == n_digits\\n            used = set()\\n            for i in range(n_digits):\\n                for d in range(0 if i else 1, s[i]):\\n                    if d in used:\\n                        continue\\n                    res += perm(9 - i, n_digits - i - 1)\\n                if s[i] in used:\\n                    break\\n                used.add(s[i])\\n            else:\\n                res += 1  # count x itself if all digits are unique\\n\\n            return res\\n\\n        return n - countUniqueDigits(n)\\n\"",
  "806_14631217_python-updated-time": "1745877769514",
  "1553_14631217_python": "\"class Solution(object):\\n    def countTriplets(self, arr):\\n        n = len(arr)\\n        px = [0] * (n + 1)\\n        for i in range(n):\\n            px[i+1] = px[i] ^ arr[i]\\n        ans = 0\\n        for i in range(n):\\n            for k in range(i+1, n):\\n                if px[i] == px[k+1]:\\n                    ans += k - i\\n        return ans\\n\"",
  "2585_14631217_python-updated-time": "1747058840873",
  "3218_14631217_python-updated-time": "1747318729341",
  "926_14631217_python": "\"class Solution(object):\\n    def findAndReplacePattern(self, words, pattern):\\n        def encode(word):\\n            mapping = {}\\n            code = []\\n            next_code = 0\\n            for ch in word:\\n                if ch not in mapping:\\n                    mapping[ch] = next_code\\n                    next_code += 1\\n                code.append(mapping[ch])\\n            return code\\n        \\n        pattern_code = encode(pattern)\\n        return [word for word in words if encode(word) == pattern_code]\\n\"",
  "987_14631217_python-updated-time": "1746004862516",
  "3706_14631217_python": "\"class Solution(object):\\n    def minLength(self, s, numOps):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type numOps: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n\\n        # ----- helpers -------------------------------------------------- #\\n        def flips_L1():\\n            \\\"\\\"\\\"minimum flips to make the string strictly alternating\\\"\\\"\\\"\\n            d0 = d1 = 0            # 0101..., 1010...\\n            for i, ch in enumerate(s):\\n                if ch != ('0' if i & 1 == 0 else '1'):\\n                    d0 += 1\\n                if ch != ('1' if i & 1 == 0 else '0'):\\n                    d1 += 1\\n            return min(d0, d1)\\n\\n        def flips_needed(L):\\n            if L == 1:\\n                return flips_L1()\\n\\n            flips = 0\\n            run_len = 1\\n            for i in range(1, n):\\n                if s[i] == s[i - 1]:\\n                    run_len += 1\\n                else:\\n                    flips += run_len // (L + 1)\\n                    run_len = 1\\n            flips += run_len // (L + 1)       # last run\\n            return flips\\n        # ---------------------------------------------------------------- #\\n\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if flips_needed(mid) <= numOps:   # feasible → try smaller L\\n                hi = mid\\n            else:\\n                lo = mid + 1                  # infeasible → need larger L\\n        return lo\\n\"",
  "2444_14631217_python": "\"class Solution(object):\\n    def longestIdealString(self, s, k):\\n        dp = [0] * 26\\n\\n        for c in s:\\n            i = ord(c) - ord('a')\\n            max_len = 0\\n            for j in range(max(0, i - k), min(26, i + k + 1)):\\n                max_len = max(max_len, dp[j])\\n            dp[i] = max(dp[i], max_len + 1)\\n\\n        return max(dp)\\n\"",
  "2550_14631217_python": "\"class Solution:\\n    def twoEditWords(self, queries, dictionary):\\n        res = []\\n        for q in queries:\\n            for d in dictionary:\\n                # Count letter differences up to 3\\n                diff = 0\\n                for qc, dc in zip(q, d):\\n                    if qc != dc:\\n                        diff += 1\\n                        if diff > 2:\\n                            break\\n                if diff <= 2:\\n                    res.append(q)\\n                    break\\n        return res\\n\"",
  "557_14631217_python-updated-time": "1745447532673",
  "2826_14631217_python": "\"class Solution:\\n    def goodSubsetofBinaryMatrix(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        # map each row-mask (0…2^n−1) to one example index\\n        mask_to_idx = {}\\n        for i, row in enumerate(grid):\\n            mask = 0\\n            for j, bit in enumerate(row):\\n                mask |= (bit << j)\\n            # only keep the first index we see for each mask\\n            if mask not in mask_to_idx:\\n                mask_to_idx[mask] = i\\n\\n        # 1) Any all-zero row is a valid subset of size 1\\n        if 0 in mask_to_idx:\\n            return [mask_to_idx[0]]\\n\\n        # 2) Otherwise look for any two rows whose masks don't overlap\\n        masks = list(mask_to_idx)\\n        for i in range(len(masks)):\\n            for j in range(i+1, len(masks)):\\n                if (masks[i] & masks[j]) == 0:\\n                    idx1 = mask_to_idx[masks[i]]\\n                    idx2 = mask_to_idx[masks[j]]\\n                    return sorted([idx1, idx2])\\n\\n        # 3) No valid subset\\n        return []\\n\"",
  "3872_14631217_python-updated-time": "1747681870005",
  "3260_14631217_python-updated-time": "1747400346357",
  "3203_14631217_python-updated-time": "1747319674727",
  "2200_14631217_python": "\"class Solution:\\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Step 1: Prefix sum matrix\\n        pre = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                pre[i+1][j+1] = grid[i][j] + pre[i][j+1] + pre[i+1][j] - pre[i][j]\\n\\n        # Step 2: Mark where stamps can be placed\\n        can_stamp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m - stampHeight + 1):\\n            for j in range(n - stampWidth + 1):\\n                r1, c1 = i, j\\n                r2, c2 = i + stampHeight, j + stampWidth\\n                total = pre[r2][c2] - pre[r2][c1] - pre[r1][c2] + pre[r1][c1]\\n                if total == 0:\\n                    can_stamp[i][j] += 1\\n                    can_stamp[i][j + stampWidth] -= 1\\n                    can_stamp[i + stampHeight][j] -= 1\\n                    can_stamp[i + stampHeight][j + stampWidth] += 1\\n\\n        # Step 3: 2D prefix sum of stamp influence\\n        for i in range(m + 1):\\n            for j in range(1, n + 1):\\n                can_stamp[i][j] += can_stamp[i][j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(n + 1):\\n                can_stamp[i][j] += can_stamp[i - 1][j]\\n\\n        # Step 4: Verify all empty cells are covered\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0 and can_stamp[i][j] == 0:\\n                    return False\\n        return True\\n\"",
  "3534_14631217_python-updated-time": "1747502421805",
  "316_14631217_python-updated-time": "1745256055579",
  "1038_14631217_python-updated-time": "1746040752942",
  "1834_14631217_python": "\"class Solution:\\n    def minimumTeachings(self, n, languages, friendships):\\n        \\\"\\\"\\\"\\n        :param n: int               # number of languages (1..n)\\n        :param languages: List[List[int]]  # languages[i] = list of langs user (i+1) knows\\n        :param friendships: List[List[int]] # 1-based user pairs [u, v]\\n        :return: int  # minimum number of users to teach\\n        \\\"\\\"\\\"\\n        m = len(languages)  # number of users\\n        # Convert each user's known languages into a set for O(1) test\\n        lang_sets = [set(lang_list) for lang_list in languages]\\n\\n        # 1) Find all \\\"bad\\\" friendships (no common language)\\n        bad_users = set()\\n        for u, v in friendships:\\n            u0, v0 = u - 1, v - 1\\n            if not (lang_sets[u0] & lang_sets[v0]):\\n                bad_users.add(u0)\\n                bad_users.add(v0)\\n\\n        # If no bad friendships, no teaching needed\\n        if not bad_users:\\n            return 0\\n\\n        # 2) For each language L, count how many bad_users need to learn it\\n        ans = float('inf')\\n        for L in range(1, n + 1):\\n            teach_count = 0\\n            for u in bad_users:\\n                if L not in lang_sets[u]:\\n                    teach_count += 1\\n            ans = min(ans, teach_count)\\n\\n        return ans\\n\"",
  "2327_14631217_python-updated-time": "1746879123492",
  "2556_14631217_python-updated-time": "1746969371040",
  "297_14631217_python-updated-time": "1745255425859",
  "514_14631217_python-updated-time": "1745446377591",
  "1380_14631217_python": "\"class Solution:\\n    def closedIsland(self, grid):\\n        rows, cols = len(grid), len(grid[0])\\n\\n        def dfs(r, c):\\n            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 1:\\n                return\\n            grid[r][c] = 1\\n            for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                dfs(r + dr, c + dc)\\n\\n        # Eliminate all lands connected to the border\\n        for r in range(rows):\\n            for c in [0, cols - 1]:\\n                if grid[r][c] == 0:\\n                    dfs(r, c)\\n        for c in range(cols):\\n            for r in [0, rows - 1]:\\n                if grid[r][c] == 0:\\n                    dfs(r, c)\\n\\n        # Count closed islands\\n        closed_islands = 0\\n        for r in range(1, rows - 1):\\n            for c in range(1, cols - 1):\\n                if grid[r][c] == 0:\\n                    dfs(r, c)\\n                    closed_islands += 1\\n\\n        return closed_islands\\n\"",
  "974_14631217_python": "\"class Solution:\\n    def reorderLogFiles(self, logs):\\n        letter_logs = []\\n        digit_logs = []\\n\\n        for log in logs:\\n            identifier, rest = log.split(\\\" \\\", 1)\\n            if rest[0].isdigit():\\n                digit_logs.append(log)\\n            else:\\n                letter_logs.append((rest, identifier))\\n\\n        # Sort letter logs: first by content, then by identifier\\n        letter_logs.sort()\\n        # Reconstruct the sorted letter logs\\n        sorted_letter_logs = [id_ + \\\" \\\" + content for content, id_ in letter_logs]\\n\\n        return sorted_letter_logs + digit_logs\\n\"",
  "2466_14631217_python-updated-time": "1746965048896",
  "2306_14631217_python": "\"class Solution(object):\\n    def createBinaryTree(self, descriptions):\\n        nodes   = {}          # value -> TreeNode\\n        has_par = set()       # every value that ever appears as a child\\n        \\n        for par, child, isLeft in descriptions:\\n            if par   not in nodes: nodes[par]   = TreeNode(par)\\n            if child not in nodes: nodes[child] = TreeNode(child)\\n\\n            if isLeft:\\n                nodes[par].left  = nodes[child]\\n            else:\\n                nodes[par].right = nodes[child]\\n\\n            has_par.add(child)\\n\\n        # root is the node that never appeared as a child\\n        for val in nodes:\\n            if val not in has_par:\\n                return nodes[val]\"",
  "2175_14631217_python": "\"class Solution(object):\\n    def countHighestScoreNodes(self, parents):\\n        \\\"\\\"\\\"\\n        :type parents: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(parents)\\n        # build children list\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            p = parents[i]\\n            children[p].append(i)\\n\\n        self.max_score = 0\\n        self.count = 0\\n        \\n        def dfs(node):\\n            # returns size of subtree rooted at node\\n            total = 1\\n            score = 1\\n            for c in children[node]:\\n                sz = dfs(c)\\n                total += sz\\n                score *= sz\\n            # size of the rest of the tree (above)\\n            rest = n - total\\n            if rest:\\n                score *= rest\\n            # update global\\n            if score > self.max_score:\\n                self.max_score = score\\n                self.count = 1\\n            elif score == self.max_score:\\n                self.count += 1\\n            return total\\n        \\n        dfs(0)\\n        return self.count\"",
  "454_14631217_python-updated-time": "1745359343105",
  "667_14631217_python": "\"class Solution(object):\\n    def constructArray(self, n, k):\\n        res = []\\n        left, right = 1, n\\n        while left <= right:\\n            if k > 1:\\n                if k % 2 == 1:\\n                    res.append(left)\\n                    left += 1\\n                else:\\n                    res.append(right)\\n                    right -= 1\\n                k -= 1\\n            else:\\n                res.append(left)\\n                left += 1\\n        return res\\n\"",
  "1843_14631217_python": "\"class Solution:\\n    def countGoodRectangles(self, rectangles):\\n        max_len = 0\\n        count = 0\\n        for l, w in rectangles:\\n            side = min(l, w)\\n            if side > max_len:\\n                max_len = side\\n                count = 1\\n            elif side == max_len:\\n                count += 1\\n        return count\\n\"",
  "1115_14631217_python-updated-time": "1746042380315",
  "1984_14631217_python-updated-time": "1746624920524",
  "763_14631217_python": "\"class Solution(object):\\n    def makeLargestSpecial(self, s):\\n        count = 0\\n        i = 0\\n        res = []\\n        \\n        for j, ch in enumerate(s):\\n            if ch == '1':\\n                count += 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                res.append('1' + self.makeLargestSpecial(s[i+1:j]) + '0')\\n                i = j + 1\\n        \\n        res.sort(reverse=True)\\n        return ''.join(res)\\n\"",
  "1823_14631217_python-updated-time": "1746453743166",
  "1545_14631217_python-updated-time": "1746347621214",
  "176_14631217_mysql-updated-time": "1745092255900",
  "898_14631217_python-updated-time": "1746001353144",
  "2542_14631217_python-updated-time": "1746968471114",
  "926_14631217_python-updated-time": "1746002040845",
  "2034_14631217_python-updated-time": "1746627828762",
  "1925_14631217_python": "\"class Solution(object):\\n    def countNicePairs(self, nums):\\n        MOD = 10**9 + 7\\n\\n        def rev(x):\\n            y = 0\\n            while x:\\n                y = y * 10 + x % 10\\n                x //= 10\\n            return y\\n\\n        count = {}\\n        ans = 0\\n        for x in nums:\\n            diff = x - rev(x)\\n            c = count.get(diff, 0)\\n            ans = (ans + c) % MOD\\n            count[diff] = c + 1\\n        return ans\\n\"",
  "552_14631217_python": "\"class Solution(object):\\n    def checkRecord(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        \\n        # dp0, dp1, dp2: # of records length i with 0 'A's ending in 0,1,2 consecutive 'L's\\n        dp0, dp1, dp2 = 1, 0, 0\\n        # ap0, ap1, ap2: # of records length i with 1 'A'  ending in 0,1,2 consecutive 'L's\\n        ap0, ap1, ap2 = 0, 0, 0\\n\\n        for _ in range(n):\\n            # totals of previous states\\n            s0 = (dp0 + dp1 + dp2) % MOD\\n            s1 = (ap0 + ap1 + ap2) % MOD\\n\\n            # extend the 0-A records by P or L (never A)\\n            ndp0 = s0            # append 'P' resets L-streak\\n            ndp1 = dp0           # append 'L' to a streak of 0 L's\\n            ndp2 = dp1           # append 'L' to a streak of 1 L\\n\\n            # extend the 1-A records by P, L, or add the sole 'A' from a 0-A record\\n            nap0 = (s1 + s0) % MOD   # append 'P' to 1-A *or* append 'A' to 0-A\\n            nap1 = ap0              # append 'L' to a streak of 0 L's\\n            nap2 = ap1              # append 'L' to a streak of 1 L\\n\\n            dp0, dp1, dp2 = ndp0, ndp1, ndp2\\n            ap0, ap1, ap2 = nap0, nap1, nap2\\n\\n        # Sum all valid end-states\\n        return (dp0 + dp1 + dp2 + ap0 + ap1 + ap2) % MOD\\n\"",
  "808_14631217_python-updated-time": "1745877828297",
  "2138_14631217_python": "\"class Solution:\\n    def sumOfBeauties(self, nums):\\n        n = len(nums)\\n        # prefix_max[i] = max of nums[0..i-1], for i from 0..n-1\\n        prefix_max = [0] * n\\n        curr_max = float('-inf')\\n        for i in range(n):\\n            prefix_max[i] = curr_max\\n            curr_max = max(curr_max, nums[i])\\n        \\n        # suffix_min[i] = min of nums[i+1..n-1], for i from 0..n-1\\n        suffix_min = [0] * n\\n        curr_min = float('inf')\\n        for i in range(n-1, -1, -1):\\n            suffix_min[i] = curr_min\\n            curr_min = min(curr_min, nums[i])\\n        \\n        beauty_sum = 0\\n        for i in range(1, n-1):\\n            val = nums[i]\\n            # beauty = 2?\\n            if val > prefix_max[i] and val < suffix_min[i]:\\n                beauty_sum += 2\\n            # beauty = 1?\\n            elif nums[i-1] < val < nums[i+1]:\\n                beauty_sum += 1\\n            # else +0\\n        return beauty_sum\\n\"",
  "2285_14631217_python": "\"class Bitset:\\n    def __init__(self, size):\\n        self.n = size\\n        self.bits = [0] * size\\n        self.flipped = False\\n        self.ones = 0\\n\\n    def fix(self, idx):\\n        actual = self.bits[idx] ^ self.flipped\\n        if actual == 0:\\n            self.bits[idx] ^= 1\\n            self.ones += 1\\n\\n    def unfix(self, idx):\\n        actual = self.bits[idx] ^ self.flipped\\n        if actual == 1:\\n            self.bits[idx] ^= 1\\n            self.ones -= 1\\n\\n    def flip(self):\\n        self.flipped = not self.flipped\\n        self.ones = self.n - self.ones\\n\\n    def all(self):\\n        return self.ones == self.n\\n\\n    def one(self):\\n        return self.ones > 0\\n\\n    def count(self):\\n        return self.ones\\n\\n    def toString(self):\\n        return ''.join(str(self.bits[i] ^ self.flipped) for i in range(self.n))\\n\"",
  "3509_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def kthLargestPerfectSubtree(self, root, k):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        perfect_sizes = []\\n\\n        def dfs(node):\\n            if not node:\\n                return True, 0, 0  # is_perfect, depth, size\\n            \\n            left_perfect, left_depth, left_size = dfs(node.left)\\n            right_perfect, right_depth, right_size = dfs(node.right)\\n            \\n            if left_perfect and right_perfect and left_depth == right_depth:\\n                size = left_size + right_size + 1\\n                depth = left_depth + 1\\n                perfect_sizes.append(size)\\n                return True, depth, size\\n            else:\\n                return False, 0, 0\\n\\n        dfs(root)\\n\\n        perfect_sizes.sort(reverse=True)\\n        return perfect_sizes[k - 1] if k <= len(perfect_sizes) else -1\\n\"",
  "1722_14631217_python": "\"from collections import defaultdict\\n\\nclass ThroneInheritance:\\n    def __init__(self, kingName):\\n        self.king = kingName\\n        self.children = defaultdict(list)\\n        self.dead = set()\\n\\n    def birth(self, parentName, childName):\\n        # add new child at the end of the parent’s list\\n        self.children[parentName].append(childName)\\n\\n    def death(self, name):\\n        # just mark dead; we still traverse them in the tree\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self):\\n        order = []\\n        # preorder DFS\\n        def dfs(name):\\n            if name not in self.dead:\\n                order.append(name)\\n            for c in self.children[name]:\\n                dfs(c)\\n\\n        dfs(self.king)\\n        return order\\n\"",
  "178_14631217_mysql": "\"SELECT \\n  s.score,\\n  (\\n    SELECT COUNT(DISTINCT score) \\n    FROM Scores \\n    WHERE score >= s.score\\n  ) AS `rank`\\nFROM \\n  Scores s\\nORDER BY \\n  s.score DESC;\\n\"",
  "925_14631217_python-updated-time": "1746002016787",
  "405_14631217_python": "\"class Solution:\\n    def toHex(self, num):\\n        if num == 0:\\n            return \\\"0\\\"\\n        \\n        hex_chars = \\\"0123456789abcdef\\\"\\n        res = \\\"\\\"\\n        \\n        num &= 0xFFFFFFFF  # Handle negative numbers with two's complement\\n        \\n        while num > 0:\\n            res = hex_chars[num % 16] + res\\n            num //= 16\\n        \\n        return res\\n\"",
  "923_14631217_python": "\"class Solution(object):\\n    def superEggDrop(self, k, n):\\n        dp = [0] * (k + 1)\\n        m = 0\\n        while dp[k] < n:\\n            m += 1\\n            for i in range(k, 0, -1):\\n                dp[i] = dp[i] + dp[i - 1] + 1\\n        return m\\n\"",
  "3092_14631217_python-updated-time": "1747227071242",
  "1670_14631217_mysql-updated-time": "1746433875791",
  "145_14631217_python-updated-time": "1745087170386",
  "3871_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def minDeletion(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        freq = Counter(s)\\n        distinct = len(freq)\\n        # If already ≤ k distinct characters, no deletions needed\\n        if distinct <= k:\\n            return 0\\n        \\n        # We need to remove (distinct - k) characters entirely.\\n        # To minimize deletions, pick the characters with the smallest frequencies.\\n        counts = sorted(freq.values())\\n        to_remove = distinct - k\\n        return sum(counts[:to_remove])\\n\"",
  "667_14631217_python-updated-time": "1745783192069",
  "205_14631217_python-updated-time": "1745245855660",
  "3830_14631217_python-updated-time": "1747681812544",
  "1786_14631217_python": "\"class Solution(object):\\n    def countConsistentStrings(self, allowed, words):\\n        allowed_set = set(allowed)\\n        return sum(all(c in allowed_set for c in word) for word in words)\\n\"",
  "2269_14631217_python": "\"class Solution:\\n    def countElements(self, nums):\\n        mn = min(nums)\\n        mx = max(nums)\\n        return sum(1 for x in nums if mn < x < mx)\\n\"",
  "2600_14631217_python": "\"class Solution:\\n    def maximumTastiness(self, price, k):\\n        price.sort()\\n        \\n        def can(diff):\\n            # Greedily pick candies with at least `diff` apart\\n            count = 1\\n            last = price[0]\\n            for p in price[1:]:\\n                if p - last >= diff:\\n                    count += 1\\n                    last = p\\n                    if count == k:\\n                        return True\\n            return False\\n        \\n        lo, hi = 0, price[-1] - price[0]\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if can(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n\"",
  "2364_14631217_python-updated-time": "1746879931389",
  "3310_14631217_python-updated-time": "1747425786273",
  "1466_14631217_python-updated-time": "1746261808683",
  "2257_14631217_python-updated-time": "1746802113863",
  "44_14631217_python-updated-time": "1744999435748",
  "2367_14631217_python": "\"class Solution:\\n    def minimumLines(self, stockPrices):\\n        n = len(stockPrices)\\n        if n < 2:\\n            return 0\\n        \\n        # Sort by day (x-coordinate)\\n        stockPrices.sort()\\n        \\n        # Helper to get slope comparison without division:\\n        # returns True if slope between (x1,y1)->(x2,y2) equals slope between (x2,y2)->(x3,y3)\\n        def same_slope(x1, y1, x2, y2, x3, y3):\\n            return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1)\\n        \\n        # At least one line between the first two points\\n        lines = 1\\n        \\n        # Iterate through triples and count when slope changes\\n        for i in range(2, n):\\n            x1, y1 = stockPrices[i-2]\\n            x2, y2 = stockPrices[i-1]\\n            x3, y3 = stockPrices[i]\\n            \\n            if not same_slope(x1, y1, x2, y2, x3, y3):\\n                lines += 1\\n        \\n        return lines\\n\"",
  "2634_14631217_python": "\"class Solution:\\n    def getCommon(self, nums1, nums2):\\n        i = j = 0\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] < nums2[j]:\\n                i += 1\\n            elif nums1[i] > nums2[j]:\\n                j += 1\\n            else:\\n                return nums1[i]\\n        return -1\\n\"",
  "1844_14631217_python": "\"class Solution(object):\\n    def countBalls(self, lowLimit, highLimit):\\n        \\\"\\\"\\\"\\n        :type lowLimit: int\\n        :type highLimit: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n        \\n        def digit_sum(num):\\n            return sum(int(d) for d in str(num))\\n        \\n        box_counts = defaultdict(int)\\n        \\n        for ball in range(lowLimit, highLimit + 1):\\n            box = digit_sum(ball)\\n            box_counts[box] += 1\\n        \\n        return max(box_counts.values())\\n\"",
  "2668_14631217_python": "\"class Solution:\\n    def minNumber(self, nums1, nums2):\\n        common = set(nums1) & set(nums2)\\n        if common:\\n            return min(common)\\n        a = min(nums1)\\n        b = min(nums2)\\n        return min(a * 10 + b, b * 10 + a)\\n\"",
  "814_14631217_python-updated-time": "1745878056590",
  "3214_14631217_python": "\"class Solution(object):\\n    def maximizeSquareHoleArea(self, n, m, hBars, vBars):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type m: int\\n        :type hBars: List[int]\\n        :type vBars: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def max_consecutive(bars):\\n            bars.sort()\\n            max_len = 1\\n            curr_len = 1\\n            for i in range(1, len(bars)):\\n                if bars[i] == bars[i-1] + 1:\\n                    curr_len += 1\\n                    max_len = max(max_len, curr_len)\\n                else:\\n                    curr_len = 1\\n            return max_len + 1  # +1 because consecutive gaps create N+1 cell span\\n\\n        max_h = max_consecutive(hBars)\\n        max_v = max_consecutive(vBars)\\n        side = min(max_h, max_v)\\n        return side * side\\n\"",
  "220_14631217_python": "\"class Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type indexDiff: int\\n        :type valueDiff: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if valueDiff < 0:\\n            return False\\n\\n        width = valueDiff + 1  # bucket size\\n        bucket = {}\\n\\n        for i, num in enumerate(nums):\\n            bucket_id = num // width\\n\\n            if bucket_id in bucket:\\n                return True\\n            if bucket_id - 1 in bucket and abs(num - bucket[bucket_id - 1]) <= valueDiff:\\n                return True\\n            if bucket_id + 1 in bucket and abs(num - bucket[bucket_id + 1]) <= valueDiff:\\n                return True\\n\\n            bucket[bucket_id] = num\\n\\n            if i >= indexDiff:\\n                old_bucket_id = nums[i - indexDiff] // width\\n                del bucket[old_bucket_id]\\n\\n        return False\\n\"",
  "3494_14631217_python-updated-time": "1747487291922",
  "1033_14631217_python-updated-time": "1746040587883",
  "2040_14631217_python-updated-time": "1746637892675",
  "731_14631217_python": "\"class MyCalendarTwo(object):\\n    def __init__(self):\\n        self.bookings = []\\n        self.overlaps = []\\n\\n    def book(self, startTime, endTime):\\n        for os, oe in self.overlaps:\\n            if startTime < oe and endTime > os:\\n                return False\\n        for bs, be in self.bookings:\\n            if startTime < be and endTime > bs:\\n                self.overlaps.append((max(startTime, bs), min(endTime, be)))\\n        self.bookings.append((startTime, endTime))\\n        return True\"",
  "1882_14631217_mysql-updated-time": "1746530264082",
  "3335_14631217_python": "\"class Solution(object):\\n    def minimumOperationsToWriteY(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        mid = n // 2\\n        \\n        # 1) Collect all coordinates in the \\\"Y\\\" shape\\n        Y = set()\\n        # two diagonals from (0,0) and (0,n-1) down to center\\n        for i in range(mid+1):\\n            Y.add((i, i))\\n            Y.add((i, n-1 - i))\\n        # vertical line from center down to bottom\\n        for r in range(mid, n):\\n            Y.add((r, mid))\\n        \\n        # 2) Try all (v1, v2) with v1 != v2\\n        best = float('inf')\\n        for v1 in (0, 1, 2):\\n            for v2 in (0, 1, 2):\\n                if v1 == v2:\\n                    continue\\n                ops = 0\\n                # count mismatches in Y where we want color v1\\n                for (r, c) in Y:\\n                    if grid[r][c] != v1:\\n                        ops += 1\\n                # count mismatches outside Y where we want v2\\n                for r in range(n):\\n                    for c in range(n):\\n                        if (r, c) not in Y and grid[r][c] != v2:\\n                            ops += 1\\n                best = min(best, ops)\\n        \\n        return best\\n\"",
  "2151_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Step 1: Build the graph\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        n = len(patience)\\n        dist = [0] * n\\n        visited = [False] * n\\n\\n        # Step 2: BFS to find shortest distance from node 0\\n        queue = deque()\\n        queue.append(0)\\n        visited[0] = True\\n        level = 0\\n\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                node = queue.popleft()\\n                dist[node] = level\\n                for neighbor in graph[node]:\\n                    if not visited[neighbor]:\\n                        visited[neighbor] = True\\n                        queue.append(neighbor)\\n            level += 1\\n\\n        # Step 3: Compute max time any reply is received\\n        max_time = 0\\n        for i in range(1, n):\\n            round_trip = 2 * dist[i]\\n            if patience[i] >= round_trip:\\n                last_time = round_trip\\n            else:\\n                last_sent = ((round_trip - 1) // patience[i]) * patience[i]\\n                last_time = last_sent + round_trip\\n            if last_time > max_time:\\n                max_time = last_time\\n\\n        return max_time + 1\\n\"",
  "526_14631217_python": "\"class Solution:\\n    def countArrangement(self, n):\\n        def backtrack(pos, visited):\\n            if pos > n:\\n                return 1\\n            total = 0\\n            for i in range(1, n + 1):\\n                if not visited[i] and (i % pos == 0 or pos % i == 0):\\n                    visited[i] = True\\n                    total += backtrack(pos + 1, visited)\\n                    visited[i] = False\\n            return total\\n\\n        return backtrack(1, [False] * (n + 1))\\n\"",
  "374_14631217_python": "\"# The guess API is already defined for you.\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n):\\n        left, right = 1, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = guess(mid)\\n            if res == 0:\\n                return mid\\n            elif res < 0:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n\"",
  "3840_14631217_python-updated-time": "1747744837865",
  "3634_14631217_python": "\"class Solution(object):\\n    def calculateScore(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Precompute mirror for each lowercase letter\\n        # mirror['a'] = 'z', mirror['b'] = 'y', ..., mirror['z'] = 'a'\\n        mirror = { \\n            chr(ord('a') + i): chr(ord('a') + 25 - i)\\n            for i in range(26)\\n        }\\n        \\n        # stacks[ch] will hold the indices of unpaired occurrences of ch\\n        stacks = { chr(ord('a')+i): [] for i in range(26) }\\n        \\n        score = 0\\n        \\n        for i, c in enumerate(s):\\n            m = mirror[c]\\n            if stacks[m]:\\n                # found a closest unmarked j < i with s[j] == m\\n                j = stacks[m].pop()\\n                score += i - j\\n                # both i and j are now marked, so we do NOT push i anywhere\\n            else:\\n                # no available mirror to pair with—keep this occurrence for future\\n                stacks[c].append(i)\\n        \\n        return score\\n\"",
  "909_14631217_python-updated-time": "1746001606352",
  "1281_14631217_python-updated-time": "1746126430427",
  "1906_14631217_python": "\"class Solution(object):\\n    def maxScore(self, nums):\\n        n = len(nums)\\n        memo = {}\\n\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        def dp(mask):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            if mask in memo:\\n                return memo[mask]\\n\\n            max_score = 0\\n            turn = bin(mask).count('1') // 2 + 1\\n\\n            for i in range(n):\\n                if not (mask & (1 << i)):\\n                    for j in range(i + 1, n):\\n                        if not (mask & (1 << j)):\\n                            new_mask = mask | (1 << i) | (1 << j)\\n                            score = turn * gcd(nums[i], nums[j]) + dp(new_mask)\\n                            max_score = max(max_score, score)\\n\\n            memo[mask] = max_score\\n            return max_score\\n\\n        return dp(0)\\n\"",
  "2000_14631217_python-updated-time": "1746625881938",
  "268_14631217_python-updated-time": "1745248165964",
  "2691_14631217_python-updated-time": "1747065018719",
  "3639_14631217_python-updated-time": "1747587849554",
  "409_14631217_python-updated-time": "1745356108772",
  "3759_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def findMaxSum(self, nums1, nums2, k):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums1)\\n        # Pair up (value in nums1, corresponding value in nums2, original index)\\n        arr = sorted([(nums1[i], nums2[i], i) for i in range(n)], key=lambda x: x[0])\\n        \\n        answer = [0] * n\\n        min_heap = []\\n        curr_sum = 0\\n        \\n        i = 0\\n        while i < n:\\n            val = arr[i][0]\\n            # Process all entries with this same nums1 value\\n            j = i\\n            while j < n and arr[j][0] == val:\\n                _, _, idx = arr[j]\\n                # Before adding any of this group's nums2, \\n                # the heap contains exactly those with nums1 < val\\n                answer[idx] = curr_sum\\n                j += 1\\n            \\n            # Now include this group's nums2 into our top-k heap\\n            for t in range(i, j):\\n                _, w, _ = arr[t]\\n                if len(min_heap) < k:\\n                    heapq.heappush(min_heap, w)\\n                    curr_sum += w\\n                else:\\n                    # If this w is larger than the smallest in our heap,\\n                    # replace to keep the top k largest\\n                    if min_heap[0] < w:\\n                        popped = heapq.heapreplace(min_heap, w)\\n                        curr_sum += w - popped\\n            \\n            i = j\\n        \\n        return answer\\n\"",
  "1245_14631217_mysql-updated-time": "1746125715134",
  "3507_14631217_python-updated-time": "1747488333316",
  "3402_14631217_python": "\"MOD = 10 ** 9 + 7\\n\\nclass Solution(object):\\n    def minCostToEqualizeArray(self, nums, cost1, cost2):\\n        n  = len(nums)\\n        if n == 1:\\n            return 0                          # already equal\\n\\n        s  = sum(nums)\\n        mn = min(nums)\\n        mx = max(nums)\\n\\n        # ─────────────────────────── simple cases ────────────────────────────\\n        if cost2 >= 2 * cost1:                # pair not cheaper than singles\\n            return ((n * mx - s) * cost1) % MOD\\n        if n == 2:                            # pairs never help with two items\\n            return abs(nums[0] - nums[1]) * cost1 % MOD\\n\\n        # ───────────────────── cost for a particular target T ─────────────────\\n        def raw_cost(T):\\n            S = n * T - s                     # total units still missing\\n            singles = max(0, (s - 2 * mn) - (n - 2) * T)  # 2·M − S\\n            if (S - singles) & 1:             # need even remainder for pairs\\n                singles += 1\\n            pairs = (S - singles) // 2\\n            return singles * cost1 + pairs * cost2  # *raw* cost, no modulo\\n\\n        # slope while singles_needed > 0\\n        slope1 = (n - 1) * cost2 - (n - 2) * cost1\\n\\n        cand = set([mx])                      # always test the current max\\n\\n        if slope1 < 0:                        # V-shape, vertex to the right\\n            num = s - 2 * mn\\n            den = n - 2                       # n ≥ 3 here, so den > 0\\n\\n            t_floor = max(mx, num // den)                 # ⌊T₀⌋\\n            t_ceil  = max(mx, (num + den - 1) // den)     # ⌈T₀⌉\\n\\n            cand.update([t_floor, t_ceil, t_ceil + 1])    # +1 covers dip\\n            if t_floor - 1 >= mx:                         # rarely useful\\n                cand.add(t_floor - 1)\\n        else:                              # cost already increasing at mx\\n            cand.add(mx + 1)               # parity dip can be right after mx\\n\\n        # evaluate ≤ 5 candidates, pick the true minimum, *then* apply modulo\\n        best_raw = min(raw_cost(T) for T in cand)\\n        return best_raw % MOD\\n\"",
  "3712_14631217_python": "\"class Solution(object):\\n    def minCost(self, arr, brr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type brr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) Cost if we never pay k: just adjust in place\\n        cost_no_perm = sum(abs(a - b) for a, b in zip(arr, brr))\\n        \\n        # 2) Cost if we do one free-form rearrangement (cost k)\\n        #    + then adjust each element.\\n        #    The best rearrangement for sum |a-b| is to match\\n        #    sorted(arr) with sorted(brr).\\n        sa = sorted(arr)\\n        sb = sorted(brr)\\n        matching_cost = sum(abs(a - b) for a, b in zip(sa, sb))\\n        cost_with_perm = k + matching_cost\\n        \\n        return min(cost_no_perm, cost_with_perm)\\n\"",
  "3199_14631217_python": "\"class Solution(object):\\n    def distributeCandies(self, n, limit):\\n        count = 0\\n        for i in range(limit + 1):\\n            for j in range(limit + 1):\\n                k = n - i - j\\n                if 0 <= k <= limit:\\n                    count += 1\\n        return count\"",
  "193_14631217_bash": "\"# Read from the file file.txt and output all valid phone numbers to stdout.\\ngrep -E \\\"^(\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}|[0-9]{3}-[0-9]{3}-[0-9]{4})$\\\" file.txt\\n\\n\\n\"",
  "2533_14631217_python-updated-time": "1746966876953",
  "1471_14631217_python": "\"class Solution:\\n    def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        # Precompute valid seat bitmasks for each row\\n        valid_row_masks = []\\n        for i in range(m):\\n            good = 0\\n            for j in range(n):\\n                if seats[i][j] == '.':\\n                    good |= (1 << j)\\n            row_masks = []\\n            # Enumerate all subsets of good seats\\n            mask = good\\n            sub = mask\\n            while True:\\n                # Check no two adjacent students in the same row\\n                if (sub & (sub << 1)) == 0:\\n                    row_masks.append(sub)\\n                if sub == 0:\\n                    break\\n                sub = (sub - 1) & good\\n            valid_row_masks.append(row_masks)\\n        \\n        # DP: dp_prev[mask] = max students up to previous row ending with mask\\n        dp_prev = {mask: bin(mask).count('1') for mask in valid_row_masks[0]}\\n        \\n        for i in range(1, m):\\n            dp_curr = {}\\n            for mask in valid_row_masks[i]:\\n                cnt = bin(mask).count('1')\\n                best = 0\\n                for pmask, val in dp_prev.items():\\n                    # No cheating diagonally with previous row\\n                    if (mask & (pmask << 1)) == 0 and (mask & (pmask >> 1)) == 0:\\n                        best = max(best, val)\\n                dp_curr[mask] = best + cnt\\n            dp_prev = dp_curr\\n        \\n        # Result is the maximum over the last row's masks\\n        return max(dp_prev.values() or [0])\\n\"",
  "2374_14631217_python-updated-time": "1746881819902",
  "817_14631217_python-updated-time": "1745786393800",
  "2654_14631217_python": "\"class Solution(object):\\n    def vowelStrings(self, words, left, right):\\n        vowels = set('aeiou')\\n        count = 0\\n        for i in range(left, right + 1):\\n            word = words[i]\\n            if word[0] in vowels and word[-1] in vowels:\\n                count += 1\\n        return count\\n\"",
  "1527_14631217_python": "\"class Solution(object):\\n    def numOfWays(self, n):\\n        MOD = 10**9 + 7\\n        color2, color3 = 6, 6  # For row 1\\n\\n        for _ in range(1, n):\\n            new_color2 = (color2 * 3 + color3 * 2) % MOD\\n            new_color3 = (color2 * 2 + color3 * 2) % MOD\\n            color2, color3 = new_color2, new_color3\\n\\n        return (color2 + color3) % MOD\\n\"",
  "775_14631217_python-updated-time": "1745448165415",
  "3068_14631217_pythondata": "\"import pandas as pd\\n\\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\\n    return students.rename(columns={\\n        'id': 'student_id',\\n        'first': 'first_name',\\n        'last': 'last_name',\\n        'age': 'age_in_years'\\n    })\\n\"",
  "687_14631217_python-updated-time": "1745785431901",
  "1479_14631217_python-updated-time": "1746345146298",
  "1946_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def minAbsoluteSumDiff(self, nums1, nums2):\\n        MOD = 10**9 + 7\\n        n = len(nums1)\\n        sorted1 = sorted(nums1)\\n        total = 0\\n        max_gain = 0\\n        for a, b in zip(nums1, nums2):\\n            diff = abs(a - b)\\n            total += diff\\n            # find in sorted1 the closest to b\\n            idx = bisect.bisect_left(sorted1, b)\\n            best = diff\\n            if idx < n:\\n                best = min(best, abs(sorted1[idx] - b))\\n            if idx > 0:\\n                best = min(best, abs(sorted1[idx-1] - b))\\n            gain = diff - best\\n            if gain > max_gain:\\n                max_gain = gain\\n        return (total - max_gain) % MOD\\n\"",
  "3613_14631217_python": "\"class Solution(object):\\n    def maxAmount(self, initialCurrency, pairs1, rates1, pairs2, rates2):\\n        from collections import defaultdict, deque\\n\\n        def build_graph(pairs, rates):\\n            # undirected adjacency: u->v with w, v->u with 1/w\\n            g = defaultdict(list)\\n            for (u, v), r in zip(pairs, rates):\\n                g[u].append((v, r))\\n                g[v].append((u, 1.0/r))\\n            return g\\n\\n        def bfs_best(start, graph):\\n            # returns dict best[x] = product along unique path start->x\\n            best = {start: 1.0}\\n            q = deque([start])\\n            while q:\\n                u = q.popleft()\\n                for v, r in graph[u]:\\n                    if v not in best:\\n                        best[v] = best[u] * r\\n                        q.append(v)\\n            return best\\n\\n        # 1) build day1 and day2 graphs\\n        g1 = build_graph(pairs1, rates1)\\n        g2 = build_graph(pairs2, rates2)\\n\\n        # 2) compute best1[C] for day1 from initial\\n        best1 = bfs_best(initialCurrency, g1)\\n        # 3) compute best2[C] for day2 from initial\\n        best2 = bfs_best(initialCurrency, g2)\\n\\n        # 4) maximize best1[C] / best2[C] over currencies reachable in both\\n        ans = 1.0  # at worst do nothing\\n        for C, amt1 in best1.items():\\n            if C in best2:\\n                cand = amt1 / best2[C]\\n                if cand > ans:\\n                    ans = cand\\n\\n        return ans\\n\"",
  "3075_14631217_pythondata": "\"import pandas as pd\\n\\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame students with columns ['student_id', 'name', 'age'],\\n    returns a new DataFrame with any rows removed where 'name' is missing (NaN or None).\\n    \\\"\\\"\\\"\\n    return students.dropna(subset=['name'])\\n\"",
  "435_14631217_python": "\"class Solution:\\n    def eraseOverlapIntervals(self, intervals):\\n        if not intervals:\\n            return 0\\n        \\n        intervals.sort(key=lambda x: x[1])\\n        end = intervals[0][1]\\n        count = 0\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] < end:\\n                count += 1\\n            else:\\n                end = intervals[i][1]\\n        \\n        return count\\n\"",
  "3439_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minimumDiameterAfterMerge(self, edges1, edges2):\\n        \\\"\\\"\\\"\\n        :type edges1: List[List[int]]\\n        :type edges2: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Helper to compute (diameter, radius) of a tree given its edges\\n        def tree_diameter_and_radius(edges):\\n            n = len(edges) + 1\\n            adj = [[] for _ in range(n)]\\n            for u, v in edges:\\n                adj[u].append(v)\\n                adj[v].append(u)\\n            \\n            # BFS to find farthest node from `start`\\n            def bfs_farthest(start):\\n                dist = [-1]*n\\n                q = deque([start])\\n                dist[start] = 0\\n                far = start\\n                while q:\\n                    u = q.popleft()\\n                    for w in adj[u]:\\n                        if dist[w] == -1:\\n                            dist[w] = dist[u] + 1\\n                            q.append(w)\\n                            if dist[w] > dist[far]:\\n                                far = w\\n                return far, dist[far]\\n            \\n            # 1) from node 0 find some farthest node A\\n            A, _ = bfs_farthest(0)\\n            # 2) from A find farthest node B and its distance = diameter\\n            B, diameter = bfs_farthest(A)\\n            # radius = ceil(diameter / 2)\\n            radius = (diameter + 1) // 2\\n            return diameter, radius\\n        \\n        d1, r1 = tree_diameter_and_radius(edges1)\\n        d2, r2 = tree_diameter_and_radius(edges2)\\n        # best merged diameter\\n        return max(d1, d2, r1 + 1 + r2)\\n\"",
  "2386_14631217_python": "\"class Solution:\\n    def minMaxGame(self, nums):\\n        while len(nums) > 1:\\n            newNums = []\\n            for i in range(len(nums) // 2):\\n                a, b = nums[2*i], nums[2*i+1]\\n                if i % 2 == 0:\\n                    newNums.append(min(a, b))\\n                else:\\n                    newNums.append(max(a, b))\\n            nums = newNums\\n        return nums[0]\\n\"",
  "3777_14631217_python-updated-time": "1747822950560",
  "3372_14631217_python-updated-time": "1747423222065",
  "3447_14631217_python-updated-time": "1747484095688",
  "2531_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution:\\n    def componentValue(self, nums, edges):\\n        n = len(nums)\\n        # Build adjacency\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # Root at 0\\n        parent = [-1] * n\\n        children = [[] for _ in range(n)]\\n        stack = [0]\\n        parent[0] = 0\\n        order = []\\n        while stack:\\n            u = stack.pop()\\n            order.append(u)\\n            for w in adj[u]:\\n                if parent[w] < 0:\\n                    parent[w] = u\\n                    children[u].append(w)\\n                    stack.append(w)\\n        S = sum(nums)\\n        # All divisors of S\\n        divs = []\\n        i = 1\\n        while i * i <= S:\\n            if S % i == 0:\\n                divs.append(i)\\n                if i * i != S:\\n                    divs.append(S // i)\\n            i += 1\\n        divs.sort()\\n        # Try each piece-sum t\\n        def can_split(t):\\n            target = t\\n            count = 0\\n            subsum = [0] * n\\n            for u in reversed(order):\\n                s = nums[u]\\n                for w in children[u]:\\n                    s += subsum[w]\\n                if s == target:\\n                    count += 1\\n                    subsum[u] = 0\\n                elif s < target:\\n                    subsum[u] = s\\n                else:\\n                    return False\\n            return count == S // t\\n\\n        for t in divs:\\n            if can_split(t):\\n                return S // t - 1\\n        return 0\\n\"",
  "566_14631217_python-updated-time": "1745447785275",
  "627_14631217_mysql-updated-time": "1745782136374",
  "93_14631217_python-updated-time": "1745015701068",
  "2436_14631217_python": "\"class Solution:\\n    def minimumOperations(self, nums):\\n        # Count how many distinct positive values there are\\n        return len({x for x in nums if x > 0})\\n\"",
  "1092_14631217_python": "\"import sys\\nsys.setrecursionlimit(10000)\\n\\nclass Solution:\\n    def maxAncestorDiff(self, root):\\n        self.ans = 0\\n        def dfs(node, lo, hi):\\n            if not node:\\n                return\\n            self.ans = max(self.ans, abs(node.val - lo), abs(node.val - hi))\\n            lo2, hi2 = min(lo, node.val), max(hi, node.val)\\n            dfs(node.left, lo2, hi2)\\n            dfs(node.right, lo2, hi2)\\n        dfs(root, root.val, root.val)\\n        return self.ans\\n\"",
  "2748_14631217_python": "\"class Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \\\"\\\"\\\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Add delay and wrap around 24-hour clock\\n        return (arrivalTime + delayedTime) % 24\\n\"",
  "2915_14631217_python": "\"class Solution(object):\\n    def countInterestingSubarrays(self, nums, modulo, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type modulo: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n        \\n        count = defaultdict(int)\\n        # prefix sum modulo counts\\n        # P[0] = 0\\n        count[0] = 1\\n        \\n        prefix = 0\\n        ans = 0\\n        \\n        for x in nums:\\n            # A[i] = 1 if x % modulo == k else 0\\n            if x % modulo == k:\\n                prefix += 1\\n            # current prefix modulo\\n            pm = prefix % modulo\\n            # we want previous prefix modulo ≡ pm - k (mod modulo)\\n            need = (pm - k) % modulo\\n            ans += count.get(need, 0)\\n            # record this prefix modulo\\n            count[pm] += 1\\n        \\n        return ans\\n\"",
  "2089_14631217_python-updated-time": "1746715269994",
  "3644_14631217_python": "\"class Solution(object):\\n    def minimumSumSubarray(self, nums, l, r):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type l: int\\n        :type r: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # build prefix sums\\n        P = [0] * (n+1)\\n        for i in range(1, n+1):\\n            P[i] = P[i-1] + nums[i-1]\\n        \\n        best = float('inf')\\n        # try all subarrays of length between l and r\\n        for end in range(1, n+1):\\n            # subarray length ℓ from l..r\\n            for length in range(l, r+1):\\n                start = end - length\\n                if start < 0:\\n                    continue\\n                s = P[end] - P[start]\\n                if 0 < s < best:\\n                    best = s\\n        \\n        return best if best != float('inf') else -1\\n\"",
  "63_14631217_python": "\"class Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\\"\\\"\\\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n\\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i > 0:\\n                        dp[i][j] += dp[i-1][j]\\n                    if j > 0:\\n                        dp[i][j] += dp[i][j-1]\\n\\n        return dp[m-1][n-1]\\n\"",
  "775_14631217_python": "\"class Solution(object):\\n    def preorder(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            res.append(node.val)\\n            # push children in reverse order so we process left-to-right\\n            for child in reversed(node.children):\\n                stack.append(child)\\n        return res\\n\"",
  "1362_14631217_python-updated-time": "1746259219611",
  "1544_14631217_python-updated-time": "1746347596485",
  "1758_14631217_python-updated-time": "1746445396887",
  "967_14631217_python": "\"class Solution:\\n    def minFallingPathSum(self, matrix):\\n        n = len(matrix)\\n        \\n        for row in range(1, n):\\n            for col in range(n):\\n                min_above = matrix[row - 1][col]\\n                if col > 0:\\n                    min_above = min(min_above, matrix[row - 1][col - 1])\\n                if col < n - 1:\\n                    min_above = min(min_above, matrix[row - 1][col + 1])\\n                matrix[row][col] += min_above\\n\\n        return min(matrix[-1])\\n\"",
  "1947_14631217_python": "\"class Solution(object):\\n    def countDifferentSubsequenceGCDs(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # custom gcd to support older Python versions\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        max_num = max(nums)\\n        present = [False] * (max_num + 1)\\n        for x in nums:\\n            present[x] = True\\n\\n        count = 0\\n        # for each possible gcd g\\n        for g in range(1, max_num + 1):\\n            current_gcd = 0\\n            # iterate multiples of g\\n            for multiple in range(g, max_num + 1, g):\\n                if present[multiple]:\\n                    val = multiple // g\\n                    current_gcd = val if current_gcd == 0 else gcd(current_gcd, val)\\n                    # early exit: if gcd becomes 1, g is achievable\\n                    if current_gcd == 1:\\n                        count += 1\\n                        break\\n        return count\\n\"",
  "1197_14631217_python": "\"class Solution(object):\\n    def parseBoolExpr(self, expression):\\n        \\\"\\\"\\\"\\n        :type expression: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        stack = []\\n\\n        for ch in expression:\\n            if ch == ',':\\n                continue\\n            elif ch == ')':\\n                vals = set()\\n                while stack[-1] != '(':\\n                    vals.add(stack.pop())\\n                stack.pop()  # remove '('\\n                op = stack.pop()\\n                if op == '&':\\n                    stack.append('t' if all(v == 't' for v in vals) else 'f')\\n                elif op == '|':\\n                    stack.append('t' if any(v == 't' for v in vals) else 'f')\\n                elif op == '!':\\n                    stack.append('f' if list(vals)[0] == 't' else 't')\\n            else:\\n                stack.append(ch)\\n\\n        return stack[0] == 't'\\n\"",
  "2402_14631217_python": "\"class Solution:\\n    def maximumXOR(self, nums):\\n        ans = 0\\n        for v in nums:\\n            ans |= v\\n        return ans\\n\"",
  "2554_14631217_python": "\"import sys\\nimport heapq\\n\\nclass Solution:\\n    def minimumTotalDistance(self, robot, factory):\\n        # Sort robots and factories by position\\n        robot.sort()\\n        factory.sort(key=lambda x: x[0])\\n        n = len(robot)\\n        # Initialize dp: dp[r] = min cost to fix first r robots\\n        INF = 10**30\\n        dp = [INF] * (n + 1)\\n        dp[0] = 0\\n        # For each factory, update dp\\n        for pos, limit in factory:\\n            # cost to assign t robots ending at r to this factory\\n            # precompute prefix sums of distances\\n            dist = [0] * (n + 1)\\n            for i in range(1, n + 1):\\n                dist[i] = dist[i-1] + abs(robot[i-1] - pos)\\n            # new dp copy\\n            new_dp = dp[:]\\n            # try assigning t robots to this factory\\n            for r in range(1, n + 1):\\n                # assign t robots ending at r\\n                for t in range(1, min(limit, r) + 1):\\n                    cost = dp[r-t] + (dist[r] - dist[r-t])\\n                    if cost < new_dp[r]:\\n                        new_dp[r] = cost\\n            dp = new_dp\\n        # answer: all n robots\\n        return dp[n]\"",
  "2195_14631217_python-updated-time": "1746729118999",
  "1348_14631217_python": "\"class Solution:\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        def kadane(diff):\\n            max_ending_here = max_so_far = diff[0]\\n            for x in diff[1:]:\\n                max_ending_here = max(x, max_ending_here + x)\\n                max_so_far = max(max_so_far, max_ending_here)\\n            return max(0, max_so_far)  # No swap is also valid\\n\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n\\n        diff1 = [b - a for a, b in zip(nums1, nums2)]\\n        diff2 = [a - b for a, b in zip(nums1, nums2)]\\n\\n        return max(s1 + kadane(diff1), s2 + kadane(diff2))\\n\"",
  "424_14631217_python": "\"class Solution:\\n    def characterReplacement(self, s, k):\\n        count = {}\\n        maxf = 0\\n        res = 0\\n        left = 0\\n        \\n        for right in range(len(s)):\\n            count[s[right]] = count.get(s[right], 0) + 1\\n            maxf = max(maxf, count[s[right]])\\n            \\n            while (right - left + 1) - maxf > k:\\n                count[s[left]] -= 1\\n                left += 1\\n            \\n            res = max(res, right - left + 1)\\n        \\n        return res\\n\"",
  "2294_14631217_python": "\"class Solution:\\n    def minimumTime(self, time, totalTrips):\\n        left, right = 1, min(time) * totalTrips\\n        while left < right:\\n            mid = (left + right) // 2\\n            if sum(mid // t for t in time) >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "1272_14631217_python": "\"class Solution(object):\\n    def invalidTransactions(self, transactions):\\n        \\\"\\\"\\\"\\n        :type transactions: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        parsed = []\\n        for t in transactions:\\n            name, time, amount, city = t.split(\\\",\\\")\\n            parsed.append((name, int(time), int(amount), city, t))\\n\\n        n = len(parsed)\\n        invalid = [False] * n\\n\\n        for i in range(n):\\n            name_i, time_i, amount_i, city_i, raw_i = parsed[i]\\n            \\n            if amount_i > 1000:\\n                invalid[i] = True\\n            \\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                name_j, time_j, amount_j, city_j, raw_j = parsed[j]\\n                if name_i == name_j and city_i != city_j and abs(time_i - time_j) <= 60:\\n                    invalid[i] = True\\n                    break\\n\\n        return [parsed[i][4] for i in range(n) if invalid[i]]\\n\"",
  "3764_14631217_python-updated-time": "1747681117784",
  "3572_14631217_python": "\"class Solution(object):\\n    def validSubstringCount(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word1)\\n        # 1) Build need‐counts for word2 in a fixed‐size array of length 26\\n        freq_need = [0] * 26\\n        for c in word2:\\n            freq_need[ord(c) - 97] += 1\\n        # Count how many distinct letters actually must be met\\n        required = sum(1 for cnt in freq_need if cnt > 0)\\n\\n        # 2) Sliding window over word1 with two pointers i (left) and r (right)\\n        freq_have = [0] * 26\\n        valid_met = 0   # how many of the required letters are currently satisfied\\n        r = 0\\n        ans = 0\\n\\n        for i in range(n):\\n            # Expand r until we cover all required letters or hit the end\\n            while r < n and valid_met < required:\\n                idx = ord(word1[r]) - 97\\n                freq_have[idx] += 1\\n                if freq_need[idx] > 0 and freq_have[idx] == freq_need[idx]:\\n                    valid_met += 1\\n                r += 1\\n\\n            # If we've satisfied all required counts, then every substring\\n            # starting at i with end ≥ r-1 is valid\\n            if valid_met == required:\\n                ans += (n - (r - 1))\\n\\n            # Before moving i→i+1, remove word1[i] from the window\\n            idx = ord(word1[i]) - 97\\n            if freq_need[idx] > 0 and freq_have[idx] == freq_need[idx]:\\n                valid_met -= 1\\n            freq_have[idx] -= 1\\n\\n        return ans\\n\"",
  "882_14631217_python": "\"class Solution(object):\\n    def peakIndexInMountainArray(self, arr):\\n        left, right = 0, len(arr) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if arr[mid] < arr[mid + 1]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n\"",
  "988_14631217_python": "\"class Solution:\\n    def flipEquiv(self, root1, root2):\\n        if not root1 and not root2:\\n            return True\\n        if not root1 or not root2 or root1.val != root2.val:\\n            return False\\n        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or \\\\\\n               (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))\\n\"",
  "1666_14631217_python": "\"class Solution(object):\\n    def makeGood(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        stack = []\\n\\n        for ch in s:\\n            if stack and abs(ord(stack[-1]) - ord(ch)) == 32:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n\\n        return ''.join(stack)\\n\"",
  "2319_14631217_python-updated-time": "1746810887894",
  "598_14631217_python-updated-time": "1745448501196",
  "2742_14631217_javascript-updated-time": "1747135631610",
  "162_14631217_python": "\"class Solution(object):\\n    def findPeakElement(self, nums):\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < nums[mid + 1]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n\"",
  "1463_14631217_python-updated-time": "1746261705991",
  "227_14631217_python": "\"class Solution(object):\\n    def calculate(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        s = s.replace(' ', '')\\n        stack = []\\n        num = 0\\n        sign = '+'\\n        \\n        for i, ch in enumerate(s):\\n            if ch.isdigit():\\n                num = num * 10 + int(ch)\\n            if ch in '+-*/' or i == len(s) - 1:\\n                if sign == '+':\\n                    stack.append(num)\\n                elif sign == '-':\\n                    stack.append(-num)\\n                elif sign == '*':\\n                    stack[-1] = stack[-1] * num\\n                elif sign == '/':\\n                    stack[-1] = int(stack[-1] / float(num))\\n                sign = ch\\n                num = 0\\n        \\n        return sum(stack)\\n\"",
  "3104_14631217_python": "\"class Solution(object):\\n    def countWays(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        res = 0\\n        \\n        # Case when we select 0 students\\n        if nums[0] > 0:\\n            res += 1\\n        \\n        # Try all splits between 1 to n-1\\n        for i in range(1, n):\\n            if nums[i-1] < i and nums[i] > i:\\n                res += 1\\n        \\n        # Case when we select all students\\n        if nums[-1] < n:\\n            res += 1\\n        \\n        return res\\n\"",
  "1310_14631217_python-updated-time": "1746729327121",
  "1029_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def verticalTraversal(self, root):\\n        node_map = defaultdict(list)\\n        queue = deque([(root, 0, 0)])  # (node, row, col)\\n\\n        while queue:\\n            node, row, col = queue.popleft()\\n            node_map[col].append((row, node.val))\\n            if node.left:\\n                queue.append((node.left, row + 1, col - 1))\\n            if node.right:\\n                queue.append((node.right, row + 1, col + 1))\\n\\n        result = []\\n        for col in sorted(node_map.keys()):\\n            # Sort first by row, then by value\\n            col_nodes = sorted(node_map[col])\\n            result.append([val for row, val in col_nodes])\\n        return result\\n\"",
  "103_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        from collections import deque\\n        result = []\\n        queue = deque([root])\\n        left_to_right = True\\n        \\n        while queue:\\n            level_size = len(queue)\\n            level = deque()\\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                if left_to_right:\\n                    level.append(node.val)\\n                else:\\n                    level.appendleft(node.val)\\n                \\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            result.append(list(level))\\n            left_to_right = not left_to_right\\n        \\n        return result\\n\"",
  "1792_14631217_python-updated-time": "1746452561863",
  "3076_14631217_pythondata-updated-time": "1747305565192",
  "3748_14631217_python": "\"class Solution(object):\\n    def sortMatrix(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        # Process each diagonal identified by d = j - i\\n        for d in range(-(n-1), n):\\n            # collect the positions along this diagonal\\n            i_start = max(0, -d)\\n            i_end   = min(n-1, n-1-d)\\n            vals = []\\n            for i in range(i_start, i_end+1):\\n                j = i + d\\n                vals.append(grid[i][j])\\n            # sort according to which triangle we're in\\n            # bottom-left (d <= 0): non-increasing\\n            # top-right   (d >  0): non-decreasing\\n            if d <= 0:\\n                vals.sort(reverse=True)\\n            else:\\n                vals.sort()\\n            # write back in the same traversal order\\n            idx = 0\\n            for i in range(i_start, i_end+1):\\n                j = i + d\\n                grid[i][j] = vals[idx]\\n                idx += 1\\n\\n        return grid\\n\"",
  "1508_14631217_python-updated-time": "1746346173237",
  "619_14631217_mysql-updated-time": "1745780611232",
  "3336_14631217_python-updated-time": "1747423077928",
  "1035_14631217_python-updated-time": "1746040652475",
  "2755_14631217_python": "\"class Solution:\\n    def minExtraChar(self, s, dictionary):\\n        n = len(s)\\n        word_set = set(dictionary)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = dp[i + 1] + 1  # assume s[i] is extra\\n            for j in range(i + 1, n + 1):\\n                if s[i:j] in word_set:\\n                    dp[i] = min(dp[i], dp[j])\\n        return dp[0]\\n\"",
  "2162_14631217_python": "\"import bisect\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        length = len(nums)\\n        n = length // 2\\n        A, B = nums[:n], nums[n:]\\n        \\n        # Collect all subset-sums of A and B by how many elements they use\\n        sumsA = defaultdict(list)\\n        sumsB = defaultdict(list)\\n        \\n        def dfsA(i, cnt, s):\\n            if i == n:\\n                sumsA[cnt].append(s)\\n                return\\n            dfsA(i+1, cnt, s)            # skip A[i]\\n            dfsA(i+1, cnt+1, s + A[i])   # take A[i]\\n        \\n        def dfsB(i, cnt, s):\\n            if i == n:\\n                sumsB[cnt].append(s)\\n                return\\n            dfsB(i+1, cnt, s)            # skip B[i]\\n            dfsB(i+1, cnt+1, s + B[i])   # take B[i]\\n        \\n        dfsA(0, 0, 0)\\n        dfsB(0, 0, 0)\\n        \\n        # Sort the lists for B so we can binary-search them\\n        for cnt in sumsB:\\n            sumsB[cnt].sort()\\n        \\n        total = sum(nums)\\n        half = total / 2.0\\n        best = float('inf')\\n        \\n        # Try picking k elements from A and (n-k) from B\\n        for cntA, listA in sumsA.iteritems():\\n            cntB = n - cntA\\n            if cntB not in sumsB:\\n                continue\\n            listB = sumsB[cntB]\\n            for sA in listA:\\n                # We want sA + sB as close to total/2 as possible\\n                target = half - sA\\n                idx = bisect.bisect_left(listB, target)\\n                # Check the candidate at idx\\n                if idx < len(listB):\\n                    sB = listB[idx]\\n                    diff = abs(2 * (sA + sB) - total)\\n                    if diff < best:\\n                        best = diff\\n                # And also check the one just before\\n                if idx > 0:\\n                    sB = listB[idx - 1]\\n                    diff = abs(2 * (sA + sB) - total)\\n                    if diff < best:\\n                        best = diff\\n        \\n        return int(best)\\n\"",
  "11_14631217_python": "\"class Solution(object):\\n    def maxArea(self, height):\\n        \\\"\\\"\\\"\\n        :type height: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(height) - 1\\n        max_area = 0\\n\\n        while left < right:\\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\\n            if height[left] < height[right]:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        return max_area\\n\"",
  "739_14631217_python-updated-time": "1745787504116",
  "1478_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxEvents(self, events):\\n        \\\"\\\"\\\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        events.sort()  # sort by start day\\n        min_heap = []\\n        day = 0\\n        i = 0\\n        res = 0\\n        n = len(events)\\n\\n        while i < n or min_heap:\\n            if not min_heap:\\n                day = events[i][0]\\n            # Add all events starting today\\n            while i < n and events[i][0] <= day:\\n                heapq.heappush(min_heap, events[i][1])\\n                i += 1\\n            # Remove all expired events\\n            while min_heap and min_heap[0] < day:\\n                heapq.heappop(min_heap)\\n            if min_heap:\\n                heapq.heappop(min_heap)  # attend event with earliest end\\n                res += 1\\n            day += 1\\n\\n        return res\\n\"",
  "2828_14631217_python-updated-time": "1747221015362",
  "587_14631217_python": "\"class Solution(object):\\n    def outerTrees(self, trees):\\n        \\\"\\\"\\\"\\n        :type trees: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # Andrew's monotone chain, keeping collinear boundary points\\n        pts = sorted(trees)\\n        if len(pts) <= 1:\\n            return pts\\n\\n        def cross(o, a, b):\\n            return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\\n\\n        # build lower hull\\n        lower = []\\n        for p in pts:\\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:\\n                lower.pop()\\n            lower.append(p)\\n\\n        # build upper hull\\n        upper = []\\n        for p in reversed(pts):\\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:\\n                upper.pop()\\n            upper.append(p)\\n\\n        # concatenate, excluding duplicate endpoints\\n        hull = lower[:-1] + upper[:-1]\\n        # remove duplicates and return\\n        return [list(x) for x in set(map(tuple, hull))]\\n\"",
  "3685_14631217_python-updated-time": "1747597877032",
  "1279_14631217_python-updated-time": "1746126404026",
  "1915_14631217_python": "\"class Solution(object):\\n    def areAlmostEqual(self, s1, s2):\\n        if s1 == s2:\\n            return True\\n\\n        diff = [(a, b) for a, b in zip(s1, s2) if a != b]\\n        return len(diff) == 2 and diff[0] == diff[1][::-1]\\n\"",
  "3633_14631217_python-updated-time": "1747595924318",
  "1699_14631217_python-updated-time": "1746438385835",
  "2794_14631217_python": "\"class Solution:\\n    def maxMoves(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[-1] * n for _ in range(m)]\\n\\n        def dfs(r, c):\\n            if visited[r][c] != -1:\\n                return visited[r][c]\\n            max_steps = 0\\n            for dr, dc in [(-1, 1), (0, 1), (1, 1)]:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and nc < n and grid[nr][nc] > grid[r][c]:\\n                    max_steps = max(max_steps, 1 + dfs(nr, nc))\\n            visited[r][c] = max_steps\\n            return max_steps\\n\\n        return max(dfs(r, 0) for r in range(m))\\n\"",
  "2171_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type time: int\\n        :type change: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Build adjacency list\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # For each node, store up to 2 distinct arrival times\\n        arrivals = [[] for _ in range(n + 1)]\\n        # Min-heap of (current_time, node)\\n        heap = [(0, 1)]  # start at node 1 at time 0\\n\\n        while heap:\\n            cur_time, node = heapq.heappop(heap)\\n\\n            # If we've already got two times and this one is not strictly better, skip\\n            times = arrivals[node]\\n            # Avoid duplicates\\n            if times and cur_time == times[-1]:\\n                continue\\n            if len(times) >= 2:\\n                continue\\n\\n            # Record this arrival\\n            arrivals[node].append(cur_time)\\n            # If we've recorded two for target, that's the answer\\n            if node == n and len(arrivals[node]) == 2:\\n                return cur_time\\n\\n            # Compute departure time after waiting for green signal if needed\\n            # Each signal is green for 'change' minutes, then red for 'change' minutes, repeating.\\n            cycle = cur_time // change\\n            if cycle % 2 == 1:\\n                # currently in a red phase\\n                wait = change - (cur_time % change)\\n                depart = cur_time + wait\\n            else:\\n                depart = cur_time\\n\\n            # Traverse neighbors\\n            for nei in graph[node]:\\n                arrive_time = depart + time\\n                heapq.heappush(heap, (arrive_time, nei))\\n\\n        # Problem guarantees a solution\\n        return -1\\n\"",
  "1046_14631217_python": "\"class Solution:\\n    def longestOnes(self, nums, k):\\n        left = 0\\n        max_len = 0\\n        zeros = 0\\n\\n        for right in range(len(nums)):\\n            if nums[right] == 0:\\n                zeros += 1\\n            while zeros > k:\\n                if nums[left] == 0:\\n                    zeros -= 1\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n\\n        return max_len\\n\"",
  "2387_14631217_python": "\"class Solution:\\n    def partitionArray(self, nums, k):\\n        # Sort the numbers to group by value\\n        nums.sort()\\n        count = 1\\n        start = nums[0]\\n        \\n        for x in nums:\\n            # If the current number is too far from the group's minimum,\\n            # start a new subsequence\\n            if x - start > k:\\n                count += 1\\n                start = x\\n        \\n        return count\\n\"",
  "767_14631217_python": "\"class Solution(object):\\n    def countPrimeSetBits(self, left, right):\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        count = 0\\n        for num in range(left, right + 1):\\n            if bin(num).count('1') in primes:\\n                count += 1\\n        return count\\n\"",
  "2883_14631217_python": "\"class Solution:\\n    def minimumBeautifulSubstrings(self, s):\\n        # Precompute all binary strings of powers of 5 up to length 15\\n        powers_of_5 = set()\\n        val = 1\\n        while val < (1 << 15):\\n            powers_of_5.add(bin(val)[2:])\\n            val *= 5\\n\\n        memo = {}\\n\\n        def dp(i):\\n            if i == len(s):\\n                return 0\\n            if s[i] == '0':  # no leading zero allowed\\n                return float('inf')\\n            if i in memo:\\n                return memo[i]\\n\\n            res = float('inf')\\n            for j in range(i + 1, len(s) + 1):\\n                if s[i:j] in powers_of_5:\\n                    res = min(res, 1 + dp(j))\\n\\n            memo[i] = res\\n            return res\\n\\n        ans = dp(0)\\n        return ans if ans != float('inf') else -1\\n\"",
  "878_14631217_python": "\"class Solution:\\n    def shiftingLetters(self, s, shifts):\\n        n = len(s)\\n        total = 0\\n        res = []\\n\\n        for i in range(n-1, -1, -1):\\n            total = (total + shifts[i]) % 26\\n            new_char = chr((ord(s[i]) - ord('a') + total) % 26 + ord('a'))\\n            res.append(new_char)\\n\\n        return ''.join(reversed(res))\\n\"",
  "1019_14631217_python-updated-time": "1746040106659",
  "621_14631217_python-updated-time": "1745780668907",
  "2848_14631217_python-updated-time": "1747221393841",
  "1960_14631217_python-updated-time": "1746544267407",
  "1889_14631217_python": "\"class Solution:\\n    def checkPowersOfThree(self, n):\\n        while n > 0:\\n            if n % 3 == 2:\\n                return False\\n            n //= 3\\n        return True\\n\"",
  "2124_14631217_python-updated-time": "1746717380584",
  "2317_14631217_python-updated-time": "1746810555302",
  "95_14631217_python-updated-time": "1745015844059",
  "2350_14631217_python-updated-time": "1746879577762",
  "780_14631217_python-updated-time": "1745876256762",
  "2636_14631217_python-updated-time": "1747061563096",
  "354_14631217_python-updated-time": "1745257262437",
  "1183_14631217_python": "\"class Solution(object):\\n    def sampleStats(self, count):\\n        \\\"\\\"\\\"\\n        :type count: List[int]\\n        :rtype: List[float]\\n        \\\"\\\"\\\"\\n        total_count = sum(count)\\n        total_sum = 0\\n        min_val = None\\n        max_val = None\\n        mode = 0\\n        max_freq = 0\\n        \\n        # First pass: min, max, sum, mode\\n        for i in range(256):\\n            if count[i] > 0:\\n                if min_val is None:\\n                    min_val = i\\n                max_val = i\\n                total_sum += count[i] * i\\n                if count[i] > max_freq:\\n                    max_freq = count[i]\\n                    mode = i\\n\\n        # Second pass: find median\\n        median = 0.0\\n        mid1 = (total_count + 1) // 2\\n        mid2 = (total_count + 2) // 2  # Handles both even and odd\\n        m1 = m2 = None\\n        curr = 0\\n\\n        for i in range(256):\\n            curr += count[i]\\n            if m1 is None and curr >= mid1:\\n                m1 = i\\n            if m2 is None and curr >= mid2:\\n                m2 = i\\n                break\\n\\n        median = (m1 + m2) / 2.0\\n\\n        return [float(min_val), float(max_val), float(total_sum) / total_count, median, float(mode)]\\n\"",
  "2577_14631217_python-updated-time": "1747057307622",
  "228_14631217_python-updated-time": "1745247088402",
  "171_14631217_python-updated-time": "1745091992551",
  "1791_14631217_python": "\"class Solution(object):\\n    def maximumWealth(self, accounts):\\n        return max(sum(customer) for customer in accounts)\\n\"",
  "832_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def pruneTree(self, root):\\n        if not root:\\n            return None\\n        root.left = self.pruneTree(root.left)\\n        root.right = self.pruneTree(root.right)\\n        if root.val == 0 and not root.left and not root.right:\\n            return None\\n        return root\"",
  "1230_14631217_python-updated-time": "1746109241026",
  "300_14631217_python": "\"class Solution(object):\\n    def lengthOfLIS(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import bisect\\n        sub = []\\n        for num in nums:\\n            i = bisect.bisect_left(sub, num)\\n            if i == len(sub):\\n                sub.append(num)\\n            else:\\n                sub[i] = num\\n        return len(sub)\\n\"",
  "753_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def openLock(self, deadends, target):\\n        dead = set(deadends)\\n        if \\\"0000\\\" in dead:\\n            return -1\\n        queue = deque([(\\\"0000\\\", 0)])\\n        visited = set(\\\"0000\\\")\\n        \\n        while queue:\\n            node, step = queue.popleft()\\n            if node == target:\\n                return step\\n            for i in range(4):\\n                for move in (-1, 1):\\n                    nxt = node[:i] + str((int(node[i]) + move) % 10) + node[i+1:]\\n                    if nxt not in dead and nxt not in visited:\\n                        visited.add(nxt)\\n                        queue.append((nxt, step + 1))\\n        return -1\\n\"",
  "1511_14631217_python-updated-time": "1746346271474",
  "2744_14631217_javascript-updated-time": "1747135598934",
  "2055_14631217_python-updated-time": "1746638534970",
  "1421_14631217_python": "\"class Solution:\\n    def findNumbers(self, nums):\\n        return sum(1 for num in nums if len(str(num)) % 2 == 0)\\n\"",
  "3773_14631217_python": "\"class Solution(object):\\n    def minimumPairRemoval(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def is_non_decreasing(arr):\\n            return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\\n        \\n        ops = 0\\n        # If already non-decreasing, no operations needed\\n        if is_non_decreasing(nums):\\n            return 0\\n        \\n        while len(nums) > 1:\\n            # Find the leftmost adjacent pair with minimum sum\\n            min_sum = nums[0] + nums[1]\\n            idx = 0\\n            for i in range(1, len(nums)-1):\\n                s = nums[i] + nums[i+1]\\n                if s < min_sum:\\n                    min_sum = s\\n                    idx = i\\n            # Replace that pair with their sum\\n            nums = nums[:idx] + [min_sum] + nums[idx+2:]\\n            ops += 1\\n            # Check if we've achieved non-decreasing order\\n            if is_non_decreasing(nums):\\n                return ops\\n        \\n        # If we collapse down to a single element, it's trivially non-decreasing\\n        return ops\\n\"",
  "2847_14631217_python-updated-time": "1747221493217",
  "3871_14631217_python-updated-time": "1747681903259",
  "2549_14631217_python": "\"class Solution:\\n    def secondGreaterElement(self, nums):\\n        n = len(nums)\\n        ans = [-1] * n\\n        stack1 = []  # indices waiting for their first greater\\n        stack2 = []  # indices waiting for their second greater\\n\\n        for i, x in enumerate(nums):\\n            # First, resolve any second-greater for stack2\\n            while stack2 and x > nums[stack2[-1]]:\\n                idx = stack2.pop()\\n                ans[idx] = x\\n\\n            # Next, move from stack1 to stack2 when we find first greater\\n            temp = []\\n            while stack1 and x > nums[stack1[-1]]:\\n                temp.append(stack1.pop())\\n            # Those popped now await their second greater\\n            stack2.extend(reversed(temp))\\n\\n            # Finally, this index itself awaits its first greater\\n            stack1.append(i)\\n\\n        return ans\\n\"",
  "3646_14631217_python-updated-time": "1747587669591",
  "391_14631217_python-updated-time": "1745355439398",
  "2347_14631217_python-updated-time": "1746880646372",
  "1278_14631217_mysql-updated-time": "1746126208603",
  "944_14631217_python": "\"class Solution:\\n    def smallestRangeI(self, nums, k):\\n        return max(0, max(nums) - min(nums) - 2 * k)\\n\"",
  "1054_14631217_python-updated-time": "1746041322960",
  "802_14631217_python-updated-time": "1745877562660",
  "1116_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxLevelSum(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_sum = float('-inf')\\n        max_level = 1\\n        level = 1\\n        queue = deque([root])\\n        \\n        while queue:\\n            level_sum = 0\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            if level_sum > max_sum:\\n                max_sum = level_sum\\n                max_level = level\\n            level += 1\\n        \\n        return max_level\\n\"",
  "2783_14631217_javascript-updated-time": "1747136227122",
  "80_14631217_python-updated-time": "1745015302282",
  "777_14631217_python-updated-time": "1745876139875",
  "2810_14631217_python-updated-time": "1747221116494",
  "2866_14631217_python": "\"class Solution:\\n    def longestAlternatingSubarray(self, nums, threshold):\\n        n = len(nums)\\n        max_len = 0\\n        i = 0\\n\\n        while i < n:\\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\\n                length = 1\\n                j = i + 1\\n                while j < n and nums[j] <= threshold and nums[j] % 2 != nums[j - 1] % 2:\\n                    length += 1\\n                    j += 1\\n                max_len = max(max_len, length)\\n                i = j  # move to the next possible start\\n            else:\\n                i += 1\\n\\n        return max_len\\n\"",
  "2953_14631217_python-updated-time": "1747227326126",
  "2595_14631217_python": "\"class Solution:\\n    def smallestValue(self, n):\\n        def prime_sum(x):\\n            s = 0\\n            i = 2\\n            while i * i <= x:\\n                while x % i == 0:\\n                    s += i\\n                    x //= i\\n                i += 1\\n            if x > 1:\\n                s += x\\n            return s\\n\\n        prev = -1\\n        while n != prev:\\n            prev = n\\n            n = prime_sum(n)\\n        return n\\n\"",
  "82_14631217_python-updated-time": "1745015367647",
  "191_14631217_python": "\"class Solution(object):\\n    def hammingWeight(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        while n:\\n            n &= (n - 1)\\n            count += 1\\n        return count\\n\"",
  "1965_14631217_python": "\"class Solution(object):\\n    def sumBase(self, n, k):\\n        s = 0\\n        while n:\\n            s += n % k\\n            n //= k\\n        return s\\n\"",
  "213_14631217_python": "\"class Solution(object):\\n    def rob(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        def rob_line(nums):\\n            prev = curr = 0\\n            for num in nums:\\n                prev, curr = curr, max(curr, prev + num)\\n            return curr\\n        \\n        return max(rob_line(nums[1:]), rob_line(nums[:-1]))\\n\"",
  "2362_14631217_python-updated-time": "1746879794851",
  "1023_14631217_python-updated-time": "1746040261325",
  "2202_14631217_python": "\"class Solution:\\n    def kMirror(self, k, n):\\n        def is_pal_base_k(x):\\n            # Check if x in base-k is a palindrome\\n            digits = []\\n            while x > 0:\\n                digits.append(x % k)\\n                x //= k\\n            return digits == digits[::-1]\\n\\n        def gen_palindromes():\\n            # Yield base-10 palindromes in ascending order\\n            # 1-digit:\\n            for d in range(1, 10):\\n                yield d\\n            length = 2\\n            while True:\\n                half = (length + 1) // 2\\n                start = 10**(half - 1)\\n                end = 10**half\\n                for first in range(start, end):\\n                    s = str(first)\\n                    if length % 2 == 1:\\n                        pal = s + s[-2::-1]\\n                    else:\\n                        pal = s + s[::-1]\\n                    yield int(pal)\\n                length += 1\\n\\n        result = []\\n        for p in gen_palindromes():\\n            if is_pal_base_k(p):\\n                result.append(p)\\n                if len(result) == n:\\n                    break\\n        return sum(result)\\n\"",
  "2481_14631217_python": "\"class Solution(object):\\n    def isStrictlyPalindromic(self, n):\\n        return False\\n\"",
  "1818_14631217_python": "\"class Solution(object):\\n    def maximumGain(self, s, x, y):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Decide which pattern to remove first\\n        if x >= y:\\n            first, first_score = \\\"ab\\\", x\\n            second, second_score = \\\"ba\\\", y\\n        else:\\n            first, first_score = \\\"ba\\\", y\\n            second, second_score = \\\"ab\\\", x\\n\\n        total = 0\\n        stack = []\\n\\n        # First pass: remove all occurrences of `first`\\n        for c in s:\\n            stack.append(c)\\n            if len(stack) >= 2 and stack[-2] + stack[-1] == first:\\n                # pop the two characters, gain score\\n                stack.pop()\\n                stack.pop()\\n                total += first_score\\n\\n        # Build the intermediate string\\n        t = \\\"\\\".join(stack)\\n\\n        # Second pass: remove all occurrences of `second`\\n        stack = []\\n        for c in t:\\n            stack.append(c)\\n            if len(stack) >= 2 and stack[-2] + stack[-1] == second:\\n                stack.pop()\\n                stack.pop()\\n                total += second_score\\n\\n        return total\\n\"",
  "2751_14631217_python-updated-time": "1747136391326",
  "3776_14631217_python": "\"import sys\\nsys.setrecursionlimit(10000)\\n\\nclass Solution(object):\\n    def minCost(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n        if n <= 2:\\n            return max(nums)\\n        \\n        # dp[i][j]: min cost to clear array [nums[j]] + nums[i:]\\n        # i: start index of suffix; j: index of survivor at front\\n        dp = [[-1] * n for _ in range(n + 1)]\\n        \\n        def solve(i, j):\\n            # dp on state (i, j)\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            # Remaining array length\\n            rem = 1 + (n - i)\\n            # Base: if rem <= 2, single final operation\\n            if rem == 2:\\n                dp[i][j] = max(nums[j], nums[i])\\n                return dp[i][j]\\n            if rem == 1:\\n                dp[i][j] = nums[j]\\n                return dp[i][j]\\n            \\n            # General: at least 3 elements in [nums[j]] + nums[i:]\\n            a0 = nums[j]\\n            a1 = nums[i]\\n            a2 = nums[i + 1]\\n            # Next suffix starts at k = i+2\\n            k = i + 2\\n            \\n            # Option 1: remove a0 and a1, survivor becomes a2 at index i+1\\n            cost1 = max(a0, a1) + solve(k, i + 1)\\n            # Option 2: remove a0 and a2, survivor becomes a1 at index i\\n            cost2 = max(a0, a2) + solve(k, i)\\n            # Option 3: remove a1 and a2, survivor remains a0 at index j\\n            cost3 = max(a1, a2) + solve(k, j)\\n            \\n            dp[i][j] = min(cost1, cost2, cost3)\\n            return dp[i][j]\\n        \\n        # Initial removal among first three of nums[0], nums[1], nums[2]\\n        a0, a1, a2 = nums[0], nums[1], nums[2]\\n        # Suffix start index\\n        k = 3\\n        ans1 = max(a0, a1) + solve(k, 2)  # remove indices 0 & 1\\n        ans2 = max(a0, a2) + solve(k, 1)  # remove 0 & 2\\n        ans3 = max(a1, a2) + solve(k, 0)  # remove 1 & 2\\n        \\n        return min(ans1, ans2, ans3)\"",
  "3405_14631217_python": "\"class Solution(object):\\n    def numberOfSpecialChars(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        # Track for each letter: last lowercase index, first uppercase index\\n        last_lower = [-1] * 26\\n        first_upper = [n] * 26\\n        has_lower = [False] * 26\\n        has_upper = [False] * 26\\n        for i, ch in enumerate(word):\\n            if 'a' <= ch <= 'z':\\n                idx = ord(ch) - ord('a')\\n                has_lower[idx] = True\\n                last_lower[idx] = i\\n            elif 'A' <= ch <= 'Z':\\n                idx = ord(ch) - ord('A')\\n                has_upper[idx] = True\\n                # record only first uppercase index\\n                if first_upper[idx] == n:\\n                    first_upper[idx] = i\\n        # Count special letters: appear both, and all lowers before first upper\\n        count = 0\\n        for idx in range(26):\\n            if has_lower[idx] and has_upper[idx] and last_lower[idx] < first_upper[idx]:\\n                count += 1\\n        return count\"",
  "2403_14631217_python-updated-time": "1746882931320",
  "3151_14631217_python-updated-time": "1747306175519",
  "2480_14631217_python-updated-time": "1746965554361",
  "42_14631217_python": "\"class Solution(object):\\n    def trap(self, height):\\n        \\\"\\\"\\\"\\n        :type height: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(height) - 1\\n        left_max, right_max = 0, 0\\n        water = 0\\n\\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] >= left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] >= right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n\\n        return water\\n\"",
  "1396_14631217_python-updated-time": "1746260003159",
  "1771_14631217_python": "\"class Solution:\\n    def maxProfit(self, inventory, orders):\\n        MOD = 10**9 + 7\\n\\n        # 1) Sort descending and append a 0 at the end as sentinel\\n        inventory.sort(reverse=True)\\n        inventory.append(0)\\n\\n        ans = 0\\n        n = len(inventory)\\n        k = 1  # number of colors at the current top height\\n\\n        for i in range(n - 1):\\n            H = inventory[i]\\n            H2 = inventory[i+1]\\n            if H > H2:\\n                # We have k piles at height H, next distinct height is H2\\n                cnt = k * (H - H2)  # total balls if we fully deplete down to H2\\n                if orders >= cnt:\\n                    # Sell the whole block from H down to H2+1\\n                    # Sum of an arithmetic sequence: (first+last)*#terms//2\\n                    block_value = k * (H + H2 + 1) * (H - H2) // 2\\n                    ans = (ans + block_value) % MOD\\n                    orders -= cnt\\n                else:\\n                    # We can't take the whole block: partial\\n                    d = orders // k  # full levels we can remove\\n                    r = orders % k   # leftover single sales\\n                    # Value from full d levels: k * (2H - d + 1) * d // 2\\n                    full_levels_val = k * (2*H - d + 1) * d // 2\\n                    # Plus r sales at height H-d\\n                    remainder_val = r * (H - d)\\n                    ans = (ans + full_levels_val + remainder_val) % MOD\\n                    return ans\\n\\n            # Move to next height\\n            k += 1\\n\\n        return ans\\n\"",
  "20_14631217_python": "\"class Solution(object):\\n    def isValid(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        stack = []\\n        mapping = {')': '(', '}': '{', ']': '['}\\n\\n        for char in s:\\n            if char in mapping:\\n                top = stack.pop() if stack else '#'\\n                if mapping[char] != top:\\n                    return False\\n            else:\\n                stack.append(char)\\n\\n        return not stack\\n\"",
  "1794_14631217_python-updated-time": "1746452666463",
  "2183_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, nums, start, goal):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type start: int\\n        :type goal: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If start already equals goal (though constraints say start != goal), we'd return 0.\\n        # Use BFS over x values in [0,1000]\\n        visited = [False] * 1001\\n        q = deque()\\n        q.append((start, 0))\\n        if 0 <= start <= 1000:\\n            visited[start] = True\\n\\n        while q:\\n            x, steps = q.popleft()\\n            for v in nums:\\n                for y in (x + v, x - v, x ^ v):\\n                    # If we hit the goal, return steps+1 immediately\\n                    if y == goal:\\n                        return steps + 1\\n                    # If y is in [0,1000] and not yet visited, enqueue\\n                    if 0 <= y <= 1000 and not visited[y]:\\n                        visited[y] = True\\n                        q.append((y, steps + 1))\\n                    # Otherwise, y is out of range and not goal ⇒ dead end\\n        # Exhausted all possibilities without reaching goal\\n        return -1\\n\"",
  "1878_14631217_python-updated-time": "1746531480846",
  "1849_14631217_python-updated-time": "1746531387451",
  "669_14631217_python": "\"class Solution(object):\\n    def trimBST(self, root, low, high):\\n        if not root:\\n            return None\\n        if root.val < low:\\n            return self.trimBST(root.right, low, high)\\n        if root.val > high:\\n            return self.trimBST(root.left, low, high)\\n        root.left = self.trimBST(root.left, low, high)\\n        root.right = self.trimBST(root.right, low, high)\\n        return root\\n\"",
  "2131_14631217_python-updated-time": "1746717761464",
  "1767_14631217_python-updated-time": "1746446006435",
  "2201_14631217_python-updated-time": "1746729758706",
  "3543_14631217_python": "\"class Solution(object):\\n    def countKConstraintSubstrings(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        Counts the number of substrings where the number of '0's is at most k\\n        or the number of '1's is at most k.\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        result = 0\\n        # Enumerate all starting positions\\n        for i in range(n):\\n            zeros = 0\\n            ones = 0\\n            # Expand the substring from i to j\\n            for j in range(i, n):\\n                if s[j] == '0':\\n                    zeros += 1\\n                else:\\n                    ones += 1\\n                # If both counts exceed k, further extensions cannot satisfy the constraint\\n                if zeros > k and ones > k:\\n                    break\\n                # Otherwise, this substring [i:j+1] is valid\\n                result += 1\\n        return result\\n\\n# Example usage:\\n# sol = Solution()\\n# print(sol.countKConstraintSubstrings(\\\"10101\\\", 1))     # 12\\n# print(sol.countKConstraintSubstrings(\\\"1010101\\\", 2))  # 25\\n# print(sol.countKConstraintSubstrings(\\\"11111\\\", 1))     # 15\\n\"",
  "3241_14631217_python-updated-time": "1747318014252",
  "1307_14631217_python": "\"class Solution(object):\\n    def nthUglyNumber(self, n, a, b, c):\\n        def gcd(x, y):\\n            while y:\\n                x, y = y, x % y\\n            return x\\n\\n        def lcm(x, y):\\n            return x * y // gcd(x, y)\\n\\n        ab = lcm(a, b)\\n        bc = lcm(b, c)\\n        ac = lcm(a, c)\\n        abc = lcm(ab, c)\\n\\n        def count(x):\\n            return (x // a) + (x // b) + (x // c) \\\\\\n                 - (x // ab) - (x // bc) - (x // ac) \\\\\\n                 + (x // abc)\\n\\n        left, right = 1, 2 * 10**9\\n        while left < right:\\n            mid = (left + right) // 2\\n            if count(mid) < n:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n\"",
  "3635_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def smallestNumber(self, num, t):\\n        primes = [2, 3, 5, 7]\\n        need = []\\n        for p in primes:\\n            c = 0\\n            while t % p == 0:\\n                t //= p\\n                c += 1\\n            need.append(c)\\n        if t != 1:\\n            return \\\"-1\\\"\\n        exp = [(0, 0, 0, 0),\\n               (0, 0, 0, 0),\\n               (1, 0, 0, 0),\\n               (0, 1, 0, 0),\\n               (2, 0, 0, 0),\\n               (0, 0, 1, 0),\\n               (1, 1, 0, 0),\\n               (0, 0, 0, 1),\\n               (3, 0, 0, 0),\\n               (0, 2, 0, 0)]\\n        need = tuple(need)\\n        dist = { (0,0,0,0): 0 }\\n        q = deque([(0,0,0,0)])\\n        while q:\\n            a, b, c, d = q.popleft()\\n            cur = dist[(a,b,c,d)]\\n            if (a,b,c,d) == need:\\n                break\\n            for dig in range(1,10):\\n                da, db, dc, dd = exp[dig]\\n                na = min(a+da, need[0])\\n                nb = min(b+db, need[1])\\n                nc = min(c+dc, need[2])\\n                nd = min(d+dd, need[3])\\n                nxt = (na,nb,nc,nd)\\n                if nxt not in dist:\\n                    dist[nxt] = cur+1\\n                    q.append(nxt)\\n        if need not in dist:\\n            return \\\"-1\\\"\\n        def min_len(v):\\n            return dist[v]\\n        def build(v,l):\\n            res=[]\\n            for _ in range(l):\\n                for d in range(1,10):\\n                    da,db,dc,dd=exp[d]\\n                    nv=(max(0,v[0]-da),max(0,v[1]-db),max(0,v[2]-dc),max(0,v[3]-dd))\\n                    if min_len(nv)<=l-len(res)-1:\\n                        res.append(str(d))\\n                        v=nv\\n                        break\\n            return ''.join(res)\\n        n=len(num)\\n        pre_exp=[(0,0,0,0)]\\n        zero=[False]\\n        for ch in num:\\n            d=int(ch)\\n            e=exp[d] if d else (0,0,0,0)\\n            pa, pb, pc, pd = pre_exp[-1]\\n            pre_exp.append((pa+e[0],pb+e[1],pc+e[2],pd+e[3]))\\n            zero.append(zero[-1] or ch=='0')\\n        if not zero[-1]:\\n            pa,pb,pc,pd=pre_exp[-1]\\n            if pa>=need[0] and pb>=need[1] and pc>=need[2] and pd>=need[3]:\\n                return num\\n        for pos in range(n-1,-1,-1):\\n            if zero[pos]:\\n                continue\\n            pa,pb,pc,pd=pre_exp[pos]\\n            cur=int(num[pos])\\n            for d in range(cur+1,10):\\n                if d==0: continue\\n                da,db,dc,dd=exp[d]\\n                na=min(pa+da,need[0])\\n                nb=min(pb+db,need[1])\\n                nc=min(pc+dc,need[2])\\n                nd=min(pd+dd,need[3])\\n                rem_need=(need[0]-na,need[1]-nb,need[2]-nc,need[3]-nd)\\n                rem=len(num)-pos-1\\n                if min_len(rem_need)<=rem:\\n                    tail=build(rem_need,rem)\\n                    return num[:pos]+str(d)+tail\\n        total_len=min_len(need)\\n        L=max(n+1,total_len)\\n        lead='1'*(L-total_len)\\n        tail=build(need,total_len)\\n        return lead+tail\\n\"",
  "2862_14631217_javascript-updated-time": "1747220418078",
  "1993_14631217_python": "\"class Solution:\\n    def subsetXORSum(self, nums):\\n        self.total = 0\\n        def dfs(i, xor):\\n            if i == len(nums):\\n                self.total += xor\\n                return\\n            dfs(i + 1, xor ^ nums[i])\\n            dfs(i + 1, xor)\\n        dfs(0, 0)\\n        return self.total\\n\"",
  "3210_14631217_python-updated-time": "1747314467682",
  "192_14631217_bash-updated-time": "1745092800594",
  "171_14631217_python": "\"class Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        result = 0\\n        for c in columnTitle:\\n            result = result * 26 + (ord(c) - ord('A') + 1)\\n        return result\\n\"",
  "852_14631217_python": "\"class Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121\\n        for age in ages:\\n            count[age] += 1\\n        \\n        res = 0\\n        for a in range(15, 121):\\n            if count[a] == 0:\\n                continue\\n            for b in range(15, 121):\\n                if count[b] == 0:\\n                    continue\\n                if b <= 0.5 * a + 7 or b > a or (b > 100 and a < 100):\\n                    continue\\n                if a == b:\\n                    res += count[a] * (count[a] - 1)\\n                else:\\n                    res += count[a] * count[b]\\n        return res\\n\"",
  "2532_14631217_python-updated-time": "1746966782310",
  "3303_14631217_python-updated-time": "1747399321669",
  "3462_14631217_python-updated-time": "1747487928989",
  "3219_14631217_python-updated-time": "1747314517754",
  "2559_14631217_python": "\"class Solution:\\n    def maxPalindromes(self, s, k):\\n        n = len(s)\\n        # nexts[i] will hold lengths of palindrome substrings starting at i with len >= k\\n        nexts = [[] for _ in range(n)]\\n        \\n        # expand odd-length palindromes\\n        for center in range(n):\\n            l = center\\n            r = center\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                length = r - l + 1\\n                if length >= k:\\n                    nexts[l].append(length)\\n                l -= 1\\n                r += 1\\n        \\n        # expand even-length palindromes\\n        for center in range(n - 1):\\n            l = center\\n            r = center + 1\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                length = r - l + 1\\n                if length >= k:\\n                    nexts[l].append(length)\\n                l -= 1\\n                r += 1\\n        \\n        # dp[i] = max number of palindromic substrings we can pick in s[i:]\\n        dp = [0] * (n + 1)\\n        \\n        # fill dp from end toward 0\\n        for i in range(n - 1, -1, -1):\\n            # option 1: skip position i\\n            best = dp[i + 1]\\n            # option 2: take any palindrome starting at i\\n            for length in nexts[i]:\\n                best = max(best, 1 + dp[i + length])\\n            dp[i] = best\\n        \\n        return dp[0]\"",
  "2519_14631217_python": "\"class Solution(object):\\n    def findArray(self, pref):\\n        n = len(pref)\\n        arr = [0] * n\\n        arr[0] = pref[0]\\n        for i in range(1, n):\\n            arr[i] = pref[i-1] ^ pref[i]\\n        return arr\\n\"",
  "1029_14631217_python-updated-time": "1746040464989",
  "1561_14631217_python-updated-time": "1746347677599",
  "1714_14631217_python-updated-time": "1746438816804",
  "128_14631217_python-updated-time": "1745085077899",
  "1962_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def getOrder(self, tasks):\\n        # tasks: List[List[int]]\\n        n = len(tasks)\\n        # augment with original indices and sort by enqueue time\\n        arr = sorted([(et, pt, i) for i, (et, pt) in enumerate(tasks)])\\n        heap = []\\n        time = 0\\n        i = 0\\n        res = []\\n        while i < n or heap:\\n            if not heap and time < arr[i][0]:\\n                time = arr[i][0]\\n            while i < n and arr[i][0] <= time:\\n                _, pt, idx = arr[i]\\n                heapq.heappush(heap, (pt, idx))\\n                i += 1\\n            pt, idx = heapq.heappop(heap)\\n            time += pt\\n            res.append(idx)\\n        return res\\n\"",
  "2251_14631217_python-updated-time": "1746802539922",
  "2493_14631217_python-updated-time": "1746966491744",
  "2334_14631217_python": "\"from bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def fullBloomFlowers(self, flowers, people):\\n        # Extract and sort all start and end times\\n        starts = sorted(s for s, e in flowers)\\n        ends   = sorted(e for s, e in flowers)\\n        \\n        ans = []\\n        for t in people:\\n            # Count how many flowers have started by time t\\n            num_started = bisect_right(starts, t)\\n            # Count how many flowers have ended before t\\n            num_ended   = bisect_left(ends, t)\\n            # Those in bloom at t are started but not yet ended\\n            ans.append(num_started - num_ended)\\n        \\n        return ans\\n\"",
  "3812_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def smallestPalindrome(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Count frequencies of each character\\n        freq = Counter(s)\\n        # Build the first half of the palindrome\\n        half_chars = []\\n        mid_char = ''\\n        # Iterate characters in sorted order\\n        for ch in sorted(freq.keys()):\\n            count = freq[ch]\\n            # If odd count, reserve one for the middle\\n            if count % 2 == 1:\\n                mid_char = ch\\n            # Add count//2 copies to the half\\n            half_chars.append(ch * (count // 2))\\n        # Join to form the half string\\n        half = ''.join(half_chars)\\n        # Construct palindrome: half + middle + reverse(half)\\n        return half + mid_char + half[::-1]\\n\"",
  "3455_14631217_python": "\"class Solution(object):\\n    def minimumLength(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Count occurrences of each lowercase letter\\n        cnt = [0]*26\\n        for ch in s:\\n            cnt[ord(ch)-97] += 1\\n        \\n        # Compute final leftover\\n        ans = 0\\n        for c in cnt:\\n            if c == 0:\\n                continue\\n            # if odd count -> 1 remains; if even -> 2 remain\\n            ans += 1 if (c % 2) else 2\\n        \\n        return ans\\n\"",
  "2239_14631217_python": "\"class Solution:\\n    def executeInstructions(self, n, startPos, s):\\n        m = len(s)\\n        result = []\\n\\n        dir_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\\n\\n        for i in range(m):\\n            r, c = startPos\\n            steps = 0\\n            for j in range(i, m):\\n                dr, dc = dir_map[s[j]]\\n                r += dr\\n                c += dc\\n                if 0 <= r < n and 0 <= c < n:\\n                    steps += 1\\n                else:\\n                    break\\n            result.append(steps)\\n\\n        return result\\n\"",
  "97_14631217_python-updated-time": "1745080804596",
  "698_14631217_python-updated-time": "1745786104625",
  "1418_14631217_python-updated-time": "1746882250028",
  "1035_14631217_python": "\"class Solution:\\n    def isCousins(self, root, x, y):\\n        from collections import deque\\n        queue = deque([(root, None, 0)])  # (node, parent, depth)\\n        x_info = y_info = None\\n\\n        while queue:\\n            node, parent, depth = queue.popleft()\\n            if node.val == x:\\n                x_info = (parent, depth)\\n            elif node.val == y:\\n                y_info = (parent, depth)\\n            if node.left:\\n                queue.append((node.left, node, depth + 1))\\n            if node.right:\\n                queue.append((node.right, node, depth + 1))\\n            if x_info and y_info:\\n                break\\n\\n        return x_info[1] == y_info[1] and x_info[0] != y_info[0]\\n\"",
  "884_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def kSimilarity(self, s1, s2):\\n        queue = deque()\\n        queue.append((s1, 0))\\n        visited = set()\\n        visited.add(s1)\\n        \\n        while queue:\\n            s, step = queue.popleft()\\n            if s == s2:\\n                return step\\n            i = 0\\n            while s[i] == s2[i]:\\n                i += 1\\n            for j in range(i + 1, len(s)):\\n                if s[j] == s2[i] and s[j] != s2[j]:\\n                    lst = list(s)\\n                    lst[i], lst[j] = lst[j], lst[i]\\n                    ns = ''.join(lst)\\n                    if ns not in visited:\\n                        visited.add(ns)\\n                        queue.append((ns, step + 1))\\n\"",
  "1430_14631217_python-updated-time": "1746880904564",
  "145_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n\\n        while stack:\\n            node = stack.pop()\\n            output.append(node.val)\\n\\n            # Push left first so that right is processed first\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        \\n        # Reverse the result to get left -> right -> root\\n        return output[::-1]\\n\"",
  "1679_14631217_python-updated-time": "1746438280247",
  "1805_14631217_python-updated-time": "1746453712747",
  "36_14631217_python": "\"class Solution(object):\\n    def isValidSudoku(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        boxes = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n                if num == '.':\\n                    continue\\n                if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3 + (j//3)]:\\n                    return False\\n                rows[i].add(num)\\n                cols[j].add(num)\\n                boxes[(i//3)*3 + (j//3)].add(num)\\n\\n        return True\\n\"",
  "593_14631217_python": "\"class Solution(object):\\n    def validSquare(self, p1, p2, p3, p4):\\n        \\\"\\\"\\\"\\n        :type p1: List[int]\\n        :type p2: List[int]\\n        :type p3: List[int]\\n        :type p4: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def dist2(a, b):\\n            dx = a[0] - b[0]\\n            dy = a[1] - b[1]\\n            return dx*dx + dy*dy\\n\\n        pts = [p1, p2, p3, p4]\\n        dists = []\\n        # compute all squared distances between pairs\\n        for i in range(4):\\n            for j in range(i+1, 4):\\n                dists.append(dist2(pts[i], pts[j]))\\n        dists.sort()\\n        # For a square:\\n        # - first 4 distances (sides) are equal and > 0\\n        # - last 2 distances (diagonals) are equal\\n        # - diagonal^2 == 2 * side^2\\n        side = dists[0]\\n        if side == 0:\\n            return False\\n        # check 4 sides equal\\n        for i in range(1, 4):\\n            if dists[i] != side:\\n                return False\\n        # check 2 diagonals equal\\n        if dists[4] != dists[5]:\\n            return False\\n        # check diagonal relation: diagonal == 2 * side\\n        if dists[4] != 2 * side:\\n            return False\\n        return True\\n\"",
  "1620_14631217_python": "\"class Solution(object):\\n    def canArrange(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        count = Counter((x % k + k) % k for x in arr)  # handle negative numbers\\n\\n        for rem in count:\\n            if rem == 0:\\n                if count[rem] % 2 != 0:\\n                    return False\\n            elif rem * 2 == k:\\n                if count[rem] % 2 != 0:\\n                    return False\\n            else:\\n                if count[rem] != count[k - rem]:\\n                    return False\\n\\n        return True\\n\"",
  "1539_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def findDiagonalOrder(self, nums):\\n        diagonals = defaultdict(list)\\n        \\n        for i in range(len(nums)):\\n            for j in range(len(nums[i])):\\n                diagonals[i + j].append(nums[i][j])\\n        \\n        result = []\\n        for k in sorted(diagonals):\\n            result.extend(reversed(diagonals[k]))\\n        \\n        return result\\n\"",
  "461_14631217_python": "\"class Solution:\\n    def hammingDistance(self, x, y):\\n        return bin(x ^ y).count('1')\\n\"",
  "3573_14631217_python": "\"class Solution(object):\\n    def validSubstringCount(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word1)\\n        # 1) build freq_need from word2\\n        freq_need = [0]*26\\n        for c in word2:\\n            freq_need[ord(c)-97] += 1\\n        # how many distinct letters we actually need to satisfy\\n        required = sum(1 for x in freq_need if x>0)\\n\\n        # 2) sliding window [i..r-1], maintain freq_have + valid_count\\n        freq_have = [0]*26\\n        valid_count = 0   # how many characters c satisfy freq_have[c]>=freq_need[c]\\n        r = 0\\n        ans = 0\\n\\n        for i in range(n):\\n            # 3) expand r until window covers word2 (or until end)\\n            while r < n and valid_count < required:\\n                idx = ord(word1[r]) - 97\\n                freq_have[idx] += 1\\n                # if this char is one we care about, and we just hit the needed count\\n                if freq_need[idx] > 0 and freq_have[idx] == freq_need[idx]:\\n                    valid_count += 1\\n                r += 1\\n\\n            # now either valid_count==required (window [i..r-1] works)\\n            # or r==n and still invalid\\n            if valid_count == required:\\n                # any extension of [i..r-1] up to [i..n-1] remains valid\\n                ans += n - (r-1)\\n\\n            # 4) before moving i→i+1, remove word1[i] from window\\n            idx = ord(word1[i]) - 97\\n            # if this char was just satisfying its need, removing it breaks validity\\n            if freq_need[idx] > 0 and freq_have[idx] == freq_need[idx]:\\n                valid_count -= 1\\n            freq_have[idx] -= 1\\n\\n        return ans\\n\"",
  "1511_14631217_python": "\"class Solution(object):\\n    def numTeams(self, rating):\\n        n = len(rating)\\n        count = 0\\n        for j in range(n):\\n            left_less = left_greater = right_less = right_greater = 0\\n            for i in range(j):\\n                if rating[i] < rating[j]:\\n                    left_less += 1\\n                elif rating[i] > rating[j]:\\n                    left_greater += 1\\n            for k in range(j + 1, n):\\n                if rating[k] < rating[j]:\\n                    right_less += 1\\n                elif rating[k] > rating[j]:\\n                    right_greater += 1\\n            count += left_less * right_greater + left_greater * right_less\\n        return count\\n\"",
  "3733_14631217_python-updated-time": "1747739926059",
  "2856_14631217_python": "\"class Solution(object):\\n    def countCompleteSubarrays(self, nums):\\n        total_unique = len(set(nums))\\n        n = len(nums)\\n        count = 0\\n\\n        for i in range(n):\\n            seen = set()\\n            for j in range(i, n):\\n                seen.add(nums[j])\\n                if len(seen) == total_unique:\\n                    count += 1\\n\\n        return count\\n\"",
  "720_14631217_python-updated-time": "1745786767155",
  "2652_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def rootCount(self, edges, guesses, k):\\n        tree = defaultdict(list)\\n        for u, v in edges:\\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        guess_set = set((u, v) for u, v in guesses)\\n        res = [0]  # wrap in list for mutability\\n\\n        def dfs(node, parent):\\n            count = 0\\n            for nei in tree[node]:\\n                if nei == parent:\\n                    continue\\n                if (node, nei) in guess_set:\\n                    count += 1\\n                count += dfs(nei, node)\\n            return count\\n\\n        def reroot(node, parent, curr_count):\\n            if curr_count >= k:\\n                res[0] += 1\\n            for nei in tree[node]:\\n                if nei == parent:\\n                    continue\\n                delta = 0\\n                if (node, nei) in guess_set:\\n                    delta -= 1\\n                if (nei, node) in guess_set:\\n                    delta += 1\\n                reroot(nei, node, curr_count + delta)\\n\\n        start_correct = dfs(0, -1)\\n        reroot(0, -1, start_correct)\\n        return res[0]\\n\"",
  "2640_14631217_python-updated-time": "1747064858199",
  "793_14631217_python-updated-time": "1745877259436",
  "3690_14631217_python": "\"class Solution(object):\\n    def minLength(self, s, numOps):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type numOps: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Convert to ints 0/1 for speed\\n        arr = [1 if c=='1' else 0 for c in s]\\n        INF = 10**9\\n\\n        # Check if it's possible to make all runs <= L with ≤ numOps flips\\n        def can(L):\\n            # dp0[r] = min flips to process up through i-1,\\n            # ending with a run of '0's of length r (1 ≤ r ≤ L)\\n            # dp1[r] similarly for '1'\\n            dp0 = [INF]*(L+1)\\n            dp1 = [INF]*(L+1)\\n            # Initialize at i=0:\\n            #   if we choose 0 at pos0: cost = (arr[0]!=0)\\n            dp0[1] = (arr[0] != 0)\\n            dp1[1] = (arr[0] != 1)\\n\\n            for i in range(1, n):\\n                a = arr[i]\\n                new0 = [INF]*(L+1)\\n                new1 = [INF]*(L+1)\\n                # try placing '0' at i: cost_add = (a!=0)\\n                cost0 = (a != 0)\\n                for r in range(1, L+1):\\n                    c = dp0[r]\\n                    if c < INF:\\n                        # extend run of 0's to length r+1?\\n                        if r+1 <= L:\\n                            new0[r+1] = min(new0[r+1], c + cost0)\\n                    c = dp1[r]\\n                    if c < INF:\\n                        # switch from run of 1's to a new run of 0's of length 1\\n                        new0[1] = min(new0[1], c + cost0)\\n\\n                # try placing '1' at i\\n                cost1 = (a != 1)\\n                for r in range(1, L+1):\\n                    c = dp1[r]\\n                    if c < INF:\\n                        if r+1 <= L:\\n                            new1[r+1] = min(new1[r+1], c + cost1)\\n                    c = dp0[r]\\n                    if c < INF:\\n                        new1[1] = min(new1[1], c + cost1)\\n\\n                dp0, dp1 = new0, new1\\n\\n            # At the end, if any dp0[r] or dp1[r] ≤ numOps, it's feasible\\n            best = min(min(dp0[1:]), min(dp1[1:]))\\n            return best <= numOps\\n\\n        # Binary search for smallest L ∈ [1..n] such that can(L) is True\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if can(mid):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return lo\\n\"",
  "3453_14631217_python-updated-time": "1747487061171",
  "1923_14631217_python-updated-time": "1746543623166",
  "871_14631217_python": "\"class Solution(object):\\n    def canVisitAllRooms(self, rooms):\\n        visited = set()\\n        \\n        def dfs(room):\\n            if room in visited:\\n                return\\n            visited.add(room)\\n            for key in rooms[room]:\\n                dfs(key)\\n        \\n        dfs(0)\\n        return len(visited) == len(rooms)\\n\"",
  "2649_14631217_python-updated-time": "1747066330959",
  "1281_14631217_python": "\"class Solution(object):\\n    def canMakePaliQueries(self, s, queries):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Prefix XOR bitmasks: 26-bit int where bit i = parity (odd/even) of letter 'a' + i\\n        prefix = [0] * (n + 1)\\n        \\n        for i in range(n):\\n            bit = 1 << (ord(s[i]) - ord('a'))\\n            prefix[i + 1] = prefix[i] ^ bit\\n\\n        def count_odd(mask):\\n            return bin(mask).count('1')\\n\\n        result = []\\n        for left, right, k in queries:\\n            mask = prefix[right + 1] ^ prefix[left]\\n            odd_count = count_odd(mask)\\n            result.append(odd_count // 2 <= k)\\n        \\n        return result\\n\"",
  "2087_14631217_mysql-updated-time": "1746638203915",
  "904_14631217_python": "\"class Solution(object):\\n    def leafSimilar(self, root1, root2):\\n        def dfs(node):\\n            if not node:\\n                return []\\n            if not node.left and not node.right:\\n                return [node.val]\\n            return dfs(node.left) + dfs(node.right)\\n        \\n        return dfs(root1) == dfs(root2)\\n\"",
  "1115_14631217_python": "\"class Solution:\\n    def isBoomerang(self, points):\\n        (x1, y1), (x2, y2), (x3, y3) = points\\n        # Check all points are distinct\\n        if len({(x1, y1), (x2, y2), (x3, y3)}) < 3:\\n            return False\\n        # Check not collinear via cross-product (area != 0)\\n        return (x2 - x1) * (y3 - y1) != (y2 - y1) * (x3 - x1)\\n\"",
  "QD_LAYOUT_RUN_SUBMIT_POSITION": "toolBar",
  "2109_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def recoverArray(self, n, sums):\\n        sums = list(sums)\\n        ans = []\\n\\n        for _ in range(n):\\n            sums.sort()\\n            diff = sums[1] - sums[0]          # candidate element (non-negative)\\n\\n            cnt = Counter(sums)\\n            without, with_elem = [], []\\n\\n            for s in sums:                     # split into “without” and “with diff”\\n                if cnt[s] == 0:\\n                    continue\\n                cnt[s] -= 1\\n                t = s + diff\\n                cnt[t] -= 1\\n                without.append(s)\\n                with_elem.append(t)\\n\\n            if 0 in without:                   # 0 is always in the group w/o the element\\n                ans.append(diff)\\n                sums = without\\n            else:                              # otherwise the element is –diff\\n                ans.append(-diff)\\n                sums = with_elem\\n\\n        return ans\\n\"",
  "630_14631217_python-updated-time": "1745782229632",
  "3218_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def placedCoins(self, edges, cost):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type cost: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(cost)\\n        # build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # result array\\n        res = [0] * n\\n        \\n        def dfs(u, parent):\\n            \\\"\\\"\\\"\\n            Returns a tuple for subtree rooted at u:\\n             - size of subtree\\n             - max3: list of up to 3 largest costs in this subtree (descending)\\n             - min2: list of up to 2 smallest costs in this subtree (ascending)\\n            Also fills res[u].\\n            \\\"\\\"\\\"\\n            size = 1\\n            max3 = [cost[u]]\\n            min2 = [cost[u]]\\n            \\n            # process children\\n            for v in adj[u]:\\n                if v == parent:\\n                    continue\\n                c_size, c_max3, c_min2 = dfs(v, u)\\n                size += c_size\\n                \\n                # merge top‐3 largest\\n                merged_max = max3 + c_max3\\n                merged_max.sort(reverse=True)\\n                max3 = merged_max[:3]\\n                \\n                # merge bottom‐2 smallest\\n                merged_min = min2 + c_min2\\n                merged_min.sort()\\n                min2 = merged_min[:2]\\n            \\n            # compute coins for u\\n            if size < 3:\\n                # fewer than 3 nodes → always place 1 coin\\n                res[u] = 1\\n            else:\\n                # candidate 1: product of the three largest positives\\n                best = float(\\\"-inf\\\")\\n                if len(max3) >= 3:\\n                    best = max(best, max3[0] * max3[1] * max3[2])\\n                # candidate 2: product of two smallest (possibly negatives) and the largest\\n                if len(min2) >= 2:\\n                    best = max(best, min2[0] * min2[1] * max3[0])\\n                # if negative, place 0\\n                res[u] = best if best > 0 else 0\\n            \\n            return size, max3, min2\\n        \\n        # run DFS from root = 0\\n        dfs(0, -1)\\n        return res\\n\"",
  "3356_14631217_python": "\"class Solution(object):\\n    def shortestSubstrings(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        \\n        # 1) Precompute the substring sets for each string\\n        subs = []\\n        for s in arr:\\n            st = set()\\n            L = len(s)\\n            for i in range(L):\\n                for j in range(i+1, L+1):\\n                    st.add(s[i:j])\\n            subs.append(st)\\n        \\n        answer = []\\n        \\n        # 2) For each string, find its shortest unique substring\\n        for i, s in enumerate(arr):\\n            L = len(s)\\n            found = \\\"\\\"\\n            # try each length\\n            for length in range(1, L+1):\\n                # collect all substrings of this length, sorted\\n                cand = sorted({s[j:j+length] for j in range(0, L-length+1)})\\n                for t in cand:\\n                    # check if t occurs in any other string\\n                    ok = True\\n                    for j in range(n):\\n                        if j == i: continue\\n                        if t in subs[j]:\\n                            ok = False\\n                            break\\n                    if ok:\\n                        found = t\\n                        break\\n                if found:\\n                    break\\n            \\n            answer.append(found)\\n        \\n        return answer\\n\"",
  "3044_14631217_python-updated-time": "1747228051393",
  "3595_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def isPossibleToRearrange(self, s, t, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        B = n // k\\n        \\n        # Split s and t into k chunks of length B\\n        S_chunks = [s[i*B:(i+1)*B] for i in range(k)]\\n        T_chunks = [t[i*B:(i+1)*B] for i in range(k)]\\n        \\n        # If the multisets of chunks match, return True\\n        return Counter(S_chunks) == Counter(T_chunks)\\n\"",
  "1350_14631217_python": "\"class Solution:\\n    def removeSubfolders(self, folder):\\n        folder.sort()\\n        res = []\\n        for f in folder:\\n            if not res or not f.startswith(res[-1] + '/'):\\n                res.append(f)\\n        return res\\n\"",
  "917_14631217_python-updated-time": "1746001727244",
  "2443_14631217_python-updated-time": "1746964835928",
  "2562_14631217_python-updated-time": "1746969132748",
  "944_14631217_python-updated-time": "1746003005799",
  "3776_14631217_python-updated-time": "1747682403745",
  "397_14631217_python-updated-time": "1745355645013",
  "2903_14631217_python-updated-time": "1747223916024",
  "17_14631217_python": "\"class Solution(object):\\n    def letterCombinations(self, digits):\\n        \\\"\\\"\\\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        if not digits:\\n            return []\\n        \\n        phone = {\\n            \\\"2\\\": \\\"abc\\\", \\\"3\\\": \\\"def\\\", \\\"4\\\": \\\"ghi\\\", \\\"5\\\": \\\"jkl\\\",\\n            \\\"6\\\": \\\"mno\\\", \\\"7\\\": \\\"pqrs\\\", \\\"8\\\": \\\"tuv\\\", \\\"9\\\": \\\"wxyz\\\"\\n        }\\n        \\n        res = []\\n        \\n        def backtrack(path, index):\\n            if index == len(digits):\\n                res.append(path)\\n                return\\n            for char in phone[digits[index]]:\\n                backtrack(path + char, index + 1)\\n        \\n        backtrack(\\\"\\\", 0)\\n        return res\\n\"",
  "3484_14631217_python-updated-time": "1747487221887",
  "457_14631217_python-updated-time": "1745359425177",
  "2050_14631217_python": "\"class Solution:\\n    def countGoodNumbers(self, n):\\n        MOD = 10**9 + 7\\n\\n        def mod_pow(x, y):\\n            res = 1\\n            x %= MOD\\n            while y:\\n                if y % 2:\\n                    res = res * x % MOD\\n                x = x * x % MOD\\n                y //= 2\\n            return res\\n\\n        even = (n + 1) // 2\\n        odd = n // 2\\n        return mod_pow(5, even) * mod_pow(4, odd) % MOD\\n\"",
  "365_14631217_python-updated-time": "1745354430006",
  "954_14631217_python": "\"class Solution:\\n    def maxSubarraySumCircular(self, nums):\\n        total = sum(nums)\\n        \\n        # Standard Kadane's algorithm for max subarray sum\\n        max_sum = curr_max = nums[0]\\n        for num in nums[1:]:\\n            curr_max = max(num, curr_max + num)\\n            max_sum = max(max_sum, curr_max)\\n\\n        # Kadane’s algorithm for min subarray sum\\n        min_sum = curr_min = nums[0]\\n        for num in nums[1:]:\\n            curr_min = min(num, curr_min + num)\\n            min_sum = min(min_sum, curr_min)\\n\\n        # If all numbers are negative, max_sum is the answer\\n        if max_sum < 0:\\n            return max_sum\\n\\n        # Otherwise, maximum of standard max subarray or circular case\\n        return max(max_sum, total - min_sum)\\n\"",
  "3350_14631217_python": "\"class FenwickTree:\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0]*(n+1)\\n    def update(self, i, delta):\\n        # add delta at index i (1-based)\\n        while i <= self.n:\\n            self.fw[i] += delta\\n            i += i & -i\\n    def query(self, i):\\n        # sum from 1..i\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n    def range_query(self, l, r):\\n        return self.query(r) - self.query(l-1)\\n\\nclass Solution(object):\\n    def resultArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # 1) Coordinate-compress nums\\n        vals = sorted(set(nums))\\n        comp = {v:i+1 for i,v in enumerate(vals)}  # 1-based indices for Fenwick\\n        m = len(vals)\\n        \\n        # 2) Fenwicks to track counts in arr1 and arr2\\n        bit1 = FenwickTree(m)\\n        bit2 = FenwickTree(m)\\n        size1 = 0\\n        size2 = 0\\n        \\n        arr1 = []\\n        arr2 = []\\n        \\n        # 3) Process\\n        # first element -> arr1, second -> arr2\\n        # then from i=3..n apply rules\\n        # use 0-based indexing for Python lists but problem is 1-indexed\\n        # so nums[0] -> arr1, nums[1] -> arr2\\n        # then for idx from 2..n-1\\n        # \\n        # helper to compute greaterCount in bitX of value v\\n        def greater_count(bit, sz, rank):\\n            # number strictly greater = total inserted sz minus count<=rank\\n            return sz - bit.query(rank)\\n        \\n        # place first\\n        r0 = comp[nums[0]]\\n        arr1.append(nums[0])\\n        bit1.update(r0, 1)\\n        size1 += 1\\n        \\n        # place second\\n        r1 = comp[nums[1]]\\n        arr2.append(nums[1])\\n        bit2.update(r1, 1)\\n        size2 += 1\\n        \\n        # remaining\\n        for x in nums[2:]:\\n            r = comp[x]\\n            g1 = greater_count(bit1, size1, r)\\n            g2 = greater_count(bit2, size2, r)\\n            if g1 > g2:\\n                # arr1\\n                arr1.append(x)\\n                bit1.update(r, 1)\\n                size1 += 1\\n            elif g1 < g2:\\n                arr2.append(x)\\n                bit2.update(r, 1)\\n                size2 += 1\\n            else:\\n                # tie on greaterCount -> choose smaller size\\n                if size1 <= size2:\\n                    arr1.append(x)\\n                    bit1.update(r, 1)\\n                    size1 += 1\\n                else:\\n                    arr2.append(x)\\n                    bit2.update(r, 1)\\n                    size2 += 1\\n        \\n        # concatenate\\n        return arr1 + arr2\\n\"",
  "2159_14631217_python-updated-time": "1746719663304",
  "483_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def smallestGoodBase(self, n):\\n        \\\"\\\"\\\"\\n        :type n: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        num = int(n)\\n        max_m = int(math.log(num + 1, 2))  # max possible length of all-1's\\n\\n        for m in range(max_m, 1, -1):\\n            k = int(num ** (1.0 / (m - 1)))\\n            if k < 2:\\n                continue\\n            # Check if 1 + k + k^2 + ... + k^(m-1) == num\\n            total = (k ** m - 1) // (k - 1)\\n            if total == num:\\n                return str(k)\\n\\n        return str(num - 1)\\n\"",
  "957_14631217_python-updated-time": "1746003663648",
  "2188_14631217_python": "\"class Solution:\\n    def minimizedMaximum(self, n, quantities):\\n        \\\"\\\"\\\"\\n        :param n: int       # number of stores\\n        :param quantities: List[int]  # quantities[i] = count of product type i\\n        :return: int        # minimum possible maximum products per store\\n        \\\"\\\"\\\"\\n        def needed_stores(cap):\\n            # For a given maximum load cap, compute how many stores are needed:\\n            # each product type i must be split into ceil(quantities[i]/cap) stores.\\n            total = 0\\n            for q in quantities:\\n                # Ceil division without floating:\\n                total += (q + cap - 1) // cap\\n                if total > n:  # early exit if already exceeds available stores\\n                    return total\\n            return total\\n\\n        # Binary search on answer x = maximum load per store\\n        left, right = 1, max(quantities)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if needed_stores(mid) <= n:\\n                # mid is feasible: try smaller\\n                right = mid\\n            else:\\n                # mid too small (requires too many stores): increase\\n                left = mid + 1\\n        return left\"",
  "1797_14631217_python-updated-time": "1746452716484",
  "3853_14631217_python-updated-time": "1747757586923",
  "3413_14631217_python-updated-time": "1747484137920",
  "2527_14631217_python": "\"class Solution:\\n    def countSubarrays(self, nums, minK, maxK):\\n        last_invalid = -1\\n        last_min = -1\\n        last_max = -1\\n        ans = 0\\n        \\n        for i, x in enumerate(nums):\\n            # If x is outside [minK, maxK], this breaks any valid subarray\\n            if x < minK or x > maxK:\\n                last_invalid = i\\n            if x == minK:\\n                last_min = i\\n            if x == maxK:\\n                last_max = i\\n            # The number of valid subarrays ending at i is the count of starting\\n            # positions after last_invalid and at or before min(last_min,last_max)\\n            valid_start = min(last_min, last_max)\\n            if valid_start > last_invalid:\\n                ans += (valid_start - last_invalid)\\n        \\n        return ans\\n\"",
  "3200_14631217_python": "\"class Solution:\\n    def stringCount(self, n):\\n        MOD = 10**9 + 7\\n\\n        # fast modular exponentiation\\n        def mpow(a, b):\\n            res = 1\\n            a %= MOD\\n            while b:\\n                if b & 1:\\n                    res = (res * a) % MOD\\n                a = (a * a) % MOD\\n                b >>= 1\\n            return res\\n\\n        total = mpow(26, n)\\n        p25n = mpow(25, n)\\n        p25n1 = mpow(25, n - 1) if n > 0 else 0\\n        p24n = mpow(24, n)\\n        p24n1 = mpow(24, n - 1) if n > 0 else 0\\n        p23n = mpow(23, n)\\n        p23n1 = mpow(23, n - 1) if n > 0 else 0\\n\\n        # inclusion-exclusion components\\n        A = p25n\\n        B = (p25n + n * p25n1) % MOD\\n        C = p25n\\n        AB = (p24n + n * p24n1) % MOD\\n        AC = p24n\\n        BC = (p24n + n * p24n1) % MOD\\n        # exclude 'l','t' and allow ≤1 'e'\\n        ABC = (p23n + n * p23n1) % MOD\\n\\n        bad = (A + B + C - AB - AC - BC + ABC) % MOD\\n        return (total - bad) % MOD\\n\"",
  "242_14631217_python-updated-time": "1745247655028",
  "774_14631217_python": "\"\\\"\\\"\\\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\\"\\\"\\\"\\n\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        if not root:\\n            return 0\\n        max_child_depth = 0\\n        for child in root.children:\\n            max_child_depth = max(max_child_depth, self.maxDepth(child))\\n        return max_child_depth + 1\\n\\n        \"",
  "88_14631217_python-updated-time": "1745015568939",
  "1632_14631217_python": "\"class Solution(object):\\n    def numSplits(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        left_count = [0] * n\\n        right_count = [0] * n\\n\\n        seen_left = set()\\n        for i in range(n):\\n            seen_left.add(s[i])\\n            left_count[i] = len(seen_left)\\n\\n        seen_right = set()\\n        for i in range(n - 1, -1, -1):\\n            seen_right.add(s[i])\\n            right_count[i] = len(seen_right)\\n\\n        res = 0\\n        for i in range(n - 1):\\n            if left_count[i] == right_count[i + 1]:\\n                res += 1\\n\\n        return res\\n\"",
  "43_14631217_python": "\"class Solution(object):\\n    def multiply(self, num1, num2):\\n        \\\"\\\"\\\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if num1 == \\\"0\\\" or num2 == \\\"0\\\":\\n            return \\\"0\\\"\\n\\n        res = [0] * (len(num1) + len(num2))\\n\\n        for i in range(len(num1)-1, -1, -1):\\n            for j in range(len(num2)-1, -1, -1):\\n                mul = int(num1[i]) * int(num2[j])\\n                sum = mul + res[i+j+1]\\n                res[i+j+1] = sum % 10\\n                res[i+j] += sum // 10\\n\\n        result = ''.join(map(str, res)).lstrip('0')\\n        return result\\n\"",
  "86_14631217_python-updated-time": "1745015478933",
  "713_14631217_python": "\"class Solution(object):\\n    def numSubarrayProductLessThanK(self, nums, k):\\n        if k <= 1:\\n            return 0\\n        \\n        prod = 1\\n        result = 0\\n        left = 0\\n        \\n        for right, value in enumerate(nums):\\n            prod *= value\\n            while prod >= k:\\n                prod //= nums[left]\\n                left += 1\\n            # All subarrays ending at 'right' with start in [left..right]\\n            result += right - left + 1\\n        \\n        return result\\n\"",
  "1936_14631217_python": "\"class Solution(object):\\n    def maxNiceDivisors(self, primeFactors):\\n        MOD = 10**9 + 7\\n        k = primeFactors\\n        if k <= 3:\\n            return k\\n        c3, r = divmod(k, 3)\\n        if r == 0:\\n            return pow(3, c3, MOD)\\n        elif r == 1:\\n            # turn one 3+1 into 2+2\\n            return (pow(3, c3-1, MOD) * 4) % MOD\\n        else:  # r == 2\\n            return (pow(3, c3, MOD) * 2) % MOD\\n\"",
  "1490_14631217_python-updated-time": "1746345591892",
  "673_14631217_python-updated-time": "1745783332403",
  "3075_14631217_pythondata-updated-time": "1747305729184",
  "2034_14631217_python": "\"class Solution:\\n    def minDifference(self, nums, queries):\\n        n = len(nums)\\n        prefix = [[0] * 101 for _ in range(n + 1)]\\n\\n        # Build prefix frequency table\\n        for i in range(n):\\n            for j in range(1, 101):\\n                prefix[i + 1][j] = prefix[i][j]\\n            prefix[i + 1][nums[i]] += 1\\n\\n        res = []\\n\\n        for l, r in queries:\\n            last = -1\\n            ans = float('inf')\\n            for x in range(1, 101):\\n                freq = prefix[r + 1][x] - prefix[l][x]\\n                if freq > 0:\\n                    if last != -1:\\n                        ans = min(ans, x - last)\\n                    last = x\\n            res.append(ans if ans != float('inf') else -1)\\n\\n        return res\\n\"",
  "2316_14631217_python": "\"class Solution(object):\\n    def countHillValley(self, nums):\\n        n = len(nums)\\n        ans = 0\\n        for i in range(1, n - 1):\\n            if nums[i] == nums[i - 1]:\\n                continue\\n            l = i - 1\\n            while l >= 0 and nums[l] == nums[i]:\\n                l -= 1\\n            r = i + 1\\n            while r < n and nums[r] == nums[i]:\\n                r += 1\\n            if l >= 0 and r < n:\\n                if nums[i] > nums[l] and nums[i] > nums[r]:\\n                    ans += 1\\n                elif nums[i] < nums[l] and nums[i] < nums[r]:\\n                    ans += 1\\n        return ans\\n\"",
  "740_14631217_python-updated-time": "1745787529752",
  "721_14631217_python-updated-time": "1745786807611",
  "3536_14631217_python-updated-time": "1747501372124",
  "1274_14631217_python-updated-time": "1746345283354",
  "1755_14631217_python": "\"class Solution:\\n    def decrypt(self, code, k):\\n        n = len(code)\\n        res = [0] * n\\n        if k == 0:\\n            return res\\n        \\n        for i in range(n):\\n            s = 0\\n            if k > 0:\\n                for j in range(1, k+1):\\n                    s += code[(i + j) % n]\\n            else:  # k < 0\\n                for j in range(1, -k+1):\\n                    s += code[(i - j) % n]\\n            res[i] = s\\n        \\n        return res\\n\"",
  "182_14631217_mysql": "\"SELECT email AS Email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\"",
  "264_14631217_python": "\"class Solution(object):\\n    def nthUglyNumber(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ugly = [1]\\n        i2 = i3 = i5 = 0\\n        \\n        for _ in range(1, n):\\n            next2, next3, next5 = ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5\\n            next_ugly = min(next2, next3, next5)\\n            ugly.append(next_ugly)\\n            \\n            if next_ugly == next2:\\n                i2 += 1\\n            if next_ugly == next3:\\n                i3 += 1\\n            if next_ugly == next5:\\n                i5 += 1\\n        \\n        return ugly[-1]\\n\"",
  "960_14631217_python-updated-time": "1746003754282",
  "1698_14631217_python": "\"class Solution(object):\\n    def modifyString(self, s):\\n        res = list(s)\\n        n = len(res)\\n        for i in range(n):\\n            if res[i] == '?':\\n                for c in 'abc':\\n                    if (i > 0 and res[i-1] == c) or (i+1 < n and res[i+1] == c):\\n                        continue\\n                    res[i] = c\\n                    break\\n        return ''.join(res)\\n\"",
  "3421_14631217_python-updated-time": "1747485212801",
  "33_14631217_python": "\"class Solution(object):\\n    def search(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n\"",
  "1283_14631217_python": "\"class Solution(object):\\n    def reformatDate(self, date):\\n        \\\"\\\"\\\"\\n        :type date: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        months = {\\n            \\\"Jan\\\": \\\"01\\\", \\\"Feb\\\": \\\"02\\\", \\\"Mar\\\": \\\"03\\\", \\\"Apr\\\": \\\"04\\\",\\n            \\\"May\\\": \\\"05\\\", \\\"Jun\\\": \\\"06\\\", \\\"Jul\\\": \\\"07\\\", \\\"Aug\\\": \\\"08\\\",\\n            \\\"Sep\\\": \\\"09\\\", \\\"Oct\\\": \\\"10\\\", \\\"Nov\\\": \\\"11\\\", \\\"Dec\\\": \\\"12\\\"\\n        }\\n\\n        day, month, year = date.split()\\n        day = day[:-2].zfill(2)  # Remove suffix and pad with 0 if needed\\n        return \\\"{}-{}-{}\\\".format(year, months[month], day)\\n\"",
  "525_14631217_python": "\"class Solution:\\n    def findMaxLength(self, nums):\\n        count = 0\\n        max_len = 0\\n        prefix_map = {0: -1}\\n        \\n        for i, num in enumerate(nums):\\n            count += 1 if num == 1 else -1\\n            if count in prefix_map:\\n                max_len = max(max_len, i - prefix_map[count])\\n            else:\\n                prefix_map[count] = i\\n        \\n        return max_len\\n\"",
  "3674_14631217_python-updated-time": "1747818619818",
  "695_14631217_python-updated-time": "1745785941369",
  "3018_14631217_python": "\"class Solution(object):\\n    def canMakeSubsequence(self, str1, str2):\\n        \\\"\\\"\\\"\\n        :type str1: str\\n        :type str2: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        j = 0\\n        m = len(str2)\\n        for c in str1:\\n            if j < m:\\n                # compute next character cyclically\\n                nc = 'a' if c == 'z' else chr(ord(c) + 1)\\n                if c == str2[j] or nc == str2[j]:\\n                    j += 1\\n        return j == m\\n\"",
  "1480_14631217_mysql-updated-time": "1746261840098",
  "3514_14631217_python-updated-time": "1747500529573",
  "1032_14631217_python": "\"class Solution:\\n    def equationsPossible(self, equations):\\n        parent = [i for i in range(26)]  # Union-Find for 26 lowercase letters\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])  # Path compression\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent[find(x)] = find(y)\\n\\n        # First, process all \\\"==\\\" equations\\n        for eq in equations:\\n            if eq[1:3] == \\\"==\\\":\\n                x = ord(eq[0]) - ord('a')\\n                y = ord(eq[3]) - ord('a')\\n                union(x, y)\\n\\n        # Then, process all \\\"!=\\\" equations and check for conflicts\\n        for eq in equations:\\n            if eq[1:3] == \\\"!=\\\":\\n                x = ord(eq[0]) - ord('a')\\n                y = ord(eq[3]) - ord('a')\\n                if find(x) == find(y):\\n                    return False\\n\\n        return True\\n\"",
  "3689_14631217_python-updated-time": "1747596656953",
  "1746_14631217_python": "\"class Solution:\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        first = [-1] * 26\\n        max_len = -1\\n        \\n        for i, ch in enumerate(s):\\n            idx = ord(ch) - ord('a')\\n            if first[idx] == -1:\\n                first[idx] = i\\n            else:\\n                curr_len = i - first[idx] - 1\\n                if curr_len > max_len:\\n                    max_len = curr_len\\n        \\n        return max_len\\n\"",
  "118_14631217_python-updated-time": "1745081485192",
  "2233_14631217_python": "\"class Solution:\\n    def getDescentPeriods(self, prices):\\n        total = 1\\n        length = 1\\n\\n        for i in range(1, len(prices)):\\n            if prices[i] == prices[i - 1] - 1:\\n                length += 1\\n            else:\\n                length = 1\\n            total += length\\n\\n        return total\\n\"",
  "2807_14631217_javascript": "\"function promiseAll(functions) {\\n  return new Promise((resolve, reject) => {\\n    const n = functions.length;\\n    const results = new Array(n);\\n    let count = 0;\\n    let hasRejected = false;\\n\\n    functions.forEach((fn, i) => {\\n      // Execute each function immediately\\n      Promise.resolve()\\n        .then(fn)\\n        .then(value => {\\n          if (hasRejected) return;\\n          results[i] = value;\\n          count += 1;\\n          if (count === n) {\\n            resolve(results);\\n          }\\n        })\\n        .catch(err => {\\n          if (!hasRejected) {\\n            hasRejected = true;\\n            reject(err);\\n          }\\n        });\\n    });\\n  });\\n}\\n\"",
  "3531_14631217_python": "\"import functools\\n\\nclass Solution(object):\\n    def minDamage(self, power, damage, health):\\n        # build (weight, processing) pairs\\n        jobs = []\\n        for w, h in zip(damage, health):\\n            t = (h + power - 1) // power\\n            jobs.append((w, t))\\n\\n        # sort by decreasing w/t ratio\\n        def cmp(a, b):\\n            w1, t1 = a\\n            w2, t2 = b\\n            # want w1/t1 > w2/t2 => w1*t2 > w2*t1\\n            if w1 * t2 > w2 * t1:\\n                return -1\\n            if w1 * t2 < w2 * t1:\\n                return 1\\n            return 0\\n\\n        jobs.sort(key=functools.cmp_to_key(cmp))\\n\\n        # accumulate completion time and weighted sum\\n        total_damage = 0\\n        elapsed = 0\\n        for w, t in jobs:\\n            elapsed += t\\n            total_damage += w * elapsed\\n\\n        return total_damage\\n\"",
  "3804_14631217_python-updated-time": "1747822008882",
  "2049_14631217_python-updated-time": "1746637534286",
  "1990_14631217_python-updated-time": "1746626153656",
  "3645_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxTargetNodes(self, edges1, edges2):\\n        \\\"\\\"\\\"\\n        :type edges1: List[List[int]]\\n        :type edges2: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def build_adj(n, edges):\\n            adj = [[] for _ in range(n)]\\n            for u, v in edges:\\n                adj[u].append(v)\\n                adj[v].append(u)\\n            return adj\\n\\n        def bfs_parities(adj):\\n            \\\"\\\"\\\"\\n            Returns:\\n             - parity: list of 0/1 parities of depth from node 0\\n             - cnt0, cnt1: counts of nodes at parity 0 and 1\\n            \\\"\\\"\\\"\\n            n = len(adj)\\n            parity = [-1]*n\\n            parity[0] = 0\\n            cnt0 = 1\\n            cnt1 = 0\\n            q = deque([0])\\n            while q:\\n                u = q.popleft()\\n                for w in adj[u]:\\n                    if parity[w] == -1:\\n                        parity[w] = parity[u]^1\\n                        if parity[w] == 0:\\n                            cnt0 += 1\\n                        else:\\n                            cnt1 += 1\\n                        q.append(w)\\n            return parity, cnt0, cnt1\\n\\n        # Build adjacency lists\\n        n = len(edges1) + 1\\n        m = len(edges2) + 1\\n        adj1 = build_adj(n, edges1)\\n        adj2 = build_adj(m, edges2)\\n\\n        # BFS to get parities and counts\\n        p1, even1, odd1 = bfs_parities(adj1)\\n        p2, even2, odd2 = bfs_parities(adj2)\\n\\n        # Precompute best possible contribution from tree2\\n        best2 = max(odd2, even2)\\n\\n        # Now compute answer for each i in tree1\\n        ans = [0]*n\\n        diff1 = even1 - odd1\\n        for i in range(n):\\n            if p1[i] == 0:\\n                E1 = (n + diff1)//2\\n            else:\\n                E1 = (n - diff1)//2\\n            ans[i] = E1 + best2\\n\\n        return ans\\n\"",
  "1752_14631217_python": "\"class Solution:\\n    def checkArithmeticSubarrays(self, nums, l, r):\\n        res = []\\n        for start, end in zip(l, r):\\n            sub = nums[start:end+1]\\n            sub.sort()\\n            diff = sub[1] - sub[0]\\n            ok = True\\n            for i in range(2, len(sub)):\\n                if sub[i] - sub[i-1] != diff:\\n                    ok = False\\n                    break\\n            res.append(ok)\\n        return res\\n\"",
  "2179_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort(key=lambda x: x[0])\\n        prices = [p for p, _ in items]\\n        max_b = []\\n        curr = 0\\n        for _, b in items:\\n            curr = curr if curr > b else b\\n            max_b.append(curr)\\n        ans = []\\n        for q in queries:\\n            i = bisect.bisect_right(prices, q) - 1\\n            ans.append(max_b[i] if i >= 0 else 0)\\n        return ans\\n\"",
  "3561_14631217_python": "\"import itertools\\nfrom collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def kthCharacter(self, k, operations):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type operations: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Number of operations\\n        m = len(operations)\\n        # Precompute the length of the string after each operation: length[i] = 2^i\\n        lengths = [1] * (m + 1)\\n        for i in range(m):\\n            lengths[i + 1] = lengths[i] << 1\\n        # Current position we want, and the total shift count\\n        cur_k = k\\n        shift_count = 0\\n        # Walk operations in reverse to map cur_k back to the original 'a'\\n        for i in range(m - 1, -1, -1):\\n            if cur_k > lengths[i]:\\n                # We're in the second half of the string after operation i\\n                cur_k -= lengths[i]\\n                # If this operation was a shift-append, accumulate one shift\\n                if operations[i] == 1:\\n                    shift_count = (shift_count + 1) % 26\\n        # After reversing all operations, we land at position cur_k in the initial string \\\"a\\\"\\n        # Since the initial word is \\\"a\\\" of length 1, cur_k must be 1\\n        # Apply the accumulated shifts to 'a'\\n        return chr((ord('a') - ord('a') + shift_count) % 26 + ord('a'))\\n\\n    def maxGoodNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_val = 0\\n        # Try all permutations of the three numbers\\n        for perm in itertools.permutations(nums):\\n            # Concatenate binary representations without leading zeros\\n            s = ''.join(bin(x)[2:] for x in perm)\\n            # Convert concatenated binary string to integer\\n            val = int(s, 2)\\n            if val > max_val:\\n                max_val = val\\n        return max_val\\n\\n    def remainingMethods(self, n, k, invocations):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type invocations: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Build graph from method to the methods it invokes\\n        graph = defaultdict(list)\\n        for a, b in invocations:\\n            graph[a].append(b)\\n        # Find all suspicious methods reachable from k\\n        suspicious = set([k])\\n        dq = deque([k])\\n        while dq:\\n            u = dq.popleft()\\n            for v in graph[u]:\\n                if v not in suspicious:\\n                    suspicious.add(v)\\n                    dq.append(v)\\n        # Check for invocations into suspicious from outside\\n        for a, b in invocations:\\n            if b in suspicious and a not in suspicious:\\n                # Removal not possible\\n                return list(range(n))\\n        # Removal possible: return methods not in suspicious\\n        return [i for i in range(n) if i not in suspicious]\\n\"",
  "3635_14631217_python-updated-time": "1747587502642",
  "2394_14631217_python": "\"class Solution:\\n    def countSubarrays(self, nums, k):\\n        n = len(nums)\\n        left = 0\\n        curr_sum = 0\\n        ans = 0\\n        \\n        # Expand right endpoint r from 0 to n-1\\n        for r in range(n):\\n            curr_sum += nums[r]\\n            # Shrink left endpoint while score >= k\\n            while left <= r and curr_sum * (r - left + 1) >= k:\\n                curr_sum -= nums[left]\\n                left += 1\\n            # Now for this r, all subarrays [L..r] with L in [left..r]\\n            # have score < k, so there are (r-left+1) of them\\n            ans += (r - left + 1)\\n        \\n        return ans\\n\"",
  "1994_14631217_python": "\"class Solution:\\n    def minSwaps(self, s):\\n        c0 = s.count('0')\\n        c1 = len(s) - c0\\n        if abs(c0 - c1) > 1:\\n            return -1\\n\\n        def count_mismatch(start):\\n            mismatches = 0\\n            for i, ch in enumerate(s):\\n                expected = str((i + start) % 2)\\n                if ch != expected:\\n                    mismatches += 1\\n            return mismatches // 2\\n\\n        if c0 == c1:\\n            return min(count_mismatch(0), count_mismatch(1))\\n        elif c0 > c1:\\n            return count_mismatch(0)\\n        else:\\n            return count_mismatch(1)\\n\"",
  "3454_14631217_python-updated-time": "1747488225925",
  "3658_14631217_python-updated-time": "1747595058879",
  "1920_14631217_python": "\"class Solution(object):\\n    def squareIsWhite(self, coordinates):\\n        col = ord(coordinates[0]) - ord('a') + 1\\n        row = int(coordinates[1])\\n        return (col + row) % 2 == 1\\n\"",
  "2166_14631217_python": "\"import itertools\\n\\nclass Solution:\\n    def countCombinations(self, pieces, positions):\\n        \\\"\\\"\\\"\\n        :param pieces: List[str]           # e.g. [\\\"rook\\\",\\\"queen\\\",\\\"bishop\\\",...]\\n        :param positions: List[List[int]]  # 1-based coords [[r,c],...]\\n        :return: int                       # number of valid move combinations\\n        \\\"\\\"\\\"\\n        # Movement directions for each piece type\\n        DIRS = {\\n            'rook':   [(1,0),(-1,0),(0,1),(0,-1)],\\n            'bishop': [(1,1),(1,-1),(-1,1),(-1,-1)],\\n            'queen':  [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)],\\n        }\\n        # 1) Precompute all possible destinations (including staying put)\\n        all_dests = []\\n        for ptype, (sr, sc) in zip(pieces, positions):\\n            dests = [(sr, sc)]\\n            for dr, dc in DIRS[ptype]:\\n                r, c = sr + dr, sc + dc\\n                while 1 <= r <= 8 and 1 <= c <= 8:\\n                    dests.append((r, c))\\n                    r += dr; c += dc\\n            all_dests.append(dests)\\n\\n        def simulate(dest_combo):\\n            \\\"\\\"\\\"Simulate simultaneous move; return False on any collision.\\\"\\\"\\\"\\n            # Build movement info: (sr, sc, tr, tc, dr, dc, dist)\\n            steps = []\\n            for (sr, sc), (tr, tc) in zip(positions, dest_combo):\\n                dr = 0 if tr == sr else (1 if tr > sr else -1)\\n                dc = 0 if tc == sc else (1 if tc > sc else -1)\\n                dist = max(abs(tr - sr), abs(tc - sc))\\n                steps.append((sr, sc, tr, tc, dr, dc, dist))\\n            # Maximum time to simulate\\n            T = max(item[6] for item in steps)\\n            # Simulate each second\\n            for t in range(T + 1):\\n                seen = set()\\n                for sr, sc, tr, tc, dr, dc, dist in steps:\\n                    if t < dist:\\n                        r = sr + dr * t\\n                        c = sc + dc * t\\n                    else:\\n                        r, c = tr, tc\\n                    if (r, c) in seen:\\n                        return False\\n                    seen.add((r, c))\\n            return True\\n\\n        # Count valid combinations\\n        ans = 0\\n        for dest_combo in itertools.product(*all_dests):\\n            if simulate(dest_combo):\\n                ans += 1\\n        return ans\"",
  "21_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def mergeTwoLists(self, list1, list2):\\n        \\\"\\\"\\\"\\n        :type list1: Optional[ListNode]\\n        :type list2: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode()\\n        current = dummy\\n\\n        while list1 and list2:\\n            if list1.val < list2.val:\\n                current.next = list1\\n                list1 = list1.next\\n            else:\\n                current.next = list2\\n                list2 = list2.next\\n            current = current.next\\n\\n        current.next = list1 if list1 else list2\\n        return dummy.next\\n\"",
  "3094_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Count the occurrences of each number\\n        from collections import Counter\\n        freq = Counter(nums)\\n        operations = 0\\n        # For each frequency, determine the minimum rounds using groups of 2 or 3\\n        for count in freq.values():\\n            # If any number appears only once, it's impossible to delete it\\n            if count == 1:\\n                return -1\\n            # Greedy grouping: use as many triplets as possible; the formula (count + 2) // 3\\n            # gives the minimum number of groups of size 2 or 3 to sum to count,\\n            # provided count > 1.\\n            operations += (count + 2) // 3\\n        return operations\\n\"",
  "2165_14631217_python": "\"class Solution:\\n    def platesBetweenCandles(self, s, queries):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        \\n        # 1) prefix_stars[i]: number of '*' in s[0..i-1]\\n        prefix_stars = [0] * (n + 1)\\n        for i, ch in enumerate(s, 1):\\n            prefix_stars[i] = prefix_stars[i - 1] + (ch == '*')\\n        \\n        # 2) nearest candle to the left of or at i\\n        left_candle = [-1] * n\\n        last = -1\\n        for i, ch in enumerate(s):\\n            if ch == '|':\\n                last = i\\n            left_candle[i] = last\\n        \\n        # 3) nearest candle to the right of or at i\\n        right_candle = [-1] * n\\n        last = -1\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == '|':\\n                last = i\\n            right_candle[i] = last\\n        \\n        ans = []\\n        for l, r in queries:\\n            # find the span [a,b] of full candle-to-candle inside [l,r]\\n            a = right_candle[l]\\n            b = left_candle[r]\\n            \\n            # valid only if there are two candles and a < b\\n            if a != -1 and b != -1 and a < b:\\n                # plates between a and b = stars up to b minus stars up to a\\n                count = prefix_stars[b] - prefix_stars[a]\\n                ans.append(count)\\n            else:\\n                ans.append(0)\\n        \\n        return ans\\n\"",
  "3017_14631217_python-updated-time": "1747225741812",
  "460_14631217_python": "\"from collections import defaultdict, OrderedDict\\n\\nclass LFUCache:\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.min_freq = 0\\n        self.key_to_val_freq = {}\\n        self.freq_to_keys = defaultdict(OrderedDict)\\n\\n    def get(self, key):\\n        if key not in self.key_to_val_freq:\\n            return -1\\n        val, freq = self.key_to_val_freq[key]\\n        del self.freq_to_keys[freq][key]\\n        if not self.freq_to_keys[freq]:\\n            del self.freq_to_keys[freq]\\n            if self.min_freq == freq:\\n                self.min_freq += 1\\n        self.freq_to_keys[freq + 1][key] = None\\n        self.key_to_val_freq[key] = (val, freq + 1)\\n        return val\\n\\n    def put(self, key, value):\\n        if self.capacity == 0:\\n            return\\n        if key in self.key_to_val_freq:\\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\\n            self.get(key)\\n            return\\n        if len(self.key_to_val_freq) >= self.capacity:\\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\\n            del self.key_to_val_freq[evict_key]\\n        self.key_to_val_freq[key] = (value, 1)\\n        self.freq_to_keys[1][key] = None\\n        self.min_freq = 1\\n\"",
  "3452_14631217_python-updated-time": "1747484731512",
  "772_14631217_python": "\"\\\"\\\"\\\"\\n# Definition for a QuadTree node.\\nclass Node(object):\\n    def __init__(self, val=False, isLeaf=False, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\\\"\\\"\\\"\\n\\nclass Solution:\\n    def construct(self, grid):\\n        def build(x0, y0, size):\\n            if size == 1:\\n                return Node(bool(grid[x0][y0]), True)\\n            \\n            half = size // 2\\n            tl = build(x0, y0, half)\\n            tr = build(x0, y0 + half, half)\\n            bl = build(x0 + half, y0, half)\\n            br = build(x0 + half, y0 + half, half)\\n            \\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n                return Node(tl.val, True)\\n            else:\\n                return Node(True, False, tl, tr, bl, br)\\n        \\n        n = len(grid)\\n        return build(0, 0, n)\"",
  "2105_14631217_python-updated-time": "1746717270565",
  "3628_14631217_python-updated-time": "1747586082156",
  "915_14631217_python-updated-time": "1745360169610",
  "2513_14631217_python-updated-time": "1746966911945",
  "2470_14631217_python": "\"class Solution(object):\\n    def removeStars(self, s):\\n        stack = []\\n        for c in s:\\n            if c != '*':\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n        return ''.join(stack)\\n\"",
  "1636_14631217_python": "\"class Solution(object):\\n    def numSub(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        count = 0\\n        result = 0\\n\\n        for char in s:\\n            if char == '1':\\n                count += 1\\n            else:\\n                result += count * (count + 1) // 2\\n                count = 0\\n\\n        # Add the last group if it ends with '1'\\n        result += count * (count + 1) // 2\\n        return result % MOD\\n\"",
  "1381_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def maxScoreWords(self, words, letters, score):\\n        letter_count = Counter(letters)\\n\\n        def word_score(word):\\n            return sum(score[ord(c) - ord('a')] for c in word)\\n\\n        def can_form(word, available):\\n            wc = Counter(word)\\n            for c in wc:\\n                if wc[c] > available[c]:\\n                    return False\\n            return True\\n\\n        def backtrack(index, available):\\n            if index == len(words):\\n                return 0\\n            # Option 1: skip the word\\n            max_score = backtrack(index + 1, available)\\n\\n            word = words[index]\\n            if can_form(word, available):\\n                used = Counter(word)\\n                for c in used:\\n                    available[c] -= used[c]\\n                total = word_score(word) + backtrack(index + 1, available)\\n                max_score = max(max_score, total)\\n                for c in used:\\n                    available[c] += used[c]\\n\\n            return max_score\\n\\n        return backtrack(0, letter_count)\\n\"",
  "241_14631217_python": "\"class Solution(object):\\n    def diffWaysToCompute(self, expression):\\n        \\\"\\\"\\\"\\n        :type expression: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        memo = {}\\n        \\n        def ways(expr):\\n            if expr in memo:\\n                return memo[expr]\\n            \\n            res = []\\n            for i in range(len(expr)):\\n                if expr[i] in \\\"+-*\\\":\\n                    left = ways(expr[:i])\\n                    right = ways(expr[i+1:])\\n                    for l in left:\\n                        for r in right:\\n                            if expr[i] == '+':\\n                                res.append(l + r)\\n                            elif expr[i] == '-':\\n                                res.append(l - r)\\n                            else:\\n                                res.append(l * r)\\n            if not res:\\n                res.append(int(expr))\\n            memo[expr] = res\\n            return res\\n        \\n        return ways(expression)\\n\"",
  "2867_14631217_python-updated-time": "1747221738970",
  "184_14631217_mysql": "\"SELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\nWHERE (e.salary, e.departmentId) IN (\\n    SELECT MAX(salary), departmentId\\n    FROM Employee\\n    GROUP BY departmentId\\n);\\n\"",
  "3195_14631217_python": "\"class Solution(object):\\n    def minimumSteps(self, s):\\n        steps = 0\\n        count_ones = 0\\n        for c in s:\\n            if c == '1':\\n                count_ones += 1\\n            else:\\n                steps += count_ones\\n        return steps\"",
  "2361_14631217_python-updated-time": "1746879747068",
  "385_14631217_python": "\"class Solution:\\n    def deserialize(self, s):\\n        if s[0] != '[':\\n            return NestedInteger(int(s))\\n        \\n        stack = []\\n        num = ''\\n        for c in s:\\n            if c == '[':\\n                stack.append(NestedInteger())\\n            elif c == ']':\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = ''\\n                if len(stack) > 1:\\n                    ni = stack.pop()\\n                    stack[-1].add(ni)\\n            elif c == ',':\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = ''\\n            else:\\n                num += c\\n        return stack[0]\\n\"",
  "2654_14631217_python-updated-time": "1747066746231",
  "3834_14631217_python": "\"class Solution(object):\\n    class BIT:\\n        # 0-indexed BIT supporting point updates and prefix sums\\n        def __init__(self, n):\\n            self.n = n\\n            self.fw = [0] * (n + 1)\\n        def update(self, i, delta):\\n            # add delta at index i\\n            i += 1\\n            while i <= self.n:\\n                self.fw[i] += delta\\n                i += i & -i\\n        def query(self, i):\\n            # sum from 0..i\\n            i += 1\\n            s = 0\\n            while i > 0:\\n                s += self.fw[i]\\n                i -= i & -i\\n            return s\\n        def range_sum(self, l, r):\\n            if l > r:\\n                return 0\\n            return self.query(r) - (self.query(l - 1) if l > 0 else 0)\\n    \\n    def minOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        \\n        # Map each value to its list of positions\\n        pos = {}\\n        for i, v in enumerate(nums):\\n            pos.setdefault(v, []).append(i)\\n        \\n        # Sort distinct values\\n        vals = sorted(pos.keys())\\n        \\n        bit = Solution.BIT(n)\\n        # Initially block all zeros\\n        if 0 in pos:\\n            for idx in pos[0]:\\n                bit.update(idx, 1)\\n        \\n        ans = 0\\n        # Process positive values in increasing order\\n        for v in vals:\\n            if v == 0:\\n                continue\\n            idxs = pos[v]\\n            prev = None\\n            for idx in idxs:\\n                if prev is None:\\n                    ans += 1\\n                else:\\n                    # if there's any blocked (i.e. smaller) index between prev and idx\\n                    if bit.range_sum(prev + 1, idx - 1) > 0:\\n                        ans += 1\\n                prev = idx\\n            # now mark these positions as blocked for future larger values\\n            for idx in idxs:\\n                bit.update(idx, 1)\\n        \\n        return ans\\n\"",
  "1645_14631217_python": "\"class Solution(object):\\n    def closestToTarget(self, arr, target):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = float('inf')\\n        prev = set()\\n\\n        for num in arr:\\n            curr = {num}\\n            for val in prev:\\n                curr.add(val & num)\\n            for val in curr:\\n                res = min(res, abs(val - target))\\n            prev = curr\\n\\n        return res\\n\"",
  "464_14631217_python-updated-time": "1745359679358",
  "2028_14631217_python": "\"class Solution:\\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\\n        first, second = firstPlayer, secondPlayer\\n        memo = {}\\n\\n        def solve(players):                       # players: tuple, ascending IDs\\n            key = players\\n            if key in memo:\\n                return memo[key]\\n\\n            # positions (1-indexed) of the two stars\\n            try:\\n                pa = players.index(first) + 1\\n                pb = players.index(second) + 1\\n            except ValueError:\\n                # one of them is already eliminated – invalid branch\\n                return (float('inf'), 0)\\n\\n            if pa + pb == len(players) + 1:       # they meet this round\\n                return (1, 1)\\n\\n            best = [float('inf'), 0]              # [earliest, latest]\\n\\n            half = len(players) // 2\\n            mid_exists = len(players) % 2 == 1\\n            mid_player = players[half] if mid_exists else None\\n\\n            winners_seen = set()                  # avoid duplicate next states\\n\\n            def backtrack(idx, curr):\\n                if idx >= half:\\n                    # append middle auto-advance if odd\\n                    if mid_exists:\\n                        curr.append(mid_player)\\n                    nxt = tuple(sorted(curr))     # winners lined up ascending\\n                    if nxt not in winners_seen:\\n                        winners_seen.add(nxt)\\n                        e, l = solve(nxt)\\n                        if e != float('inf'):\\n                            best[0] = min(best[0], e + 1)\\n                            best[1] = max(best[1], l + 1)\\n                    if mid_exists:\\n                        curr.pop()\\n                    return\\n\\n                left = players[idx]\\n                right = players[-1 - idx]\\n\\n                # if this pair contains exactly the two stars, they meet now (handled earlier)\\n                if (left == first and right == second) or (left == second and right == first):\\n                    return\\n\\n                # if pair involves one star, that star must win\\n                if left == first or left == second:\\n                    curr.append(left)\\n                    backtrack(idx + 1, curr)\\n                    curr.pop()\\n                elif right == first or right == second:\\n                    curr.append(right)\\n                    backtrack(idx + 1, curr)\\n                    curr.pop()\\n                else:\\n                    # branch: left wins or right wins\\n                    curr.append(left)\\n                    backtrack(idx + 1, curr)\\n                    curr.pop()\\n                    curr.append(right)\\n                    backtrack(idx + 1, curr)\\n                    curr.pop()\\n\\n            backtrack(0, [])\\n            memo[key] = tuple(best)\\n            return memo[key]\\n\\n        initial_players = tuple(range(1, n + 1))\\n        return list(solve(initial_players))\\n\"",
  "476_14631217_python": "\"class Solution:\\n    def findComplement(self, num):\\n        bit_length = num.bit_length()\\n        mask = (1 << bit_length) - 1\\n        return num ^ mask\\n\"",
  "2448_14631217_python-updated-time": "1746964716687",
  "2305_14631217_python-updated-time": "1746804637348",
  "682_14631217_python-updated-time": "1745785080781",
  "3223_14631217_python-updated-time": "1747316306481",
  "1489_14631217_python": "\"class Solution(object):\\n    def maxSizeSlices(self, slices):\\n        def maxSum(arr, k):\\n            n = len(arr)\\n            dp = [[0] * (k + 1) for _ in range(n + 1)]\\n            for i in range(1, n + 1):\\n                for j in range(1, k + 1):\\n                    # Either skip current slice or take it (must skip i-1)\\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + arr[i - 1] if i >= 2 else arr[i - 1])\\n            return dp[n][k]\\n\\n        k = len(slices) // 3\\n        # Case 1: exclude last slice\\n        case1 = maxSum(slices[:-1], k)\\n        # Case 2: exclude first slice\\n        case2 = maxSum(slices[1:], k)\\n        return max(case1, case2)\\n\"",
  "1301_14631217_mysql": "\"SELECT\\n  id,\\n  MAX(CASE WHEN month = 'Jan' THEN revenue END) AS Jan_Revenue,\\n  MAX(CASE WHEN month = 'Feb' THEN revenue END) AS Feb_Revenue,\\n  MAX(CASE WHEN month = 'Mar' THEN revenue END) AS Mar_Revenue,\\n  MAX(CASE WHEN month = 'Apr' THEN revenue END) AS Apr_Revenue,\\n  MAX(CASE WHEN month = 'May' THEN revenue END) AS May_Revenue,\\n  MAX(CASE WHEN month = 'Jun' THEN revenue END) AS Jun_Revenue,\\n  MAX(CASE WHEN month = 'Jul' THEN revenue END) AS Jul_Revenue,\\n  MAX(CASE WHEN month = 'Aug' THEN revenue END) AS Aug_Revenue,\\n  MAX(CASE WHEN month = 'Sep' THEN revenue END) AS Sep_Revenue,\\n  MAX(CASE WHEN month = 'Oct' THEN revenue END) AS Oct_Revenue,\\n  MAX(CASE WHEN month = 'Nov' THEN revenue END) AS Nov_Revenue,\\n  MAX(CASE WHEN month = 'Dec' THEN revenue END) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n\"",
  "3645_14631217_python-updated-time": "1747596001127",
  "8_14631217_python": "\"class Solution(object):\\n    def myAtoi(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        i = 0\\n        n = len(s)\\n        while i < n and s[i] == ' ':\\n            i += 1\\n\\n        if i == n:\\n            return 0\\n\\n        sign = 1\\n        if s[i] == '-':\\n            sign = -1\\n            i += 1\\n        elif s[i] == '+':\\n            i += 1\\n\\n        result = 0\\n        while i < n and s[i].isdigit():\\n            result = result * 10 + int(s[i])\\n            i += 1\\n\\n        result *= sign\\n\\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\\n        if result < INT_MIN:\\n            return INT_MIN\\n        if result > INT_MAX:\\n            return INT_MAX\\n        return result\\n\"",
  "1360_14631217_python": "\"class Solution:\\n    def maxLength(self, arr):\\n        def isUnique(s):\\n            return len(s) == len(set(s))\\n\\n        def backtrack(index, current, max_len):\\n            if isUnique(current):\\n                max_len[0] = max(max_len[0], len(current))\\n            else:\\n                return\\n            for i in range(index, len(arr)):\\n                backtrack(i + 1, current + arr[i], max_len)\\n\\n        max_len = [0]\\n        backtrack(0, \\\"\\\", max_len)\\n        return max_len[0]\\n\"",
  "3140_14631217_python": "\"class Solution(object):\\n    def countVisitedNodes(self, edges):\\n        n = len(edges)\\n        ans = [0] * n\\n        state = [0] * n  # 0=unvisited,1=visiting,2=done\\n        for i in range(n):\\n            if state[i] != 0:\\n                continue\\n            path = []\\n            node = i\\n            while True:\\n                state[node] = 1\\n                path.append(node)\\n                nxt = edges[node]\\n                if state[nxt] == 0:\\n                    node = nxt\\n                    continue\\n                # found a back-edge or to completed\\n                if state[nxt] == 1:\\n                    # cycle detected\\n                    idx = path.index(nxt)\\n                    cycle_len = len(path) - idx\\n                    for j in range(idx, len(path)):\\n                        ans[path[j]] = cycle_len\\n                    # nodes before cycle\\n                    for j in range(idx-1, -1, -1):\\n                        ans[path[j]] = ans[path[j+1]] + 1\\n                else:\\n                    # nxt already done\\n                    for j in range(len(path)-1, -1, -1):\\n                        ans[path[j]] = ans[edges[path[j]]] + 1\\n                break\\n            # mark all on path as done\\n            for node in path:\\n                state[node] = 2\\n        return ans\"",
  "1916_14631217_python-updated-time": "1746542706378",
  "3714_14631217_python": "\"class Solution(object):\\n    def minMaxSums(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k:    int\\n        :rtype:     int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        \\n        # 1) Precompute factorials & inv-factorials up to n\\n        fac    = [1] * (n+1)\\n        invfac = [1] * (n+1)\\n        for i in range(1, n+1):\\n            fac[i] = fac[i-1] * i % MOD\\n        invfac[n] = pow(fac[n], MOD-2, MOD)\\n        for i in range(n, 0, -1):\\n            invfac[i-1] = invfac[i] * i % MOD\\n        \\n        def comb(a, b):\\n            if b < 0 or b > a:\\n                return 0\\n            return fac[a] * invfac[b] % MOD * invfac[a-b] % MOD\\n        \\n        # 2) Precompute f(i) = sum_{t=0..min(i,k-1)} C(i, t)\\n        f = [0] * n\\n        # powers of 2 up to k-1\\n        pow2 = [1] * k\\n        for i in range(1, k):\\n            pow2[i] = (pow2[i-1] * 2) % MOD\\n        \\n        for i in range(n):\\n            if i < k:\\n                # f(i) = 2^i\\n                f[i] = pow2[i]\\n            else:\\n                # f(i) = 2*f(i-1) - C(i-1, k-1)\\n                val = (2 * f[i-1] - comb(i-1, k-1)) % MOD\\n                f[i] = val\\n        \\n        # 3) Sort the array\\n        A = sorted(nums)\\n        \\n        # 4) Sum up max-contributions and min-contributions\\n        ans = 0\\n        for i, v in enumerate(A):\\n            ans = (ans + v * f[i] + v * f[n-1-i]) % MOD\\n        \\n        return ans\\n\"",
  "32_14631217_python": "\"class Solution(object):\\n    def longestValidParentheses(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        stack = [-1]\\n        max_len = 0\\n\\n        for i, char in enumerate(s):\\n            if char == '(':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    max_len = max(max_len, i - stack[-1])\\n\\n        return max_len\\n\"",
  "1049_14631217_python-updated-time": "1746041234874",
  "3627_14631217_python-updated-time": "1747586032582",
  "1426_14631217_python-updated-time": "1746260627933",
  "939_14631217_python-updated-time": "1746002722551",
  "1475_14631217_python-updated-time": "1746345564082",
  "658_14631217_python": "\"class Solution(object):\\n    def findClosestElements(self, arr, k, x):\\n        left, right = 0, len(arr) - k\\n        while left < right:\\n            mid = (left + right) // 2\\n            if x - arr[mid] > arr[mid + k] - x:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return arr[left:left + k]\\n\"",
  "1513_14631217_python-updated-time": "1746346354424",
  "1490_14631217_python": "\"class Solution(object):\\n    def generateTheString(self, n):\\n        if n % 2 == 1:\\n            return 'a' * n\\n        else:\\n            return 'a' * (n - 1) + 'b'\\n\"",
  "1243_14631217_python-updated-time": "1746261140941",
  "1807_14631217_python-updated-time": "1746453090288",
  "3622_14631217_python-updated-time": "1747586668880",
  "2237_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def longestPalindrome(self, words):\\n        count = Counter(words)\\n        res = 0\\n        center_used = False\\n\\n        for word in list(count.keys()):\\n            rev = word[::-1]\\n            if word != rev:\\n                pairs = min(count[word], count[rev])\\n                res += pairs * 4\\n                count[word] -= pairs\\n                count[rev] -= pairs\\n            else:\\n                pairs = count[word] // 2\\n                res += pairs * 4\\n                count[word] -= pairs * 2\\n\\n        for word in count:\\n            if word[0] == word[1] and count[word] > 0:\\n                res += 2\\n                break\\n\\n        return res\\n\"",
  "827_14631217_python-updated-time": "1745878523438",
  "437_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root, targetSum):\\n        def dfs(node, curr_sum):\\n            if not node:\\n                return 0\\n            curr_sum += node.val\\n            count = prefix_sums.get(curr_sum - targetSum, 0)\\n            prefix_sums[curr_sum] = prefix_sums.get(curr_sum, 0) + 1\\n            count += dfs(node.left, curr_sum)\\n            count += dfs(node.right, curr_sum)\\n            prefix_sums[curr_sum] -= 1\\n            return count\\n        \\n        prefix_sums = {0: 1}\\n        return dfs(root, 0)\"",
  "823_14631217_python": "\"class Solution(object):\\n    def splitArraySameAverage(self, nums):\\n        n = len(nums)\\n        total = sum(nums)\\n        dp = [set() for _ in range(n+1)]\\n        dp[0].add(0)\\n        \\n        for num in nums:\\n            for i in range(n-1, -1, -1):\\n                for s in dp[i]:\\n                    dp[i+1].add(s + num)\\n        \\n        for k in range(1, n):\\n            if total * k % n == 0 and (total * k // n) in dp[k]:\\n                return True\\n        return False\\n\"",
  "2343_14631217_python": "\"class Solution:\\n    def countUnguarded(self, m, n, guards, walls):\\n        total = m * n\\n        # 0 = empty, 1 = guard, 2 = wall, 3 = guarded\\n        grid = [0] * total\\n        \\n        # Place guards and walls\\n        for r, c in guards:\\n            grid[r*n + c] = 1\\n        for r, c in walls:\\n            grid[r*n + c] = 2\\n        \\n        # Helper to sweep a line of indices in 'grid'\\n        def sweep_line(idxs):\\n            seen = False\\n            for idx in idxs:\\n                cell = grid[idx]\\n                if cell == 2:        # wall\\n                    seen = False\\n                elif cell == 1:      # guard\\n                    seen = True\\n                elif cell == 0 and seen:\\n                    grid[idx] = 3     # mark as guarded\\n        \\n        # Sweep each row left→right and right→left\\n        for r in range(m):\\n            base = r * n\\n            row_idxs = [base + c for c in range(n)]\\n            sweep_line(row_idxs)\\n            sweep_line(row_idxs[::-1])\\n        \\n        # Sweep each column top→down and bottom→up\\n        for c in range(n):\\n            col_idxs = [r*n + c for r in range(m)]\\n            sweep_line(col_idxs)\\n            sweep_line(col_idxs[::-1])\\n        \\n        # Count unguarded empty cells\\n        ans = 0\\n        for v in grid:\\n            if v == 0:\\n                ans += 1\\n        return ans\\n\"",
  "1920_14631217_python-updated-time": "1746543596600",
  "1326_14631217_python": "\"class Solution:\\n    def sumOfFlooredPairs(self, nums):\\n        mod = 10**9 + 7\\n        maxv = max(nums)\\n        # frequency array\\n        f = [0] * (maxv + 1)\\n        for x in nums:\\n            f[x] += 1\\n        # prefix sums of frequencies\\n        pref = [0] * (maxv + 1)\\n        for i in range(1, maxv + 1):\\n            pref[i] = pref[i - 1] + f[i]\\n        ans = 0\\n        # for each divisor y\\n        for y in range(1, maxv + 1):\\n            fy = f[y]\\n            if fy == 0:\\n                continue\\n            Sy = 0\\n            # sum floor(x / y) * freq(x) over x\\n            maxk = maxv // y\\n            for k in range(1, maxk + 1):\\n                l = k * y\\n                r = min(maxv, l + y - 1)\\n                cnt = pref[r] - pref[l - 1]\\n                Sy += k * cnt\\n            ans = (ans + fy * Sy) % mod\\n        return ans\\n\"",
  "2817_14631217_python-updated-time": "1747140315396",
  "1946_14631217_python-updated-time": "1746543818868",
  "3485_14631217_python-updated-time": "1747571014189",
  "3460_14631217_python": "\"class Solution(object):\\n    def numberOfPermutations(self, n, requirements):\\n        MOD = 10**9 + 7\\n        \\n        # 1) Build C[L] = required inversions for prefix length L, or -1\\n        C = [-1] * (n+1)\\n        for endi, cnti in requirements:\\n            C[endi+1] = cnti\\n        \\n        # 2) Find max constraint M\\n        M = max(cnt for cnt in C if cnt >= 0)\\n        \\n        # 3) DP base: length 0 has exactly 0 inversions\\n        prev_dp = [1]        # dp[0][0] = 1\\n        prev_prefix = [1]    # prefix sums of prev_dp\\n        prevK = 0            # max k for L-1 = 0\\n        \\n        # 4) Build up to length n\\n        for L in range(1, n+1):\\n            # max inversions we care about at length L\\n            KL = min(L*(L-1)//2, M)\\n            dp = [0] * (KL + 1)\\n            \\n            # prefix sums of prev_dp up to prevK\\n            P = prev_prefix\\n            last_sum = P[-1]  # sum up to prevK\\n            \\n            # fill dp[L][k]\\n            for k in range(KL + 1):\\n                # total ways up to k in prev_dp\\n                if k <= prevK:\\n                    s1 = P[k]\\n                else:\\n                    s1 = last_sum\\n                # subtract ways above k-(L-1) to enforce i<=L-1\\n                if k >= L:\\n                    j = k - L\\n                    s2 = P[j] if j <= prevK else last_sum\\n                else:\\n                    s2 = 0\\n                dp[k] = (s1 - s2) % MOD\\n            \\n            # 5) enforce constraint if any\\n            c = C[L]\\n            if c >= 0:\\n                # if the required c > KL, impossible\\n                if c > KL:\\n                    return 0\\n                val = dp[c]\\n                # zero out everything except dp[c]\\n                dp = [0]*(KL+1)\\n                dp[c] = val\\n            \\n            # 6) build prefix sums for dp[L]\\n            prefix = [0] * (KL + 1)\\n            running = 0\\n            for k in range(KL + 1):\\n                running = (running + dp[k]) % MOD\\n                prefix[k] = running\\n            \\n            # move forward\\n            prev_dp = dp\\n            prev_prefix = prefix\\n            prevK = KL\\n        \\n        # 7) final answer is dp[n][C[n]] (there is always a constraint at L=n)\\n        return prev_dp[C[n]]\\n\"",
  "883_14631217_python": "\"class Solution(object):\\n    def carFleet(self, target, position, speed):\\n        cars = sorted(zip(position, speed), reverse=True)\\n        times = [(target - p) / float(s) for p, s in cars]\\n\\n        fleets = 0\\n        curr_time = 0\\n        for time in times:\\n            if time > curr_time:\\n                fleets += 1\\n                curr_time = time\\n        return fleets\\n\"",
  "71_14631217_python-updated-time": "1745015021462",
  "3396_14631217_python": "\"class Solution(object):\\n    def isValid(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # 1. Check minimum length\\n        if len(word) < 3:\\n            return False\\n\\n        vowels = set(\\\"aeiouAEIOU\\\")\\n        has_vowel = False\\n        has_consonant = False\\n\\n        for ch in word:\\n            # 2. Allow only letters and digits\\n            if not (ch.isdigit() or ch.isalpha()):\\n                return False\\n\\n            # 3. Track vowels and consonants\\n            if ch.isalpha():\\n                if ch in vowels:\\n                    has_vowel = True\\n                else:\\n                    has_consonant = True\\n\\n        # 4. Must have at least one vowel and one consonant\\n        return has_vowel and has_consonant\\n\"",
  "572_14631217_python": "\"class Solution(object):\\n    def isSubtree(self, root, subRoot):\\n        if not root:\\n            return False\\n        if self.isSame(root, subRoot):\\n            return True\\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\\n    \\n    def isSame(self, s, t):\\n        if not s and not t:\\n            return True\\n        if not s or not t:\\n            return False\\n        if s.val != t.val:\\n            return False\\n        return self.isSame(s.left, t.left) and self.isSame(s.right, t.right)\\n\"",
  "2470_14631217_python-updated-time": "1746965412214",
  "992_14631217_python-updated-time": "1746038715945",
  "2298_14631217_python": "\"class Solution:\\n    def countEven(self, num):\\n        def digit_sum(n):\\n            return sum(int(d) for d in str(n))\\n        \\n        count = 0\\n        for i in range(1, num + 1):\\n            if digit_sum(i) % 2 == 0:\\n                count += 1\\n        return count\\n\"",
  "983_14631217_python-updated-time": "1746004704533",
  "452_14631217_python": "\"class Solution:\\n    def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n        \\n        points.sort(key=lambda x: x[1])\\n        arrows = 1\\n        end = points[0][1]\\n        \\n        for xstart, xend in points[1:]:\\n            if xstart > end:\\n                arrows += 1\\n                end = xend\\n        \\n        return arrows\\n\"",
  "1203_14631217_java-updated-time": "1746108872083",
  "3795_14631217_python-updated-time": "1747682778948",
  "872_14631217_python-updated-time": "1745879819433",
  "3395_14631217_python": "\"class Solution(object):\\n    def minAnagramLength(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        n = len(s)\\n        total = Counter(s)\\n\\n        # helper: all divisors of n, in ascending order\\n        divs = []\\n        i = 1\\n        while i * i <= n:\\n            if n % i == 0:\\n                divs.append(i)\\n                if i * i != n:\\n                    divs.append(n // i)\\n            i += 1\\n        divs.sort()\\n\\n        # try each possible block-size k\\n        for k in divs:\\n            B = n // k  # number of blocks\\n            # quick check: each char count must be divisible by B\\n            ok = True\\n            per = {}\\n            for ch, cnt in total.items():\\n                if cnt % B:\\n                    ok = False\\n                    break\\n                per[ch] = cnt // B\\n            if not ok:\\n                continue\\n\\n            # now verify every length-k block matches per[]\\n            from collections import Counter\\n            valid = True\\n            for start in range(0, n, k):\\n                blk = s[start:start+k]\\n                if Counter(blk) != per:\\n                    valid = False\\n                    break\\n            if valid:\\n                return k\\n\\n        # (theoretically won't happen, since k = n always works)\\n        return n\\n\"",
  "662_14631217_python-updated-time": "1745783027354",
  "1617_14631217_python": "\"class Solution(object):\\n    def winnerSquareGame(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        dp = [False] * (n + 1)\\n        \\n        for i in range(1, n + 1):\\n            j = 1\\n            while j * j <= i:\\n                if not dp[i - j * j]:\\n                    dp[i] = True\\n                    break\\n                j += 1\\n\\n        return dp[n]\\n\"",
  "3464_14631217_python": "\"class Solution(object):\\n    def maximumTotalCost(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # running alternating prefix sum\\n        pa = 0\\n        \\n        # best over j even: max(DP[j-1] - PA[j-1])\\n        best_even = 0  \\n        # best over j odd : max(DP[j-1] + PA[j-1])\\n        best_odd  = -10**30  \\n        \\n        dp_i = 0\\n        for i, x in enumerate(nums):\\n            # update PA[i]\\n            if i & 1:\\n                pa -= x\\n            else:\\n                pa += x\\n            \\n            # compute DP[i]\\n            dp_i = max(best_even + pa,\\n                       best_odd  - pa)\\n            \\n            # now fold in j = i+1 as a potential start for future segments\\n            if (i+1) & 1:  # j odd\\n                best_odd = max(best_odd, dp_i + pa)\\n            else:          # j even\\n                best_even = max(best_even, dp_i - pa)\\n        \\n        return dp_i\\n\"",
  "1475_14631217_python": "\"class Solution(object):\\n    def maxSumBST(self, root):\\n        self.max_sum = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return (True, float('inf'), float('-inf'), 0)  # isBST, min, max, sum\\n\\n            left_is_bst, left_min, left_max, left_sum = dfs(node.left)\\n            right_is_bst, right_min, right_max, right_sum = dfs(node.right)\\n\\n            if left_is_bst and right_is_bst and left_max < node.val < right_min:\\n                curr_sum = node.val + left_sum + right_sum\\n                self.max_sum = max(self.max_sum, curr_sum)\\n                return (True,\\n                        min(left_min, node.val),\\n                        max(right_max, node.val),\\n                        curr_sum)\\n            else:\\n                return (False, 0, 0, 0)\\n\\n        dfs(root)\\n        return self.max_sum\\n\"",
  "2766_14631217_python-updated-time": "1747136745009",
  "1783_14631217_python-updated-time": "1746445729961",
  "1324_14631217_python": "\"class Solution(object):\\n    def findBall(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        answer = []\\n        \\n        for start_col in range(n):\\n            col = start_col\\n            for row in range(m):\\n                dir = grid[row][col]\\n                next_col = col + dir\\n                # Check if next move goes out of bounds\\n                if next_col < 0 or next_col >= n:\\n                    col = -1\\n                    break\\n                # Check for \\\"V\\\" shape (mismatch in direction)\\n                if grid[row][next_col] != dir:\\n                    col = -1\\n                    break\\n                # Valid move\\n                col = next_col\\n            answer.append(col)\\n        \\n        return answer\\n\"",
  "1563_14631217_python-updated-time": "1746347741235",
  "3540_14631217_python": "\"class Solution(object):\\n    def stringHash(self, s, k):\\n        result = \\\"\\\"\\n        for i in range(0, len(s), k):\\n            chunk = s[i:i + k]\\n            total = sum(ord(c) - ord('a') for c in chunk)\\n            hashed_char = chr((total % 26) + ord('a'))\\n            result += hashed_char\\n        return result\\n\"",
  "2077_14631217_python-updated-time": "1746638617312",
  "3759_14631217_python-updated-time": "1747682558077",
  "1694_14631217_python": "\"class Solution(object):\\n    def minSubarray(self, nums, p):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type p: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = sum(nums) % p\\n        if total == 0:\\n            return 0\\n        \\n        n = len(nums)\\n        best = n + 1\\n        prefix = 0\\n        last = {0: 0}\\n        \\n        for k, x in enumerate(nums, 1):\\n            prefix = (prefix + x) % p\\n            need = (prefix - total) % p\\n            if need in last:\\n                best = min(best, k - last[need])\\n            last[prefix] = k\\n        \\n        return best if best < n else -1\\n\"",
  "3715_14631217_python-updated-time": "1747655997077",
  "1454_14631217_python": "\"class Solution:\\n    def removePalindromeSub(self, s):\\n        # If the entire string is already a palindrome, 1 step suffices.\\n        if s == s[::-1]:\\n            return 1\\n        # Otherwise, we can do it in 2 steps (remove all 'a's then all 'b's).\\n        return 2\\n\"",
  "2308_14631217_python-updated-time": "1746810421086",
  "1306_14631217_python": "\"class Solution(object):\\n    def minimumAbsDifference(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        arr.sort()\\n        min_diff = float('inf')\\n        result = []\\n\\n        for i in range(1, len(arr)):\\n            diff = arr[i] - arr[i - 1]\\n            if diff < min_diff:\\n                min_diff = diff\\n                result = [[arr[i - 1], arr[i]]]\\n            elif diff == min_diff:\\n                result.append([arr[i - 1], arr[i]])\\n\\n        return result\\n\"",
  "2685_14631217_python": "\"class Solution(object):\\n    def firstCompleteIndex(self, arr, mat):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type mat: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(mat), len(mat[0])\\n        # Map each value to its (row, col) in mat\\n        pos = {}\\n        for i in range(m):\\n            for j in range(n):\\n                pos[mat[i][j]] = (i, j)\\n                \\n        # Counters for painted cells in each row/column\\n        row_cnt = [0] * m\\n        col_cnt = [0] * n\\n        \\n        # Paint in the order given by arr\\n        for idx, v in enumerate(arr):\\n            r, c = pos[v]\\n            row_cnt[r] += 1\\n            col_cnt[c] += 1\\n            # Check if this row or column is now fully painted\\n            if row_cnt[r] == n or col_cnt[c] == m:\\n                return idx\\n        \\n        # Per problem statement this should never happen, but just in case:\\n        return -1\\n\"",
  "1375_14631217_python": "\"class Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        res = []\\n        half = (intLength + 1) // 2\\n        start = 10 ** (half - 1)\\n        max_count = 9 * start\\n        for q in queries:\\n            if q > max_count:\\n                res.append(-1)\\n            else:\\n                prefix = start + q - 1\\n                s = str(prefix)\\n                if intLength % 2 == 0:\\n                    pal = s + s[::-1]\\n                else:\\n                    pal = s + s[-2::-1]\\n                res.append(int(pal))\\n        return res\\n\"",
  "3569_14631217_python": "\"class Solution(object):\\n    def kthCharacter(self, k):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        word = 'a'\\n        while len(word) < k:\\n            shifted = ''.join(\\n                chr((ord(c) - ord('a') + 1) % 26 + ord('a'))\\n                for c in word\\n            )\\n            word += shifted\\n        return word[k-1]\\n\\n    def countOfSubstrings(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        vowels = set('aeiou')\\n        # Track last occurrence of each vowel\\n        last_occ = {v: -1 for v in vowels}\\n        # For consonant positions\\n        cons_indices = []\\n        # Last consonant index, for k==0 case\\n        last_cons = -1\\n        result = 0\\n        for j, c in enumerate(word):\\n            if c in vowels:\\n                last_occ[c] = j\\n            else:\\n                cons_indices.append(j)\\n                last_cons = j\\n            # If any vowel hasn't appeared, skip\\n            left_v = min(last_occ.values())\\n            if left_v < 0:\\n                continue\\n            # Handle k == 0 separately (no consonants)\\n            if k == 0:\\n                # Start must be after last consonant\\n                lb = last_cons + 1\\n                # And start must be <= leftmost vowel to include all vowels\\n                ub = left_v\\n                if ub >= lb:\\n                    result += (ub - lb + 1)\\n            else:\\n                t = len(cons_indices)\\n                if t < k:\\n                    continue\\n                # First consonant index to include in substring\\n                first_cons = cons_indices[t - k]\\n                # Lower bound: start must be after previous consonant\\n                if t - k - 1 >= 0:\\n                    lb = cons_indices[t - k - 1] + 1\\n                else:\\n                    lb = 0\\n                # Upper bound: start must be <= first_cons to include exactly k total consonants\\n                ub = first_cons\\n                # Also start <= left_v to include all vowels\\n                ub = min(ub, left_v)\\n                if ub >= lb:\\n                    result += (ub - lb + 1)\\n        return result\"",
  "3362_14631217_python": "\"class Solution(object):\\n    def medianOfUniquenessArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # total subarrays\\n        N = n * (n + 1) // 2\\n        # lower‐median index\\n        k = (N + 1) // 2\\n\\n        # maximum possible distinct in any subarray\\n        max_distinct = len(set(nums))\\n\\n        # helper to count subarrays with ≤ t distinct\\n        from collections import defaultdict\\n        def count_at_most(t):\\n            freq = defaultdict(int)\\n            left = 0\\n            distinct = 0\\n            total = 0\\n            for right, v in enumerate(nums):\\n                if freq[v] == 0:\\n                    distinct += 1\\n                freq[v] += 1\\n                while distinct > t:\\n                    freq[nums[left]] -= 1\\n                    if freq[nums[left]] == 0:\\n                        distinct -= 1\\n                    left += 1\\n                total += right - left + 1\\n            return total\\n\\n        # binary search smallest t in [1..max_distinct] with F(t) >= k\\n        lo, hi = 1, max_distinct\\n        ans = max_distinct\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if count_at_most(mid) >= k:\\n                ans = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return ans\\n\"",
  "2711_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumTime(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][1] > 1 and grid[1][0] > 1:\\n            return -1\\n\\n        heap = [(0, 0, 0)]  # (time, row, col)\\n        visited = [[False]*n for _ in range(m)]\\n        dirs = [(-1,0), (1,0), (0,-1), (0,1)]\\n\\n        while heap:\\n            time, r, c = heapq.heappop(heap)\\n            if visited[r][c]:\\n                continue\\n            visited[r][c] = True\\n\\n            if r == m - 1 and c == n - 1:\\n                return time\\n\\n            for dr, dc in dirs:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:\\n                    wait_time = max(grid[nr][nc], time + 1)\\n                    # adjust for even-odd parity trap\\n                    if (wait_time - time) % 2 == 0:\\n                        wait_time += 1\\n                    heapq.heappush(heap, (wait_time, nr, nc))\\n\\n        return -1\\n\"",
  "1662_14631217_python-updated-time": "1746434768001",
  "3252_14631217_python-updated-time": "1747318398480",
  "575_14631217_python": "\"class Solution(object):\\n    def distributeCandies(self, candyType):\\n        # You can eat at most n/2 candies, and you want as many distinct types as possible.\\n        # The maximum distinct types you can eat is the minimum of:\\n        #   - the number of unique candy types\\n        #   - n/2 (the total candies you are allowed to eat)\\n        return min(len(set(candyType)), len(candyType) // 2)\\n\"",
  "306_14631217_python-updated-time": "1745255756663",
  "2476_14631217_python": "\"class Solution(object):\\n    def checkDistances(self, s, distance):\\n        first = {}\\n        for i, ch in enumerate(s):\\n            idx = ord(ch) - ord('a')\\n            if ch in first:\\n                if i - first[ch] - 1 != distance[idx]:\\n                    return False\\n            else:\\n                first[ch] = i\\n        return True\\n\"",
  "2743_14631217_javascript": "\"function debounce(fn, t) {\\n  let timerId = null;\\n\\n  return function (...args) {\\n    if (timerId !== null) {\\n      clearTimeout(timerId);\\n    }\\n    timerId = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n}\\n\"",
  "3269_14631217_python-updated-time": "1747413680748",
  "3479_14631217_python": "\"class Solution(object):\\n    def numberOfSubstrings(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # 1) substrings of all '1's\\n        ans = 0\\n        run = 0\\n        for ch in s:\\n            if ch == '1':\\n                run += 1\\n            else:\\n                ans += run * (run + 1) // 2\\n                run = 0\\n        ans += run * (run + 1) // 2\\n\\n        # 2) zero positions\\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\\n        Z = len(zeros)\\n        if Z == 0:\\n            return ans\\n\\n        # 3) max z with z(z+1) <= n, via float sqrt\\n        import math\\n        zmax = int((math.sqrt(1 + 4*n) - 1) // 2)\\n\\n        # 4) slide window over zeros for each z\\n        for z in range(1, min(Z, zmax) + 1):\\n            M = z*(z+1)       # need substring‐length ≥ M → r-l+1 ≥ M → r-l ≥ M-1\\n            for k in range(Z - z + 1):\\n                left0 = zeros[k]\\n                right0 = zeros[k+z-1]\\n                A = zeros[k-1] + 1 if k > 0 else 0\\n                B = zeros[k+z] - 1 if (k+z) < Z else n - 1\\n                Rcount = B - right0 + 1\\n                if Rcount <= 0:\\n                    continue\\n\\n                # Case 1: l ≤ right0-(M-1)\\n                t = right0 - (M - 1)\\n                L2 = min(left0, t)\\n                cnt = 0\\n                if L2 >= A:\\n                    cnt += (L2 - A + 1) * Rcount\\n\\n                # Case 2: l > t, and r ≥ l+(M-1)\\n                start2 = max(A, t+1)\\n                # r runs from (l+M-1) to B, so count_r = B-(l+M-1)+1 = (B-M+2)-l = K-l\\n                K = B - M + 2\\n                U = min(left0, K - 1)\\n                if U >= start2:\\n                    c = U - start2 + 1\\n                    cnt += c*K - (start2 + U)*c//2\\n\\n                ans += cnt\\n\\n        return ans\\n\"",
  "810_14631217_python": "\"class Solution(object):\\n    def validTicTacToe(self, board):\\n        def win(p):\\n            for i in range(3):\\n                if all(board[i][j] == p for j in range(3)) or all(board[j][i] == p for j in range(3)):\\n                    return True\\n            if all(board[i][i] == p for i in range(3)) or all(board[i][2-i] == p for i in range(3)):\\n                return True\\n            return False\\n        \\n        x_count = sum(row.count('X') for row in board)\\n        o_count = sum(row.count('O') for row in board)\\n        \\n        if o_count > x_count or x_count > o_count + 1:\\n            return False\\n        if win('X') and x_count != o_count + 1:\\n            return False\\n        if win('O') and x_count != o_count:\\n            return False\\n        return True\\n\"",
  "600_14631217_python": "\"class Solution(object):\\n    def findIntegers(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # fib[i] = number of binary strings of length i without consecutive ones\\n        fib = [0] * 32\\n        fib[0] = 1\\n        fib[1] = 2\\n        for i in range(2, 32):\\n            fib[i] = fib[i-1] + fib[i-2]\\n\\n        ans = 0\\n        prev_bit = 0\\n        # process bits from most significant to least\\n        k = n.bit_length()  # number of bits needed to represent n\\n        for i in range(k-1, -1, -1):\\n            if (n >> i) & 1:\\n                # if this bit is 1, add all valid combinations with a 0 here\\n                ans += fib[i]\\n                # if previous bit was also 1, we've formed '11', stop here\\n                if prev_bit:\\n                    return ans\\n                prev_bit = 1\\n            else:\\n                prev_bit = 0\\n\\n        # if we never saw consecutive ones in n itself, include n\\n        return ans + 1\\n\"",
  "800_14631217_python": "\"class Solution(object):\\n    def letterCasePermutation(self, s):\\n        res = []\\n        \\n        def dfs(path, i):\\n            if i == len(s):\\n                res.append(path)\\n                return\\n            if s[i].isalpha():\\n                dfs(path + s[i].lower(), i + 1)\\n                dfs(path + s[i].upper(), i + 1)\\n            else:\\n                dfs(path + s[i], i + 1)\\n        \\n        dfs(\\\"\\\", 0)\\n        return res\\n\"",
  "1814_14631217_python-updated-time": "1746453256352",
  "3297_14631217_python": "\"class Solution(object):\\n    def minimumTimeToInitialState(self, word, k):\\n        n = len(word)\\n        for t in range(1, (n + k - 1) // k + 1):\\n            if word[k * t:] == word[:n - k * t]:\\n                return t\\n        return (n + k - 1) // k\\n\"",
  "371_14631217_python": "\"class Solution:\\n    def getSum(self, a, b):\\n        MASK = 0xFFFFFFFF\\n        MAX_INT = 0x7FFFFFFF\\n        \\n        while b != 0:\\n            carry = (a & b) & MASK\\n            a = (a ^ b) & MASK\\n            b = (carry << 1) & MASK\\n        \\n        return a if a <= MAX_INT else ~(a ^ MASK)\\n\"",
  "3610_14631217_python-updated-time": "1747578262970",
  "680_14631217_python-updated-time": "1745785050225",
  "790_14631217_python-updated-time": "1745877223159",
  "2820_14631217_javascript": "\"/**\\n * @param {...(null|boolean|number|string|Array|Object)} args\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\"",
  "3318_14631217_python": "\"class Solution(object):\\n    def maxOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n\\n        # Only these three scores can appear on the very first removal from [0..n-1]\\n        candidates = {\\n            nums[0] + nums[1],      # remove first two\\n            nums[-2] + nums[-1],    # remove last two\\n            nums[0] + nums[-1],     # remove one from each end\\n        }\\n\\n        best = 0\\n        for S in candidates:\\n            # dp2[i] = best #ops on subarray of length (L-2) starting at i\\n            dp2 = [0] * (n + 2)\\n            # dp1[i] = best #ops on subarray of length (L-1) starting at i\\n            dp1 = [0] * (n + 1)\\n\\n            # Build for subarray‐length L = 2..n\\n            for L in range(2, n + 1):\\n                size = n - L + 1\\n                dp0 = [0] * size\\n                for i in range(size):\\n                    j = i + L - 1\\n                    v = 0\\n                    # 1) first two\\n                    if nums[i] + nums[i+1] == S:\\n                        v = max(v, 1 + dp2[i+2])\\n                    # 2) last two\\n                    if nums[j-1] + nums[j] == S:\\n                        v = max(v, 1 + dp2[i])\\n                    # 3) one from each end\\n                    if nums[i] + nums[j] == S:\\n                        v = max(v, 1 + dp2[i+1])\\n                    dp0[i] = v\\n\\n                # roll forward: next L+1 will use these\\n                dp2, dp1 = dp1, dp0\\n\\n            # dp1[0] now holds the best #ops for the full array [0..n-1]\\n            best = max(best, dp1[0])\\n\\n        return best\\n\"",
  "1628_14631217_python-updated-time": "1746433203100",
  "1793_14631217_python": "\"class Solution(object):\\n    def minMoves(self, nums, limit):\\n        n = len(nums)\\n        change = [0] * (2 * limit + 2)\\n        for i in range(n // 2):\\n            a = nums[i]\\n            b = nums[n - 1 - i]\\n            lo = min(a, b) + 1\\n            hi = max(a, b) + limit\\n            s = a + b\\n            change[2] += 2\\n            change[lo] -= 1\\n            change[s] -= 1\\n            change[s + 1] += 1\\n            change[hi + 1] += 1\\n            change[2 * limit + 1] -= 2\\n        res = float('inf')\\n        cur = 0\\n        for x in range(2, 2 * limit + 1):\\n            cur += change[x]\\n            if cur < res:\\n                res = cur\\n        return res\\n\"",
  "62_14631217_python": "\"class Solution(object):\\n    def uniquePaths(self, m, n):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [[1] * n for _ in range(m)]\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n\\n        return dp[m-1][n-1]\\n\"",
  "3852_14631217_python": "\"import sys\\nfrom bisect import bisect_right\\ndef readints():\\n    return map(int, sys.stdin.readline().split())\\n\\nclass Solution(object):\\n    def pathExistenceQueries(self, n, nums, maxDiff, queries):\\n        # Sort nodes by value, but remember original indices.\\n        order = sorted(range(n), key=lambda i: nums[i])\\n        vals  = [nums[i] for i in order]\\n        # map original index -> position in sorted array\\n        pos   = [0]*n\\n        for j,i in enumerate(order):\\n            pos[i] = j\\n\\n        # Build component ids by checking gaps > maxDiff\\n        comp = [0]*n\\n        cid = 0\\n        for j in range(1,n):\\n            if vals[j]-vals[j-1] > maxDiff:\\n                cid += 1\\n            comp[j] = cid\\n\\n        # Precompute for each j the farthest index we can reach in one hop forward\\n        # i.e. largest k>j with vals[k] <= vals[j] + maxDiff\\n        nxt = [j for j in range(n)]\\n        for j in range(n):\\n            # binary search the first index > vals[j]+maxDiff\\n            k = bisect_right(vals, vals[j] + maxDiff) - 1\\n            nxt[j] = k\\n\\n        # And similarly backward\\n        prv = [j for j in range(n)]\\n        for j in range(n):\\n            # first index where vals[idx] >= vals[j] - maxDiff\\n            low = bisect_right(vals, vals[j]-maxDiff-1)\\n            prv[j] = low\\n\\n        # Build binary lifting tables\\n        LOG = (n-1).bit_length()\\n        jump_f = [nxt]\\n        jump_b = [prv]\\n        for k in range(1, LOG):\\n            prev_f = jump_f[k-1]\\n            prev_b = jump_b[k-1]\\n            cur_f = [0]*n\\n            cur_b = [0]*n\\n            for j in range(n):\\n                cur_f[j] = prev_f[prev_f[j]]\\n                cur_b[j] = prev_b[prev_b[j]]\\n            jump_f.append(cur_f)\\n            jump_b.append(cur_b)\\n\\n        ans = []\\n        for u, v in queries:\\n            pu, pv = pos[u], pos[v]\\n            # if same node\\n            if pu == pv:\\n                ans.append(0)\\n                continue\\n            # if not even in same component\\n            if comp[pu] != comp[pv]:\\n                ans.append(-1)\\n                continue\\n            # ensure pu < pv for forward jumps\\n            if pu < pv:\\n                cur = pu\\n                steps = 0\\n                # greedy lift: try the largest 2^k jump that stays below pv\\n                for k in reversed(range(LOG)):\\n                    to = jump_f[k][cur]\\n                    if to < pv:\\n                        cur = to\\n                        steps += (1<<k)\\n                # one more hop gets us >= pv\\n                ans.append(steps+1)\\n            else:\\n                cur = pu\\n                steps = 0\\n                for k in reversed(range(LOG)):\\n                    to = jump_b[k][cur]\\n                    if to > pv:\\n                        cur = to\\n                        steps += (1<<k)\\n                ans.append(steps+1)\\n\\n        return ans\"",
  "1424_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\\n        n = len(status)\\n        found = set(initialBoxes)\\n        queue = deque()\\n        opened = set()\\n        available_keys = set()\\n        total_candies = 0\\n\\n        # Add initially open boxes to the queue\\n        for box in initialBoxes:\\n            if status[box] == 1:\\n                queue.append(box)\\n\\n        while queue:\\n            box = queue.popleft()\\n            if box in opened:\\n                continue\\n            opened.add(box)\\n            total_candies += candies[box]\\n\\n            # Collect keys and try to open new boxes\\n            for key in keys[box]:\\n                if key not in available_keys:\\n                    available_keys.add(key)\\n                    if key in found and key not in opened:\\n                        queue.append(key)\\n\\n            # Add contained boxes\\n            for contained in containedBoxes[box]:\\n                found.add(contained)\\n                if status[contained] == 1 or contained in available_keys:\\n                    queue.append(contained)\\n\\n        return total_candies\\n\"",
  "2434_14631217_python-updated-time": "1746907726508",
  "3691_14631217_python-updated-time": "1747652728023",
  "1811_14631217_mysql": "\"SELECT\\n  user_id,\\n  CONCAT(\\n    UPPER(LEFT(name, 1)),\\n    LOWER(SUBSTRING(name, 2))\\n  ) AS name\\nFROM Users\\nORDER BY user_id;\\n\"",
  "584_14631217_mysql": "\"SELECT name\\nFROM Customer\\nWHERE referee_id IS NULL\\n   OR referee_id <> 2;\\n\"",
  "2330_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n        # 1) Separate already‐full gardens from the rest\\n        flowers.sort()\\n        n = len(flowers)\\n        # number of gardens already >= target\\n        full0 = bisect.bisect_left(flowers, target)\\n        full0 = n - full0\\n        # B = flowers < target\\n        B = flowers[:n - full0]\\n        M = len(B)\\n        \\n        # 2) Prefix sums on B for raising the minimum\\n        ps = [0] * (M + 1)\\n        for i in range(M):\\n            ps[i+1] = ps[i] + B[i]\\n        \\n        # 3) Suffix sums on B for completing gardens\\n        #    suf[i] = sum of B[i..M-1]\\n        suf = [0] * (M + 1)\\n        for i in range(M - 1, -1, -1):\\n            suf[i] = suf[i+1] + B[i]\\n        \\n        best = 0\\n        \\n        # 4) Try making f_add of the incomplete gardens full\\n        for f_add in range(M + 1):\\n            # cost to make the largest f_add of B full:\\n            #   = f_add*target - sum of those f_add = f_add*target - suf[M-f_add]\\n            cost_full_add = f_add * target - suf[M - f_add]\\n            if cost_full_add > newFlowers:\\n                break\\n            \\n            rem = newFlowers - cost_full_add\\n            total_full = full0 + f_add\\n            incomplete = M - f_add\\n            \\n            # 5a) If no incomplete remain, only full term\\n            if incomplete == 0:\\n                best = max(best, total_full * full)\\n            else:\\n                # 5b) Binary‐search the maximum m ≤ target-1 we can raise all B[0..incomplete-1] to\\n                lo, hi = B[0], target - 1\\n                if lo > hi:\\n                    m = hi\\n                else:\\n                    while lo < hi:\\n                        mid = (lo + hi + 1) // 2\\n                        # how many are below mid in B[0..incomplete-1]?\\n                        idx = bisect.bisect_left(B, mid, 0, incomplete)\\n                        cost = mid * idx - ps[idx]\\n                        if cost <= rem:\\n                            lo = mid\\n                        else:\\n                            hi = mid - 1\\n                    m = lo\\n                \\n                best = max(best, total_full * full + m * partial)\\n        \\n        return best\\n\"",
  "2307_14631217_python": "\"class Solution(object):\\n    def replaceNonCoprimes(self, nums):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n        stack = []\\n        for x in nums:\\n            stack.append(x)\\n            while len(stack) > 1:\\n                g = gcd(stack[-1], stack[-2])\\n                if g == 1:\\n                    break\\n                lcm = stack[-2] // g * stack[-1]\\n                stack.pop()\\n                stack[-1] = lcm\\n        return stack\\n\"",
  "2761_14631217_javascript-updated-time": "1747135393208",
  "2264_14631217_python": "\"class Solution:\\n    def minimumSum(self, num):\\n        digits = sorted(map(int, str(num)))\\n        new1 = digits[0] * 10 + digits[2]\\n        new2 = digits[1] * 10 + digits[3]\\n        return new1 + new2\\n\"",
  "473_14631217_python-updated-time": "1745360009986",
  "442_14631217_python": "\"class Solution:\\n    def findDuplicates(self, nums):\\n        res = []\\n        for num in nums:\\n            idx = abs(num) - 1\\n            if nums[idx] < 0:\\n                res.append(abs(num))\\n            else:\\n                nums[idx] *= -1\\n        return res\\n\"",
  "1004_14631217_python": "\"class Solution:\\n    def leastOpsExpressTarget(self, x, target):\\n        def cost(i):          # operators to write x^i once (without leading + / -)\\n            return 2 if i == 0 else i\\n\\n        dp0, dp1 = 0, float('inf')    # dp0: no carry, dp1: carry = 1 to next digit\\n        i = 0\\n        t = target\\n\\n        while t:\\n            d = t % x                 # current base-x digit\\n            t //= x\\n            c = cost(i)\\n\\n            next0 = min(dp0 + d * c,           # keep carry 0\\n                         dp1 + (d + 1) * c)    # resolve previous carry-1\\n            next1 = min(dp0 + (x - d) * c,     # create new carry-1\\n                         dp1 + (x - d - 1) * c)\\n\\n            dp0, dp1 = next0, next1\\n            i += 1\\n\\n        ans = min(dp0, dp1 + cost(i)) - 1      # minus 1: first term has no leading op\\n        return ans\\n\"",
  "3080_14631217_python-updated-time": "1747305084835",
  "3603_14631217_python": "\"class Solution(object):\\n    def findAnswer(self, parent, s):\\n        \\\"\\\"\\\"\\n        :type parent: List[int]\\n        :type s: str\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        n = len(parent)\\n        # build adjacency list of children and sort\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            p = parent[i]\\n            children[p].append(i)\\n        for ch in children:\\n            ch.sort()\\n        # iterative post-order traversal\\n        post = []\\n        stack = [(0, False)]\\n        while stack:\\n            u, visited = stack.pop()\\n            if visited:\\n                post.append(u)\\n            else:\\n                stack.append((u, True))\\n                for v in reversed(children[u]):\\n                    stack.append((v, False))\\n        # compute subtree sizes using post-order\\n        size = [0] * n\\n        for u in post:\\n            total = 1\\n            for v in children[u]:\\n                total += size[v]\\n            size[u] = total\\n        # map each node to its position in post-order\\n        pos = [0] * n\\n        for idx, u in enumerate(post):\\n            pos[u] = idx\\n        # build the post-order string array\\n        T = [s[u] for u in post]\\n        # reverse string for backward hashing\\n        TR = T[::-1]\\n        # rolling hash parameters\\n        M = 10**9 + 7\\n        B = 29\\n        # precompute powers of B\\n        P = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            P[i] = (P[i-1] * B) % M\\n        # prefix hashes for T\\n        H = [0] * (n + 1)\\n        for i, ch in enumerate(T):\\n            H[i+1] = (H[i] * B + (ord(ch) - ord('a') + 1)) % M\\n        # prefix hashes for TR\\n        HR = [0] * (n + 1)\\n        for i, ch in enumerate(TR):\\n            HR[i+1] = (HR[i] * B + (ord(ch) - ord('a') + 1)) % M\\n        # compute answer for each node\\n        answer = [False] * n\\n        for u in range(n):\\n            r = pos[u]\\n            L = size[u]\\n            l = r - L + 1\\n            # forward hash on T[l..r]\\n            hf = (H[r+1] - H[l] * P[L] % M + M) % M\\n            # corresponding reversed segment in TR: indices [n-1-r .. n-1-l]\\n            L2 = n - 1 - r\\n            R2 = n - 1 - l\\n            hr = (HR[R2+1] - HR[L2] * P[L] % M + M) % M\\n            answer[u] = (hf == hr)\\n        return answer\\n\"",
  "1161_14631217_mysql-updated-time": "1746107933829",
  "3530_14631217_mysql": "\"SELECT\\n  transaction_date,\\n  COALESCE(SUM(CASE WHEN amount % 2 = 1 THEN amount END), 0) AS odd_sum,\\n  COALESCE(SUM(CASE WHEN amount % 2 = 0 THEN amount END), 0) AS even_sum\\nFROM transactions\\nGROUP BY transaction_date\\nORDER BY transaction_date;\\n\"",
  "1740_14631217_python-updated-time": "1746444212463",
  "283_14631217_python-updated-time": "1745248526815",
  "1889_14631217_python-updated-time": "1746532314787",
  "2347_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def averageOfSubtree(self, root):\\n        self.ans = 0\\n        \\n        def dfs(node):\\n            # returns (sum of subtree, count of nodes)\\n            if not node:\\n                return (0, 0)\\n            ls, lc = dfs(node.left)\\n            rs, rc = dfs(node.right)\\n            total_sum = ls + rs + node.val\\n            total_count = lc + rc + 1\\n            # integer average (floored)\\n            if node.val == total_sum // total_count:\\n                self.ans += 1\\n            return (total_sum, total_count)\\n        \\n        dfs(root)\\n        return self.ans\\n\"",
  "3482_14631217_python": "\"import array\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def minimumCost(self, target, words, costs):\\n        \\\"\\\"\\\"\\n        :type target: str\\n        :type words: List[str]\\n        :type costs: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) Deduplicate words, keeping only the minimal cost\\n        best = {}\\n        for w, c in zip(words, costs):\\n            if w in best:\\n                if c < best[w]:\\n                    best[w] = c\\n            else:\\n                best[w] = c\\n\\n        # 2) Build Aho–Corasick trie of the unique words\\n        # children[node][ci] = next state for char ci (0..25)\\n        children = []\\n        fail     = array.array('I', [])    # failure link per node\\n        output   = []                       # output[node] = list of (length, cost)\\n\\n        # initialize root\\n        children.append(array.array('I', [0]*26))\\n        fail.append(0)\\n        output.append([])\\n\\n        # insert each word\\n        for w, c in best.items():\\n            node = 0\\n            for ch in w:\\n                ci = ord(ch) - ord('a')\\n                nxt = children[node][ci]\\n                if nxt == 0:\\n                    nxt = len(children)\\n                    children.append(array.array('I', [0]*26))\\n                    fail.append(0)\\n                    output.append([])\\n                    children[node][ci] = nxt\\n                node = nxt\\n            # mark end: store (word_length, cost)\\n            output[node].append((len(w), c))\\n\\n        # 3) Build failure links and complete the goto table\\n        q = deque()\\n        # Depth‐1: link children of root back to root\\n        for ci in range(26):\\n            nxt = children[0][ci]\\n            if nxt:\\n                fail[nxt] = 0\\n                q.append(nxt)\\n            else:\\n                # missing edge => stay at root\\n                children[0][ci] = 0\\n\\n        # BFS\\n        while q:\\n            r = q.popleft()\\n            for ci in range(26):\\n                u = children[r][ci]\\n                if u:\\n                    # set failure[u] = children[ fail[r] ][ci]\\n                    f = fail[r]\\n                    fci = children[f][ci]\\n                    fail[u] = fci\\n                    # merge outputs\\n                    output[u].extend(output[fci])\\n                    q.append(u)\\n                else:\\n                    # fill missing transition\\n                    children[r][ci] = children[fail[r]][ci]\\n\\n        # 4) DP over prefixes of target\\n        n = len(target)\\n        INF = 10**30\\n        dp = [INF] * (n+1)\\n        dp[0] = 0\\n\\n        node = 0\\n        for i, ch in enumerate(target, start=1):\\n            ci = ord(ch) - ord('a')\\n            node = children[node][ci]\\n            # for every word ending here\\n            for length, c in output[node]:\\n                prev = dp[i - length]\\n                if prev + c < dp[i]:\\n                    dp[i] = prev + c\\n\\n        return dp[n] if dp[n] < INF else -1\\n\"",
  "1155_14631217_mysql": "\"SELECT s.product_id, s.year AS first_year, s.quantity, s.price\\nFROM Sales s\\nJOIN (\\n    SELECT product_id, MIN(year) AS first_year\\n    FROM Sales\\n    GROUP BY product_id\\n) first_sale\\nON s.product_id = first_sale.product_id AND s.year = first_sale.first_year;\\n\"",
  "1690_14631217_python": "\"class Solution(object):\\n    def getMaxLen(self, nums):\\n        ans = 0\\n        n = len(nums)\\n        i = 0\\n        while i < n:\\n            if nums[i] == 0:\\n                i += 1\\n                continue\\n            start = i\\n            neg_count = 0\\n            first_neg = -1\\n            last_neg = -1\\n            while i < n and nums[i] != 0:\\n                if nums[i] < 0:\\n                    neg_count += 1\\n                    if first_neg == -1:\\n                        first_neg = i\\n                    last_neg = i\\n                i += 1\\n            end = i - 1\\n            if neg_count % 2 == 0:\\n                ans = max(ans, end - start + 1)\\n            else:\\n                ans = max(ans, end - first_neg, last_neg - start)\\n        return ans\\n\"",
  "2423_14631217_python-updated-time": "1746907638263",
  "1282_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def findNumOfValidWords(self, words, puzzles):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type puzzles: List[str]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def to_mask(word):\\n            mask = 0\\n            for ch in set(word):  # set to avoid duplicates\\n                mask |= 1 << (ord(ch) - ord('a'))\\n            return mask\\n\\n        # Step 1: Build frequency map of word bitmasks\\n        word_count = Counter(to_mask(word) for word in words if len(set(word)) <= 7)\\n\\n        res = []\\n        for puzzle in puzzles:\\n            first = 1 << (ord(puzzle[0]) - ord('a'))\\n            mask = to_mask(puzzle)\\n            sub = mask\\n            total = 0\\n\\n            while sub:\\n                if sub & first:  # must include first letter\\n                    total += word_count.get(sub, 0)\\n                sub = (sub - 1) & mask  # next subset\\n            res.append(total)\\n\\n        return res\\n\"",
  "2695_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def findScore(self, nums):\\n        n = len(nums)\\n        marked = [False] * n\\n        heap = [(val, i) for i, val in enumerate(nums)]\\n        heapq.heapify(heap)\\n\\n        score = 0\\n        marked_count = 0\\n\\n        while marked_count < n:\\n            val, i = heapq.heappop(heap)\\n            if marked[i]:\\n                continue\\n            # pick this element\\n            score += val\\n            # mark i and its neighbors\\n            for j in (i-1, i, i+1):\\n                if 0 <= j < n and not marked[j]:\\n                    marked[j] = True\\n                    marked_count += 1\\n\\n        return score\\n\"",
  "151_14631217_python": "\"class Solution(object):\\n    def reverseWords(self, s):\\n        return ' '.join(s.strip().split()[::-1])\\n\"",
  "2059_14631217_python-updated-time": "1746637961871",
  "1220_14631217_python": "\"class Solution(object):\\n    def smallestSufficientTeam(self, req_skills, people):\\n        \\\"\\\"\\\"\\n        :type req_skills: List[str]\\n        :type people: List[List[str]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        skill_index = {skill: i for i, skill in enumerate(req_skills)}\\n        n_skills = len(req_skills)\\n\\n        # Convert each person's skills to a bitmask\\n        people_masks = []\\n        for p in people:\\n            mask = 0\\n            for skill in p:\\n                mask |= 1 << skill_index[skill]\\n            people_masks.append(mask)\\n\\n        dp = {0: []}  # key = skill bitmask, value = list of people indices\\n\\n        for i, person_mask in enumerate(people_masks):\\n            new_dp = dp.copy()\\n            for skill_set, team in dp.items():\\n                combined = skill_set | person_mask\\n                if combined not in new_dp or len(new_dp[combined]) > len(team) + 1:\\n                    new_dp[combined] = team + [i]\\n            dp = new_dp\\n\\n        full_mask = (1 << n_skills) - 1\\n        return dp[full_mask]\\n\"",
  "2346_14631217_python-updated-time": "1746880620659",
  "715_14631217_python": "\"import bisect\\n\\nclass RangeModule(object):\\n\\n    def __init__(self):\\n        # List of non-overlapping, sorted intervals [start, end)\\n        self.intervals = []\\n\\n    def addRange(self, left, right):\\n        \\\"\\\"\\\"\\n        Adds [left, right), merging overlapping intervals.\\n        \\\"\\\"\\\"\\n        intervals = self.intervals\\n        # Find the position to insert\\n        i = bisect.bisect_left(intervals, [left, 0])\\n        # If there is an interval before i that overlaps, include it\\n        if i > 0 and intervals[i-1][1] >= left:\\n            i -= 1\\n            left = min(left, intervals[i][0])\\n            right = max(right, intervals[i][1])\\n        # Merge all intervals that overlap [left, right)\\n        j = i\\n        while j < len(intervals) and intervals[j][0] <= right:\\n            right = max(right, intervals[j][1])\\n            j += 1\\n        # Replace intervals[i:j] with the merged interval\\n        intervals[i:j] = [[left, right]]\\n\\n    def queryRange(self, left, right):\\n        \\\"\\\"\\\"\\n        Returns True if every point in [left, right) is covered.\\n        \\\"\\\"\\\"\\n        intervals = self.intervals\\n        # Find the first interval with start > left\\n        i = bisect.bisect_right(intervals, [left, float('inf')])\\n        # The covering interval, if it exists, must be intervals[i-1]\\n        if i == 0:\\n            return False\\n        return intervals[i-1][1] >= right\\n\\n    def removeRange(self, left, right):\\n        \\\"\\\"\\\"\\n        Removes coverage of [left, right) by splitting intervals as needed.\\n        \\\"\\\"\\\"\\n        intervals = self.intervals\\n        new_intervals = []\\n        for start, end in intervals:\\n            # No overlap\\n            if end <= left or start >= right:\\n                new_intervals.append([start, end])\\n            else:\\n                # Left piece remains\\n                if start < left:\\n                    new_intervals.append([start, left])\\n                # Right piece remains\\n                if end > right:\\n                    new_intervals.append([right, end])\\n        self.intervals = new_intervals\\n\"",
  "2113_14631217_python-updated-time": "1746716924488",
  "432_14631217_python": "\"class Node:\\n    def __init__(self, count):\\n        self.count = count\\n        self.keys = set()\\n        self.prev = None\\n        self.next = None\\n        \\nclass AllOne:\\n    def __init__(self):\\n        self.head = Node(float('-inf'))\\n        self.tail = Node(float('inf'))\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.key_node = {}  # key -> node\\n\\n    def _insert_after(self, node, new_node):\\n        nxt = node.next\\n        node.next = new_node\\n        new_node.prev = node\\n        new_node.next = nxt\\n        nxt.prev = new_node\\n\\n    def _remove(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        prev.next = nxt\\n        nxt.prev = prev\\n\\n    def inc(self, key):\\n        if key not in self.key_node:\\n            if self.head.next.count != 1:\\n                new_node = Node(1)\\n                self._insert_after(self.head, new_node)\\n            self.head.next.keys.add(key)\\n            self.key_node[key] = self.head.next\\n        else:\\n            node = self.key_node[key]\\n            nxt = node.next\\n            if nxt.count != node.count + 1:\\n                new_node = Node(node.count + 1)\\n                self._insert_after(node, new_node)\\n            else:\\n                new_node = nxt\\n            new_node.keys.add(key)\\n            self.key_node[key] = new_node\\n            node.keys.remove(key)\\n            if len(node.keys) == 0:\\n                self._remove(node)\\n\\n    def dec(self, key):\\n        node = self.key_node[key]\\n        if node.count == 1:\\n            del self.key_node[key]\\n            node.keys.remove(key)\\n            if len(node.keys) == 0:\\n                self._remove(node)\\n        else:\\n            prev = node.prev\\n            if prev.count != node.count - 1:\\n                new_node = Node(node.count - 1)\\n                self._insert_after(prev, new_node)\\n            else:\\n                new_node = prev\\n            new_node.keys.add(key)\\n            self.key_node[key] = new_node\\n            node.keys.remove(key)\\n            if len(node.keys) == 0:\\n                self._remove(node)\\n\\n    def getMaxKey(self):\\n        if self.tail.prev == self.head:\\n            return \\\"\\\"\\n        return next(iter(self.tail.prev.keys))\\n\\n    def getMinKey(self):\\n        if self.head.next == self.tail:\\n            return \\\"\\\"\\n        return next(iter(self.head.next.keys))\\n\\n# Your AllOne object will be instantiated and called as such:\\n# obj = AllOne()\\n# obj.inc(key)\\n# obj.dec(key)\\n# param_3 = obj.getMaxKey()\\n# param_4 = obj.getMinKey()\"",
  "2892_14631217_python-updated-time": "1747222487308",
  "3826_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def maxProfit(self, n, edges, score):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type score: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        \\n        # predecessor_mask[i] will be a bitmask where the j-th bit is set \\n        # if node j is a direct predecessor of node i.\\n        predecessor_mask = [0] * n\\n        for u, v_node in edges: # Renamed v to v_node for clarity\\n            predecessor_mask[v_node] |= (1 << u)\\n            \\n        # dp[mask] stores the maximum profit for the subset of nodes represented by 'mask'.\\n        # These nodes are arranged to fill the first popcount(mask) positions \\n        # in a valid topological order.\\n        # Initialize with -1 to signify states not yet reached or not optimally reachable yet.\\n        # Since scores are positive (>=1), any valid profit will be non-negative.\\n        dp = [-1] * (1 << n)\\n        \\n        # Base case: for an empty set of nodes (mask 0), profit is 0.\\n        dp[0] = 0\\n        \\n        # Precompute popcounts for all masks.\\n        # popcounts[mask] stores the number of set bits (nodes) in 'mask'.\\n        popcounts = [0] * (1 << n)\\n        # For mask 0, popcount is 0 (already set by initialization).\\n        # For other masks:\\n        for i_mask_val in range(1, 1 << n):\\n            # The popcount of i_mask_val is popcount of (i_mask_val / 2) plus (i_mask_val % 2)\\n            # Using bitwise operations: popcounts[i_mask_val >> 1] + (i_mask_val & 1)\\n            popcounts[i_mask_val] = popcounts[i_mask_val >> 1] + (i_mask_val & 1)\\n\\n        # Iterate through all masks. 'prev_mask' represents the set of nodes already processed.\\n        for prev_mask in range(1 << n):\\n            # If prev_mask is not a reachable state, skip.\\n            if dp[prev_mask] == -1:\\n                continue\\n            \\n            # The node to be added now will be placed at k_pos (1-based).\\n            # k_pos is the count of nodes in prev_mask + 1.\\n            k_pos = popcounts[prev_mask] + 1\\n            \\n            # Consider adding each node 'i_node' that is not already in prev_mask.\\n            for i_node in range(n):\\n                # Check if i_node is NOT in prev_mask using bitwise AND\\n                if not (prev_mask & (1 << i_node)):\\n                    # Check if all predecessors of i_node ARE in prev_mask.\\n                    # The condition (A | B) == B means A is a submask of B.\\n                    # Here, all bits set in predecessor_mask[i_node] must also be set in prev_mask.\\n                    if (predecessor_mask[i_node] | prev_mask) == prev_mask:\\n                        # If valid to add i_node:\\n                        # Form the new mask including i_node using bitwise OR.\\n                        current_mask = prev_mask | (1 << i_node)\\n                        # Calculate profit if i_node is added at k_pos.\\n                        profit_val = dp[prev_mask] + score[i_node] * k_pos\\n                        \\n                        # Update dp[current_mask] if this path yields higher profit.\\n                        if profit_val > dp[current_mask]:\\n                            dp[current_mask] = profit_val\\n                            \\n        # The final answer is the max profit for the set of all nodes.\\n        # This mask is (1 << n) - 1.\\n        return dp[(1 << n) - 1]\"",
  "3062_14631217_pythondata-updated-time": "1747305524131",
  "2692_14631217_python-updated-time": "1747064997306",
  "3511_14631217_python": "\"class Solution(object):\\n    def winningPlayer(self, x, y):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :type y: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        moves = min(x, y // 4)\\n        return \\\"Alice\\\" if (moves % 2) == 1 else \\\"Bob\\\"\\n\"",
  "2366_14631217_python": "\"class Solution:\\n    def maximumBags(self, capacity, rocks, additionalRocks):\\n        # Compute how many more rocks each bag needs to be full\\n        needed = [c - r for c, r in zip(capacity, rocks)]\\n        # Fill the bags that need the fewest rocks first\\n        needed.sort()\\n        \\n        full = 0\\n        for n in needed:\\n            if n == 0:\\n                # Already full\\n                full += 1\\n            elif additionalRocks >= n:\\n                additionalRocks -= n\\n                full += 1\\n            else:\\n                break\\n        \\n        return full\\n\"",
  "1119_14631217_python-updated-time": "1746042712905",
  "2884_14631217_python": "\"class Solution:\\n    def longestValidSubstring(self, word, forbidden):\\n        forbidden_by_len = {}\\n        for f in forbidden:\\n            forbidden_by_len.setdefault(len(f), set()).add(f)\\n        \\n        n = len(word)\\n        start = 0\\n        best = 0\\n        \\n        for r in range(n):\\n            for L in range(1, min(10, r + 1) + 1):\\n                if L in forbidden_by_len:\\n                    sub = word[r - L + 1 : r + 1]\\n                    if sub in forbidden_by_len[L]:\\n                        start = max(start, r - L + 2)\\n            best = max(best, r - start + 1)\\n        \\n        return best\\n\"",
  "3751_14631217_python-updated-time": "1747671366223",
  "1746_14631217_python-updated-time": "1746444647898",
  "169_14631217_python-updated-time": "1745091546689",
  "3190_14631217_python-updated-time": "1747311436348",
  "3215_14631217_python-updated-time": "1747314424920",
  "2013_14631217_python": "\"import math\\n\\nclass Solution:\\n    def minSkips(self, dist, speed, hoursBefore):\\n        n = len(dist)\\n        INF = float('inf')\\n\\n        # dp[i][k] = min time (in units) to reach i-th road with k skips\\n        dp = [ [INF] * (n + 1) for _ in range(n + 1) ]\\n        dp[0][0] = 0  # 0 roads, 0 skips = 0 time\\n\\n        for i in range(1, n + 1):\\n            d = dist[i - 1]\\n            for k in range(0, i + 1):\\n                # Option 1: don't skip\\n                if dp[i - 1][k] != INF:\\n                    t = dp[i - 1][k] + d\\n                    if i < n:\\n                        # round up to next multiple of speed\\n                        t = ((t + speed - 1) // speed) * speed\\n                    dp[i][k] = min(dp[i][k], t)\\n\\n                # Option 2: skip this rest\\n                if k > 0 and dp[i - 1][k - 1] != INF:\\n                    t = dp[i - 1][k - 1] + d\\n                    dp[i][k] = min(dp[i][k], t)\\n\\n        max_time = hoursBefore * speed\\n        for k in range(n + 1):\\n            if dp[n][k] <= max_time:\\n                return k\\n        return -1\\n\"",
  "3231_14631217_python-updated-time": "1747315661022",
  "464_14631217_python": "\"class Solution:\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal <= 0:\\n            return True\\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\\n            return False\\n\\n        memo = {}\\n\\n        def dfs(used, total):\\n            if used in memo:\\n                return memo[used]\\n\\n            for i in range(1, maxChoosableInteger + 1):\\n                if not (used >> i) & 1:\\n                    if total + i >= desiredTotal or not dfs(used | (1 << i), total + i):\\n                        memo[used] = True\\n                        return True\\n            memo[used] = False\\n            return False\\n\\n        return dfs(0, 0)\\n\"",
  "496_14631217_python-updated-time": "1745445990411",
  "1155_14631217_mysql-updated-time": "1746107763616",
  "2454_14631217_python": "\"class Solution(object):\\n    def largestLocal(self, grid):\\n        n = len(grid)\\n        res = [[0] * (n - 2) for _ in range(n - 2)]\\n\\n        for i in range(n - 2):\\n            for j in range(n - 2):\\n                max_val = 0\\n                for x in range(i, i + 3):\\n                    for y in range(j, j + 3):\\n                        max_val = max(max_val, grid[x][y])\\n                res[i][j] = max_val\\n\\n        return res\\n\"",
  "746_14631217_python": "\"class WordFilter(object):\\n\\n    def __init__(self, words):\\n        self.lookup = {}\\n        for index, word in enumerate(words):\\n            length = len(word)\\n            for i in range(length + 1):\\n                for j in range(length + 1):\\n                    key = (word[:i], word[j:])\\n                    self.lookup[key] = index\\n\\n    def f(self, pref, suff):\\n        return self.lookup.get((pref, suff), -1)\\n\"",
  "1886_14631217_python-updated-time": "1746531689450",
  "2250_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def highestRankedKItems(self, grid, pricing, start, k):\\n        m, n = len(grid), len(grid[0])\\n        low, high = pricing\\n        sr, sc = start\\n        visited = [[False]*n for _ in range(m)]\\n        queue = deque()\\n        queue.append((sr, sc, 0))  # (row, col, distance)\\n        visited[sr][sc] = True\\n        result = []\\n\\n        while queue:\\n            r, c, dist = queue.popleft()\\n            val = grid[r][c]\\n            if low <= val <= high:\\n                result.append((dist, val, r, c))\\n            for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] != 0:\\n                    visited[nr][nc] = True\\n                    queue.append((nr, nc, dist + 1))\\n\\n        result.sort()\\n        return [[r, c] for _, _, r, c in result[:k]]\\n\"",
  "2615_14631217_python-updated-time": "1747060692118",
  "1414_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def shortestPath(self, grid, k):\\n        m, n = len(grid), len(grid[0])\\n        if k >= m + n - 2:\\n            return m + n - 2  # shortcut if we can go straight through\\n\\n        visited = set()\\n        queue = deque([(0, 0, 0, 0)])  # (x, y, steps, obstacles_used)\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n\\n        while queue:\\n            x, y, steps, obs = queue.popleft()\\n\\n            if (x, y, obs) in visited:\\n                continue\\n            visited.add((x, y, obs))\\n\\n            if x == m - 1 and y == n - 1:\\n                return steps\\n\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    new_obs = obs + grid[nx][ny]\\n                    if new_obs <= k and (nx, ny, new_obs) not in visited:\\n                        queue.append((nx, ny, steps + 1, new_obs))\\n\\n        return -1\\n\"",
  "2472_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def buildMatrix(self, k, rowConditions, colConditions):\\n        def topoSort(conds):\\n            indeg = [0] * (k + 1)\\n            adj = defaultdict(list)\\n            for u, v in conds:\\n                adj[u].append(v)\\n                indeg[v] += 1\\n            q = deque(u for u in range(1, k + 1) if indeg[u] == 0)\\n            order = []\\n            while q:\\n                u = q.popleft()\\n                order.append(u)\\n                for v in adj[u]:\\n                    indeg[v] -= 1\\n                    if indeg[v] == 0:\\n                        q.append(v)\\n            return order if len(order) == k else []\\n\\n        row_order = topoSort(rowConditions)\\n        if not row_order:\\n            return []\\n        col_order = topoSort(colConditions)\\n        if not col_order:\\n            return []\\n\\n        row_pos = {num: i for i, num in enumerate(row_order)}\\n        col_pos = {num: j for j, num in enumerate(col_order)}\\n\\n        matrix = [[0] * k for _ in range(k)]\\n        for num in range(1, k + 1):\\n            i = row_pos[num]\\n            j = col_pos[num]\\n            matrix[i][j] = num\\n\\n        return matrix\\n\"",
  "2125_14631217_python": "\"class Solution:\\n    def gcdSort(self, nums):\\n        import math\\n        from collections import defaultdict\\n\\n        n = len(nums)\\n        A = max(nums)\\n\\n        # 1) Build SPF (smallest prime factor) sieve up to A\\n        spf = list(range(A + 1))\\n        limit = int(A**0.5)\\n        for p in range(2, limit + 1):\\n            if spf[p] == p:\\n                step = p * p\\n                for multiple in range(step, A + 1, p):\\n                    if spf[multiple] == multiple:\\n                        spf[multiple] = p\\n\\n        # 2) Factorization using SPF\\n        def get_primes(x):\\n            s = set()\\n            while x > 1:\\n                p = spf[x]\\n                s.add(p)\\n                x //= p\\n            return s\\n\\n        # 3) Union-Find on indices\\n        parent = list(range(n))\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra != rb:\\n                parent[rb] = ra\\n\\n        prime_to_index = {}\\n        for i, v in enumerate(nums):\\n            for p in get_primes(v):\\n                if p in prime_to_index:\\n                    union(i, prime_to_index[p])\\n                else:\\n                    prime_to_index[p] = i\\n\\n        # 4) Group indices by root\\n        groups = defaultdict(list)\\n        for i in range(n):\\n            groups[find(i)].append(i)\\n\\n        # 5) Compare multisets within each component\\n        sorted_nums = sorted(nums)\\n        for grp in groups.values():\\n            orig = sorted(nums[i] for i in grp)\\n            targ = sorted(sorted_nums[i] for i in grp)\\n            if orig != targ:\\n                return False\\n\\n        return True\\n\"",
  "2627_14631217_python-updated-time": "1747061411780",
  "3306_14631217_python-updated-time": "1747420700052",
  "1659_14631217_python-updated-time": "1746434235203",
  "551_14631217_python": "\"class Solution:\\n    def checkRecord(self, s):\\n        return s.count('A') < 2 and 'LLL' not in s\\n\"",
  "2408_14631217_python-updated-time": "1746906662159",
  "2238_14631217_python-updated-time": "1746801680456",
  "2854_14631217_python": "\"class Solution:\\n    def minimizeConcatenatedLength(self, words):\\n        n = len(words)\\n        memo = {}\\n\\n        def dp(i, first, last):\\n            key = (i, first, last)\\n            if key in memo:\\n                return memo[key]\\n            if i == n:\\n                return 0\\n\\n            word = words[i]\\n            wlen = len(word)\\n            wf, wl = word[0], word[-1]\\n\\n            # join(str + word)\\n            overlap1 = 1 if last == wf else 0\\n            cost1 = wlen - overlap1 + dp(i + 1, first, wl)\\n\\n            # join(word + str)\\n            overlap2 = 1 if wl == first else 0\\n            cost2 = wlen - overlap2 + dp(i + 1, wf, last)\\n\\n            memo[key] = min(cost1, cost2)\\n            return memo[key]\\n\\n        first_word = words[0]\\n        return len(first_word) + dp(1, first_word[0], first_word[-1])\\n\"",
  "3725_14631217_python-updated-time": "1747659803720",
  "3865_14631217_mysql-updated-time": "1747683563041",
  "412_14631217_python": "\"class Solution:\\n    def fizzBuzz(self, n):\\n        res = []\\n        for i in range(1, n + 1):\\n            if i % 3 == 0 and i % 5 == 0:\\n                res.append(\\\"FizzBuzz\\\")\\n            elif i % 3 == 0:\\n                res.append(\\\"Fizz\\\")\\n            elif i % 5 == 0:\\n                res.append(\\\"Buzz\\\")\\n            else:\\n                res.append(str(i))\\n        return res\\n\"",
  "188_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, k, prices):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type prices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not prices:\\n            return 0\\n        \\n        n = len(prices)\\n        \\n        if k >= n // 2:\\n            profit = 0\\n            for i in range(1, n):\\n                if prices[i] > prices[i-1]:\\n                    profit += prices[i] - prices[i-1]\\n            return profit\\n        \\n        dp = [[0] * n for _ in range(k + 1)]\\n        \\n        for i in range(1, k + 1):\\n            max_diff = -prices[0]\\n            for j in range(1, n):\\n                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\\n                max_diff = max(max_diff, dp[i-1][j] - prices[j])\\n        \\n        return dp[k][n-1]\\n\"",
  "2872_14631217_python": "\"class Solution:\\n    def maxArrayValue(self, nums):\\n        total = nums[-1]\\n        for i in range(len(nums) - 2, -1, -1):\\n            if nums[i] <= total:\\n                total += nums[i]\\n            else:\\n                total = nums[i]\\n        return total\\n\"",
  "2333_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def countRectangles(self, rectangles, points):\\n        # 1) Bucket rectangle lengths by their height h=1..100\\n        by_h = [[] for _ in range(101)]\\n        for L, H in rectangles:\\n            by_h[H].append(L)\\n        # Sort each bucket once\\n        for h in range(1, 101):\\n            by_h[h].sort()\\n        \\n        # 2) Group queries (points) by their y_j\\n        #    so we can answer them exactly when sweep reaches that y\\n        qs = [[] for _ in range(101)]\\n        for idx, (x, y) in enumerate(points):\\n            qs[y].append((x, idx))\\n        \\n        # 3) Sweep y from 100 down to 1, maintaining a sorted list L\\n        L = []          # merged list of all lengths with height >= current y\\n        res = [0] * len(points)\\n        \\n        for y in range(100, 0, -1):\\n            # Merge in the rectangles of exactly height y\\n            # (both L and by_h[y] are sorted)\\n            if by_h[y]:\\n                # Standard two-pointer merge into a new list\\n                merged = []\\n                i = j = 0\\n                A, B = L, by_h[y]\\n                na, nb = len(A), len(B)\\n                while i < na and j < nb:\\n                    if A[i] <= B[j]:\\n                        merged.append(A[i]); i += 1\\n                    else:\\n                        merged.append(B[j]); j += 1\\n                if i < na:\\n                    merged.extend(A[i:])\\n                if j < nb:\\n                    merged.extend(B[j:])\\n                L = merged\\n            \\n            # Answer any queries whose y_j == y\\n            # Count how many lengths in L are >= x via bisect\\n            for x, qi in qs[y]:\\n                # first position where length >= x\\n                pos = bisect.bisect_left(L, x)\\n                res[qi] = len(L) - pos\\n        \\n        return res\\n\"",
  "972_14631217_python-updated-time": "1746004115472",
  "2006_14631217_python": "\"class Solution:\\n    def chalkReplacer(self, chalk, k):\\n        total = sum(chalk)\\n        k %= total\\n        for i, c in enumerate(chalk):\\n            if k < c:\\n                return i\\n            k -= c\\n\"",
  "3289_14631217_python": "\"class Solution:\\n    def earliestSecondToMarkIndices(self, nums, changeIndices):\\n        n, m = len(nums), len(changeIndices)\\n        base = n + sum(nums)                        # cost with no “set”\\n\\n        # ---------- helper that tests if we can finish in `s` seconds ----------\\n        def ok(s):\\n            need = base - s                         # seconds we still have to save\\n            if need <= 0:                           # already enough time\\n                return True\\n\\n            # first appearance (1-based) of every index in the range [1, s-1]\\n            first = [-1] * n\\n            for t in range(s - 1):                  # we cannot “set” at second s\\n                i = changeIndices[t] - 1\\n                if first[i] == -1:\\n                    first[i] = t + 1\\n\\n            # candidates = (saving, position) for indices with nums[i] > 1\\n            cand = [(-(nums[i] - 1), first[i])\\n                     for i in range(n)\\n                     if nums[i] > 1 and first[i] != -1]\\n            cand.sort()                             # biggest saving first\\n\\n            from bisect import bisect_left, insort\\n            chosen = []                             # positions of selected “set”s\\n            saved  = 0\\n\\n            for neg_save, pos in cand:\\n                insort(chosen, pos)                 # try to take this “set”\\n                # check the spacing condition:\\n                # for every suffix, #sets ≤ free seconds in that suffix\\n                ok_here, k = True, len(chosen)\\n                cnt = 0\\n                for p in reversed(chosen):          # iterate suffix sizes\\n                    cnt += 1                        # sets in this suffix\\n                    if 2 * cnt - 1 > s - p:        # not enough room for marks\\n                        ok_here = False\\n                        break\\n                if not ok_here:                     # keep schedule valid\\n                    chosen.pop(bisect_left(chosen, pos))\\n                    continue\\n\\n                saved += -neg_save                  # add this saving\\n                if saved >= need:                  # reached required saving\\n                    return True\\n            return False\\n\\n        # ---------------- binary-search the answer ----------------\\n        lo, hi, ans = 1, m, -1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if ok(mid):\\n                ans = mid\\n                hi  = mid - 1\\n            else:\\n                lo  = mid + 1\\n        return ans\\n\"",
  "1894_14631217_python-updated-time": "1746531914653",
  "518_14631217_python-updated-time": "1745446471171",
  "729_14631217_python-updated-time": "1745787014526",
  "1911_14631217_python-updated-time": "1746542519701",
  "2432_14631217_python": "\"class Solution:\\n    def zeroFilledSubarray(self, nums):\\n        total = 0\\n        streak = 0\\n        \\n        for x in nums:\\n            if x == 0:\\n                streak += 1\\n            else:\\n                # add all subarrays within the completed zero-streak\\n                total += streak * (streak + 1) // 2\\n                streak = 0\\n        \\n        # account for a trailing zero-streak\\n        total += streak * (streak + 1) // 2\\n        \\n        return total\\n\"",
  "262_14631217_mysql": "\"SELECT \\n    request_at AS Day,\\n    ROUND(\\n        SUM(CASE WHEN status IN ('cancelled_by_driver', 'cancelled_by_client') THEN 1 ELSE 0 END) \\n        / COUNT(*), \\n        2\\n    ) AS `Cancellation Rate`\\nFROM Trips t\\nJOIN Users c ON t.client_id = c.users_id AND c.banned = 'No'\\nJOIN Users d ON t.driver_id = d.users_id AND d.banned = 'No'\\nWHERE request_at BETWEEN '2013-10-01' AND '2013-10-03'\\nGROUP BY request_at;\\n\"",
  "903_14631217_python": "\"# Assume rand7() is already defined and returns a random integer from 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        while True:\\n            row = rand7()\\n            col = rand7()\\n            idx = (row - 1) * 7 + col  # maps to range 1 to 49\\n            if idx <= 40:\\n                return (idx - 1) % 10 + 1\\n\"",
  "3524_14631217_python-updated-time": "1747494529440",
  "2673_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maximizeWin(self, prizePositions, k):\\n        n = len(prizePositions)\\n        left_max = [0] * (n + 1)\\n        res = 0\\n\\n        j = 0\\n        for i in range(n):\\n            while prizePositions[i] - prizePositions[j] > k:\\n                j += 1\\n            win = i - j + 1\\n            left_max[i + 1] = max(left_max[i], win)\\n\\n        j = n - 1\\n        for i in reversed(range(n)):\\n            while j >= 0 and prizePositions[j] - prizePositions[i] > k:\\n                j -= 1\\n            win = j - i + 1\\n            res = max(res, win + left_max[i])\\n\\n        return res\\n\"",
  "3786_14631217_python": "\"class Solution(object):\\n    def longestPalindromicSubsequence(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Precompute minimal cost to pair s[i] and s[j]\\n        cost_pair = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                diff = abs(ord(s[i]) - ord(s[j]))\\n                cost_pair[i][j] = min(diff, 26 - diff)\\n\\n        # dp[i][j][c] = max length of palindromic subsequence in s[i..j] with <= c operations\\n        # Initialize 3D DP array\\n        dp = [[[0] * (k+1) for _ in range(n)] for __ in range(n)]\\n\\n        # Base case: single characters\\n        for i in range(n):\\n            for c in range(k+1):\\n                dp[i][i][c] = 1\\n\\n        # Fill DP for substrings of increasing length\\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                j = i + length - 1\\n                for c in range(k+1):\\n                    # Option 1: skip s[i]\\n                    dp[i][j][c] = dp[i+1][j][c]\\n                    # Option 2: skip s[j]\\n                    if dp[i][j-1][c] > dp[i][j][c]:\\n                        dp[i][j][c] = dp[i][j-1][c]\\n                    # Option 3: pair s[i] and s[j]\\n                    cost = cost_pair[i][j]\\n                    if c >= cost:\\n                        val = 2 + (dp[i+1][j-1][c-cost] if i+1 <= j-1 else 0)\\n                        if val > dp[i][j][c]:\\n                            dp[i][j][c] = val\\n        return dp[0][n-1][k]\"",
  "2161_14631217_python": "\"import heapq\\n\\nclass StockPrice(object):\\n\\n    def __init__(self):\\n        self.timestamp_to_price = {}\\n        self.max_heap = []\\n        self.min_heap = []\\n        self.latest_timestamp = 0\\n\\n    def update(self, timestamp, price):\\n        self.timestamp_to_price[timestamp] = price\\n        self.latest_timestamp = max(self.latest_timestamp, timestamp)\\n        # Push new entries to both heaps\\n        heapq.heappush(self.max_heap, (-price, timestamp))\\n        heapq.heappush(self.min_heap, (price, timestamp))\\n\\n    def current(self):\\n        return self.timestamp_to_price[self.latest_timestamp]\\n\\n    def maximum(self):\\n        while True:\\n            price, timestamp = self.max_heap[0]\\n            if self.timestamp_to_price[timestamp] == -price:\\n                return -price\\n            heapq.heappop(self.max_heap)\\n\\n    def minimum(self):\\n        while True:\\n            price, timestamp = self.min_heap[0]\\n            if self.timestamp_to_price[timestamp] == price:\\n                return price\\n            heapq.heappop(self.min_heap)\\n\"",
  "2566_14631217_python": "\"class Solution:\\n    def unequalTriplets(self, nums):\\n        n = len(nums)\\n        from collections import Counter\\n        cnt = Counter(nums)\\n        \\n        # We'll count triples by fixing the middle element j\\n        # For each j, count number of i<j with nums[i]!=nums[j],\\n        # and number of k>j with nums[k]!=nums[j] and nums[k]!=nums[i].\\n        # A simpler formula: total pairs of distinct on left * total distinct on right,\\n        # minus pairs where left value == right value.\\n        \\n        # But an even simpler O(n + U^2) is:\\n        # Let pref and suff be frequency maps for left/right of j.\\n        pref = Counter()\\n        suff = cnt.copy()\\n        \\n        ans = 0\\n        # iterate j from 0 to n-1\\n        for j in range(n):\\n            x = nums[j]\\n            # remove current from right\\n            suff[x] -= 1\\n            if suff[x] == 0:\\n                del suff[x]\\n            \\n            # count of left positions is j, right is n-j-1\\n            # total ways to pick i in left ≠ x: j - pref[x]\\n            left_total = j - pref.get(x, 0)\\n            # total ways to pick k in right ≠ x: (n-j-1) - suff.get(x,0)\\n            right_total = (n - j - 1) - suff.get(x, 0)\\n            \\n            # but among those left i and right k, we must also ensure nums[i] != nums[k].\\n            # The total pairs left_total*right_total counts pairs where nums[i] == nums[k] too.\\n            # For each value v ≠ x, the bad pairs = pref[v] * suff[v].\\n            bad = 0\\n            for v in pref:\\n                if v == x:\\n                    continue\\n                bad += pref[v] * suff.get(v, 0)\\n            \\n            ans += left_total * right_total - bad\\n            \\n            # add current to left\\n            pref[x] += 1\\n        \\n        return ans\\n\"",
  "295_14631217_python-updated-time": "1745255155252",
  "692_14631217_python": "\"import heapq\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        count = Counter(words)\\n        heap = []\\n        for word, freq in count.items():\\n            heapq.heappush(heap, (-freq, word))\\n        \\n        res = []\\n        for _ in range(k):\\n            res.append(heapq.heappop(heap)[1])\\n        return res\\n\"",
  "620_14631217_mysql": "\"SELECT *\\nFROM Cinema\\nWHERE id % 2 = 1\\n  AND description != 'boring'\\nORDER BY rating DESC;\\n\"",
  "189_14631217_python-updated-time": "1745092713534",
  "1286_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums, k):\\n        n = len(nums)\\n        dp = nums[:]\\n        q = deque()\\n        q.append(0)\\n        max_sum = nums[0]\\n        \\n        for i in range(1, n):\\n            # Remove indices out of window\\n            if q and q[0] < i - k:\\n                q.popleft()\\n\\n            dp[i] = max(dp[q[0]] + nums[i], nums[i])\\n            max_sum = max(max_sum, dp[i])\\n\\n            # Maintain deque in decreasing dp order\\n            while q and dp[i] >= dp[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n\\n        return max_sum\\n\"",
  "44_14631217_python": "\"class Solution(object):\\n    def isMatch(self, s, p):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n\\n        for j in range(1, n + 1):\\n            if p[j - 1] == '*':\\n                dp[0][j] = dp[0][j - 1]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j - 1] == '*':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n\\n        return dp[m][n]\\n\"",
  "2494_14631217_python-updated-time": "1746966521850",
  "1561_14631217_python": "\"class Solution(object):\\n    def arrangeWords(self, text):\\n        words = text.split(\\\" \\\")\\n        # normalize to lowercase for sorting\\n        lower_words = [w.lower() for w in words]\\n        # stable sort by length\\n        sorted_words = sorted(lower_words, key=len)\\n        # capitalize first word, others remain lowercase\\n        sorted_words[0] = sorted_words[0].capitalize()\\n        return \\\" \\\".join(sorted_words)\\n\"",
  "1502_14631217_python-updated-time": "1746346399329",
  "728_14631217_python": "\"class Solution(object):\\n    def selfDividingNumbers(self, left, right):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def is_self_dividing(n):\\n            original = n\\n            while n > 0:\\n                d = n % 10\\n                if d == 0 or original % d != 0:\\n                    return False\\n                n //= 10\\n            return True\\n        \\n        res = []\\n        for num in range(left, right + 1):\\n            if is_self_dividing(num):\\n                res.append(num)\\n        return res\\n\"",
  "3411_14631217_python-updated-time": "1747481583125",
  "3112_14631217_python-updated-time": "1747227986562",
  "948_14631217_python": "\"class Solution:\\n    def sortArray(self, nums):\\n        # In-place heapsort: O(n log n) time, O(1) extra space\\n        n = len(nums)\\n\\n        def sift_down(start, end):\\n            root = start\\n            while True:\\n                child = 2 * root + 1  # left child\\n                if child >= end:\\n                    break\\n                # pick the larger of the two children\\n                if child + 1 < end and nums[child + 1] > nums[child]:\\n                    child += 1\\n                # if root is smaller than the larger child, swap\\n                if nums[root] < nums[child]:\\n                    nums[root], nums[child] = nums[child], nums[root]\\n                    root = child\\n                else:\\n                    break\\n\\n        # build max-heap\\n        for start in range(n // 2 - 1, -1, -1):\\n            sift_down(start, n)\\n\\n        # extract elements from heap one by one\\n        for end in range(n - 1, 0, -1):\\n            # move current max to the end\\n            nums[0], nums[end] = nums[end], nums[0]\\n            # restore heap property on the reduced heap\\n            sift_down(0, end)\\n\\n        return nums\\n\"",
  "1766_14631217_python-updated-time": "1746446047706",
  "895_14631217_python": "\"class Solution(object):\\n    def shortestPathAllKeys(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        all_keys = 0\\n        sx = sy = 0\\n        for i in range(m):\\n            for j in range(n):\\n                c = grid[i][j]\\n                if c == '@':\\n                    sx, sy = i, j\\n                elif 'a' <= c <= 'f':\\n                    all_keys |= 1 << (ord(c) - ord('a'))\\n        from collections import deque\\n        q = deque([(sx, sy, 0, 0)])\\n        visited = [[[False] * (1<<6) for _ in range(n)] for _ in range(m)]\\n        visited[sx][sy][0] = True\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        while q:\\n            x, y, mask, steps = q.popleft()\\n            if mask == all_keys:\\n                return steps\\n            for dx, dy in dirs:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    c = grid[nx][ny]\\n                    if c == '#':\\n                        continue\\n                    new_mask = mask\\n                    if 'a' <= c <= 'f':\\n                        new_mask |= 1 << (ord(c) - ord('a'))\\n                    if 'A' <= c <= 'F':\\n                        if not mask & (1 << (ord(c) - ord('A'))):\\n                            continue\\n                    if not visited[nx][ny][new_mask]:\\n                        visited[nx][ny][new_mask] = True\\n                        q.append((nx, ny, new_mask, steps + 1))\\n        return -1\\n\"",
  "1706_14631217_python-updated-time": "1746438546279",
  "476_14631217_python-updated-time": "1745360105038",
  "2877_14631217_python": "\"class Solution(object):\\n    def minimumString(self, a, b, c):\\n        from itertools import permutations\\n\\n        def merge(x, y):\\n            if y in x:\\n                return x\\n            max_overlap = 0\\n            for i in range(1, min(len(x), len(y)) + 1):\\n                if x[-i:] == y[:i]:\\n                    max_overlap = i\\n            return x + y[max_overlap:]\\n\\n        res = None\\n        for p in permutations([a, b, c]):\\n            merged = merge(merge(p[0], p[1]), p[2])\\n            if res is None or len(merged) < len(res) or (len(merged) == len(res) and merged < res):\\n                res = merged\\n        return res\\n\"",
  "594_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def findLHS(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        freq = Counter(nums)\\n        ans = 0\\n        for x in freq:\\n            if x + 1 in freq:\\n                ans = max(ans, freq[x] + freq[x + 1])\\n        return ans\\n\"",
  "924_14631217_python-updated-time": "1746001988787",
  "1092_14631217_python-updated-time": "1746041933802",
  "3519_14631217_python-updated-time": "1747494367170",
  "596_14631217_mysql-updated-time": "1745448469425",
  "2645_14631217_python": "\"class Solution(object):\\n    def passThePillow(self, n, time):\\n        cycle = 2 * (n - 1)\\n        t = time % cycle\\n        if t < n:\\n            return 1 + t\\n        else:\\n            return 2 * n - 1 - t\\n\"",
  "2057_14631217_mysql": "\"SELECT 'Low Salary' AS category, \\n       COUNT(*) AS accounts_count\\nFROM Accounts\\nWHERE income < 20000\\n\\nUNION ALL\\n\\nSELECT 'Average Salary', \\n       COUNT(*)\\nFROM Accounts\\nWHERE income BETWEEN 20000 AND 50000\\n\\nUNION ALL\\n\\nSELECT 'High Salary', \\n       COUNT(*)\\nFROM Accounts\\nWHERE income > 50000;\\n\"",
  "2499_14631217_python": "\"class Solution:\\n    def minimumMoney(self, transactions):\\n        loss_sum = 0\\n        loss_max_cashback = 0\\n        profit_max_cost = 0\\n        \\n        for cost, cash in transactions:\\n            if cash >= cost:\\n                # “Profit” or neutral transaction\\n                profit_max_cost = max(profit_max_cost, cost)\\n            else:\\n                # Loss-making transaction\\n                loss_sum += (cost - cash)\\n                loss_max_cashback = max(loss_max_cashback, cash)\\n        \\n        # Worst case for a profit transaction i scheduled after all losses:\\n        #    requires M ≥ loss_sum + cost_i, so loss_sum + profit_max_cost\\n        # Worst case for a loss transaction j scheduled last among losses:\\n        #    requires M ≥ (loss_sum - (cost_j-cash_j)) + cost_j\\n        #             = loss_sum + cash_j, so loss_sum + loss_max_cashback\\n        return loss_sum + max(profit_max_cost, loss_max_cashback)\\n\"",
  "1169_14631217_python": "\"class Solution(object):\\n    def largestValsFromLabels(self, values, labels, numWanted, useLimit):\\n        \\\"\\\"\\\"\\n        :type values: List[int]\\n        :type labels: List[int]\\n        :type numWanted: int\\n        :type useLimit: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        items = sorted(zip(values, labels), reverse=True)\\n        label_count = {}\\n        total = 0\\n        count = 0\\n\\n        for value, label in items:\\n            if count == numWanted:\\n                break\\n            if label_count.get(label, 0) < useLimit:\\n                total += value\\n                label_count[label] = label_count.get(label, 0) + 1\\n                count += 1\\n\\n        return total\\n\"",
  "1734_14631217_mysql": "\"SELECT\\n  u.name,\\n  SUM(t.amount) AS balance\\nFROM Users AS u\\nJOIN Transactions AS t\\n  ON u.account = t.account\\nGROUP BY\\n  u.account,\\n  u.name\\nHAVING\\n  SUM(t.amount) > 10000;\\n\"",
  "1361_14631217_python": "\"class Solution:\\n    def tilingRectangle(self, n, m):\\n        if n > m:\\n            n, m = m, n\\n        self.res = n * m\\n\\n        def dfs(grid, count):\\n            if count >= self.res:\\n                return\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] == 0:\\n                        x, y = i, j\\n                        break\\n                else:\\n                    continue\\n                break\\n            else:\\n                self.res = min(self.res, count)\\n                return\\n\\n            max_len = min(n - x, m - y)\\n            for size in range(max_len, 0, -1):\\n                if all(grid[x + dx][y + dy] == 0 for dx in range(size) for dy in range(size)):\\n                    for dx in range(size):\\n                        for dy in range(size):\\n                            grid[x + dx][y + dy] = 1\\n                    dfs(grid, count + 1)\\n                    for dx in range(size):\\n                        for dy in range(size):\\n                            grid[x + dx][y + dy] = 0\\n\\n        dfs([[0] * m for _ in range(n)], 0)\\n        return self.res\\n\"",
  "2311_14631217_python-updated-time": "1746810505552",
  "1723_14631217_python": "\"class Solution:\\n    def maximumRequests(self, n, requests):\\n        m = len(requests)\\n        # Precompute all subset masks\\n        masks = list(range(1 << m))\\n        # Sort subsets by size (number of requests chosen) descending\\n        masks.sort(key=lambda mask: bin(mask).count('1'), reverse=True)\\n\\n        for mask in masks:\\n            k = bin(mask).count('1')\\n            # If even the largest remaining subset can't beat 0, we can stop early\\n            if k == 0:\\n                break\\n\\n            # Track net transfer balance for each building\\n            bal = [0] * n\\n            for i in range(m):\\n                if (mask >> i) & 1:\\n                    frm, to = requests[i]\\n                    bal[frm] -= 1\\n                    bal[to]  += 1\\n\\n            # If all balances zero, this subset is valid\\n            if all(x == 0 for x in bal):\\n                return k\\n\\n        return 0\\n\"",
  "3797_14631217_python": "\"class Spreadsheet(object):\\n    def __init__(self, rows):\\n        \\\"\\\"\\\"\\n        :type rows: int\\n        \\\"\\\"\\\"\\n        # We don't actually need to track rows beyond validation,\\n        # since constraints guarantee valid references.\\n        # Store only explicitly set cells in a dict.\\n        self.cells = {}\\n\\n    def setCell(self, cell, value):\\n        \\\"\\\"\\\"\\n        :type cell: str\\n        :type value: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        # Store the integer value for this cell reference.\\n        # Cell is like \\\"A1\\\", \\\"Z1000\\\"\\n        self.cells[cell] = value\\n\\n    def resetCell(self, cell):\\n        \\\"\\\"\\\"\\n        :type cell: str\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        # Reset to 0 by removing from dict if present.\\n        if cell in self.cells:\\n            del self.cells[cell]\\n\\n    def getValue(self, formula):\\n        \\\"\\\"\\\"\\n        :type formula: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # formula is always \\\"=X+Y\\\"\\n        expr = formula[1:]         # remove leading '='\\n        left, right = expr.split('+')\\n        \\n        def val(token):\\n            # If token starts with a letter, it's a cell reference\\n            if token[0].isalpha():\\n                return self.cells.get(token, 0)\\n            else:\\n                # Otherwise it's a non-negative integer\\n                return int(token)\\n        \\n        return val(left) + val(right)\\n\"",
  "686_14631217_python-updated-time": "1745785183899",
  "1332_14631217_python-updated-time": "1746127781652",
  "2345_14631217_python-updated-time": "1746811179947",
  "66_14631217_python-updated-time": "1745014855024",
  "2712_14631217_python": "\"class Solution(object):\\n    def maxNumOfMarkedIndices(self, nums):\\n        nums.sort()\\n        n = len(nums)\\n        i = 0\\n        j = n // 2\\n        count = 0\\n\\n        while i < n // 2 and j < n:\\n            if 2 * nums[i] <= nums[j]:\\n                count += 2\\n                i += 1\\n            j += 1\\n\\n        return count\\n\"",
  "1148_14631217_python": "\"class Solution(object):\\n    def addNegabinary(self, arr1, arr2):\\n        \\\"\\\"\\\"\\n        :type arr1: List[int]\\n        :type arr2: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        i, j = len(arr1) - 1, len(arr2) - 1\\n        res = []\\n        carry = 0\\n\\n        while i >= 0 or j >= 0 or carry != 0:\\n            a = arr1[i] if i >= 0 else 0\\n            b = arr2[j] if j >= 0 else 0\\n            total = a + b + carry\\n            res.append(total & 1)  # total % 2\\n            # Update carry based on base -2\\n            carry = -(total >> 1)\\n            i -= 1\\n            j -= 1\\n\\n        # Remove leading zeros\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n\\n        return res[::-1]\\n\"",
  "1574_14631217_python-updated-time": "1746348171517",
  "1403_14631217_python-updated-time": "1746260124183",
  "479_14631217_python-updated-time": "1745441360376",
  "2881_14631217_python-updated-time": "1747222585654",
  "3415_14631217_python-updated-time": "1747480683157",
  "3563_14631217_python": "\"class Solution(object):\\n    def maxScore(self, grid):\\n        rows = len(grid)\\n        # Precompute for each row the set of values in that row\\n        row_vals = [set(r) for r in grid]\\n        # List of distinct values across the grid\\n        distinct = sorted({v for row in grid for v in row})\\n        \\n        # DP[mask] = max score using values processed so far,\\n        # assigning to rows indicated by bits in mask\\n        # mask bit i = 1 means row i has been assigned a value\\n        N = 1 << rows\\n        DP = [-10**18] * N\\n        DP[0] = 0\\n        \\n        for v in distinct:\\n            DP2 = DP[:]  # copy previous\\n            # Try assigning this value v to any one unassigned row\\n            for mask in range(N):\\n                cur = DP[mask]\\n                if cur < 0:\\n                    continue\\n                # rows not yet assigned\\n                avail = (~mask) & (N - 1)\\n                # iterate through set bits\\n                while avail:\\n                    i = (avail & -avail).bit_length() - 1\\n                    if v in row_vals[i]:\\n                        nm = mask | (1 << i)\\n                        DP2[nm] = max(DP2[nm], cur + v)\\n                    avail &= avail - 1\\n            DP = DP2\\n        \\n        # The answer is the maximum over all masks\\n        return max(DP)\\n\"",
  "919_14631217_python": "\"class Solution(object):\\n    def projectionArea(self, grid):\\n        n = len(grid)\\n        xy = sum(1 for i in range(n) for j in range(n) if grid[i][j] > 0)\\n        yz = sum(max(row) for row in grid)\\n        zx = sum(max(col) for col in zip(*grid))\\n        return xy + yz + zx\\n\"",
  "2263_14631217_python-updated-time": "1746802257880",
  "921_14631217_python": "\"class Solution(object):\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        result = []\\n        steps = 1\\n        x, y = rStart, cStart\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N\\n        dir_idx = 0\\n\\n        while len(result) < rows * cols:\\n            for _ in range(2):\\n                dx, dy = dirs[dir_idx]\\n                for _ in range(steps):\\n                    if 0 <= x < rows and 0 <= y < cols:\\n                        result.append([x, y])\\n                    x += dx\\n                    y += dy\\n                dir_idx = (dir_idx + 1) % 4\\n            steps += 1\\n\\n        return result\\n\"",
  "1725_14631217_python-updated-time": "1746444493873",
  "2213_14631217_python-updated-time": "1746729650495",
  "3207_14631217_python-updated-time": "1747311701230",
  "2028_14631217_python-updated-time": "1746627672820",
  "3361_14631217_python": "\"class Solution(object):\\n    def findLatestTime(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # convert to list for mutability\\n        t = list(s)\\n        \\n        # Hour tens (t[0])\\n        if t[0] == '?':\\n            # If hour ones is '?' or <= '1', we can pick '1'; else must pick '0'\\n            if t[1] == '?' or t[1] <= '1':\\n                t[0] = '1'\\n            else:\\n                t[0] = '0'\\n        \\n        # Hour ones (t[1])\\n        if t[1] == '?':\\n            # If tens is '0', ones can be '9'; if tens is '1', ones max is '1'\\n            if t[0] == '0':\\n                t[1] = '9'\\n            else:  # t[0] == '1'\\n                t[1] = '1'\\n        \\n        # Minute tens (t[3])\\n        if t[3] == '?':\\n            t[3] = '5'\\n        \\n        # Minute ones (t[4])\\n        if t[4] == '?':\\n            t[4] = '9'\\n        \\n        return \\\"\\\".join(t)\\n\"",
  "3831_14631217_python": "\"class Solution(object):\\n    def resultArray(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # result[r] = total # of subarrays whose product % k == r\\n        result = [0] * k\\n        \\n        # dp_prev[r] = # of subarrays ending at i−1 with product % k == r\\n        dp_prev = [0] * k\\n        \\n        for a in nums:\\n            a_mod = a % k\\n            \\n            # dp_cur[r] = # of subarrays ending at i with product % k == r\\n            dp_cur = [0] * k\\n            \\n            # 1) the subarray consisting of a single element a\\n            dp_cur[a_mod] += 1\\n            \\n            # 2) extend each previous subarray ending at i−1 by a\\n            for r in range(k):\\n                cnt = dp_prev[r]\\n                if cnt:\\n                    new_r = (r * a_mod) % k\\n                    dp_cur[new_r] += cnt\\n            \\n            # accumulate into the global result\\n            for r in range(k):\\n                result[r] += dp_cur[r]\\n            \\n            # shift dp\\n            dp_prev = dp_cur\\n        \\n        return result\\n\"",
  "1456_14631217_python": "\"class Solution:\\n    def findTheCity(self, n, edges, distanceThreshold):\\n        # Initialize distance matrix\\n        INF = 10**9\\n        dist = [[INF] * n for _ in range(n)]\\n        for i in range(n):\\n            dist[i][i] = 0\\n        for u, v, w in edges:\\n            dist[u][v] = w\\n            dist[v][u] = w\\n        \\n        # Floyd-Warshall to compute all-pairs shortest paths\\n        for k in range(n):\\n            for i in range(n):\\n                # Early skip if no improvement possible\\n                dik = dist[i][k]\\n                if dik == INF:\\n                    continue\\n                row_i = dist[i]\\n                row_k = dist[k]\\n                for j in range(n):\\n                    nd = dik + row_k[j]\\n                    if nd < row_i[j]:\\n                        row_i[j] = nd\\n        \\n        # For each city, count reachable within threshold\\n        best_city = -1\\n        best_count = n + 1\\n        for i in range(n):\\n            count = sum(1 for j in range(n) if i != j and dist[i][j] <= distanceThreshold)\\n            # We want the smallest count, and in tie the largest index\\n            if count < best_count or (count == best_count and i > best_city):\\n                best_count = count\\n                best_city = i\\n        \\n        return best_city\\n\"",
  "3106_14631217_python-updated-time": "1747308486925",
  "449_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if not node:\\n                return []\\n            return [str(node.val)] + preorder(node.left) + preorder(node.right)\\n        \\n        return ','.join(preorder(root))\\n\\n    def deserialize(self, data):\\n        if not data:\\n            return None\\n        \\n        preorder = list(map(int, data.split(',')))\\n        self.i = 0\\n        \\n        def build(lower, upper):\\n            if self.i == len(preorder):\\n                return None\\n            val = preorder[self.i]\\n            if val < lower or val > upper:\\n                return None\\n            self.i += 1\\n            node = TreeNode(val)\\n            node.left = build(lower, val)\\n            node.right = build(val, upper)\\n            return node\\n        \\n        return build(float('-inf'), float('inf'))\\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\"",
  "2714_14631217_python-updated-time": "1747066050799",
  "2026_14631217_python-updated-time": "1746627137870",
  "3637_14631217_python-updated-time": "1747586151791",
  "3496_14631217_python-updated-time": "1747572722346",
  "233_14631217_python": "\"class Solution(object):\\n    def countDigitOne(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = 0\\n        i = 1\\n        while i <= n:\\n            divider = i * 10\\n            res += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\\n            i *= 10\\n        return res\\n\"",
  "1532_14631217_python": "\"class Solution(object):\\n    def reformat(self, s):\\n        letters = [c for c in s if c.isalpha()]\\n        digits = [c for c in s if c.isdigit()]\\n\\n        if abs(len(letters) - len(digits)) > 1:\\n            return \\\"\\\"\\n\\n        res = []\\n        # Decide which type to start with (longer one goes first)\\n        if len(letters) > len(digits):\\n            first, second = letters, digits\\n        else:\\n            first, second = digits, letters\\n\\n        for i in range(len(s)):\\n            if i % 2 == 0:\\n                res.append(first.pop())\\n            else:\\n                res.append(second.pop())\\n\\n        return ''.join(res)\\n\"",
  "2341_14631217_python-updated-time": "1746880201165",
  "1279_14631217_python": "\"class Solution(object):\\n    def numPrimeArrangements(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n\\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n\\n        # Count how many primes <= n\\n        prime_count = sum(is_prime(i) for i in range(1, n + 1))\\n\\n        # Compute factorial with modulo\\n        def factorial(x):\\n            res = 1\\n            for i in range(2, x + 1):\\n                res = (res * i) % MOD\\n            return res\\n\\n        return (factorial(prime_count) * factorial(n - prime_count)) % MOD\\n\"",
  "888_14631217_python-updated-time": "1745953886757",
  "1311_14631217_python-updated-time": "1746626616096",
  "2235_14631217_python-updated-time": "1746801905783",
  "2309_14631217_python-updated-time": "1746810445159",
  "809_14631217_python": "\"class Solution(object):\\n    def preimageSizeFZF(self, k):\\n        def zeta(x):\\n            res = 0\\n            while x:\\n                x //= 5\\n                res += x\\n            return res\\n        \\n        def search(k):\\n            low, high = 0, 5 * (k + 1)\\n            while low < high:\\n                mid = (low + high) // 2\\n                if zeta(mid) < k:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n            return low\\n        \\n        return 5 if zeta(search(k)) == k else 0\\n\"",
  "2665_14631217_python-updated-time": "1747067340790",
  "787_14631217_python-updated-time": "1745877189717",
  "1208_14631217_python": "\"class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \\\"\\\"\\\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        depth = 0\\n        for ch in seq:\\n            if ch == '(':\\n                depth += 1\\n                res.append(depth % 2)\\n            else:\\n                res.append(depth % 2)\\n                depth -= 1\\n        return res\\n\"",
  "980_14631217_python-updated-time": "1746004628945",
  "1507_14631217_python-updated-time": "1746346150305",
  "3143_14631217_python-updated-time": "1747307294099",
  "539_14631217_python": "\"class Solution:\\n    def findMinDifference(self, timePoints):\\n        minutes = []\\n        for time in timePoints:\\n            h, m = map(int, time.split(\\\":\\\"))\\n            minutes.append(h * 60 + m)\\n        \\n        minutes.sort()\\n        min_diff = float('inf')\\n        \\n        for i in range(1, len(minutes)):\\n            min_diff = min(min_diff, minutes[i] - minutes[i - 1])\\n        \\n        # Check difference between last and first across midnight\\n        min_diff = min(min_diff, 1440 - (minutes[-1] - minutes[0]))\\n        \\n        return min_diff\\n\"",
  "1034_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums, k):\\n        def atMostK(k):\\n            count = defaultdict(int)\\n            res = left = 0\\n            for right in range(len(nums)):\\n                if count[nums[right]] == 0:\\n                    k -= 1\\n                count[nums[right]] += 1\\n                while k < 0:\\n                    count[nums[left]] -= 1\\n                    if count[nums[left]] == 0:\\n                        k += 1\\n                    left += 1\\n                res += right - left + 1\\n            return res\\n\\n        return atMostK(k) - atMostK(k - 1)\\n\"",
  "831_14631217_python": "\"class Solution(object):\\n    def largestSumOfAverages(self, nums, k):\\n        n = len(nums)\\n        prefix = [0] * (n+1)\\n        for i in range(n):\\n            prefix[i+1] = prefix[i] + nums[i]\\n        \\n        dp = [0] * (n+1)\\n        for i in range(1, n+1):\\n            dp[i] = prefix[i] * 1.0 / i\\n        \\n        for _ in range(k-1):\\n            for i in range(n, 0, -1):\\n                for j in range(i):\\n                    dp[i] = max(dp[i], dp[j] + (prefix[i] - prefix[j]) * 1.0 / (i-j))\\n        \\n        return dp[n]\\n\"",
  "3556_14631217_python": "\"MOD = 1000000007          # modulus\\n\\nclass Solution(object):\\n    def getFinalState(self, nums, k, multiplier):\\n        if k == 0 or multiplier == 1:\\n            return [x % MOD for x in nums]\\n\\n        import math\\n        n     = len(nums)\\n        log_m = math.log(multiplier)\\n        exp0  = [math.log(x) / log_m for x in nums]   # fractional exponents\\n\\n        # -------- 1. binary-search the smallest integer E with ≥ k terms -----\\n        def count_leq(E):\\n            tot = 0\\n            for e in exp0:\\n                if E + 1e-12 >= e:                    # small guard\\n                    tot += int(E - e) + 1\\n            return tot\\n\\n        lo = int(min(exp0))\\n        hi = lo + k                                   # safe upper bound\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if count_leq(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        E = lo                                        # final threshold\\n\\n        # -------- 2. counts up to E and the \\\"last picked\\\" value --------------\\n        cnt   = [0] * n\\n        total = 0\\n        tails = []                                    # (last_value, index)\\n\\n        for i, e in enumerate(exp0):\\n            if E + 1e-12 >= e:\\n                c = int(E - e) + 1\\n                cnt[i] = c\\n                total += c\\n                tails.append((e + (c - 1), i))        # last exponent\\n\\n        # -------- 3. drop the 'excess' largest tails (value, then index) -----\\n        excess = total - k\\n        if excess:\\n            tails.sort(key=lambda p: (-p[0], -p[1]))  # descending\\n            for _, idx in tails[:excess]:\\n                cnt[idx] -= 1\\n\\n        # -------- 4. rebuild the array under the modulus ---------------------\\n        mm = multiplier % MOD\\n        return [(x % MOD) * pow(mm, c, MOD) % MOD for x, c in zip(nums, cnt)]\\n\"",
  "1129_14631217_python": "\"class Solution:\\n    def longestStrChain(self, words):\\n        words.sort(key=len)\\n        dp = {}\\n        res = 1\\n        for w in words:\\n            best = 1\\n            for i in range(len(w)):\\n                prev = w[:i] + w[i+1:]\\n                if prev in dp:\\n                    best = max(best, dp[prev] + 1)\\n            dp[w] = best\\n            res = max(res, best)\\n        return res\\n\"",
  "3783_14631217_python": "\"class Solution(object):\\n    def permute(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # total odds and evens\\n        odd_total = (n + 1)//2\\n        even_total = n//2\\n\\n        # manual memoization\\n        dp_memo = {}\\n        def dp(o, e, last_parity):\\n            # last_parity: 0=start, 1=odd, 2=even\\n            if o == 0 and e == 0:\\n                return 1\\n            key = (o, e, last_parity)\\n            if key in dp_memo:\\n                return dp_memo[key]\\n            ways = 0\\n            if last_parity != 1 and o > 0:\\n                ways += o * dp(o-1, e, 1)\\n            if last_parity != 2 and e > 0:\\n                ways += e * dp(o, e-1, 2)\\n            dp_memo[key] = ways\\n            return ways\\n\\n        total = dp(odd_total, even_total, 0)\\n        if k > total:\\n            return []\\n\\n        odds = list(range(1, n+1, 2))\\n        evens = list(range(2, n+1, 2))\\n        ans = []\\n        o_rem, e_rem = odd_total, even_total\\n        last = 0\\n\\n        for _ in range(n):\\n            i = j = 0\\n            while i < len(odds) or j < len(evens):\\n                if j == len(evens) or (i < len(odds) and odds[i] < evens[j]):\\n                    x, parity = odds[i], 1\\n                    i += 1\\n                else:\\n                    x, parity = evens[j], 2\\n                    j += 1\\n                if parity == last:\\n                    continue\\n                if parity == 1:\\n                    cnt = dp(o_rem-1, e_rem, 1)\\n                else:\\n                    cnt = dp(o_rem, e_rem-1, 2)\\n                if cnt >= k:\\n                    ans.append(x)\\n                    last = parity\\n                    if parity == 1:\\n                        odds.pop(i-1)\\n                        o_rem -= 1\\n                    else:\\n                        evens.pop(j-1)\\n                        e_rem -= 1\\n                    break\\n                k -= cnt\\n            else:\\n                return []\\n        return ans\\n\"",
  "2193_14631217_python": "\"class Solution:\\n    def countPyramids(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp_down = [[0]*n for _ in range(m)]\\n        dp_up = [[0]*n for _ in range(m)]\\n        \\n        # Downward pyramids\\n        for r in range(m-2, -1, -1):\\n            for c in range(1, n-1):\\n                if grid[r][c] == 1 and grid[r+1][c-1] and grid[r+1][c] and grid[r+1][c+1]:\\n                    dp_down[r][c] = 1 + min(\\n                        dp_down[r+1][c-1],\\n                        dp_down[r+1][c],\\n                        dp_down[r+1][c+1]\\n                    )\\n        \\n        # Upward pyramids\\n        for r in range(1, m):\\n            for c in range(1, n-1):\\n                if grid[r][c] == 1 and grid[r-1][c-1] and grid[r-1][c] and grid[r-1][c+1]:\\n                    dp_up[r][c] = 1 + min(\\n                        dp_up[r-1][c-1],\\n                        dp_up[r-1][c],\\n                        dp_up[r-1][c+1]\\n                    )\\n        \\n        total = 0\\n        for r in range(m):\\n            for c in range(n):\\n                total += dp_down[r][c] + dp_up[r][c]\\n        return total\\n\"",
  "542_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def updateMatrix(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        queue = deque()\\n\\n        # Initialize queue with all 0s and set 1s to -1 as unvisited\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] == 0:\\n                    queue.append((i, j))\\n                else:\\n                    mat[i][j] = -1\\n\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n\\n        while queue:\\n            i, j = queue.popleft()\\n            for di, dj in directions:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and mat[ni][nj] == -1:\\n                    mat[ni][nj] = mat[i][j] + 1\\n                    queue.append((ni, nj))\\n\\n        return mat\\n\"",
  "1295_14631217_python": "\"class Solution(object):\\n    def minimumPerimeter(self, neededApples):\\n        # Number of apples in a square of \\\"radius\\\" k is:\\n        #   A(k) = 2 * k * (k + 1) * (2*k + 1)\\n        def apples(k):\\n            return 2 * k * (k + 1) * (2 * k + 1)\\n        \\n        k = 0\\n        # increase k until we have enough apples\\n        while apples(k) < neededApples:\\n            k += 1\\n        # perimeter = 8 * k\\n        return 8 * k\\n\"",
  "155_14631217_python": "\"class MinStack(object):\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.min_stack = []\\n\\n    def push(self, val):\\n        self.stack.append(val)\\n        if not self.min_stack or val <= self.min_stack[-1]:\\n            self.min_stack.append(val)\\n\\n    def pop(self):\\n        if self.stack.pop() == self.min_stack[-1]:\\n            self.min_stack.pop()\\n\\n    def top(self):\\n        return self.stack[-1]\\n\\n    def getMin(self):\\n        return self.min_stack[-1]\\n\"",
  "2228_14631217_python": "\"class Solution:\\n    def minimumRefill(self, plants, capacityA, capacityB):\\n        i, j = 0, len(plants) - 1\\n        a, b = capacityA, capacityB\\n        refills = 0\\n\\n        while i < j:\\n            if a < plants[i]:\\n                refills += 1\\n                a = capacityA\\n            a -= plants[i]\\n            i += 1\\n\\n            if b < plants[j]:\\n                refills += 1\\n                b = capacityB\\n            b -= plants[j]\\n            j -= 1\\n\\n        # If they meet in the middle\\n        if i == j:\\n            # Alice waters if her water >= Bob's water\\n            if a >= b:\\n                if a < plants[i]:\\n                    refills += 1\\n            else:\\n                if b < plants[j]:\\n                    refills += 1\\n\\n        return refills\\n\"",
  "182_14631217_mysql-updated-time": "1745092524616",
  "2626_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def countGood(self, nums, k):\\n        n = len(nums)\\n        count = defaultdict(int)\\n        left = 0\\n        pairs = 0\\n        res = 0\\n\\n        for right in range(n):\\n            # When adding nums[right], we add count[nums[right]] pairs\\n            pairs += count[nums[right]]\\n            count[nums[right]] += 1\\n\\n            # Shrink left pointer while pair count >= k\\n            while pairs >= k:\\n                res += n - right  # all subarrays starting from `left` to `right` are good\\n                count[nums[left]] -= 1\\n                pairs -= count[nums[left]]\\n                left += 1\\n\\n        return res\\n\"",
  "1048_14631217_python-updated-time": "1746041205148",
  "1586_14631217_python-updated-time": "1746432981789",
  "3790_14631217_python": "\"class Solution(object):\\n    def numOfUnplacedFruits(self, fruits, baskets):\\n        \\\"\\\"\\\"\\n        :type fruits: List[int]\\n        :type baskets: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(fruits)\\n        used = [False] * n  # Track if a basket has been used\\n        unplaced = 0\\n\\n        for fruit in fruits:\\n            placed = False\\n            for i in range(n):\\n                if not used[i] and baskets[i] >= fruit:\\n                    used[i] = True\\n                    placed = True\\n                    break\\n            if not placed:\\n                unplaced += 1\\n\\n        return unplaced\\n\"",
  "EDITOR_SETTING": "{\"state\":{\"shortcuts\":{\"enableQuickRunCode\":true,\"enableQuickSubmit\":true},\"config\":{\"fontSize\":13,\"theme\":\"\",\"keyBinding\":\"standard\",\"tabSize\":4,\"enableWordWrap\":true,\"enableRelativeLineNumber\":false}},\"version\":0}",
  "3447_14631217_python": "\"class Solution(object):\\n    def clearDigits(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        stack = []\\n        for ch in s:\\n            if ch.isdigit():\\n                # remove the closest non-digit to the left\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return \\\"\\\".join(stack)\\n\"",
  "2134_14631217_python": "\"class Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        \\\"\\\"\\\"\\n        :type answerKey: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def max_length(ch):\\n            left = 0\\n            count = 0\\n            max_len = 0\\n            for right in range(len(answerKey)):\\n                if answerKey[right] != ch:\\n                    count += 1\\n                while count > k:\\n                    if answerKey[left] != ch:\\n                        count -= 1\\n                    left += 1\\n                max_len = max(max_len, right - left + 1)\\n            return max_len\\n\\n        return max(max_length('T'), max_length('F'))\\n\"",
  "2274_14631217_python": "\"class Solution:\\n    def findFinalValue(self, nums, original):\\n        num_set = set(nums)\\n        while original in num_set:\\n            original *= 2\\n        return original\\n\"",
  "2979_14631217_python": "\"class Solution(object):\\n    def maximizeTheProfit(self, n, offers):\\n        from collections import defaultdict\\n        offers_by_end = defaultdict(list)\\n        \\n        for start, end, gold in offers:\\n            offers_by_end[end].append((start, gold))\\n        \\n        dp = [0] * (n + 1)  # dp[i]: max gold using houses [0..i-1]\\n        \\n        for i in range(1, n + 1):\\n            # Option 1: don't take any offer ending at i-1\\n            dp[i] = dp[i - 1]\\n            # Option 2: take one of the offers ending at i-1\\n            for start, gold in offers_by_end[i - 1]:\\n                dp[i] = max(dp[i], dp[start] + gold)\\n        \\n        return dp[n]\\n\"",
  "1234_14631217_python": "\"class Solution:\\n    def pathsWithMaxScore(self, board):\\n        MOD = 10**9 + 7\\n        n = len(board)\\n        dp = [[(-1, 0) for _ in range(n)] for _ in range(n)]  # (max_score, path_count)\\n        dp[n - 1][n - 1] = (0, 1)  # Start at 'S'\\n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if board[i][j] == 'X' or dp[i][j][1] == 0:\\n                    continue\\n\\n                for dx, dy in [(-1, 0), (0, -1), (-1, -1)]:\\n                    ni, nj = i + dx, j + dy\\n                    if 0 <= ni < n and 0 <= nj < n and board[ni][nj] != 'X':\\n                        val = 0 if board[ni][nj] in 'SE' else int(board[ni][nj])\\n                        current_score = dp[i][j][0] + val\\n                        if current_score > dp[ni][nj][0]:\\n                            dp[ni][nj] = (current_score, dp[i][j][1])\\n                        elif current_score == dp[ni][nj][0]:\\n                            dp[ni][nj] = (\\n                                dp[ni][nj][0],\\n                                (dp[ni][nj][1] + dp[i][j][1]) % MOD\\n                            )\\n\\n        max_score, path_count = dp[0][0]\\n        return [0, 0] if path_count == 0 else [max_score, path_count]\\n\"",
  "560_14631217_python-updated-time": "1745447624452",
  "2475_14631217_python": "\"class Solution(object):\\n    def largestPalindromic(self, num):\\n        from collections import Counter\\n\\n        count = Counter(num)\\n        half = []\\n        mid = ''\\n\\n        for d in reversed('0123456789'):\\n            pairs = count[d] // 2\\n            if pairs > 0:\\n                half.extend([d] * pairs)\\n                count[d] -= 2 * pairs\\n\\n        for d in reversed('0123456789'):\\n            if count[d] > 0:\\n                mid = d\\n                break\\n\\n        while half and half[0] == '0':\\n            half.pop(0)\\n\\n        if not half and not mid:\\n            return '0'\\n\\n        return ''.join(half) + mid + ''.join(reversed(half))\\n\"",
  "1531_14631217_python": "\"class Solution:\\n    def numberWays(self, hats):\\n        from collections import defaultdict\\n        MOD = 10**9 + 7\\n        n = len(hats)\\n\\n        # Build mapping from hat to list of people who like it\\n        hat_to_people = defaultdict(list)\\n        for person, hat_list in enumerate(hats):\\n            for hat in hat_list:\\n                hat_to_people[hat].append(person)\\n\\n        # dp[mask] = number of ways to assign hats with current mask of assigned people\\n        dp = [0] * (1 << n)\\n        dp[0] = 1\\n\\n        for hat in range(1, 41):\\n            if hat not in hat_to_people:\\n                continue\\n\\n            ndp = dp[:]\\n            for mask in range(1 << n):\\n                if dp[mask] == 0:\\n                    continue\\n                for person in hat_to_people[hat]:\\n                    if not (mask & (1 << person)):\\n                        ndp[mask | (1 << person)] = (ndp[mask | (1 << person)] + dp[mask]) % MOD\\n            dp = ndp\\n\\n        return dp[(1 << n) - 1]\\n\"",
  "2871_14631217_python": "\"class Solution(object):\\n    def doubleIt(self, head):\\n        def reverse(node):\\n            prev = None\\n            while node:\\n                nxt = node.next\\n                node.next = prev\\n                prev = node\\n                node = nxt\\n            return prev\\n\\n        head = reverse(head)\\n        curr = head\\n        carry = 0\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        while curr:\\n            total = curr.val * 2 + carry\\n            curr.val = total % 10\\n            carry = total // 10\\n            prev = curr\\n            curr = curr.next\\n\\n        if carry:\\n            prev.next = ListNode(carry)\\n\\n        return reverse(head)\\n\"",
  "2670_14631217_python": "\"class Solution:\\n    def makeSubKSumEqual(self, arr, k):\\n        n = len(arr)\\n        visited = [False] * n\\n        total_ops = 0\\n\\n        for start in range(n):\\n            if visited[start]:\\n                continue\\n            # Traverse the cycle starting from this index\\n            cycle = []\\n            i = start\\n            while not visited[i]:\\n                visited[i] = True\\n                cycle.append(arr[i])\\n                i = (i + k) % n\\n\\n            cycle.sort()\\n            median = cycle[len(cycle) // 2]\\n            total_ops += sum(abs(x - median) for x in cycle)\\n\\n        return total_ops\\n\"",
  "1631_14631217_python-updated-time": "1746433799624",
  "2272_14631217_python": "\"class Solution:\\n    def maximumGood(self, statements):\\n        n = len(statements)\\n        ans = 0\\n\\n        for mask in range(1 << n):  # Try all combinations of people being good/bad\\n            valid = True\\n            for i in range(n):\\n                if not (mask >> i) & 1:\\n                    continue  # i is not assumed to be good, skip\\n\\n                for j in range(n):\\n                    if statements[i][j] == 2:\\n                        continue\\n                    if statements[i][j] == 1 and not ((mask >> j) & 1):\\n                        valid = False  # Good person i says j is good but j is not in the mask\\n                    if statements[i][j] == 0 and ((mask >> j) & 1):\\n                        valid = False  # Good person i says j is bad but j is in the mask\\n            if valid:\\n                ans = max(ans, bin(mask).count('1'))\\n\\n        return ans\\n\"",
  "674_14631217_python": "\"class Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        max_len = 1\\n        curr_len = 1\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                curr_len += 1\\n                max_len = max(max_len, curr_len)\\n            else:\\n                curr_len = 1\\n        \\n        return max_len\\n\"",
  "2657_14631217_python": "\"class Fenwick:\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0] * (n+1)\\n    def update(self, i, v):\\n        # add v at index i (1-based)\\n        while i <= self.n:\\n            self.fw[i] += v\\n            i += i & -i\\n    def query(self, i):\\n        # sum from 1..i\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n    def range_query(self, l, r):\\n        return self.query(r) - self.query(l-1)\\n\\nclass Solution(object):\\n    def findMinimumTime(self, tasks):\\n        # tasks: List of [start, end, duration]\\n        # times go 1..2000\\n        # 1) sort by end-time\\n        tasks.sort(key=lambda x: x[1])\\n        maxT = max(end for _, end, _ in tasks)\\n        bit = Fenwick(maxT)\\n        selected = [0] * (maxT + 1)  # 1-based times\\n\\n        for start, end, dur in tasks:\\n            # how many already selected in [start..end]\\n            have = bit.range_query(start, end)\\n            need = dur - have\\n            t = end\\n            # pick 'need' new points from the right end backwards\\n            while need > 0:\\n                if selected[t] == 0:\\n                    selected[t] = 1\\n                    bit.update(t, 1)\\n                    need -= 1\\n                t -= 1\\n\\n        # total seconds on = total selected points\\n        return sum(selected)\\n\"",
  "2731_14631217_javascript-updated-time": "1747135245450",
  "1954_14631217_python": "\"class Solution(object):\\n    def replaceDigits(self, s):\\n        res = list(s)\\n        for i in range(1, len(s), 2):\\n            res[i] = chr(ord(res[i-1]) + int(s[i]))\\n        return \\\"\\\".join(res)\\n\"",
  "1236_14631217_python": "\"class Solution(object):\\n    def tribonacci(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n\\n        a, b, c = 0, 1, 1\\n        for _ in range(3, n + 1):\\n            a, b, c = b, c, a + b + c\\n        return c\\n\"",
  "2148_14631217_python": "\"class Solution(object):\\n    def minMovesToSeat(self, seats, students):\\n        \\\"\\\"\\\"\\n        :type seats: List[int]\\n        :type students: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seats.sort()\\n        students.sort()\\n        moves = 0\\n        for i in range(len(seats)):\\n            moves += abs(seats[i] - students[i])\\n        return moves\\n\"",
  "2796_14631217_javascript": "\"function once(fn) {\\n  let called = false;\\n  let result;\\n  return function(...args) {\\n    if (!called) {\\n      called = true;\\n      result = fn.apply(this, args);\\n      return result;\\n    }\\n    // Subsequent calls return undefined\\n    return undefined;\\n  };\\n}\"",
  "1535_14631217_python": "\"MOD = 10**9 + 7\\n\\nclass Solution:\\n    def numOfArrays(self, n, m, k):\\n        dp = [[[0] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\\n        \\n        for j in range(1, m + 1):\\n            dp[1][j][1] = 1\\n        \\n        for i in range(2, n + 1):\\n            for j in range(1, m + 1):\\n                for x in range(1, k + 1):\\n                    dp[i][j][x] = dp[i - 1][j][x] * j % MOD\\n                    for p in range(1, j):\\n                        dp[i][j][x] = (dp[i][j][x] + dp[i - 1][p][x - 1]) % MOD\\n\\n        return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD\\n\"",
  "2351_14631217_python": "\"class Solution:\\n    def waysToBuyPensPencils(self, total, cost1, cost2):\\n        ways = 0\\n        # Try buying x pens for x = 0..max pens you can afford\\n        for x in range(total // cost1 + 1):\\n            remaining = total - cost1 * x\\n            # With the remaining money, you can buy 0..(remaining//cost2) pencils\\n            ways += remaining // cost2 + 1\\n        return ways\\n\"",
  "1443_14631217_python": "\"class Solution:\\n    def minimumDistance(self, word):\\n        # Precompute positions for 'A'-'Z'\\n        pos = [(i // 6, i % 6) for i in range(26)]\\n        # Add a dummy position for 'no finger' with zero move cost\\n        pos.append((-1, -1))  # index 26\\n\\n        def dist(i, j):\\n            # If either finger is not placed yet, moving cost is 0\\n            if i == 26 or j == 26:\\n                return 0\\n            r1, c1 = pos[i]\\n            r2, c2 = pos[j]\\n            return abs(r1 - r2) + abs(c1 - c2)\\n\\n        # Map characters in word to indices 0-25\\n        w = [ord(ch) - ord('A') for ch in word]\\n\\n        # dp[a][b] = min cost with finger1 at a, finger2 at b\\n        INF = float('inf')\\n        dp = [[INF] * 27 for _ in range(27)]\\n        dp[26][26] = 0  # both fingers start unplaced\\n\\n        for c in w:\\n            new_dp = [[INF] * 27 for _ in range(27)]\\n            for i in range(27):\\n                for j in range(27):\\n                    cost = dp[i][j]\\n                    if cost == INF:\\n                        continue\\n                    # Move finger1 to c\\n                    nc = cost + dist(i, c)\\n                    if nc < new_dp[c][j]:\\n                        new_dp[c][j] = nc\\n                    # Move finger2 to c\\n                    nc = cost + dist(j, c)\\n                    if nc < new_dp[i][c]:\\n                        new_dp[i][c] = nc\\n            dp = new_dp\\n\\n        # result is minimum cost over all end states\\n        ans = min(dp[i][j] for i in range(27) for j in range(27))\\n        return ans\\n\"",
  "3106_14631217_python": "\"class Solution(object):\\n    def lengthOfLongestSubsequence(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [-1] * (target + 1)\\n        dp[0] = 0\\n\\n        for num in nums:\\n            for s in range(target, num - 1, -1):\\n                if dp[s - num] != -1:\\n                    dp[s] = max(dp[s], dp[s - num] + 1)\\n\\n        return dp[target]\\n\"",
  "383_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, ransomNote, magazine):\\n        ransom_count = Counter(ransomNote)\\n        magazine_count = Counter(magazine)\\n        \\n        for char, count in ransom_count.items():\\n            if magazine_count[char] < count:\\n                return False\\n        return True\\n\"",
  "1179_14631217_mysql-updated-time": "1745446308281",
  "690_14631217_python": "\"class Solution(object):\\n    def getImportance(self, employees, id):\\n        emp_map = {e.id: e for e in employees}\\n        \\n        def dfs(emp_id):\\n            emp = emp_map[emp_id]\\n            total = emp.importance\\n            for sub_id in emp.subordinates:\\n                total += dfs(sub_id)\\n            return total\\n        \\n        return dfs(id)\\n\"",
  "1488_14631217_python-updated-time": "1746346001561",
  "2673_14631217_python-updated-time": "1747064905144",
  "3202_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def findHighAccessEmployees(self, access_times):\\n        d = defaultdict(list)\\n        for name, t in access_times:\\n            hh, mm = int(t[:2]), int(t[2:])\\n            d[name].append(hh * 60 + mm)\\n\\n        res = []\\n        for name, times in d.items():\\n            times.sort()\\n            j = 0\\n            for i in range(len(times)):\\n                # shrink window so that difference ≤ 59 minutes\\n                while times[i] - times[j] > 59:\\n                    j += 1\\n                if i - j + 1 >= 3:\\n                    res.append(name)\\n                    break\\n        return res\\n\"",
  "2627_14631217_python": "\"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(1000000)\\n\\nclass Solution:\\n    def maxOutput(self, n, edges, price):\\n        # Build adjacency list\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        down1 = [0] * n       # best path sum starting at u going downward\\n        m1 = [0] * n          # largest child down1 value\\n        m2 = [0] * n          # second-largest child down1 value\\n        m1_child = [-1] * n   # which child gives m1\\n\\n        # 1) Post-order DFS to compute down1, m1, m2, m1_child\\n        def dfs1(u, p):\\n            best1 = best2 = 0\\n            best_child = -1\\n            for v in g[u]:\\n                if v == p:\\n                    continue\\n                dfs1(v, u)\\n                val = down1[v]  # child’s best path from v\\n                if val > best1:\\n                    best2 = best1\\n                    best1 = val\\n                    best_child = v\\n                elif val > best2:\\n                    best2 = val\\n            m1[u], m2[u], m1_child[u] = best1, best2, best_child\\n            down1[u] = price[u] + best1\\n\\n        dfs1(0, -1)\\n\\n        up = [0] * n  # best path sum starting at u going upward (toward parent)\\n        up[0] = price[0]\\n\\n        # 2) Pre-order DFS to compute up[v] using rerooting\\n        def dfs2(u, p):\\n            for v in g[u]:\\n                if v == p:\\n                    continue\\n                # best downward at u excluding subtree v\\n                if m1_child[u] == v:\\n                    best_down_excl = price[u] + m2[u]\\n                else:\\n                    best_down_excl = price[u] + m1[u]\\n                # best path from u that doesn't go into v\\n                best_from_u = max(up[u], best_down_excl)\\n                # up[v] = price[v] + best_from_u\\n                up[v] = price[v] + best_from_u\\n                dfs2(v, u)\\n\\n        dfs2(0, -1)\\n\\n        # 3) Compute answer: max over u of (max(down1[u], up[u]) - price[u])\\n        ans = 0\\n        for u in range(n):\\n            ecc = max(down1[u], up[u])\\n            ans = max(ans, ecc - price[u])\\n        return ans\\n\"",
  "1006_14631217_python-updated-time": "1746039682123",
  "2264_14631217_python-updated-time": "1746802917378",
  "2110_14631217_mysql": "\"SELECT s.employee_id\\nFROM Salaries AS s\\nLEFT JOIN Employees AS e\\n  ON s.employee_id = e.employee_id\\nWHERE e.employee_id IS NULL\\n\\nUNION\\n\\nSELECT e.employee_id\\nFROM Employees AS e\\nLEFT JOIN Salaries AS s\\n  ON e.employee_id = s.employee_id\\nWHERE s.employee_id IS NULL\\n\\nORDER BY employee_id;\\n\"",
  "685_14631217_python": "\"class Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n        n = len(edges)\\n        parent = [0] * (n + 1)\\n        cand1 = cand2 = None\\n\\n        for u, v in edges:\\n            if parent[v] == 0:\\n                parent[v] = u\\n            else:\\n                cand1 = [parent[v], v]\\n                cand2 = [u, v]\\n                break\\n\\n        def find(u, par):\\n            if par[u] != u:\\n                par[u] = find(par[u], par)\\n            return par[u]\\n\\n        def union(u, v, par):\\n            pu, pv = find(u, par), find(v, par)\\n            if pu == pv:\\n                return False\\n            par[pu] = pv\\n            return True\\n\\n        if not cand1:\\n            par = [i for i in range(n + 1)]\\n            for u, v in edges:\\n                if not union(u, v, par):\\n                    return [u, v]\\n        else:\\n            for cand in [cand2, cand1]:\\n                par = [i for i in range(n + 1)]\\n                for u in range(1, n + 1):\\n                    parent[u] = u\\n                valid = True\\n                for u, v in edges:\\n                    if [u, v] == cand:\\n                        continue\\n                    if not union(u, v, par):\\n                        valid = False\\n                        break\\n                if valid:\\n                    return cand\\n\"",
  "1971_14631217_python": "\"class Solution:\\n    def memLeak(self, memory1, memory2):\\n        t = 1\\n        while True:\\n            if memory1 < t and memory2 < t:\\n                return [t, memory1, memory2]\\n            if memory1 >= memory2:\\n                memory1 -= t\\n            else:\\n                memory2 -= t\\n            t += 1\\n\"",
  "896_14631217_python": "\"class Solution(object):\\n    def subtreeWithAllDeepest(self, root):\\n        def dfs(node):\\n            if not node:\\n                return (0, None)\\n            l_depth, l_node = dfs(node.left)\\n            r_depth, r_node = dfs(node.right)\\n            if l_depth > r_depth:\\n                return (l_depth + 1, l_node)\\n            elif r_depth > l_depth:\\n                return (r_depth + 1, r_node)\\n            else:\\n                return (l_depth + 1, node)\\n        return dfs(root)[1]\\n\"",
  "1967_14631217_python": "\"class Solution(object):\\n    def longestBeautifulSubstring(self, word):\\n        idx = {'a':0, 'e':1, 'i':2, 'o':3, 'u':4}\\n        n = len(word)\\n        if n < 5:\\n            return 0\\n        start = 0\\n        prev = idx[word[0]]\\n        distinct = 1\\n        ans = 0\\n        for i in range(1, n):\\n            curr = idx[word[i]]\\n            if curr < prev:\\n                start = i\\n                distinct = 1\\n            else:\\n                if curr > prev:\\n                    distinct += 1\\n                if distinct == 5:\\n                    ans = max(ans, i - start + 1)\\n            prev = curr\\n        return ans\\n\"",
  "2109_14631217_python-updated-time": "1746716869581",
  "1238_14631217_python": "\"class Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \\\"\\\"\\\"\\n        :type target: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        def position(ch):\\n            idx = ord(ch) - ord('a')\\n            return divmod(idx, 5)  # (row, col)\\n\\n        res = []\\n        cur_r, cur_c = 0, 0\\n\\n        for ch in target:\\n            target_r, target_c = position(ch)\\n\\n            # Move UP and LEFT before DOWN and RIGHT to handle 'z' correctly\\n            # Special care for 'z' at (5, 0) since it’s the only char in its row\\n            while cur_r > target_r:\\n                res.append('U')\\n                cur_r -= 1\\n            while cur_c > target_c:\\n                res.append('L')\\n                cur_c -= 1\\n            while cur_r < target_r:\\n                res.append('D')\\n                cur_r += 1\\n            while cur_c < target_c:\\n                res.append('R')\\n                cur_c += 1\\n\\n            res.append('!')\\n\\n        return ''.join(res)\\n\"",
  "3508_14631217_python": "\"class Solution(object):\\n    def minChanges(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If k has a 1-bit where n has 0, impossible\\n        if k & ~n:\\n            return -1\\n        # Otherwise, must clear every 1 in n that's 0 in k\\n        return bin(n & ~k).count('1')\\n\"",
  "2419_14631217_python-updated-time": "1746907258193",
  "3553_14631217_python": "\"class Solution(object):\\n    def checkTwoChessboards(self, coordinate1, coordinate2):\\n        parity = lambda c: ((ord(c[0]) - ord('a')) + (int(c[1]) - 1)) & 1\\n        return parity(coordinate1) == parity(coordinate2)\\n\"",
  "1331_14631217_python-updated-time": "1746127726317",
  "1968_14631217_python": "\"class Solution(object):\\n    def maxBuilding(self, n, restrictions):\\n        # add building 1 and n\\n        restrictions.append([1, 0])\\n        restrictions.append([n, n-1])\\n        # sort by position\\n        restrictions.sort(key=lambda x: x[0])\\n        m = len(restrictions)\\n        # forward pass\\n        for i in range(1, m):\\n            dist = restrictions[i][0] - restrictions[i-1][0]\\n            restrictions[i][1] = min(restrictions[i][1],\\n                                     restrictions[i-1][1] + dist)\\n        # backward pass\\n        for i in range(m-2, -1, -1):\\n            dist = restrictions[i+1][0] - restrictions[i][0]\\n            restrictions[i][1] = min(restrictions[i][1],\\n                                     restrictions[i+1][1] + dist)\\n        # compute maximum between adjacent restrictions\\n        ans = 0\\n        for i in range(1, m):\\n            id1, h1 = restrictions[i-1]\\n            id2, h2 = restrictions[i]\\n            d = id2 - id1\\n            # max height in this segment\\n            local_max = (h1 + h2 + d) // 2\\n            if local_max > ans:\\n                ans = local_max\\n        return ans\\n\"",
  "524_14631217_python-updated-time": "1745446612866",
  "350_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def intersect(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        count1 = collections.Counter(nums1)\\n        res = []\\n        for num in nums2:\\n            if count1[num] > 0:\\n                res.append(num)\\n                count1[num] -= 1\\n        return res\\n\"",
  "1257_14631217_python": "\"class Solution:\\n    def matrixRankTransform(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        # Prepare list of (value, row, col)\\n        cells = [(matrix[i][j], i, j) for i in range(m) for j in range(n)]\\n        cells.sort(key=lambda x: x[0])\\n        \\n        # Track the maximum rank assigned so far for each row and column\\n        row_max = [0]*m\\n        col_max = [0]*n\\n        \\n        # The answer matrix\\n        answer = [[0]*n for _ in range(m)]\\n        \\n        # Union-Find helper\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx != ry:\\n                parent[ry] = rx\\n        \\n        # Process cells in increasing value order, grouping equal values\\n        i = 0\\n        N = m*n\\n        while i < N:\\n            # Gather all cells with the same value\\n            v = cells[i][0]\\n            j = i\\n            while j < N and cells[j][0] == v:\\n                j += 1\\n            \\n            # DSU over this batch of cells: indices 0..(j-i-1)\\n            size = j - i\\n            parent = list(range(size))\\n            \\n            # Map row -> index in this batch, col -> index\\n            row_rep = {}\\n            col_rep = {}\\n            \\n            for k in range(size):\\n                _, r, c = cells[i + k]\\n                if r in row_rep:\\n                    union(row_rep[r], k)\\n                else:\\n                    row_rep[r] = k\\n                if c in col_rep:\\n                    union(col_rep[c], k)\\n                else:\\n                    col_rep[c] = k\\n            \\n            # For each group root, collect its cells\\n            groups = {}\\n            for k in range(size):\\n                root = find(k)\\n                groups.setdefault(root, []).append(k)\\n            \\n            # Compute and assign ranks for each group\\n            for group in groups.values():\\n                # Determine the rank base from max of row_max and col_max\\n                best_prev = 0\\n                for k in group:\\n                    _, r, c = cells[i + k]\\n                    best_prev = max(best_prev, row_max[r], col_max[c])\\n                rank = best_prev + 1\\n                # Assign and update row_max, col_max\\n                for k in group:\\n                    _, r, c = cells[i + k]\\n                    answer[r][c] = rank\\n                    row_max[r] = max(row_max[r], rank)\\n                    col_max[c] = max(col_max[c], rank)\\n            \\n            i = j\\n        \\n        return answer\\n\"",
  "1356_14631217_python": "\"class Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        moves = 0\\n\\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                left, right = i, j\\n                while left < j and s[left] != s[j]:\\n                    left += 1\\n                while right > i and s[right] != s[i]:\\n                    right -= 1\\n                if left != j:\\n                    while left > i:\\n                        s[left], s[left - 1] = s[left - 1], s[left]\\n                        left -= 1\\n                        moves += 1\\n                    i += 1\\n                    j -= 1\\n                else:\\n                    while right < j:\\n                        s[right], s[right + 1] = s[right + 1], s[right]\\n                        right += 1\\n                        moves += 1\\n                    i += 1\\n                    j -= 1\\n\\n        return moves\\n\"",
  "869_14631217_python-updated-time": "1745879712257",
  "877_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def shortestPathLength(self, graph):\\n        n = len(graph)\\n        queue = deque()\\n        visited = set()\\n\\n        for i in range(n):\\n            mask = 1 << i\\n            queue.append((i, mask, 0))  # (node, visited_mask, steps)\\n            visited.add((i, mask))\\n\\n        target = (1 << n) - 1  # all nodes visited\\n\\n        while queue:\\n            node, mask, steps = queue.popleft()\\n            if mask == target:\\n                return steps\\n            for nei in graph[node]:\\n                next_mask = mask | (1 << nei)\\n                if (nei, next_mask) not in visited:\\n                    visited.add((nei, next_mask))\\n                    queue.append((nei, next_mask, steps + 1))\\n\"",
  "493_14631217_python-updated-time": "1745445905928",
  "722_14631217_python": "\"class Solution(object):\\n    def removeComments(self, source):\\n        \\\"\\\"\\\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        in_block = False\\n        buf = []\\n        \\n        for line in source:\\n            i = 0\\n            if not in_block:\\n                buf = []\\n            while i < len(line):\\n                if in_block:\\n                    # Look for end of block comment\\n                    if i + 1 < len(line) and line[i] == '*' and line[i+1] == '/':\\n                        in_block = False\\n                        i += 2\\n                    else:\\n                        i += 1\\n                else:\\n                    # Not in block\\n                    if i + 1 < len(line) and line[i] == '/' and line[i+1] == '*':\\n                        in_block = True\\n                        i += 2\\n                    elif i + 1 < len(line) and line[i] == '/' and line[i+1] == '/':\\n                        # Line comment: ignore rest of line\\n                        break\\n                    else:\\n                        buf.append(line[i])\\n                        i += 1\\n            # After processing line, if not in block and buffer non-empty, flush\\n            if not in_block and buf:\\n                res.append(\\\"\\\".join(buf))\\n        return res\\n\"",
  "2379_14631217_python": "\"class Solution:\\n    def maximumImportance(self, n, roads):\\n        # 1) Compute degrees\\n        deg = [0]*n\\n        for u,v in roads:\\n            deg[u] += 1\\n            deg[v] += 1\\n        \\n        # 2) Sort degrees ascending\\n        deg.sort()\\n        \\n        # 3) Assign values 1..n to degrees in sorted order\\n        ans = 0\\n        for i, d in enumerate(deg):\\n            ans += d * (i+1)\\n        \\n        return ans\\n\"",
  "129_14631217_python-updated-time": "1745085128892",
  "1026_14631217_python-updated-time": "1746040368111",
  "178_14631217_mysql-updated-time": "1745092409141",
  "1408_14631217_python-updated-time": "1746260225375",
  "3206_14631217_python-updated-time": "1747316973042",
  "3533_14631217_python": "\"class Solution(object):\\n    def finalPositionOfSnake(self, n, commands):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type commands: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # start at cell 0 → (r,c) = (0,0)\\n        r, c = 0, 0\\n        for cmd in commands:\\n            if cmd == \\\"UP\\\":\\n                r -= 1\\n            elif cmd == \\\"DOWN\\\":\\n                r += 1\\n            elif cmd == \\\"LEFT\\\":\\n                c -= 1\\n            elif cmd == \\\"RIGHT\\\":\\n                c += 1\\n            # boundaries guaranteed by problem statement\\n\\n        # convert back to cell index\\n        return r * n + c\\n\"",
  "1941_14631217_python": "\"MOD = 10**9 + 7\\n\\nclass Solution(object):\\n    def makeStringSorted(self, s):\\n        n = len(s)\\n        # precompute factorials and inverse factorials\\n        fact = [1] * (n+1)\\n        for i in range(1, n+1):\\n            fact[i] = fact[i-1] * i % MOD\\n        invfact = [1] * (n+1)\\n        invfact[n] = pow(fact[n], MOD-2, MOD)\\n        for i in range(n, 0, -1):\\n            invfact[i-1] = invfact[i] * i % MOD\\n\\n        # frequency of each character\\n        freq = [0] * 26\\n        for ch in s:\\n            freq[ord(ch) - ord('a')] += 1\\n\\n        # denom = product of invfact[freq[c]] for all c\\n        denom = 1\\n        for c in range(26):\\n            denom = denom * invfact[freq[c]] % MOD\\n\\n        rank = 0\\n        rem = n\\n        for ch in s:\\n            cidx = ord(ch) - ord('a')\\n            rem -= 1\\n            # count characters smaller than ch\\n            for c in range(cidx):\\n                if freq[c] > 0:\\n                    # number of perms if we put char c here\\n                    # = fact[rem] * denom' where denom' = denom * fact[freq[c]] * invfact[freq[c]-1]\\n                    add = fact[rem] * denom % MOD\\n                    add = add * fact[freq[c]] % MOD\\n                    add = add * invfact[freq[c]-1] % MOD\\n                    rank = (rank + add) % MOD\\n            # fix ch at this position: update denom and freq\\n            denom = denom * fact[freq[cidx]] % MOD\\n            denom = denom * invfact[freq[cidx]-1] % MOD\\n            freq[cidx] -= 1\\n\\n        return rank\\n\"",
  "2388_14631217_python-updated-time": "1746881944560",
  "1403_14631217_python": "\"class Solution:\\n    def palindromePartition(self, s, k):\\n        n = len(s)\\n\\n        # Precompute the cost to make s[i:j+1] a palindrome\\n        cost = [[0] * n for _ in range(n)]\\n        for l in range(n):\\n            for i in range(n - l):\\n                j = i + l\\n                if i >= j:\\n                    cost[i][j] = 0\\n                else:\\n                    cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])\\n\\n        # DP: dp[i][k] = min cost to split first i characters into k palindromic parts\\n        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 0\\n\\n        for i in range(1, n + 1):\\n            for p in range(1, k + 1):\\n                for j in range(p - 1, i):\\n                    dp[i][p] = min(dp[i][p], dp[j][p - 1] + cost[j][i - 1])\\n\\n        return dp[n][k]\\n\"",
  "1678_14631217_python-updated-time": "1746438255345",
  "2348_14631217_python": "\"class Solution:\\n    def countTexts(self, pressedKeys):\\n        mod = 10**9 + 7\\n        n = len(pressedKeys)\\n        \\n        # Precompute dp3[k] = #ways for run of length k with M=3\\n        #            dp4[k] = #ways for run of length k with M=4\\n        dp3 = [0] * (n + 1)\\n        dp4 = [0] * (n + 1)\\n        dp3[0] = dp4[0] = 1\\n        \\n        for k in range(1, n + 1):\\n            # M = 3\\n            dp3[k] = dp3[k - 1]\\n            if k >= 2:\\n                dp3[k] = (dp3[k] + dp3[k - 2]) % mod\\n            if k >= 3:\\n                dp3[k] = (dp3[k] + dp3[k - 3]) % mod\\n            # M = 4\\n            dp4[k] = dp4[k - 1]\\n            if k >= 2:\\n                dp4[k] = (dp4[k] + dp4[k - 2]) % mod\\n            if k >= 3:\\n                dp4[k] = (dp4[k] + dp4[k - 3]) % mod\\n            if k >= 4:\\n                dp4[k] = (dp4[k] + dp4[k - 4]) % mod\\n        \\n        ans = 1\\n        i = 0\\n        while i < n:\\n            j = i\\n            # find run of same digit\\n            while j < n and pressedKeys[j] == pressedKeys[i]:\\n                j += 1\\n            length = j - i\\n            d = pressedKeys[i]\\n            # choose dp3 or dp4\\n            if d in {'7', '9'}:\\n                ans = ans * dp4[length] % mod\\n            else:\\n                ans = ans * dp3[length] % mod\\n            i = j\\n        \\n        return ans\\n\"",
  "3869_14631217_python": "\"class Solution(object):\\n    def smallestIndex(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        for i, num in enumerate(nums):\\n            # compute sum of digits\\n            s = 0\\n            x = num\\n            while x > 0:\\n                s += x % 10\\n                x //= 10\\n            if s == i:\\n                return i\\n        return -1\\n\"",
  "1782_14631217_python-updated-time": "1746445684631",
  "2059_14631217_python": "\"class Solution(object):\\n    def countPalindromicSubsequence(self, s):\\n        first = {}\\n        last = {}\\n        for i, ch in enumerate(s):\\n            if ch not in first:\\n                first[ch] = i\\n            last[ch] = i\\n        ans = 0\\n        for ch in first:\\n            i = first[ch]\\n            j = last[ch]\\n            if j - i < 2:\\n                continue\\n            seen = set()\\n            for k in range(i+1, j):\\n                seen.add(s[k])\\n            ans += len(seen)\\n        return ans\\n\"",
  "617_14631217_python": "\"class Solution(object):\\n    def mergeTrees(self, root1, root2):\\n        if not root1 and not root2:\\n            return None\\n        val = (root1.val if root1 else 0) + (root2.val if root2 else 0)\\n        node = TreeNode(val)\\n        node.left = self.mergeTrees(root1.left if root1 else None, root2.left if root2 else None)\\n        node.right = self.mergeTrees(root1.right if root1 else None, root2.right if root2 else None)\\n        return node\\n\"",
  "2099_14631217_python-updated-time": "1746639381829",
  "2463_14631217_python": "\"class Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        min_ops = float('inf')\\n        count_w = 0\\n\\n        for i in range(k):\\n            if blocks[i] == 'W':\\n                count_w += 1\\n        min_ops = count_w\\n\\n        for i in range(k, len(blocks)):\\n            if blocks[i - k] == 'W':\\n                count_w -= 1\\n            if blocks[i] == 'W':\\n                count_w += 1\\n            min_ops = min(min_ops, count_w)\\n\\n        return min_ops\\n\"",
  "2289_14631217_python-updated-time": "1746803257532",
  "2803_14631217_python-updated-time": "1747139701029",
  "2577_14631217_python": "\"class Solution(object):\\n    def countPalindromes(self, s):\\n        MOD = 10**9 + 7\\n        n = len(s)\\n        # build suffix pair counts\\n        suffixCount = [0] * 10\\n        suffixPair = [[0] * 10 for _ in range(10)]\\n        suffixPairs = [None] * n\\n        for i in range(n - 1, -1, -1):\\n            suffixPairs[i] = [row[:] for row in suffixPair]\\n            d = ord(s[i]) - ord('0')\\n            for b in range(10):\\n                suffixPair[d][b] += suffixCount[b]\\n            suffixCount[d] += 1\\n        # scan prefixes and accumulate answer\\n        prefixCount = [0] * 10\\n        prefixPair = [[0] * 10 for _ in range(10)]\\n        ans = 0\\n        for k in range(n):\\n            sp = suffixPairs[k]\\n            for a in range(10):\\n                row = prefixPair[a]\\n                for b in range(10):\\n                    if row[b] and sp[b][a]:\\n                        ans = (ans + row[b] * sp[b][a]) % MOD\\n            d = ord(s[k]) - ord('0')\\n            for a in range(10):\\n                prefixPair[a][d] += prefixCount[a]\\n            prefixCount[d] += 1\\n        return ans\\n\"",
  "2721_14631217_python-updated-time": "1747134805317",
  "3000_14631217_python": "\"from bisect import bisect_left, insort\\n\\nclass Solution(object):\\n    def minAbsoluteDifference(self, nums, x):\\n        if x == 0:\\n            return 0\\n\\n        s = []\\n        res = float('inf')\\n        for i in range(x, len(nums)):\\n            insort(s, nums[i - x])\\n            idx = bisect_left(s, nums[i])\\n            if idx < len(s):\\n                res = min(res, abs(s[idx] - nums[i]))\\n            if idx > 0:\\n                res = min(res, abs(s[idx - 1] - nums[i]))\\n        return res\\n\"",
  "1087_14631217_python-updated-time": "1746041961968",
  "1287_14631217_python-updated-time": "1746126527398",
  "2705_14631217_python": "\"class Solution(object):\\n    def minImpossibleOR(self, nums):\\n        # Track which single‐bit values appear\\n        seen = [False]*32\\n        for v in nums:\\n            # check if v is a power of two\\n            if v & (v-1) == 0:\\n                b = v.bit_length() - 1  # v == 1<<b\\n                seen[b] = True\\n        # find the smallest i>=0 such that 2^i wasn't seen\\n        for i in range(32):\\n            if not seen[i]:\\n                return 1 << i\\n        # (in practice you'll always return before reaching here)\\n        return 1 << 32\\n\"",
  "829_14631217_python-updated-time": "1745878580589",
  "3654_14631217_python-updated-time": "1747595695566",
  "1249_14631217_python": "\"import bisect\\n\\nclass SnapshotArray(object):\\n    def __init__(self, length):\\n        self.data = [[] for _ in range(length)]\\n        self.snap_id = 0\\n\\n    def set(self, index, val):\\n        if self.data[index] and self.data[index][-1][0] == self.snap_id:\\n            self.data[index][-1] = (self.snap_id, val)  # overwrite last if same snap_id\\n        else:\\n            self.data[index].append((self.snap_id, val))\\n\\n    def snap(self):\\n        self.snap_id += 1\\n        return self.snap_id - 1\\n\\n    def get(self, index, snap_id):\\n        arr = self.data[index]\\n        i = bisect.bisect_right(arr, (snap_id, float('inf'))) - 1\\n        return arr[i][1] if i >= 0 else 0\\n\"",
  "1873_14631217_python": "\"class Solution(object):\\n    def longestNiceSubstring(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if len(s) < 2:\\n            return \\\"\\\"\\n        \\n        charset = set(s)\\n        for i in range(len(s)):\\n            ch = s[i]\\n            if ch.swapcase() not in charset:\\n                left = self.longestNiceSubstring(s[:i])\\n                right = self.longestNiceSubstring(s[i+1:])\\n                return left if len(left) >= len(right) else right\\n        \\n        return s\\n\"",
  "3248_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def incremovableSubarrayCount(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # longest strictly‐increasing prefix ends at P\\n        P = 0\\n        while P + 1 < n and nums[P + 1] > nums[P]:\\n            P += 1\\n        # earliest strictly‐increasing suffix starts at S\\n        S = n - 1\\n        while S - 1 >= 0 and nums[S] > nums[S - 1]:\\n            S -= 1\\n        # we can only start removals up to l_max\\n        l_max = min(P + 1, n - 1)\\n        total = 0\\n        for l in range(l_max + 1):\\n            # minimal r so that suffix from r+1... is increasing\\n            r_min = max(l, S - 1)\\n            if l == 0:\\n                # no prefix to worry about\\n                total += n - r_min\\n            else:\\n                # need nums[l-1] < nums[r+1] for r < n-1\\n                threshold = nums[l - 1]\\n                k_start = r_min + 1\\n                if k_start > n - 1:\\n                    total += 1  # only r = n-1\\n                else:\\n                    # binary search in the strictly increasing tail [k_start..n-1]\\n                    k0 = bisect.bisect_right(nums, threshold, k_start, n)\\n                    # k in [k0..n-1] ↔ r = k-1 in [r_min..n-2], plus r=n-1\\n                    total += (n - k0) + 1\\n        return total\\n\"",
  "949_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        N = len(graph)\\n        # 0 = unknown, 1 = mouse win, 2 = cat win\\n        dp = [[[0]*2 for _ in range(N)] for _ in range(N)]\\n        # degree[m][c][t]: number of moves available from state (m,c,t)\\n        degree = [[[0]*2 for _ in range(N)] for _ in range(N)]\\n        \\n        for m in range(N):\\n            for c in range(N):\\n                degree[m][c][0] = len(graph[m])                # mouse’s turn: all neighbors\\n                degree[m][c][1] = sum(1 for nc in graph[c]    # cat’s turn: neighbors except hole 0\\n                                     if nc != 0)\\n        \\n        q = deque()\\n        # Initialize terminal states\\n        for i in range(N):\\n            for t in range(2):\\n                # mouse at hole → mouse wins\\n                dp[0][i][t] = 1\\n                q.append((0, i, t, 1))\\n                # cat catches mouse → cat wins\\n                dp[i][i][t] = 2\\n                q.append((i, i, t, 2))\\n        \\n        def parents(m, c, t):\\n            prev_t = 1 - t\\n            if t == 0:\\n                # arrived on mouse's turn → previous was cat move\\n                for pc in graph[c]:\\n                    if pc == 0: continue\\n                    yield (m, pc, prev_t)\\n            else:\\n                # arrived on cat's turn → previous was mouse move\\n                for pm in graph[m]:\\n                    yield (pm, c, prev_t)\\n        \\n        # Retrograde BFS\\n        while q:\\n            m, c, t, winner = q.popleft()\\n            for pm, pc, pt in parents(m, c, t):\\n                if dp[pm][pc][pt] != 0:\\n                    continue\\n                # If the player whose turn it is in the parent can move into a winning state for them:\\n                if (winner == 1 and pt == 0) or (winner == 2 and pt == 1):\\n                    dp[pm][pc][pt] = winner\\n                    q.append((pm, pc, pt, winner))\\n                else:\\n                    degree[pm][pc][pt] -= 1\\n                    # If all moves lead to opponent wins, then opponent wins here\\n                    if degree[pm][pc][pt] == 0:\\n                        lose = 2 if pt == 0 else 1\\n                        dp[pm][pc][pt] = lose\\n                        q.append((pm, pc, pt, lose))\\n        \\n        return dp[1][2][0]\\n\"",
  "724_14631217_python": "\"class Solution(object):\\n    def pivotIndex(self, nums):\\n        total = sum(nums)\\n        left_sum = 0\\n        \\n        for i, x in enumerate(nums):\\n            # right sum = total - left_sum - x\\n            if left_sum == total - left_sum - x:\\n                return i\\n            left_sum += x\\n        \\n        return -1\\n\"",
  "3379_14631217_lang-updated-time": "1720875059996",
  "3422_14631217_python": "\"class Solution(object):\\n    def valueAfterKSeconds(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        total = (n - 1) + k\\n        r = k\\n        # Compute C(total, r) mod MOD in O(r log MOD)\\n        res = 1\\n        for i in range(1, r + 1):\\n            # multiply by (total - r + i) / i\\n            res = res * (total - r + i) % MOD\\n            res = res * pow(i, MOD - 2, MOD) % MOD\\n        return res\\n\"",
  "2038_14631217_python-updated-time": "1746637825018",
  "1000_14631217_python": "\"class Solution:\\n    def minDeletionSize(self, strs):\\n        n, m = len(strs), len(strs[0])\\n        dp = [1] * m\\n\\n        for j in range(m):\\n            for i in range(j):\\n                if all(strs[row][i] <= strs[row][j] for row in range(n)):\\n                    dp[j] = max(dp[j], dp[i] + 1)\\n\\n        return m - max(dp)\\n\"",
  "2789_14631217_javascript": "\"function createCounter(init) {\\n  let value = init;\\n  return {\\n    increment: function() {\\n      value += 1;\\n      return value;\\n    },\\n    decrement: function() {\\n      value -= 1;\\n      return value;\\n    },\\n    reset: function() {\\n      value = init;\\n      return value;\\n    }\\n  };\\n}\\n\\n// Example Usage:\\n// const counter = createCounter(5);\\n// console.log(counter.increment()); // 6\\n// console.log(counter.reset());     // 5\\n// console.log(counter.decrement()); // 4\\n\"",
  "3750_14631217_python": "\"from bisect import bisect_left\\n\\nclass Solution(object):\\n    def solveQueries(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Map each value to the sorted list of indices where it occurs\\n        positions = {}\\n        for i, v in enumerate(nums):\\n            positions.setdefault(v, []).append(i)\\n        \\n        # Ensure each list is sorted (though insertion order is increasing)\\n        # But to be safe if needed:\\n        # for v in positions:\\n        #     positions[v].sort()\\n        \\n        answer = []\\n        for q in queries:\\n            v = nums[q]\\n            pos_list = positions[v]\\n            if len(pos_list) == 1:\\n                # Only occurrence\\n                answer.append(-1)\\n                continue\\n            \\n            # Find the index of q in pos_list\\n            idx = bisect_left(pos_list, q)\\n            # Sanity: pos_list[idx] == q\\n            # Predecessor (circular)\\n            if idx > 0:\\n                pred = pos_list[idx - 1]\\n            else:\\n                pred = pos_list[-1]\\n            # Successor (circular)\\n            if idx + 1 < len(pos_list):\\n                succ = pos_list[idx + 1]\\n            else:\\n                succ = pos_list[0]\\n            \\n            # Compute minimal circular distance for both\\n            best = n  # large initial\\n            for j in (pred, succ):\\n                d = abs(j - q)\\n                circ = n - d\\n                best = min(best, d, circ)\\n            \\n            answer.append(best)\\n        \\n        return answer\\n\"",
  "387_14631217_python-updated-time": "1745355279326",
  "417_14631217_python-updated-time": "1745356318042",
  "2618_14631217_python": "\"class Solution:\\n    def maxPower(self, stations, r, k):\\n        n = len(stations)\\n        \\n        # 1) Compute initial power for each city via sliding window of width 2r+1\\n        power = [0] * n\\n        window = 0\\n        # initialize window for i = 0: sum stations[0..r]\\n        for j in range(0, min(n, r + 1)):\\n            window += stations[j]\\n        power[0] = window\\n        \\n        for i in range(1, n):\\n            # slide out station at i - r - 1\\n            if i - r - 1 >= 0:\\n                window -= stations[i - r - 1]\\n            # slide in station at i + r\\n            if i + r < n:\\n                window += stations[i + r]\\n            power[i] = window\\n        \\n        # 2) Helper to test if we can achieve at least 'target' everywhere\\n        def can(target):\\n            diff = [0] * (n + 1)\\n            add = 0\\n            remaining = k\\n            \\n            for i in range(n):\\n                add += diff[i]\\n                curr = power[i] + add\\n                if curr < target:\\n                    need = target - curr\\n                    if need > remaining:\\n                        return False\\n                    remaining -= need\\n                    add += need\\n                    end = i + 2*r + 1\\n                    if end < n:\\n                        diff[end] -= need\\n            return True\\n        \\n        # 3) Binary search answer between min(power) and min(power) + k\\n        lo = min(power)\\n        hi = lo + k\\n        ans = lo\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if can(mid):\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        \\n        return ans\\n\"",
  "2836_14631217_python": "\"class Solution:\\n    def findNonMinOrMax(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if len(nums) < 3:\\n            return -1\\n        \\n        _min = min(nums)\\n        _max = max(nums)\\n        \\n        for x in nums:\\n            if x != _min and x != _max:\\n                return x\\n        \\n        return -1\\n\"",
  "2128_14631217_python": "\"class Solution:\\n    def reversePrefix(self, word, ch):\\n        idx = word.find(ch)\\n        if idx == -1:\\n            return word\\n        return word[:idx+1][::-1] + word[idx+1:]\\n\"",
  "3568_14631217_python": "\"class Solution(object):\\n    def generateKey(self, num1, num2, num3):\\n        # Convert to 4-digit strings with leading zeros\\n        s1 = str(num1).zfill(4)\\n        s2 = str(num2).zfill(4)\\n        s3 = str(num3).zfill(4)\\n\\n        # Take the minimum digit in each position\\n        key_digits = [min(s1[i], s2[i], s3[i]) for i in range(4)]\\n\\n        # Join and convert to int to remove leading zeros\\n        return int(''.join(key_digits))\\n\"",
  "2760_14631217_javascript": "\"Array.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) return [];\\n\\n  const result = Array.from({ length: rowsCount }, () => Array(colsCount).fill(0));\\n  let i = 0;\\n\\n  for (let col = 0; col < colsCount; col++) {\\n    if (col % 2 === 0) {\\n      for (let row = 0; row < rowsCount; row++) {\\n        result[row][col] = this[i++];\\n      }\\n    } else {\\n      for (let row = rowsCount - 1; row >= 0; row--) {\\n        result[row][col] = this[i++];\\n      }\\n    }\\n  }\\n\\n  return result;\\n};\\n\"",
  "1319_14631217_python-updated-time": "1746127549420",
  "1464_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def minSetSize(self, arr):\\n        freq = Counter(arr)\\n        counts = sorted(freq.values(), reverse=True)\\n        removed = 0\\n        target = len(arr) // 2\\n        ans = 0\\n        for c in counts:\\n            removed += c\\n            ans += 1\\n            if removed >= target:\\n                return ans\\n        return ans\\n\"",
  "596_14631217_mysql": "\"SELECT\\n    class\\nFROM Courses\\nGROUP BY class\\nHAVING COUNT(*) >= 5;\\n\"",
  "1431_14631217_python-updated-time": "1746804069786",
  "759_14631217_python-updated-time": "1745875890909",
  "2269_14631217_python-updated-time": "1746802612286",
  "2525_14631217_python": "\"class Solution(object):\\n    def countDistinctIntegers(self, nums):\\n        seen = set(nums)\\n        def rev(x):\\n            r = 0\\n            while x:\\n                r = r*10 + x%10\\n                x //= 10\\n            return r\\n        for x in nums:\\n            seen.add(rev(x))\\n        return len(seen)\\n\"",
  "3492_14631217_python": "\"class Solution(object):\\n    def numberOfSubmatrices(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        \\n        # prev prefix sums for X and Y up through previous row\\n        prev_px = [0] * (m+1)\\n        prev_py = [0] * (m+1)\\n        \\n        for i in xrange(1, n+1):\\n            row = grid[i-1]\\n            cur_px = [0] * (m+1)\\n            cur_py = [0] * (m+1)\\n            for j in xrange(1, m+1):\\n                c = row[j-1]\\n                isX = 1 if c == 'X' else 0\\n                isY = 1 if c == 'Y' else 0\\n                \\n                # 2D prefix sum relation\\n                cur_px[j] = (cur_px[j-1]\\n                             + prev_px[j]\\n                             - prev_px[j-1]\\n                             + isX)\\n                cur_py[j] = (cur_py[j-1]\\n                             + prev_py[j]\\n                             - prev_py[j-1]\\n                             + isY)\\n                \\n                # submatrix from (0,0) to (i-1,j-1):\\n                # needs at least one X and equal X/Y counts\\n                if cur_px[j] > 0 and cur_px[j] == cur_py[j]:\\n                    ans += 1\\n            \\n            # advance prev to this row\\n            prev_px = cur_px\\n            prev_py = cur_py\\n        \\n        return ans\\n\"",
  "3558_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def findSafeWalk(self, grid, health):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[-1]*n for _ in range(m)]\\n        dq = deque()\\n        dq.append((0, 0, health - grid[0][0]))\\n        visited[0][0] = health - grid[0][0]\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n\\n        while dq:\\n            x, y, h = dq.popleft()\\n            if h <= 0:\\n                continue\\n            if x == m - 1 and y == n - 1:\\n                return True\\n            for dx, dy in dirs:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    nh = h - grid[nx][ny]\\n                    if nh > visited[nx][ny]:\\n                        visited[nx][ny] = nh\\n                        dq.append((nx, ny, nh))\\n        return False\\n\"",
  "886_14631217_python-updated-time": "1745953784614",
  "2641_14631217_python": "\"class Solution(object):\\n    def isPossibleToCutPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        def dfs(x, y, visited):\\n            if x >= m or y >= n or grid[x][y] == 0 or visited[x][y]:\\n                return False\\n            if x == m - 1 and y == n - 1:\\n                return True\\n            visited[x][y] = True\\n            return dfs(x + 1, y, visited) or dfs(x, y + 1, visited)\\n\\n        # First DFS: mark one valid path from (0,0) to (m-1,n-1)\\n        visited1 = [[False] * n for _ in range(m)]\\n        if not dfs(0, 0, visited1):\\n            return True  # Already disconnected\\n\\n        # Flip all visited path to 0 (simulate cut)\\n        for i in range(m):\\n            for j in range(n):\\n                if visited1[i][j] and (i != 0 or j != 0) and (i != m - 1 or j != n - 1):\\n                    grid[i][j] = 0\\n\\n        # Second DFS: check if any other path exists\\n        visited2 = [[False] * n for _ in range(m)]\\n        return not dfs(0, 0, visited2)\\n\"",
  "529_14631217_python": "\"class Solution:\\n    def updateBoard(self, board, click):\\n        m, n = len(board), len(board[0])\\n        directions = [(-1, -1), (-1, 0), (-1, 1),\\n                      (0, -1),          (0, 1),\\n                      (1, -1),  (1, 0), (1, 1)]\\n        \\n        def count_mines(x, y):\\n            count = 0\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n and board[nx][ny] == 'M':\\n                    count += 1\\n            return count\\n\\n        def dfs(x, y):\\n            if not (0 <= x < m and 0 <= y < n) or board[x][y] != 'E':\\n                return\\n            mine_count = count_mines(x, y)\\n            if mine_count > 0:\\n                board[x][y] = str(mine_count)\\n            else:\\n                board[x][y] = 'B'\\n                for dx, dy in directions:\\n                    dfs(x + dx, y + dy)\\n\\n        cx, cy = click\\n        if board[cx][cy] == 'M':\\n            board[cx][cy] = 'X'\\n        else:\\n            dfs(cx, cy)\\n\\n        return board\\n\"",
  "239_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        dq = collections.deque()\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if dq and dq[0] == i - k:\\n                dq.popleft()\\n            while dq and nums[dq[-1]] < nums[i]:\\n                dq.pop()\\n            dq.append(i)\\n            if i >= k - 1:\\n                res.append(nums[dq[0]])\\n        \\n        return res\\n\"",
  "2215_14631217_python": "\"class Solution:\\n    def findEvenNumbers(self, digits):\\n        \\\"\\\"\\\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(digits)\\n        result = set()\\n        \\n        # Precompute indices by digit properties\\n        nonzero_indices = [i for i, d in enumerate(digits) if d != 0]\\n        even_indices = [i for i, d in enumerate(digits) if d % 2 == 0]\\n        \\n        for i in nonzero_indices:\\n            for j in range(n):\\n                if j == i:\\n                    continue\\n                for k in even_indices:\\n                    if k == i or k == j:\\n                        continue\\n                    num = digits[i] * 100 + digits[j] * 10 + digits[k]\\n                    result.add(num)\\n        \\n        return sorted(result)\\n\"",
  "2217_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getDirections(self, root, startValue, destValue):\\n        # Helper: return the path from root to target as a string of 'L'/'R'\\n        def getPath(node, target, path):\\n            if not node:\\n                return False\\n            if node.val == target:\\n                return True\\n            # Try left\\n            path.append('L')\\n            if getPath(node.left, target, path):\\n                return True\\n            path.pop()\\n            # Try right\\n            path.append('R')\\n            if getPath(node.right, target, path):\\n                return True\\n            path.pop()\\n            return False\\n        \\n        path_s = []\\n        path_t = []\\n        # Fill path_s and path_t\\n        getPath(root, startValue, path_s)\\n        getPath(root, destValue, path_t)\\n        \\n        # Find common prefix length\\n        i = 0\\n        while i < len(path_s) and i < len(path_t) and path_s[i] == path_t[i]:\\n            i += 1\\n        \\n        # Steps up from start to LCA, then down to dest\\n        up_moves = 'U' * (len(path_s) - i)\\n        down_moves = ''.join(path_t[i:])\\n        return up_moves + down_moves\\n\"",
  "180_14631217_mysql-updated-time": "1745092471768",
  "3591_14631217_python-updated-time": "1747595188170",
  "2699_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def countFairPairs(self, nums, lower, upper):\\n        nums.sort()\\n        n = len(nums)\\n        res = 0\\n        for i in xrange(n):\\n            lo = lower - nums[i]\\n            hi = upper - nums[i]\\n            left = bisect.bisect_left(nums, lo, i+1, n)\\n            right = bisect.bisect_right(nums, hi, i+1, n)\\n            res += right - left\\n        return res\\n\"",
  "389_14631217_python-updated-time": "1745355371983",
  "15_14631217_python-updated-time": "1744980696222",
  "29_14631217_python-updated-time": "1744987931774",
  "453_14631217_python": "\"class Solution:\\n    def minMoves(self, nums):\\n        min_num = min(nums)\\n        return sum(num - min_num for num in nums)\\n\"",
  "2722_14631217_python": "\"class Solution:\\n    def diagonalPrime(self, nums):\\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            if x == 2 or x == 3:\\n                return True\\n            if x % 2 == 0 or x % 3 == 0:\\n                return False\\n            i = 5\\n            while i * i <= x:\\n                if x % i == 0 or x % (i + 2) == 0:\\n                    return False\\n                i += 6\\n            return True\\n\\n        n = len(nums)\\n        max_prime = 0\\n\\n        for i in range(n):\\n            for val in [nums[i][i], nums[i][n - 1 - i]]:\\n                if is_prime(val):\\n                    max_prime = max(max_prime, val)\\n\\n        return max_prime\\n\"",
  "3829_14631217_python": "\"class Fenwick:\\n    \\\"\\\"\\\"Fenwick tree for range‐add / point‐query.\\\"\\\"\\\"\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0] * (n+1)\\n    def _add(self, i, v):\\n        while i <= self.n:\\n            self.fw[i] += v\\n            i += i & -i\\n    def range_add(self, l, r, v):\\n        self._add(l, v)\\n        self._add(r+1, -v)\\n    def point_query(self, i):\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n\\nclass Solution(object):\\n    def treeQueries(self, n, edges, queries):\\n        import sys\\n        sys.setrecursionlimit(10**7)\\n\\n        # Build adjacency\\n        g = [[] for _ in range(n+1)]\\n        for u, v, w in edges:\\n            g[u].append((v, w))\\n            g[v].append((u, w))\\n\\n        tin  = [0] * (n+1)\\n        tout = [0] * (n+1)\\n        dist0 = [0] * (n+1)\\n        edge_weight = {}  # child -> weight to its parent\\n\\n        timer = [0]  # use list so we can mutate inside dfs\\n\\n        def dfs(u, p):\\n            timer[0] += 1\\n            tin[u] = timer[0]\\n            for v, w in g[u]:\\n                if v == p:\\n                    continue\\n                dist0[v] = dist0[u] + w\\n                edge_weight[v] = w\\n                dfs(v, u)\\n            tout[u] = timer[0]\\n\\n        # run DFS from root = 1\\n        dfs(1, 0)\\n\\n        bit = Fenwick(n)\\n        ans = []\\n\\n        for q in queries:\\n            if q[0] == 1:\\n                # Update edge (u,v) to new weight w_new\\n                _, u, v, w_new = q\\n                # determine child in our rooted tree by tin/tout\\n                if tin[u] < tin[v] and tout[v] <= tout[u]:\\n                    parent, child = u, v\\n                else:\\n                    parent, child = v, u\\n                delta = w_new - edge_weight[child]\\n                edge_weight[child] = w_new\\n                bit.range_add(tin[child], tout[child], delta)\\n            else:\\n                # Query distance to x\\n                _, x = q\\n                d = dist0[x] + bit.point_query(tin[x])\\n                ans.append(d)\\n\\n        return ans\\n\"",
  "77_14631217_python": "\"class Solution(object):\\n    def combine(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(start, path):\\n            if len(path) == k:\\n                res.append(list(path))\\n                return\\n            for i in range(start, n + 1):\\n                path.append(i)\\n                backtrack(i + 1, path)\\n                path.pop()\\n\\n        backtrack(1, [])\\n        return res\\n\"",
  "2156_14631217_python": "\"class Solution(object):\\n    def stoneGameIX(self, stones):\\n        \\\"\\\"\\\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        mod = [0, 0, 0]\\n        for val in stones:\\n            mod[val % 3] += 1\\n\\n        if mod[1] == 0 or mod[2] == 0:\\n            return mod[1] + mod[2] > 2 and mod[0] % 2 == 1\\n        return abs(mod[1] - mod[2]) > 2 or mod[0] % 2 == 0\\n\"",
  "2221_14631217_python-updated-time": "1746800257754",
  "2602_14631217_python-updated-time": "1747059255792",
  "3001_14631217_python": "\"class Solution(object):\\n    def maximumScore(self, nums, k):\\n        mod = 10**9+7\\n        n = len(nums)\\n\\n        # sieve for smallest prime factor up to max(nums)\\n        maxv = max(nums)\\n        spf = list(range(maxv+1))\\n        i = 2\\n        while i*i <= maxv:\\n            if spf[i] == i:\\n                j = i*i\\n                while j <= maxv:\\n                    if spf[j] == j:\\n                        spf[j] = i\\n                    j += i\\n            i += 1\\n\\n        # prime‐score for each nums[i]\\n        A = [0]*n\\n        for idx, v in enumerate(nums):\\n            cnt = 0\\n            prev = 0\\n            x = v\\n            while x > 1:\\n                p = spf[x]\\n                if p != prev:\\n                    cnt += 1\\n                    prev = p\\n                x //= p\\n            A[idx] = cnt\\n\\n        # prev greater or equal\\n        L = [-1]*n\\n        st = []\\n        for i in range(n):\\n            while st and A[st[-1]] < A[i]:\\n                st.pop()\\n            L[i] = st[-1] if st else -1\\n            st.append(i)\\n\\n        # next strictly greater\\n        R = [n]*n\\n        st = []\\n        for i in range(n-1, -1, -1):\\n            while st and A[st[-1]] <= A[i]:\\n                st.pop()\\n            R[i] = st[-1] if st else n\\n            st.append(i)\\n\\n        # count of subarrays where i is chosen\\n        counts = [0]*n\\n        for i in range(n):\\n            counts[i] = (i - L[i]) * (R[i] - i)\\n\\n        # pick up to k factors in descending nums order\\n        idxs = list(range(n))\\n        idxs.sort(key=lambda i: nums[i], reverse=True)\\n\\n        res = 1\\n        rem = k\\n        for i in idxs:\\n            if rem <= 0:\\n                break\\n            t = counts[i] if counts[i] < rem else rem\\n            res = res * pow(nums[i], t, mod) % mod\\n            rem -= t\\n\\n        return res\\n\"",
  "3381_14631217_python-updated-time": "1747422704711",
  "2139_14631217_python-updated-time": "1746718179183",
  "2386_14631217_python-updated-time": "1746881886808",
  "380_14631217_python-updated-time": "1745354816499",
  "3856_14631217_python-updated-time": "1747684111741",
  "1096_14631217_python": "\"class Solution:\\n    def maxSumTwoNoOverlap(self, nums, firstLen, secondLen):\\n        n = len(nums)\\n        # prefix sums\\n        pre = [0] * (n + 1)\\n        for i in range(n):\\n            pre[i+1] = pre[i] + nums[i]\\n        # sums of windows\\n        A = [0] * n  # firstLen-window ending at i\\n        B = [0] * n  # secondLen-window ending at i\\n        for i in range(firstLen - 1, n):\\n            A[i] = pre[i+1] - pre[i+1-firstLen]\\n        for i in range(secondLen - 1, n):\\n            B[i] = pre[i+1] - pre[i+1-secondLen]\\n        # best prefix maxima\\n        bestA = [0] * n\\n        bestB = [0] * n\\n        best = 0\\n        for i in range(n):\\n            best = max(best, A[i])\\n            bestA[i] = best\\n        best = 0\\n        for i in range(n):\\n            best = max(best, B[i])\\n            bestB[i] = best\\n        # combine: A before B or B before A\\n        ans = 0\\n        # A before B\\n        for i in range(secondLen, n):\\n            ans = max(ans, bestA[i-secondLen] + B[i])\\n        # B before A\\n        for i in range(firstLen, n):\\n            ans = max(ans, bestB[i-firstLen] + A[i])\\n        return ans\\n\"",
  "1319_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def uniqueOccurrences(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        freq = Counter(arr).values()\\n        return len(freq) == len(set(freq))\\n\"",
  "3437_14631217_python": "\"import bisect\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def maximumTotalDamage(self, power):\\n        \\\"\\\"\\\"\\n        :type power: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = None  # not needed here, sums stay within Python int\\n        \\n        # 1) Build weight for each distinct damage value\\n        cnt = Counter(power)\\n        vals = sorted(cnt)\\n        m = len(vals)\\n        wt   = [v*cnt[v] for v in vals]\\n        \\n        # 2) DP array\\n        dp = [0]*m\\n        \\n        # Base case: either take the first value or not\\n        dp[0] = wt[0]\\n        \\n        for i in range(1, m):\\n            # Option A: skip vals[i]\\n            best = dp[i-1]\\n            \\n            # Option B: take vals[i]\\n            # find rightmost j < i with vals[j] <= vals[i]-3\\n            # bisect_right returns first index > (vals[i]-3), so minus one gives j\\n            threshold = vals[i] - 3\\n            j = bisect.bisect_right(vals, threshold, 0, i) - 1\\n            \\n            take = wt[i] + (dp[j] if j >= 0 else 0)\\n            dp[i] = max(best, take)\\n        \\n        return dp[-1]\\n\"",
  "1832_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def minOperations(self, target, arr):\\n        \\\"\\\"\\\"\\n        :type target: List[int]\\n        :type arr:    List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Map each value in target to its index\\n        pos = {val: i for i, val in enumerate(target)}\\n        \\n        # Build the sequence of target-indices for elements in arr that appear in target\\n        seq = [pos[x] for x in arr if x in pos]\\n        \\n        # Find length of Longest Increasing Subsequence in seq\\n        tails = []\\n        for x in seq:\\n            # Find insertion point for x in tails to keep it strictly increasing\\n            idx = bisect.bisect_left(tails, x)\\n            if idx == len(tails):\\n                tails.append(x)\\n            else:\\n                tails[idx] = x\\n        \\n        # We need to insert the missing elements of target\\n        return len(target) - len(tails)\\n\"",
  "2320_14631217_python": "\"class Solution(object):\\n    def findKDistantIndices(self, nums, key, k):\\n        n = len(nums)\\n        keep = set()\\n        for i, v in enumerate(nums):\\n            if v == key:\\n                keep.update(xrange(max(0, i - k), min(n - 1, i + k) + 1))\\n        return sorted(keep)\\n\"",
  "32_14631217_python-updated-time": "1744988489241",
  "2184_14631217_python-updated-time": "1746720782070",
  "1549_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums, limit):\\n        max_deque = deque()  # To keep track of maximum elements in the current window\\n        min_deque = deque()  # To keep track of minimum elements in the current window\\n        \\n        left = 0\\n        max_length = 0\\n        \\n        for right in range(len(nums)):\\n            # Maintain the max deque (elements in decreasing order)\\n            while max_deque and nums[max_deque[-1]] <= nums[right]:\\n                max_deque.pop()\\n            max_deque.append(right)\\n            \\n            # Maintain the min deque (elements in increasing order)\\n            while min_deque and nums[min_deque[-1]] >= nums[right]:\\n                min_deque.pop()\\n            min_deque.append(right)\\n            \\n            # Ensure that the difference between max and min is within the limit\\n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\\n                left += 1\\n                # Remove elements outside the current window\\n                if max_deque[0] < left:\\n                    max_deque.popleft()\\n                if min_deque[0] < left:\\n                    min_deque.popleft()\\n            \\n            # Update the max length of the valid window\\n            max_length = max(max_length, right - left + 1)\\n        \\n        return max_length\\n\"",
  "3065_14631217_pythondata": "\"import pandas as pd\\n\\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\\n    return employees.head(3)\\n\"",
  "467_14631217_python-updated-time": "1745359838156",
  "1491_14631217_python": "\"class Solution(object):\\n    def numTimesAllBlue(self, flips):\\n        res = 0\\n        max_flip = 0\\n\\n        for i, flip in enumerate(flips, 1):\\n            max_flip = max(max_flip, flip)\\n            if max_flip == i:\\n                res += 1\\n\\n        return res\\n\"",
  "3611_14631217_python": "\"class Solution(object):\\n    def minBitwiseArray(self, nums):\\n        ans = []\\n        for num in nums:\\n            res = -1\\n            for k in range(num.bit_length()):\\n                x = num - (1 << k)\\n                if x < 0:\\n                    continue\\n                if (x | (x + 1)) == num:\\n                    if res == -1 or x < res:\\n                        res = x\\n            ans.append(res)\\n        return ans\\n\"",
  "2753_14631217_python": "\"# define gcd since math.gcd may not be available\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Count existing ones\\n        ones = nums.count(1)\\n        # If all are ones, no operations needed\\n        if ones == n:\\n            return 0\\n        # If there is at least one 1, we can convert others by neighboring gcd operations\\n        if ones > 0:\\n            return n - ones\\n\\n        # Otherwise, no initial 1s: we need to create a 1 via gcd on some subarray\\n        best = float('inf')\\n        for i in range(n):\\n            current = nums[i]\\n            for j in range(i+1, n):\\n                current = gcd(current, nums[j])\\n                if current == 1:\\n                    # j-i operations to yield first 1\\n                    best = min(best, j - i)\\n                    break\\n\\n        # If no subarray gcd reduces to 1, impossible\\n        if best == float('inf'):\\n            return -1\\n\\n        # Cost = operations to make first 1 + spread to others\\n        return best + (n - 1)\"",
  "3687_14631217_python-updated-time": "1747659184249",
  "2583_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def magnificentSets(self, n, edges):\\n        # build adjacency list\\n        adj = [[] for _ in range(n+1)]\\n        for a, b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        visited = [False] * (n+1)\\n        color = [0] * (n+1)\\n        ans = 0\\n        # process each connected component\\n        for u in range(1, n+1):\\n            if not visited[u]:\\n                # BFS to collect component and check bipartiteness\\n                comp = []\\n                q = deque([u])\\n                visited[u] = True\\n                color[u] = 0\\n                comp.append(u)\\n                while q:\\n                    x = q.popleft()\\n                    for y in adj[x]:\\n                        if not visited[y]:\\n                            visited[y] = True\\n                            color[y] = 1 - color[x]\\n                            q.append(y)\\n                            comp.append(y)\\n                        else:\\n                            if color[y] == color[x]:\\n                                return -1\\n                # compute diameter of this component\\n                diameter = 0\\n                for w in comp:\\n                    # BFS from w to get max distance\\n                    dist = {w: 0}\\n                    dq = deque([w])\\n                    while dq:\\n                        v = dq.popleft()\\n                        for nei in adj[v]:\\n                            if nei not in dist:\\n                                dist[nei] = dist[v] + 1\\n                                dq.append(nei)\\n                    diameter = max(diameter, max(dist.values()))\\n                # maximum groups from this component\\n                ans += diameter + 1\\n        return ans\\n\"",
  "1881_14631217_python-updated-time": "1746531590372",
  "3792_14631217_mysql-updated-time": "1747679941931",
  "3309_14631217_python": "\"class Solution(object):\\n    def countPrefixSuffixPairs(self, words):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        n = len(words)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a, b = words[i], words[j]\\n                if len(a) <= len(b) and b.startswith(a) and b.endswith(a):\\n                    count += 1\\n        return count\\n\"",
  "1978_14631217_python-updated-time": "1746624825443",
  "2780_14631217_python-updated-time": "1747137597945",
  "46_14631217_python-updated-time": "1744999503697",
  "859_14631217_python-updated-time": "1745782492362",
  "47_14631217_python-updated-time": "1744999540136",
  "2736_14631217_python-updated-time": "1747136086599",
  "2533_14631217_python": "\"class Solution:\\n    def xorAllNums(self, nums1, nums2):\\n        xor1 = 0\\n        for x in nums1:\\n            xor1 ^= x\\n        xor2 = 0\\n        for x in nums2:\\n            xor2 ^= x\\n\\n        res = 0\\n        # If len(nums2) is odd, xor1 contributes\\n        if len(nums2) & 1:\\n            res ^= xor1\\n        # If len(nums1) is odd, xor2 contributes\\n        if len(nums1) & 1:\\n            res ^= xor2\\n        return res\\n\"",
  "2747_14631217_javascript": "\"function map(arr, fn) {\\n  const result = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    result.push(fn(arr[i], i));\\n  }\\n  return result;\\n}\\n\"",
  "3260_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n     def minimumCost(self, nums, k, dist):\\n         import heapq\\n         n = len(nums)\\n         id_of_index = [0] * n\\n         maxA = []      # max-heap (store negatives) of the current k-1 smallest\\n         minB = []      # min-heap of the rest\\n         id2set = {}    # maps id -> 'A' or 'B'\\n         removed = set()\\n         sizeA = sizeB = 0\\n         sumA = 0\\n         uid = 0\\n\\n         def pruneA():\\n             while maxA:\\n                 val, iid = maxA[0]\\n                 if iid in removed:\\n                     heapq.heappop(maxA)\\n                     removed.remove(iid)\\n                 else:\\n                     break\\n\\n         def pruneB():\\n             while minB:\\n                 val, iid = minB[0]\\n                 if iid in removed:\\n                     heapq.heappop(minB)\\n                     removed.remove(iid)\\n                 else:\\n                     break\\n\\n         # --- build the initial window [1..r] exactly as before ---\\n         r = min(n-1, dist+1)\\n         for i in xrange(1, r+1):\\n             x = nums[i]\\n             uid += 1\\n             iid = uid\\n             id_of_index[i] = iid\\n             if sizeA < k-1:\\n                 heapq.heappush(maxA, (-x, iid))\\n                 id2set[iid] = 'A'\\n                 sizeA += 1\\n                 sumA += x\\n             else:\\n                 pruneA()\\n                 maxA_val = -maxA[0][0]\\n                 if x < maxA_val:\\n                     # swap out the current largest of A\\n                     neg_y, yid = heapq.heappop(maxA)\\n                     y = -neg_y\\n                     sizeA -= 1\\n                     sumA -= y\\n                     heapq.heappush(minB, (y, yid))\\n                     id2set[yid] = 'B'\\n                     sizeB += 1\\n                     # insert the new x into A\\n                     heapq.heappush(maxA, (-x, iid))\\n                     id2set[iid] = 'A'\\n                     sizeA += 1\\n                     sumA += x\\n                 else:\\n                     heapq.heappush(minB, (x, iid))\\n                     id2set[iid] = 'B'\\n                     sizeB += 1\\n\\n         ans = float('inf')\\n         prev_r = r\\n\\n         # --- slide the window's left edge from 1 up to n-k+1 ---\\n         for l in xrange(1, n - k + 2):\\n             ans = min(ans, sumA)\\n             if l == n - k + 1:\\n                 break\\n\\n             # remove the outgoing index l\\n             iid_out = id_of_index[l]\\n             if id2set[iid_out] == 'A':\\n                 sizeA -= 1\\n                 sumA -= nums[l]\\n             else:\\n                 sizeB -= 1\\n             removed.add(iid_out)\\n\\n             # add the new element at prev_r+1, if any\\n             if prev_r < n - 1:\\n                 new_r = prev_r + 1\\n                 x = nums[new_r]\\n                 uid += 1\\n                 nid = uid\\n                 id_of_index[new_r] = nid\\n\\n                 # **always** compare to max of A, then push\\n                 pruneA()\\n                 pruneB()\\n                 if maxA and x < -maxA[0][0]:\\n                     heapq.heappush(maxA, (-x, nid))\\n                     id2set[nid] = 'A'\\n                     sizeA += 1\\n                     sumA += x\\n                 else:\\n                     heapq.heappush(minB, (x, nid))\\n                     id2set[nid] = 'B'\\n                     sizeB += 1\\n\\n                 prev_r = new_r\\n\\n             # now rebalance to restore sizeA == k-1\\n             pruneA()\\n             pruneB()\\n             while sizeA < k-1:\\n                 pruneB()\\n                 y, yid = heapq.heappop(minB)\\n                 sizeB -= 1\\n                 heapq.heappush(maxA, (-y, yid))\\n                 id2set[yid] = 'A'\\n                 sizeA += 1\\n                 sumA += y\\n             while sizeA > k-1:\\n                 pruneA()\\n                 neg_y, yid = heapq.heappop(maxA)\\n                 y = -neg_y\\n                 sizeA -= 1\\n                 sumA -= y\\n                 heapq.heappush(minB, (y, yid))\\n                 id2set[yid] = 'B'\\n                 sizeB += 1\\n\\n         return nums[0] + ans\\n\"",
  "817_14631217_python": "\"class MyHashMap(object):\\n    def __init__(self):\\n        # key range is [0, 10^6], so we allocate size 10^6+1\\n        self.size = 10**6 + 1\\n        # Initialize all entries to -1, meaning \\\"no mapping\\\"\\n        self.data = [-1] * self.size\\n\\n    def put(self, key, value):\\n        \\\"\\\"\\\"\\n        Insert a (key, value) pair into the HashMap.\\n        If the key already exists, update its value.\\n        \\\"\\\"\\\"\\n        self.data[key] = value\\n\\n    def get(self, key):\\n        \\\"\\\"\\\"\\n        Return the value to which the specified key is mapped,\\n        or -1 if this map contains no mapping for the key.\\n        \\\"\\\"\\\"\\n        return self.data[key]\\n\\n    def remove(self, key):\\n        \\\"\\\"\\\"\\n        Remove the mapping for the specified key, if it exists.\\n        \\\"\\\"\\\"\\n        self.data[key] = -1\\n\"",
  "3688_14631217_python": "\"class Solution(object):\\n    def maxSubarraySum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n == 1:                         # cannot delete the only element\\n            return nums[0]\\n\\n        INF = 10 ** 18\\n\\n        # --------  segment tree  ------------------------------------------\\n        size = 1\\n        while size < n:\\n            size <<= 1                    # power of two ≥ n\\n\\n        total  = [0]           * (2 * size)\\n        prefix = [-INF]        * (2 * size)\\n        suffix = [-INF]        * (2 * size)\\n        best   = [-INF]        * (2 * size)\\n\\n        # leaves\\n        for i, v in enumerate(nums):\\n            idx = size + i\\n            total[idx] = prefix[idx] = suffix[idx] = best[idx] = v\\n        # internal nodes\\n        for i in range(size - 1, 0, -1):\\n            l, r = i * 2, i * 2 + 1\\n            total[i]  = total[l] + total[r]\\n            prefix[i] = max(prefix[l], total[l] + prefix[r])\\n            suffix[i] = max(suffix[r], total[r] + suffix[l])\\n            best[i]   = max(best[l], best[r], suffix[l] + prefix[r])\\n\\n        def combine(a, b):\\n            \\\"\\\"\\\"combine two 4-tuples\\\"\\\"\\\"\\n            if a is None:\\n                return b\\n            if b is None:\\n                return a\\n            at, ap, asu, ab = a\\n            bt, bp, bs, bb = b\\n            nt  = at + bt\\n            np  = max(ap, at + bp)\\n            ns  = max(bs, bt + asu)\\n            nb  = max(ab, bb, asu + bp)\\n            return (nt, np, ns, nb)\\n\\n        def query(l, r):\\n            \\\"\\\"\\\"inclusive range query\\\"\\\"\\\"\\n            l += size\\n            r += size + 1\\n            left = right = None\\n            while l < r:\\n                if l & 1:\\n                    left  = combine(left,\\n                                     (total[l], prefix[l], suffix[l], best[l]))\\n                    l += 1\\n                if r & 1:\\n                    r -= 1\\n                    right = combine((total[r], prefix[r], suffix[r], best[r]),\\n                                     right)\\n                l //= 2\\n                r //= 2\\n            return combine(left, right)\\n\\n        # -------------------------------------------------------------------\\n        from collections import defaultdict\\n        pos = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            pos[v].append(i)\\n\\n        answer = best[1]                  # no-deletion answer\\n\\n        for v, idxs in pos.items():\\n            if len(idxs) == n:            # removing v empties the array\\n                continue\\n            prev = 0\\n            agg = None\\n            for p in idxs:\\n                if prev <= p - 1:         # segment before this v\\n                    agg = combine(agg, query(prev, p - 1))\\n                prev = p + 1\\n            if prev <= n - 1:             # tail segment\\n                agg = combine(agg, query(prev, n - 1))\\n            answer = max(answer, agg[3])  # agg[3] == best subarray\\n\\n        return answer\\n\"",
  "3785_14631217_python": "\"class Solution(object):\\n    def countArrays(self, original, bounds):\\n        \\\"\\\"\\\"\\n        :type original: List[int]\\n        :type bounds: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(original)\\n        base = original[0]\\n        # Initial lower/upper bounds on copy[0] from i = 0\\n        lb, ub = bounds[0][0], bounds[0][1]\\n\\n        # Incorporate constraints from each position i\\n        for i in range(1, n):\\n            offset = original[i] - base\\n            ui, vi = bounds[i]\\n            lb = max(lb, ui - offset)\\n            ub = min(ub, vi - offset)\\n            if lb > ub:\\n                return 0\\n\\n        # Number of integer choices for copy[0]\\n        return ub - lb + 1\\n\"",
  "1450_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nimport sys\\nsys.setrecursionlimit(10000)\\n\\nclass Solution:\\n    def removeLeafNodes(self, root, target):\\n        def dfs(node):\\n            if not node:\\n                return None\\n            node.left = dfs(node.left)\\n            node.right = dfs(node.right)\\n            # If it's now a leaf with value == target, remove it\\n            if not node.left and not node.right and node.val == target:\\n                return None\\n            return node\\n        \\n        return dfs(root)\\n\"",
  "1776_14631217_python-updated-time": "1746445477170",
  "114_14631217_python-updated-time": "1745081358358",
  "3568_14631217_python-updated-time": "1747570032383",
  "591_14631217_python": "\"class Solution(object):\\n    def isValid(self, code):\\n        \\\"\\\"\\\"\\n        :type code: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        MOD = 10**9+7\\n        n = len(code)\\n        stack = []\\n        i = 0\\n\\n        # Must start with an opening tag\\n        if n < 7 or code[0] != '<' or code[1] in ('/', '!'):\\n            return False\\n\\n        while i < n:\\n            if code[i] != '<':\\n                # text outside any open tag is invalid\\n                if not stack:\\n                    return False\\n                i += 1\\n                continue\\n\\n            # CDATA section\\n            if i + 9 <= n and code[i:i+9] == '<![CDATA[':\\n                if not stack:\\n                    return False\\n                j = code.find(']]>', i+9)\\n                if j < 0:\\n                    return False\\n                i = j + 3\\n\\n            # Closing tag\\n            elif i + 2 < n and code[i+1] == '/':\\n                j = code.find('>', i+2)\\n                if j < 0:\\n                    return False\\n                tagname = code[i+2:j]\\n                # stricter check: only A–Z letters, length 1–9\\n                if not (1 <= len(tagname) <= 9 and tagname.isalpha() and tagname.isupper()):\\n                    return False\\n                # must match the top of the stack\\n                if not stack or stack[-1] != tagname:\\n                    return False\\n                stack.pop()\\n                i = j + 1\\n                # if we've just closed the root, we must be at the very end\\n                if not stack and i != n:\\n                    return False\\n\\n            # Opening tag\\n            else:\\n                j = code.find('>', i+1)\\n                if j < 0:\\n                    return False\\n                tagname = code[i+1:j]\\n                if not (1 <= len(tagname) <= 9 and tagname.isalpha() and tagname.isupper()):\\n                    return False\\n                stack.append(tagname)\\n                i = j + 1\\n\\n        # all tags should be closed\\n        return not stack\\n\"",
  "748_14631217_python-updated-time": "1745875480143",
  "2326_14631217_python": "\"class Solution(object):\\n    def sumScores(self, s):\\n        n = len(s)\\n        Z = [0] * n\\n        l = r = 0\\n        for i in xrange(1, n):\\n            if i <= r:\\n                k = i - l\\n                if Z[k] < r - i + 1:\\n                    Z[i] = Z[k]\\n                else:\\n                    j = r + 1\\n                    while j < n and s[j] == s[j - i]:\\n                        j += 1\\n                    Z[i] = j - i\\n                    l, r = i, j - 1\\n            else:\\n                j = 0\\n                while i + j < n and s[j] == s[i + j]:\\n                    j += 1\\n                Z[i] = j\\n                if j > 0:\\n                    l, r = i, i + j - 1\\n        return n + sum(Z)\\n\"",
  "3477_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        flips = 0\\n        parity = 0      # how many flips we've done so far, mod 2\\n        for x in nums:\\n            # x ^ parity is the effective bit after applying all previous suffix-flips\\n            if x ^ parity == 0:\\n                flips += 1\\n                parity ^= 1\\n        return flips\\n\"",
  "2180_14631217_python": "\"from bisect import bisect_left\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        tasks.sort()\\n        workers.sort()\\n        n, m = len(tasks), len(workers)\\n\\n        def can_do(k):\\n            # Try to assign the k easiest tasks using the k strongest workers\\n            ws = workers[-k:]      # take k strongest\\n            pills_left = pills\\n            # We'll keep ws as a sorted list and remove one worker per task\\n            for t in reversed(tasks[:k]):\\n                # 1) try to find a worker who can do it without a pill\\n                i = bisect_left(ws, t)\\n                if i < len(ws):\\n                    ws.pop(i)\\n                else:\\n                    # 2) otherwise try to find a worker who with a pill can do it\\n                    #    i.e. w + strength >= t  ⇒  w >= t − strength\\n                    j = bisect_left(ws, t - strength)\\n                    if j < len(ws) and pills_left > 0:\\n                        ws.pop(j)\\n                        pills_left -= 1\\n                    else:\\n                        return False\\n            return True\\n\\n        # binary search the maximum k\\n        lo, hi, ans = 0, min(n, m), 0\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if can_do(mid):\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return ans\\n\"",
  "2154_14631217_python": "\"class Solution(object):\\n    def minimumMoves(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        i = 0\\n        moves = 0\\n        while i < len(s):\\n            if s[i] == 'X':\\n                moves += 1\\n                i += 3  # skip the next 3 positions, as they get turned to 'O'\\n            else:\\n                i += 1\\n        return moves\\n\"",
  "3580_14631217_python-updated-time": "1747575254490",
  "1858_14631217_python": "\"class Solution:\\n    def maximumTime(self, time):\\n        t = list(time)\\n        \\n        # Hour tens\\n        if t[0] == '?':\\n            if t[1] == '?' or t[1] <= '3':\\n                t[0] = '2'\\n            else:\\n                t[0] = '1'\\n        \\n        # Hour units\\n        if t[1] == '?':\\n            if t[0] == '2':\\n                t[1] = '3'\\n            else:\\n                t[1] = '9'\\n        \\n        # Minute tens\\n        if t[3] == '?':\\n            t[3] = '5'\\n        \\n        # Minute units\\n        if t[4] == '?':\\n            t[4] = '9'\\n        \\n        return \\\"\\\".join(t)\\n\"",
  "2215_14631217_python-updated-time": "1746729680680",
  "3535_14631217_python-updated-time": "1747501330775",
  "714_14631217_python-updated-time": "1745786583938",
  "3264_14631217_python": "\"class Solution(object):\\n    def maximumPoints(self, enemyEnergies, currentEnergy):\\n        \\\"\\\"\\\"\\n        :type enemyEnergies: List[int]\\n        :type currentEnergy: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # cheapest attack‐cost\\n        f = min(enemyEnergies)\\n        # need at least one attack to unlock any rests\\n        if currentEnergy < f:\\n            return 0\\n        # leave one cheapest enemy unmarked so we can keep using it for attacks,\\n        # rest on all the others to pool their energy,\\n        # then do all possible attacks on the cheapest.\\n        total = sum(enemyEnergies)\\n        # formula derived: final points = floor((E0 + (sum_all - f)) / f)\\n        return (currentEnergy + total - f) // f\\n\"",
  "1244_14631217_python-updated-time": "1746261169612",
  "2408_14631217_python": "\"class Solution(object):\\n    def peopleAwareOfSecret(self, n, delay, forget):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type delay: int\\n        :type forget: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        \\n        # dp[i] = number of people who learn the secret on day i\\n        dp = [0] * (n + 1)\\n        dp[1] = 1\\n        \\n        # prefix[i] = dp[1] + dp[2] + ... + dp[i]\\n        prefix = [0] * (n + 1)\\n        prefix[1] = 1\\n        \\n        for day in range(2, n + 1):\\n            # j can share on 'day' if:\\n            #   day - j >= delay  -->  j <= day - delay\\n            #   day - j < forget  -->  j >  day - forget\\n            lo = day - forget + 1\\n            hi = day - delay\\n            if hi >= 1:\\n                lo = max(lo, 1)\\n                dp[day] = (prefix[hi] - prefix[lo - 1]) % MOD\\n            else:\\n                dp[day] = 0\\n            \\n            prefix[day] = (prefix[day - 1] + dp[day]) % MOD\\n        \\n        # People who still remember the secret on day n\\n        # are those who learned on days j where j + forget > n\\n        #   j > n - forget\\n        cutoff = n - forget\\n        if cutoff >= 1:\\n            ans = (prefix[n] - prefix[cutoff]) % MOD\\n        else:\\n            ans = prefix[n] % MOD\\n        \\n        return ans\\n\"",
  "1148_14631217_python-updated-time": "1746107864714",
  "2716_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def primeSubOperation(self, nums):\\n        # Precompute all primes up to max(nums)\\n        M = max(nums)\\n        is_prime = [True] * (M+1)\\n        is_prime[0] = is_prime[1] = False\\n        for i in range(2, int(M**0.5)+1):\\n            if is_prime[i]:\\n                for j in range(i*i, M+1, i):\\n                    is_prime[j] = False\\n        primes = [p for p in range(2, M+1) if is_prime[p]]\\n        \\n        prev = -10**18\\n        # Process each position\\n        for x in nums:\\n            # build all possible new values: x itself + x-p for prime p<x\\n            # (we want them sorted so we can binary-search)\\n            cand = [x]\\n            for p in primes:\\n                if p >= x:\\n                    break\\n                cand.append(x - p)\\n            cand.sort()\\n            \\n            # pick the smallest candidate > prev\\n            j = bisect.bisect_right(cand, prev)\\n            if j == len(cand):\\n                return False\\n            prev = cand[j]\\n        return True\\n\"",
  "1925_14631217_python-updated-time": "1746543649100",
  "2889_14631217_python-updated-time": "1747222167429",
  "1080_14631217_python": "\"class Solution:\\n    def camelMatch(self, queries, pattern):\\n        def matches(query):\\n            p = 0\\n            for c in query:\\n                if p < len(pattern) and c == pattern[p]:\\n                    p += 1\\n                elif c.isupper():\\n                    return False\\n            return p == len(pattern)\\n\\n        return [matches(q) for q in queries]\\n\"",
  "38_14631217_python-updated-time": "1744988732255",
  "1435_14631217_python": "\"class Solution:\\n    def xorQueries(self, arr, queries):\\n        prefix = [0]\\n        for num in arr:\\n            prefix.append(prefix[-1] ^ num)\\n        return [prefix[r + 1] ^ prefix[l] for l, r in queries]\\n\"",
  "2165_14631217_python-updated-time": "1746720424335",
  "2633_14631217_python-updated-time": "1747061843102",
  "398_14631217_python": "\"import random\\n\\nclass Solution:\\n    def __init__(self, nums):\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        indices = [i for i, num in enumerate(self.nums) if num == target]\\n        return random.choice(indices)\\n\"",
  "3311_14631217_python-updated-time": "1747413386853",
  "1185_14631217_python-updated-time": "1746108355472",
  "3436_14631217_python": "\"class Solution(object):\\n    def minimumDifference(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # dp_set holds all distinct OR‐values of subarrays ending at the previous index\\n        dp_set = set()\\n        ans = float('inf')\\n        \\n        for num in nums:\\n            # Build the new set of OR‐values for subarrays ending here:\\n            # either start at this num, or extend each previous subarray by OR’ing with num\\n            new_set = {num}\\n            for prev_or in dp_set:\\n                new_set.add(prev_or | num)\\n            \\n            # Check each OR‐value’s distance to k\\n            for val in new_set:\\n                diff = abs(k - val)\\n                if diff < ans:\\n                    ans = diff\\n                    # early exit if we hit zero\\n                    if ans == 0:\\n                        return 0\\n            \\n            # Move forward\\n            dp_set = new_set\\n        \\n        return ans\\n\"",
  "237_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def deleteNode(self, node):\\n        \\\"\\\"\\\"\\n        :type node: ListNode\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        node.val = node.next.val\\n        node.next = node.next.next\\n\"",
  "3732_14631217_python": "\"class Solution(object):\\n    def calculateScore(self, instructions, values):\\n        \\\"\\\"\\\"\\n        :type instructions: List[str]\\n        :type values: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(instructions)\\n        visited = set()\\n        score = 0\\n        i = 0\\n\\n        while 0 <= i < n and i not in visited:\\n            visited.add(i)\\n            instr = instructions[i]\\n            val = values[i]\\n\\n            if instr == \\\"add\\\":\\n                score += val\\n                i += 1\\n            else:  # \\\"jump\\\"\\n                i += val\\n\\n        return score\\n\"",
  "33_14631217_python-updated-time": "1744988522825",
  "2227_14631217_python": "\"class Solution:\\n    def subArrayRanges(self, nums):\\n        total = 0\\n        n = len(nums)\\n\\n        for i in range(n):\\n            max_val = min_val = nums[i]\\n            for j in range(i, n):\\n                max_val = max(max_val, nums[j])\\n                min_val = min(min_val, nums[j])\\n                total += max_val - min_val\\n\\n        return total\\n\"",
  "3314_14631217_python": "\"class Solution(object):\\n    def mostFrequentPrime(self, mat):\\n        from collections import defaultdict\\n\\n        # Check if number is prime (only called for numbers > 10)\\n        def is_prime(n):\\n            if n < 2:\\n                return False\\n            if n == 2:\\n                return True\\n            if n % 2 == 0:\\n                return False\\n            i = 3\\n            while i * i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n\\n        m, n = len(mat), len(mat[0])\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1),\\n                      (-1, -1), (-1, 1), (1, -1), (1, 1)]\\n\\n        count = defaultdict(int)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                for dx, dy in directions:\\n                    x, y = i, j\\n                    num = ''\\n                    while 0 <= x < m and 0 <= y < n:\\n                        num += str(mat[x][y])\\n                        val = int(num)\\n                        if val > 10 and is_prime(val):\\n                            count[val] += 1\\n                        x += dx\\n                        y += dy\\n\\n        if not count:\\n            return -1\\n\\n        max_freq = max(count.values())\\n        best = -1\\n        for num in count:\\n            if count[num] == max_freq:\\n                best = max(best, num)\\n        return best\\n\"",
  "750_14631217_python": "\"class Solution(object):\\n    def containVirus(self, isInfected):\\n        m, n = len(isInfected), len(isInfected[0])\\n        ans = 0\\n        \\n        while True:\\n            regions = []\\n            frontiers = []\\n            walls = []\\n            visited = [[0] * n for _ in range(m)]\\n            \\n            for i in range(m):\\n                for j in range(n):\\n                    if isInfected[i][j] == 1 and not visited[i][j]:\\n                        region = []\\n                        frontier = set()\\n                        wall = 0\\n                        stack = [(i, j)]\\n                        visited[i][j] = 1\\n                        while stack:\\n                            x, y = stack.pop()\\n                            region.append((x, y))\\n                            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                                nx, ny = x + dx, y + dy\\n                                if 0 <= nx < m and 0 <= ny < n:\\n                                    if isInfected[nx][ny] == 0:\\n                                        frontier.add((nx, ny))\\n                                        wall += 1\\n                                    elif isInfected[nx][ny] == 1 and not visited[nx][ny]:\\n                                        visited[nx][ny] = 1\\n                                        stack.append((nx, ny))\\n                        regions.append(region)\\n                        frontiers.append(frontier)\\n                        walls.append(wall)\\n            \\n            if not regions:\\n                break\\n            \\n            idx = frontiers.index(max(frontiers, key=len))\\n            ans += walls[idx]\\n            \\n            for i, region in enumerate(regions):\\n                if i == idx:\\n                    for x, y in region:\\n                        isInfected[x][y] = -1\\n                else:\\n                    for x, y in frontiers[i]:\\n                        isInfected[x][y] = 1\\n                        \\n        return ans\\n\"",
  "2780_14631217_python": "\"class Solution(object):\\n    def minIncrements(self, n, cost):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type cost: List[int]\\n        :rtype: int\\n        Returns the minimum number of increments to equalize all root-to-leaf path sums.\\n        Perfect binary tree stored as 1-indexed: node i has children 2*i and 2*i+1.\\n        cost array is 0-indexed for nodes 1..n at cost[i-1].\\n        \\\"\\\"\\\"\\n        # Use recursion with post-order traversal\\n        self.ans = 0\\n        # define dfs on 1-indexed node\\n        def dfs(i):\\n            # if leaf node\\n            left_idx = 2 * i\\n            if left_idx > n:\\n                # leaf: path sum from i down is cost[i-1]\\n                return cost[i-1]\\n            # internal node: compute children's max path sums\\n            right_idx = left_idx + 1\\n            left_sum = dfs(left_idx)\\n            right_sum = dfs(right_idx)\\n            # balance children by incrementing the smaller subtree\\n            if left_sum > right_sum:\\n                self.ans += left_sum - right_sum\\n            else:\\n                self.ans += right_sum - left_sum\\n            # return path sum from current node including the larger child's sum\\n            return cost[i-1] + max(left_sum, right_sum)\\n\\n        dfs(1)\\n        return self.ans\"",
  "2793_14631217_python-updated-time": "1747138783871",
  "3427_14631217_python-updated-time": "1747482870323",
  "1613_14631217_python-updated-time": "1746432922441",
  "2357_14631217_python-updated-time": "1746881390554",
  "897_14631217_python": "\"class Solution(object):\\n    def primePalindrome(self, n):\\n        def is_prime(x):\\n            if x < 2: return False\\n            if x == 2: return True\\n            if x % 2 == 0: return False\\n            i = 3\\n            while i * i <= x:\\n                if x % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        if 8 <= n <= 11:\\n            return 11\\n\\n        for length in range(1, 6):\\n            for half in range(10**(length - 1), 10**length):\\n                s = str(half)\\n                p = int(s + s[-2::-1])\\n                if p >= n and is_prime(p):\\n                    return p\\n\"",
  "382_14631217_python-updated-time": "1745355114616",
  "1224_14631217_python-updated-time": "1746260335050",
  "879_14631217_python-updated-time": "1745880278524",
  "1010_14631217_python-updated-time": "1746039803811",
  "520_14631217_python": "\"class Solution:\\n    def detectCapitalUse(self, word):\\n        return word.isupper() or word.islower() or word.istitle()\\n\"",
  "2873_14631217_python": "\"class Solution:\\n    def findPrimePairs(self, n):\\n        if n < 3:\\n            return []\\n\\n        # Sieve of Eratosthenes to find all primes up to n\\n        is_prime = [False, False] + [True] * (n - 1)\\n        for i in range(2, int(n**0.5) + 1):\\n            if is_prime[i]:\\n                for j in range(i * i, n + 1, i):\\n                    is_prime[j] = False\\n\\n        result = []\\n        for x in range(2, n // 2 + 1):\\n            y = n - x\\n            if is_prime[x] and is_prime[y]:\\n                result.append([x, y])\\n\\n        return result\\n\"",
  "2503_14631217_python": "\"class Solution:\\n    def longestSubarray(self, nums):\\n        # The maximum AND of any subarray is the maximum element.\\n        k = max(nums)\\n        max_len = 0\\n        curr = 0\\n        \\n        for x in nums:\\n            # Only elements that have all bits of k can form a subarray with AND == k\\n            if x & k == k:\\n                curr += 1\\n                max_len = max(max_len, curr)\\n            else:\\n                curr = 0\\n        \\n        return max_len\\n\"",
  "1813_14631217_python-updated-time": "1746453232189",
  "3631_14631217_python": "\"class Solution(object):\\n    def countKReducibleNumbers(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(s)\\n\\n        # Precompute factorials and inv factorials for C(n, k)\\n        max_n = n\\n        fact = [1] * (max_n + 1)\\n        inv  = [1] * (max_n + 1)\\n        for i in range(1, max_n + 1):\\n            fact[i] = fact[i-1] * i % MOD\\n        inv[max_n] = pow(fact[max_n], MOD-2, MOD)\\n        for i in range(max_n, 0, -1):\\n            inv[i-1] = inv[i] * i % MOD\\n\\n        def comb(a, b):\\n            if b < 0 or b > a:\\n                return 0\\n            return fact[a] * inv[b] % MOD * inv[a-b] % MOD\\n\\n        # Precompute f[c] = # operations to reduce c → 1 by replacing with popcount\\n        pop = [bin(i).count('1') for i in range(n+1)]\\n        f   = [-1] * (n+1)\\n        f[1] = 0\\n        def getf(x):\\n            if f[x] != -1:\\n                return f[x]\\n            f[x] = 1 + getf(pop[x])\\n            return f[x]\\n        for i in range(2, n+1):\\n            getf(i)\\n\\n        # Which popcounts p satisfy 1 + f(p) ≤ k  ⇔  f(p) ≤ k-1\\n        good = [False] * (n+1)\\n        for p in range(1, n+1):\\n            if f[p] <= k-1:\\n                good[p] = True\\n\\n        # DP to count how many x < s have exactly p ones\\n        counts = [0] * (n+1)\\n        ones_so_far = 0\\n        for i, ch in enumerate(s):\\n            if ch == '1':\\n                rem = n - i - 1\\n                for j in range(rem+1):\\n                    counts[ones_so_far + j] = (counts[ones_so_far + j] + comb(rem, j)) % MOD\\n                ones_so_far += 1\\n\\n        # Exclude x = 0 (popcount = 0), since we only want positive integers\\n        counts[0] = 0\\n\\n        # Sum over all popcounts that are “good”\\n        ans = 0\\n        for p in range(1, n+1):\\n            if good[p]:\\n                ans = (ans + counts[p]) % MOD\\n\\n        return ans\\n\"",
  "2316_14631217_python-updated-time": "1746810532905",
  "2720_14631217_python-updated-time": "1747134837627",
  "2615_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def isItPossible(self, word1, word2):\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n\\n        for a in c1:\\n            for b in c2:\\n                # Clone counters to simulate the swap\\n                new_c1 = c1.copy()\\n                new_c2 = c2.copy()\\n\\n                # Apply the swap a <-> b\\n                new_c1[a] -= 1\\n                if new_c1[a] == 0:\\n                    del new_c1[a]\\n                new_c2[b] -= 1\\n                if new_c2[b] == 0:\\n                    del new_c2[b]\\n\\n                new_c1[b] = new_c1.get(b, 0) + 1\\n                new_c2[a] = new_c2.get(a, 0) + 1\\n\\n                if len(new_c1) == len(new_c2):\\n                    return True\\n\\n        return False\\n\"",
  "206_14631217_python-updated-time": "1745245889455",
  "416_14631217_python": "\"class Solution:\\n    def canPartition(self, nums):\\n        total = sum(nums)\\n        if total % 2 != 0:\\n            return False\\n        \\n        target = total // 2\\n        dp = set([0])\\n        \\n        for num in nums:\\n            next_dp = set()\\n            for t in dp:\\n                if t + num == target:\\n                    return True\\n                next_dp.add(t)\\n                next_dp.add(t + num)\\n            dp = next_dp\\n        \\n        return target in dp\\n\"",
  "3618_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def maxScore(self, n, k, stayScore, travelScore):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type stayScore: List[List[int]]\\n        :type travelScore: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        # dp_prev[j] will hold the max score ending at city j after previous day\\n        dp_prev = [0] * n\\n        # Iterate over each day\\n        for day in range(k):\\n            dp_cur = [0] * n\\n            # Compute dp for current day\\n            for dest in range(n):\\n                # Option 1: stay in city dest\\n                stay = dp_prev[dest] + stayScore[day][dest]\\n                # Option 2: travel from some city p to dest\\n                # Initialize with travel from city 0\\n                max_travel = dp_prev[0] + travelScore[0][dest]\\n                # Check travel from other cities\\n                for p in range(1, n):\\n                    val = dp_prev[p] + travelScore[p][dest]\\n                    if val > max_travel:\\n                        max_travel = val\\n                # Choose the better option\\n                dp_cur[dest] = stay if stay > max_travel else max_travel\\n            dp_prev = dp_cur\\n        # The answer is the best score among all cities after k days\\n        return max(dp_prev)\\n\\n    def possibleStringCount(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        # Compute run-lengths of the observed word\\n        runs = []\\n        cur_char = None\\n        cur_len = 0\\n        for c in word:\\n            if c == cur_char:\\n                cur_len += 1\\n            else:\\n                if cur_len > 0:\\n                    runs.append(cur_len)\\n                cur_char = c\\n                cur_len = 1\\n        if cur_len > 0:\\n            runs.append(cur_len)\\n        m = len(runs)\\n        # Total number of raw assignments (each run i has Li choices for Mi)\\n        total = 1\\n        for Li in runs:\\n            total = (total * Li) % mod\\n        # If minimum possible original length m >= k, all assignments are valid\\n        if m >= k:\\n            return total\\n        # Otherwise, subtract those with sum Mi < k via DP up to k-1\\n        dp = [0] * k\\n        dp[0] = 1\\n        for Li in runs:\\n            # Compute prefix sums of dp\\n            prefix = [0] * k\\n            prefix[0] = dp[0]\\n            for i in range(1, k):\\n                prefix[i] = (prefix[i-1] + dp[i]) % mod\\n            new_dp = [0] * k\\n            # For each possible total t (<k), count assignments ending at t\\n            for t in range(1, k):\\n                a = prefix[t-1]\\n                b = prefix[t-1-Li] if t-1-Li >= 0 else 0\\n                new_dp[t] = (a - b) % mod\\n            dp = new_dp\\n        # Count of assignments with sum Mi < k is sum(dp[0..k-1])\\n        count_bad = sum(dp) % mod\\n        return (total - count_bad + mod) % mod\\n\"",
  "117_14631217_python": "\"# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=0, left=None, right=None, next=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Node\\n        :rtype: Node\\n        \\\"\\\"\\\"\\n        curr = root\\n\\n        while curr:\\n            dummy = Node(0)\\n            tail = dummy\\n\\n            while curr:\\n                if curr.left:\\n                    tail.next = curr.left\\n                    tail = tail.next\\n                if curr.right:\\n                    tail.next = curr.right\\n                    tail = tail.next\\n                curr = curr.next\\n\\n            curr = dummy.next\\n\\n        return root\\n\"",
  "problem-list:itemsPerPage": "100",
  "863_14631217_python-updated-time": "1745879417104",
  "392_14631217_python-updated-time": "1745355469044",
  "1944_14631217_python-updated-time": "1746543738173",
  "3682_14631217_python": "\"class Solution(object):\\n    def countGoodArrays(self, n, m, k):\\n        MOD = 10**9 + 7\\n        \\n        # Precompute factorials + inverses up to n:\\n        fact = [1] * (n)\\n        inv_fact = [1] * (n)\\n        for i in range(1, n):\\n            fact[i] = fact[i-1] * i % MOD\\n        \\n        # Fermat’s little theorem for inverses:\\n        inv_fact[n-1] = pow(fact[n-1], MOD-2, MOD)\\n        for i in range(n-1, 0, -1):\\n            inv_fact[i-1] = inv_fact[i] * i % MOD\\n        \\n        # Binomial helper: C(a, b) with 0 <= b <= a < n\\n        def comb(a, b):\\n            if b < 0 or b > a:\\n                return 0\\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\\n        \\n        # Number of segments = n - k\\n        # Answer = C(n-1, k) * m * (m-1)^(n-k-1)\\n        return (\\n            comb(n-1, k)\\n            * m\\n            % MOD\\n            * pow(m-1, n-k-1, MOD)\\n            % MOD\\n        )\\n\"",
  "139_14631217_python": "\"class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True  # Empty string is always \\\"breakable\\\"\\n\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i] = True\\n                    break  # No need to check further if s[:i] is already breakable\\n\\n        return dp[n]\\n\"",
  "3707_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def findCommonResponse(self, responses):\\n        \\\"\\\"\\\"\\n        :type responses: List[List[str]]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        freq = Counter()\\n        \\n        # For each day, count each response at most once\\n        for day in responses:\\n            for resp in set(day):\\n                freq[resp] += 1\\n        \\n        # Find the maximum frequency\\n        max_count = max(freq.values())\\n        \\n        # Among those with max_count, pick lexicographically smallest\\n        candidates = [resp for resp, cnt in freq.items() if cnt == max_count]\\n        return min(candidates)\\n\"",
  "3419_14631217_python-updated-time": "1747480713556",
  "2777_14631217_python": "\"class Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        Compute diff[i] = distinct count prefix nums[0..i] - distinct count suffix nums[i+1..n-1]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        result = [0] * n\\n        for i in range(n):\\n            prefix = set(nums[:i+1])\\n            suffix = set(nums[i+1:])\\n            result[i] = len(prefix) - len(suffix)\\n        return result\"",
  "1548_14631217_python": "\"class Solution:\\n    def kLengthApart(self, nums, k):\\n        last_one_index = -1\\n        \\n        for i, num in enumerate(nums):\\n            if num == 1:\\n                if last_one_index != -1 and i - last_one_index <= k:\\n                    return False\\n                last_one_index = i\\n        \\n        return True\\n\"",
  "3444_14631217_python-updated-time": "1747483525354",
  "1241_14631217_python": "\"class Solution:\\n    def decompressRLElist(self, nums):\\n        res = []\\n        for i in range(0, len(nums), 2):\\n            res.extend([nums[i + 1]] * nums[i])\\n        return res\\n\"",
  "1985_14631217_python": "\"class Solution:\\n    def maxSumMinProduct(self, nums):\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        # prefix sums\\n        prefix = [0] * (n + 1)\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + nums[i]\\n        # previous smaller element index\\n        left = [-1] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            left[i] = stack[-1] if stack else -1\\n            stack.append(i)\\n        # next smaller element index\\n        right = [n] * n\\n        stack = []\\n        for i in range(n - 1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            right[i] = stack[-1] if stack else n\\n            stack.append(i)\\n        # compute max min-product\\n        ans = 0\\n        for i in range(n):\\n            total = prefix[right[i]] - prefix[left[i] + 1]\\n            ans = max(ans, nums[i] * total)\\n        return ans % mod\\n\"",
  "1645_14631217_python-updated-time": "1746433720862",
  "2157_14631217_python-updated-time": "1746719625562",
  "3242_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxFrequencyElements(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1. Count frequencies\\n        freq = Counter(nums)\\n        \\n        # 2. Determine the maximum frequency\\n        max_freq = max(freq.values())\\n        \\n        # 3. Sum the frequencies of all elements having that maximum frequency\\n        total = sum(count for count in freq.values() if count == max_freq)\\n        \\n        return total\\n\"",
  "160_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \\\"\\\"\\\"\\n        :type headA, headB: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        if not headA or not headB:\\n            return None\\n        \\n        a, b = headA, headB\\n        while a != b:\\n            a = a.next if a else headB\\n            b = b.next if b else headA\\n        return a\\n\"",
  "2001_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def canReach(self, s, minJump, maxJump):\\n        n = len(s)\\n        # visited positions\\n        visited = [False] * n\\n        visited[0] = True\\n        \\n        q = deque([0])\\n        # furthest right we've enqueued so far\\n        furthest = 0\\n        \\n        while q:\\n            i = q.popleft()\\n            # compute the new window [start, end]\\n            start = i + minJump\\n            end = min(i + maxJump, n - 1)\\n            # only consider from furthest+1 up to end\\n            for j in range(max(start, furthest + 1), end + 1):\\n                if s[j] == '0' and not visited[j]:\\n                    if j == n - 1:\\n                        return True\\n                    visited[j] = True\\n                    q.append(j)\\n            # update how far we've processed\\n            furthest = max(furthest, end)\\n        \\n        # check if we ever reached n-1 (in case start=0)\\n        return visited[n - 1]\\n\"",
  "689_14631217_python": "\"class Solution(object):\\n    def maxSumOfThreeSubarrays(self, nums, k):\\n        n = len(nums)\\n        sum_k = [0] * (n - k + 1)\\n        curr_sum = sum(nums[:k])\\n        sum_k[0] = curr_sum\\n        for i in range(1, n - k + 1):\\n            curr_sum += nums[i + k - 1] - nums[i - 1]\\n            sum_k[i] = curr_sum\\n\\n        left = [0] * len(sum_k)\\n        best = 0\\n        for i in range(len(sum_k)):\\n            if sum_k[i] > sum_k[best]:\\n                best = i\\n            left[i] = best\\n\\n        right = [0] * len(sum_k)\\n        best = len(sum_k) - 1\\n        for i in range(len(sum_k) - 1, -1, -1):\\n            if sum_k[i] >= sum_k[best]:\\n                best = i\\n            right[i] = best\\n\\n        res = None\\n        max_total = 0\\n        for j in range(k, len(sum_k) - k):\\n            i, l = left[j - k], right[j + k]\\n            total = sum_k[i] + sum_k[j] + sum_k[l]\\n            if res is None or total > max_total:\\n                max_total = total\\n                res = [i, j, l]\\n        \\n        return res\\n\"",
  "1648_14631217_python": "\"class Solution(object):\\n    def minInsertions(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        insertions = 0\\n        open_needed = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            if s[i] == '(':\\n                open_needed += 2\\n                if open_needed % 2:\\n                    insertions += 1\\n                    open_needed -= 1\\n                i += 1\\n            else:\\n                if i + 1 < n and s[i + 1] == ')':\\n                    i += 2\\n                else:\\n                    insertions += 1\\n                    i += 1\\n                open_needed -= 2\\n                if open_needed < 0:\\n                    insertions += 1\\n                    open_needed = 0\\n\\n        return insertions + open_needed\\n\"",
  "1708_14631217_python-updated-time": "1746443868740",
  "2541_14631217_python": "\"class Solution(object):\\n    def sumOfNumberAndReverse(self, num):\\n        def reverse(x):\\n            r = 0\\n            while x:\\n                r = r*10 + x%10\\n                x //= 10\\n            return r\\n        \\n        for x in range(num+1):\\n            if x + reverse(x) == num:\\n                return True\\n        return False\\n\"",
  "2544_14631217_python": "\"class Solution:\\n    def makeIntegerBeautiful(self, n, target):\\n        # Helper to compute digit sum\\n        def digit_sum(x):\\n            s = 0\\n            while x:\\n                s += x % 10\\n                x //= 10\\n            return s\\n\\n        # If already beautiful, no need to add\\n        if digit_sum(n) <= target:\\n            return 0\\n\\n        res = 0\\n        p = 1  # current power of ten\\n        # We'll zero out digits from least significant upward\\n        while digit_sum(n) > target:\\n            digit = (n // p) % 10\\n            inc = (10 - digit) % 10\\n            add = inc * p\\n            res += add\\n            n += add\\n            # Move to next digit\\n            p *= 10\\n\\n        return res\\n\"",
  "495_14631217_python-updated-time": "1745445961132",
  "373_14631217_python-updated-time": "1745354588695",
  "3487_14631217_python": "\"class Solution(object):\\n    def maxRemovals(self, source, pattern, targetIndices):\\n        n, m = len(source), len(pattern)\\n        # Step 1: weight[i] = 1 if i in targetIndices else 0\\n        T = set(targetIndices)\\n        weight = [1 if i in T else 0 for i in range(n)]\\n        \\n        # dp[j] = minimum total weight to match pattern[:j]\\n        # using a subsequence of source scanned so far.\\n        INF = 10**9\\n        dp = [INF] * (m + 1)\\n        dp[0] = 0\\n        \\n        # Step 2: Build dp over the source string\\n        for i, ch in enumerate(source):\\n            w = weight[i]\\n            # go backwards to avoid overwriting dp[j] before using it\\n            for j in range(m - 1, -1, -1):\\n                if pattern[j] == ch:\\n                    # we can extend a match of length j to length j+1\\n                    cand = dp[j] + w\\n                    if cand < dp[j + 1]:\\n                        dp[j + 1] = cand\\n        \\n        # dp[m] is the minimum number of targetIndices positions\\n        # we were forced to “use” in matching the entire pattern.\\n        min_conflicts = dp[m]\\n        \\n        # Step 3: We can remove all the other targetIndices\\n        return len(targetIndices) - min_conflicts\\n\"",
  "3500_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, m, n, horizontalCut, verticalCut):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :type horizontalCut: List[int]\\n        :type verticalCut: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sort cuts in descending order so we always apply the largest next\\n        horizontalCut.sort(reverse=True)\\n        verticalCut.sort(reverse=True)\\n        \\n        # initially we have 1 horizontal segment and 1 vertical segment\\n        h_segs = 1\\n        v_segs = 1\\n        \\n        i = 0\\n        j = 0\\n        total = 0\\n        \\n        # Greedily pick the next largest cut\\n        while i < len(horizontalCut) and j < len(verticalCut):\\n            if horizontalCut[i] > verticalCut[j]:\\n                # cutting horizontally splits across all current vertical segments\\n                total += horizontalCut[i] * v_segs\\n                h_segs += 1\\n                i += 1\\n            else:\\n                # cutting vertically splits across all current horizontal segments\\n                total += verticalCut[j] * h_segs\\n                v_segs += 1\\n                j += 1\\n        \\n        # apply any remaining horizontal cuts\\n        while i < len(horizontalCut):\\n            total += horizontalCut[i] * v_segs\\n            i += 1\\n        \\n        # apply any remaining vertical cuts\\n        while j < len(verticalCut):\\n            total += verticalCut[j] * h_segs\\n            j += 1\\n        \\n        return total\\n\"",
  "1677_14631217_python-updated-time": "1746438229533",
  "2191_14631217_python": "\"class Solution:\\n    def minimumBuckets(self, hamsters):\\n        n = len(hamsters)\\n        buckets = [False] * n\\n        ans = 0\\n        \\n        for i in range(n):\\n            if hamsters[i] == 'H':\\n                # already fed by a bucket on the left?\\n                if i > 0 and buckets[i-1]:\\n                    continue\\n                # try to place on the right\\n                if i+1 < n and hamsters[i+1] == '.' and not buckets[i+1]:\\n                    buckets[i+1] = True\\n                    ans += 1\\n                # otherwise, try to place on the left\\n                elif i > 0 and hamsters[i-1] == '.' and not buckets[i-1]:\\n                    buckets[i-1] = True\\n                    ans += 1\\n                else:\\n                    return -1\\n        \\n        return ans\\n\"",
  "3434_14631217_python-updated-time": "1747483140869",
  "142_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        slow = fast = head\\n\\n        # Step 1: Detect if a cycle exists\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            # No cycle\\n            return None\\n\\n        # Step 2: Find the entry point\\n        slow = head\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        return slow\\n\"",
  "1643_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def countSubTrees(self, n, edges, labels):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type labels: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Build the graph\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        ans = [0] * n\\n\\n        def dfs(node, parent):\\n            counter = [0] * 26  # label counts in subtree\\n\\n            label_index = ord(labels[node]) - ord('a')\\n            counter[label_index] = 1\\n\\n            for neighbor in graph[node]:\\n                if neighbor == parent:\\n                    continue\\n                child_counter = dfs(neighbor, node)\\n                for i in range(26):\\n                    counter[i] += child_counter[i]\\n\\n            ans[node] = counter[label_index]\\n            return counter\\n\\n        dfs(0, -1)\\n        return ans\\n\"",
  "1885_14631217_python-updated-time": "1746531661234",
  "889_14631217_python-updated-time": "1745953918303",
  "601_14631217_mysql": "\"WITH Filtered AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        ROW_NUMBER() OVER (ORDER BY id) AS rn\\n    FROM Stadium\\n    WHERE people >= 100\\n),\\nGrouped AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        id - rn AS grp\\n    FROM Filtered\\n),\\nCounted AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        COUNT(*) OVER (PARTITION BY grp) AS cnt\\n    FROM Grouped\\n)\\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM Counted\\nWHERE cnt >= 3\\nORDER BY visit_date;\\n\"",
  "828_14631217_python-updated-time": "1745878545945",
  "1656_14631217_python": "\"class Solution(object):\\n    def countGoodTriplets(self, arr, a, b, c):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        count = 0\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if abs(arr[i] - arr[j]) > a:\\n                    continue\\n                for k in range(j + 1, n):\\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\\n                        count += 1\\n\\n        return count\\n\"",
  "2232_14631217_python": "\"class Solution:\\n    def addSpaces(self, s, spaces):\\n        space_set = set(spaces)\\n        result = []\\n\\n        for i, ch in enumerate(s):\\n            if i in space_set:\\n                result.append(' ')\\n            result.append(ch)\\n\\n        return ''.join(result)\\n\"",
  "2754_14631217_python-updated-time": "1747139925441",
  "1105_14631217_python": "\"class Solution:\\n    def maxUncrossedLines(self, nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if nums1[i] == nums2[j]:\\n                    dp[i][j] = 1 + dp[i + 1][j + 1]\\n                else:\\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\\n        return dp[0][j] if False else dp[0][0]\\n\"",
  "2033_14631217_python-updated-time": "1746627762606",
  "3166_14631217_python-updated-time": "1747308284934",
  "1466_14631217_python": "\"class Solution:\\n    def maxJumps(self, arr, d):\\n        n = len(arr)\\n        dp = [-1] * n  # dp[i] = max number of indices starting from i\\n\\n        def dfs(i):\\n            if dp[i] != -1:\\n                return dp[i]\\n            best = 1  # can always stay at i\\n            # jump to the right\\n            for x in range(1, d+1):\\n                j = i + x\\n                if j >= n or arr[j] >= arr[i]:\\n                    break\\n                best = max(best, 1 + dfs(j))\\n            # jump to the left\\n            for x in range(1, d+1):\\n                j = i - x\\n                if j < 0 or arr[j] >= arr[i]:\\n                    break\\n                best = max(best, 1 + dfs(j))\\n            dp[i] = best\\n            return best\\n\\n        return max(dfs(i) for i in range(n))\\n\"",
  "77_14631217_python-updated-time": "1745015211981",
  "1203_14631217_lang-updated-time": "1746108866968",
  "954_14631217_python-updated-time": "1746003512592",
  "2310_14631217_python-updated-time": "1746810478233",
  "3636_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nmod = 10**9 + 7\\n\\nclass Solution(object):\\n    def lengthAfterTransformations(self, s, t, nums):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        A = [[0] * 26 for _ in range(26)]\\n        for i in range(26):\\n            for k in range(1, nums[i] + 1):\\n                j = (i + k) % 26\\n                A[i][j] = 1\\n\\n        def mat_mult(X, Y):\\n            Z = [[0] * 26 for _ in range(26)]\\n            for i in range(26):\\n                for k in range(26):\\n                    if X[i][k]:\\n                        for j in range(26):\\n                            Z[i][j] = (Z[i][j] + X[i][k] * Y[k][j]) % mod\\n            return Z\\n\\n        def mat_pow(mat, power):\\n            res = [[int(i == j) for j in range(26)] for i in range(26)]\\n            while power:\\n                if power % 2:\\n                    res = mat_mult(res, mat)\\n                mat = mat_mult(mat, mat)\\n                power //= 2\\n            return res\\n\\n        if t == 0:\\n            return len(s) % mod\\n\\n        At = mat_pow(A, t)\\n        f = [sum(At[c]) % mod for c in range(26)]\\n\\n        return sum(f[ord(ch) - ord('a')] for ch in s) % mod\\n\\n    def isBalanced(self, num):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\\n        return even_sum == odd_sum\"",
  "193_14631217_bash-updated-time": "1745092874837",
  "115_14631217_python": "\"class Solution(object):\\n    def numDistinct(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(s), len(t)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = 1\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == t[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        \\n        return dp[m][n]\\n\"",
  "2477_14631217_python": "\"class Solution:\\n    def numberOfWays(self, startPos, endPos, k):\\n        mod = 10**9 + 7\\n        diff = endPos - startPos\\n        \\n        # r = number of right steps, l = number of left steps\\n        # r - l = diff, and r + l = k  =>  r = (k + diff)//2\\n        if (k + diff) % 2 != 0 or abs(diff) > k:\\n            return 0\\n        \\n        r = (k + diff) // 2\\n        if r < 0 or r > k:\\n            return 0\\n        \\n        # Precompute factorials and inverse factorials up to k\\n        fact = [1] * (k + 1)\\n        for i in range(1, k + 1):\\n            fact[i] = fact[i - 1] * i % mod\\n        \\n        invfact = [1] * (k + 1)\\n        invfact[k] = pow(fact[k], mod - 2, mod)\\n        for i in range(k, 0, -1):\\n            invfact[i - 1] = invfact[i] * i % mod\\n        \\n        # Compute C(k, r) = fact[k] * invfact[r] * invfact[k-r]\\n        return fact[k] * invfact[r] % mod * invfact[k - r] % mod\\n\"",
  "1221_14631217_python-updated-time": "1746260293450",
  "495_14631217_python": "\"class Solution:\\n    def findPoisonedDuration(self, timeSeries, duration):\\n        if not timeSeries:\\n            return 0\\n        \\n        total = 0\\n        for i in range(1, len(timeSeries)):\\n            gap = timeSeries[i] - timeSeries[i - 1]\\n            total += min(duration, gap)\\n        \\n        # Add full duration for the last attack\\n        total += duration\\n        return total\\n\"",
  "2808_14631217_python": "\"class Solution:\\n    def paintWalls(self, cost, time):\\n        \\\"\\\"\\\"\\n        :type cost: List[int]\\n        :type time: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(cost)\\n        # Each paid wall i contributes (time[i] + 1) \\\"work‐units\\\"\\n        # We need total work ≥ n to cover the n free‐painter slots.\\n        target = n\\n        # dp[w] = minimum money to achieve exactly w work‐units (clamped at target)\\n        INF = 10**30\\n        dp = [INF] * (target + 1)\\n        dp[0] = 0\\n\\n        for c, t in zip(cost, time):\\n            w = t + 1\\n            # traverse backwards so 0-1 knapsack\\n            for curr in range(target, -1, -1):\\n                if dp[curr] == INF:\\n                    continue\\n                nxt = curr + w\\n                if nxt >= target:\\n                    nxt = target\\n                # either take wall i for paid painter\\n                if dp[nxt] > dp[curr] + c:\\n                    dp[nxt] = dp[curr] + c\\n\\n        return dp[target]\\n\"",
  "1626_14631217_python": "\"class Solution(object):\\n    def canMakeArithmeticProgression(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        arr.sort()\\n        diff = arr[1] - arr[0]\\n\\n        for i in range(2, len(arr)):\\n            if arr[i] - arr[i - 1] != diff:\\n                return False\\n\\n        return True\\n\"",
  "2483_14631217_python-updated-time": "1746964737836",
  "1934_14631217_python": "\"class Solution(object):\\n    def evaluate(self, s, knowledge):\\n        # build lookup dict\\n        km = {k: v for k, v in knowledge}\\n        res = []\\n        i, n = 0, len(s)\\n        while i < n:\\n            if s[i] == '(':\\n                # extract key until ')'\\n                j = i + 1\\n                while j < n and s[j] != ')':\\n                    j += 1\\n                key = s[i+1:j]\\n                # append value or '?' if missing\\n                res.append(km.get(key, '?'))\\n                i = j + 1\\n            else:\\n                res.append(s[i])\\n                i += 1\\n        return ''.join(res)\\n\"",
  "3188_14631217_python-updated-time": "1747309763456",
  "150_14631217_python": "\"class Solution(object):\\n    def evalRPN(self, tokens):\\n        stack = []\\n        for token in tokens:\\n            if token not in \\\"+-*/\\\":\\n                stack.append(int(token))\\n            else:\\n                b = stack.pop()\\n                a = stack.pop()\\n                if token == '+':\\n                    stack.append(a + b)\\n                elif token == '-':\\n                    stack.append(a - b)\\n                elif token == '*':\\n                    stack.append(a * b)\\n                else:\\n                    stack.append(int(float(a) / b))\\n        return stack[0]\\n\"",
  "2610_14631217_python-updated-time": "1747060129863",
  "2567_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def closestNodes(self, root, queries):\\n        # In-order traversal to get sorted node values\\n        vals = []\\n        stack = []\\n        node = root\\n        while stack or node:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            vals.append(node.val)\\n            node = node.right\\n        \\n        res = []\\n        n = len(vals)\\n        for q in queries:\\n            # floor: largest <= q\\n            # bisect_right gives first index > q\\n            i = bisect.bisect_right(vals, q)\\n            floor = vals[i-1] if i > 0 else -1\\n            \\n            # ceil: smallest >= q\\n            # bisect_left gives first index >= q\\n            j = bisect.bisect_left(vals, q)\\n            ceil = vals[j] if j < n else -1\\n            \\n            res.append([floor, ceil])\\n        \\n        return res\\n\"",
  "460_14631217_python-updated-time": "1745359550712",
  "1576_14631217_python-updated-time": "1746348218086",
  "273_14631217_python": "\"class Solution(object):\\n    def numberToWords(self, num):\\n        \\\"\\\"\\\"\\n        :type num: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if num == 0:\\n            return \\\"Zero\\\"\\n        \\n        below_20 = [\\\"\\\", \\\"One\\\", \\\"Two\\\", \\\"Three\\\", \\\"Four\\\", \\\"Five\\\", \\\"Six\\\", \\\"Seven\\\", \\\"Eight\\\", \\\"Nine\\\", \\\"Ten\\\",\\n                    \\\"Eleven\\\", \\\"Twelve\\\", \\\"Thirteen\\\", \\\"Fourteen\\\", \\\"Fifteen\\\", \\\"Sixteen\\\", \\\"Seventeen\\\", \\\"Eighteen\\\", \\\"Nineteen\\\"]\\n        \\n        tens = [\\\"\\\", \\\"Ten\\\", \\\"Twenty\\\", \\\"Thirty\\\", \\\"Forty\\\", \\\"Fifty\\\", \\\"Sixty\\\", \\\"Seventy\\\", \\\"Eighty\\\", \\\"Ninety\\\"]\\n        \\n        thousands = [\\\"\\\", \\\"Thousand\\\", \\\"Million\\\", \\\"Billion\\\"]\\n        \\n        def helper(n):\\n            if n == 0:\\n                return \\\"\\\"\\n            elif n < 20:\\n                return below_20[n] + \\\" \\\"\\n            elif n < 100:\\n                return tens[n // 10] + \\\" \\\" + helper(n % 10)\\n            else:\\n                return below_20[n // 100] + \\\" Hundred \\\" + helper(n % 100)\\n        \\n        res = \\\"\\\"\\n        for i in range(len(thousands)):\\n            if num % 1000 != 0:\\n                res = helper(num % 1000) + thousands[i] + \\\" \\\" + res\\n            num //= 1000\\n        \\n        return res.strip()\\n\"",
  "1250_14631217_python": "\"class Solution(object):\\n    def longestCommonSubsequence(self, text1, text2):\\n        \\\"\\\"\\\"\\n        :type text1: str\\n        :type text2: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(text1), len(text2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if text1[i] == text2[j]:\\n                    dp[i + 1][j + 1] = dp[i][j] + 1\\n                else:\\n                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\\n        \\n        return dp[m][n]\\n\"",
  "2857_14631217_python": "\"class Solution:\\n    def distanceTraveled(self, mainTank, additionalTank):\\n        \\\"\\\"\\\"\\n        :type mainTank: int\\n        :type additionalTank: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        used = 0\\n        # Each time we consume 5 L from main, we get 1 L from additional (if available)\\n        while mainTank >= 5 and additionalTank > 0:\\n            mainTank -= 5\\n            used += 5\\n            additionalTank -= 1\\n            mainTank += 1\\n        \\n        # consume whatever remains in the main tank\\n        used += mainTank\\n        \\n        # mileage is 10 km per liter\\n        return used * 10\\n\"",
  "2978_14631217_python-updated-time": "1747226613408",
  "2563_14631217_python-updated-time": "1746969326997",
  "1378_14631217_python-updated-time": "1746259570286",
  "1528_14631217_python-updated-time": "1746347122188",
  "3224_14631217_python": "\"class Solution(object):\\n    def numberOfSequence(self, n, sick):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type sick: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9 + 7\\n        m = len(sick)\\n        # Build segment lengths\\n        segments = []\\n        # left end\\n        segments.append(sick[0])\\n        # interior segments\\n        for i in range(1, m):\\n            segments.append(sick[i] - sick[i-1] - 1)\\n        # right end\\n        segments.append(n - 1 - sick[-1])\\n        # total uninfected\\n        M = n - m\\n\\n        # Precompute factorials and inverse factorials up to n\\n        fac = [1] * (n+1)\\n        ifac = [1] * (n+1)\\n        for i in range(1, n+1):\\n            fac[i] = fac[i-1] * i % mod\\n        ifac[n] = pow(fac[n], mod-2, mod)\\n        for i in range(n, 0, -1):\\n            ifac[i-1] = ifac[i] * i % mod\\n\\n        # Multinomial coefficient: M! / (prod L_i!)\\n        res = fac[M]\\n        for L in segments:\\n            res = res * ifac[L] % mod\\n\\n        # For each interior segment (not the first or last), multiply by 2^(L-1)\\n        for L in segments[1:-1]:\\n            if L > 0:\\n                res = res * pow(2, L-1, mod) % mod\\n\\n        return res\\n\"",
  "1395_14631217_python-updated-time": "1746259976555",
  "2260_14631217_python-updated-time": "1746802172209",
  "3251_14631217_python": "\"class Solution(object):\\n    def areaOfMaxDiagonal(self, dimensions):\\n        max_diag = -1\\n        max_area = 0\\n        for l, w in dimensions:\\n            diag_sq = l * l + w * w\\n            area = l * w\\n            if diag_sq > max_diag:\\n                max_diag = diag_sq\\n                max_area = area\\n            elif diag_sq == max_diag:\\n                max_area = max(max_area, area)\\n        return max_area\\n\"",
  "2785_14631217_python": "\"class Solution:\\n    def semiOrderedPermutation(self, nums):\\n        n = len(nums)\\n        i = nums.index(1)\\n        j = nums.index(n)\\n        if i < j:\\n            return i + (n - 1 - j)\\n        else:\\n            return i + (n - 1 - j) - 1\\n\"",
  "3045_14631217_python": "\"class Solution(object):\\n    def minimumRightShifts(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Sorted target\\n        target = sorted(nums)\\n        # Find index of the minimal element (target[0]) in nums\\n        first = target[0]\\n        idx = nums.index(first)\\n        # Compute required right-shifts k so that idx -> 0\\n        k = (n - idx) % n\\n        # Apply the rotation and check\\n        # rotate_right by k: take last k elements, then the rest\\n        if k == 0:\\n            rotated = nums\\n        else:\\n            rotated = nums[-k:] + nums[:-k]\\n        return k if rotated == target else -1\\n\"",
  "823_14631217_python-updated-time": "1745878310429",
  "363_14631217_python-updated-time": "1745354293635",
  "3308_14631217_python-updated-time": "1747413876769",
  "1406_14631217_python-updated-time": "1746260169762",
  "3737_14631217_python": "\"class Solution(object):\\n    def minCost(self, n, cost):\\n        \\\"\\\"\\\"\\n        :type n:   int        (even)\\n        :type cost: List[List[int]]  # n × 3\\n        :rtype:     int\\n        \\\"\\\"\\\"\\n        M = n // 2\\n        # Build the two rows:\\n        #  P1[i] = cost[i]\\n        #  Q[i] = cost[n-1-i]\\n        cost_P1 = cost[:M]\\n        cost_Q  = [cost[n-1-i] for i in range(M)]\\n        \\n        # All valid (c1,c2) with c1!=c2:\\n        states = [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\\n        \\n        # Precompute, for each state s, which previous-state indices t\\n        # satisfy t[0]!=c1 and t[1]!=c2.\\n        prev_states = []\\n        for (c1,c2) in states:\\n            ok = []\\n            for ti,(p1,p2) in enumerate(states):\\n                if p1 != c1 and p2 != c2:\\n                    ok.append(ti)\\n            prev_states.append(ok)\\n        \\n        # dp_prev[s] = min cost up through column i-1 ending in state s\\n        # Initialize for column 0:\\n        dp_prev = [\\n            cost_P1[0][c1] + cost_Q[0][c2]\\n            for (c1,c2) in states\\n        ]\\n        \\n        # Sweep columns 1..M-1\\n        for i in range(1, M):\\n            dp_cur = [10**30]*6\\n            for si,(c1,c2) in enumerate(states):\\n                base = cost_P1[i][c1] + cost_Q[i][c2]\\n                # transition only from those prev states where\\n                # P1[i]!=P1[i-1] and Q[i]!=Q[i-1]\\n                best_prev = min(dp_prev[t] for t in prev_states[si])\\n                dp_cur[si] = base + best_prev\\n            dp_prev = dp_cur\\n        \\n        # Answer is the minimum over final‐column states\\n        return min(dp_prev)\\n\"",
  "2462_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def kSum(self, nums, k):\\n        # 1) Maximum subsequence sum = sum of positives.\\n        total = sum(x for x in nums if x > 0)\\n        # 2) Sort abs values so we peel off the smallest contributions first.\\n        abs_sorted = sorted(abs(x) for x in nums)\\n        n = len(abs_sorted)\\n\\n        # Max-heap via negation: entries are (-current_sum, idx)\\n        heap = [(-total, 0)]\\n        # Track visited (idx, current_sum) to avoid duplicates\\n        visited = {(0, total)}\\n\\n        ans = total\\n        for _ in range(k):\\n            if not heap:\\n                # No more new states: remaining sums all == ans\\n                break\\n\\n            neg_curr, i = heapq.heappop(heap)\\n            curr = -neg_curr\\n            ans = curr\\n\\n            # Generate next states by “removing” abs_sorted[i]\\n            if i < n:\\n                # A) Simply subtract abs_sorted[i]\\n                s1 = curr - abs_sorted[i]\\n                state1 = (i + 1, s1)\\n                if state1 not in visited:\\n                    visited.add(state1)\\n                    heapq.heappush(heap, (-s1, i + 1))\\n\\n                # B) If i>0, swap out the previous removal for this one\\n                if i > 0:\\n                    s2 = curr - abs_sorted[i] + abs_sorted[i - 1]\\n                    state2 = (i + 1, s2)\\n                    if state2 not in visited:\\n                        visited.add(state2)\\n                        heapq.heappush(heap, (-s2, i + 1))\\n\\n        return ans\\n\"",
  "2352_14631217_python": "\"class ATM:\\n    def __init__(self):\\n        # counts for [20, 50, 100, 200, 500]\\n        self.counts = [0] * 5\\n        self.denoms = [20, 50, 100, 200, 500]\\n\\n    def deposit(self, banknotesCount):\\n        # Add the deposited banknotes to the machine\\n        for i in range(5):\\n            self.counts[i] += banknotesCount[i]\\n\\n    def withdraw(self, amount):\\n        # Try to greedily use largest denominations first\\n        to_use = [0] * 5\\n        remaining = amount\\n\\n        for i in range(4, -1, -1):\\n            # maximum we could use of denom i\\n            max_notes = remaining // self.denoms[i]\\n            use = min(self.counts[i], max_notes)\\n            to_use[i] = use\\n            remaining -= use * self.denoms[i]\\n\\n        # If we couldn't make the exact amount, reject\\n        if remaining != 0:\\n            return [-1]\\n\\n        # Otherwise commit the withdrawal\\n        for i in range(5):\\n            self.counts[i] -= to_use[i]\\n\\n        return to_use\\n\"",
  "394_14631217_python-updated-time": "1745355528693",
  "2417_14631217_python": "\"class Solution:\\n    def latestTimeCatchTheBus(self, buses, passengers, capacity):\\n        buses.sort()\\n        passengers.sort()\\n        n = len(passengers)\\n        j = 0\\n        \\n        # simulate boarding on each bus\\n        for depart in buses:\\n            cnt = 0\\n            while j < n and passengers[j] <= depart and cnt < capacity:\\n                j += 1\\n                cnt += 1\\n        \\n        last_depart = buses[-1]\\n        \\n        # if last bus isn't full, we can arrive exactly at its departure\\n        if cnt < capacity:\\n            candidate = last_depart\\n        else:\\n            # otherwise, one before the last boarded passenger\\n            candidate = passengers[j-1] - 1\\n            \\n            # avoid any run of consecutive arrivals at the end of that bus\\n            l = j - cnt\\n            r = j - 1\\n            arr = passengers\\n            lo, hi = l, r\\n            # binary-search for the start of the maximal consecutive suffix ending at r\\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                # if arr[mid..r] are fully consecutive integers...\\n                if arr[r] - arr[mid] == r - mid:\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            # now arr[lo..r] is a consecutive block, so we must step before arr[lo]\\n            if candidate >= arr[lo]:\\n                candidate = arr[lo] - 1\\n        \\n        # finally, ensure we don't clash with *any* passenger arrival\\n        import bisect\\n        pos = bisect.bisect_left(passengers, candidate)\\n        while pos >= 0 and pos < n and passengers[pos] == candidate:\\n            candidate -= 1\\n            pos -= 1\\n        \\n        return candidate\\n\"",
  "1170_14631217_python-updated-time": "1746108253848",
  "3314_14631217_python-updated-time": "1747416523668",
  "388_14631217_python": "\"class Solution:\\n    def lengthLongestPath(self, input):\\n        max_length = 0\\n        path_length = {0: 0}\\n        \\n        for line in input.split('\\\\n'):\\n            depth = line.count('\\\\t')\\n            name = line.lstrip('\\\\t')\\n            if '.' in name:\\n                max_length = max(max_length, path_length[depth] + len(name))\\n            else:\\n                path_length[depth + 1] = path_length[depth] + len(name) + 1  # +1 for '/'\\n        \\n        return max_length\\n\"",
  "275_14631217_python-updated-time": "1745248302623",
  "2324_14631217_python-updated-time": "1746811072528",
  "2199_14631217_python": "\"class Solution:\\n    def maxDistance(self, colors):\\n        \\\"\\\"\\\"\\n        :type colors: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(colors)\\n        first_color = colors[0]\\n        last_color = colors[-1]\\n        \\n        # Furthest from the start that differs from colors[0]\\n        max_from_start = 0\\n        for j in range(n - 1, -1, -1):\\n            if colors[j] != first_color:\\n                max_from_start = j\\n                break\\n        \\n        # Furthest from the end that differs from colors[-1]\\n        min_from_end = n - 1\\n        for i in range(n):\\n            if colors[i] != last_color:\\n                min_from_end = i\\n                break\\n        \\n        return max(max_from_start, (n - 1) - min_from_end)\\n\"",
  "1449_14631217_python": "\"class Solution:\\n    def printVertically(self, s):\\n        words = s.split()\\n        max_len = max(len(w) for w in words)\\n        res = []\\n        for j in range(max_len):\\n            col = ''.join(w[j] if j < len(w) else ' ' for w in words)\\n            res.append(col.rstrip())\\n        return res\\n\"",
  "927_14631217_python": "\"class Solution(object):\\n    def sumSubseqWidths(self, nums):\\n        MOD = 10**9 + 7\\n        nums.sort()\\n        n = len(nums)\\n        pow2 = [1] * n\\n        for i in range(1, n):\\n            pow2[i] = (pow2[i - 1] * 2) % MOD\\n\\n        res = 0\\n        for i in range(n):\\n            res = (res + nums[i] * pow2[i] - nums[i] * pow2[n - 1 - i]) % MOD\\n\\n        return res\\n\"",
  "419_14631217_python": "\"class Solution:\\n    def countBattleships(self, board):\\n        if not board or not board[0]:\\n            return 0\\n        \\n        m, n = len(board), len(board[0])\\n        count = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 'X':\\n                    if (i > 0 and board[i-1][j] == 'X') or (j > 0 and board[i][j-1] == 'X'):\\n                        continue\\n                    count += 1\\n        return count\\n\"",
  "1001_14631217_python": "\"class Solution:\\n    def repeatedNTimes(self, nums):\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return num\\n            seen.add(num)\\n\"",
  "1693_14631217_python": "\"class Solution(object):\\n    def sumOddLengthSubarrays(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        total = 0\\n\\n        for i, val in enumerate(arr):\\n            # number of ways to choose start j in [0..i]\\n            L = i + 1\\n            left_even = (i // 2) + 1\\n            left_odd = L - left_even\\n\\n            # number of ways to choose end k in [i..n-1]\\n            R = n - i\\n            if i % 2 == 0:\\n                right_even = (R + 1) // 2\\n                right_odd = R - right_even\\n            else:\\n                right_odd = (R + 1) // 2\\n                right_even = R - right_odd\\n\\n            # only pairs (j,k) with same parity give odd-length subarray\\n            count = left_even * right_even + left_odd * right_odd\\n            total += val * count\\n\\n        return total\\n\"",
  "3279_14631217_python-updated-time": "1747411939964",
  "851_14631217_python-updated-time": "1745879108335",
  "1370_14631217_python-updated-time": "1746259451173",
  "2449_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\\n        n = len(chargeTimes)\\n        max_charge_deque = deque()\\n        sum_running = 0\\n        l = 0\\n        ans = 0\\n\\n        for r in range(n):\\n            # Add running cost\\n            sum_running += runningCosts[r]\\n            # Maintain deque for max charge time\\n            while max_charge_deque and chargeTimes[r] > max_charge_deque[-1]:\\n                max_charge_deque.pop()\\n            max_charge_deque.append(chargeTimes[r])\\n\\n            # Shrink window while cost exceeds budget\\n            while l <= r and (max_charge_deque[0] + (r - l + 1) * sum_running) > budget:\\n                # Remove running cost of leftmost\\n                sum_running -= runningCosts[l]\\n                # Pop from deque if it was the max at front\\n                if max_charge_deque[0] == chargeTimes[l]:\\n                    max_charge_deque.popleft()\\n                l += 1\\n\\n            # Update answer\\n            ans = max(ans, r - l + 1)\\n\\n        return ans\\n\"",
  "1247_14631217_python": "\"class Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def moves(required_high_at_even):\\n            moves = 0\\n            for i in range(len(nums)):\\n                left = nums[i - 1] if i - 1 >= 0 else float('inf')\\n                right = nums[i + 1] if i + 1 < len(nums) else float('inf')\\n                if (required_high_at_even and i % 2 == 0) or (not required_high_at_even and i % 2 == 1):\\n                    continue\\n                min_adj = min(left, right)\\n                if nums[i] >= min_adj:\\n                    moves += nums[i] - (min_adj - 1)\\n            return moves\\n        \\n        return min(moves(True), moves(False))\\n\"",
  "780_14631217_python": "\"class Solution(object):\\n    def maxChunksToSorted(self, arr):\\n        res = 0\\n        curr_max = 0\\n        for i, num in enumerate(arr):\\n            curr_max = max(curr_max, num)\\n            if curr_max == i:\\n                res += 1\\n        return res\\n\"",
  "535_14631217_python": "\"import random\\nimport string\\n\\nclass Codec:\\n\\n    def __init__(self):\\n        self.url_map = {}\\n        self.base_url = \\\"http://tinyurl.com/\\\"\\n    \\n    def encode(self, longUrl):\\n        while True:\\n            short_key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\\n            short_url = self.base_url + short_key\\n            if short_url not in self.url_map:\\n                self.url_map[short_url] = longUrl\\n                return short_url\\n\\n    def decode(self, shortUrl):\\n        return self.url_map.get(shortUrl, \\\"\\\")\\n\"",
  "1709_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def alertNames(self, keyName, keyTime):\\n        # Map each worker to their list of access times (in minutes)\\n        times_map = defaultdict(list)\\n        for name, t in zip(keyName, keyTime):\\n            minutes = int(t[:2]) * 60 + int(t[3:])\\n            times_map[name].append(minutes)\\n        \\n        alerted = []\\n        # Check each worker's sorted times for any 3 within a 60‑minute window\\n        for name, times in times_map.items():\\n            times.sort()\\n            # Sliding window of size 3: check if times[i+2] - times[i] <= 60\\n            for i in range(len(times) - 2):\\n                if times[i+2] - times[i] <= 60:\\n                    alerted.append(name)\\n                    break\\n        \\n        return sorted(alerted)\\n\"",
  "1824_14631217_python-updated-time": "1746453788523",
  "2339_14631217_python-updated-time": "1746880513449",
  "3079_14631217_python-updated-time": "1747226931082",
  "441_14631217_python-updated-time": "1745358960728",
  "3817_14631217_python": "\"class Solution(object):\\n    def maxContainers(self, n, w, maxWeight):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type w: int\\n        :type maxWeight: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return min(n * n, maxWeight // w)\\n\"",
  "1113_14631217_python": "\"class Solution:\\n    def numMovesStonesII(self, stones):\\n        stones.sort()\\n        n = len(stones)\\n\\n        # -------- maximum moves ----------\\n        max_moves = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (n - 2)\\n\\n        # -------- minimum moves ----------\\n        min_moves = n\\n        i = 0\\n        for j in range(n):\\n            while stones[j] - stones[i] >= n:\\n                i += 1\\n            window = j - i + 1\\n            min_moves = min(min_moves, n - window)\\n\\n        # special case: all stones are consecutive except one gap of size 2\\n        if (stones[-2] - stones[0] == n - 2 and stones[-1] - stones[-2] > 2) or \\\\\\n           (stones[-1] - stones[1] == n - 2 and stones[1] - stones[0] > 2):\\n            min_moves = 2\\n\\n        return [min_moves, max_moves]\\n\"",
  "957_14631217_python": "\"class Solution:\\n    def minAddToMakeValid(self, s):\\n        open_needed = 0\\n        close_needed = 0\\n\\n        for char in s:\\n            if char == '(':\\n                open_needed += 1\\n            else:  # char == ')'\\n                if open_needed > 0:\\n                    open_needed -= 1\\n                else:\\n                    close_needed += 1\\n\\n        return open_needed + close_needed\\n\"",
  "3523_14631217_python-updated-time": "1747501462221",
  "1462_14631217_mysql": "\"SELECT\\n  p.product_name,\\n  SUM(o.unit) AS unit\\nFROM Orders o\\nJOIN Products p\\n  ON o.product_id = p.product_id\\nWHERE o.order_date BETWEEN '2020-02-01' AND '2020-02-29'\\nGROUP BY p.product_id, p.product_name\\nHAVING SUM(o.unit) >= 100;\\n\"",
  "2413_14631217_python-updated-time": "1746907325480",
  "825_14631217_python": "\"class Solution(object):\\n    def maxIncreaseKeepingSkyline(self, grid):\\n        n = len(grid)\\n        row_max = [max(row) for row in grid]\\n        col_max = [max(grid[i][j] for i in range(n)) for j in range(n)]\\n        \\n        res = 0\\n        for i in range(n):\\n            for j in range(n):\\n                res += min(row_max[i], col_max[j]) - grid[i][j]\\n        return res\\n\"",
  "2290_14631217_python-updated-time": "1746803291420",
  "2819_14631217_python-updated-time": "1747140102045",
  "2456_14631217_python": "\"class Solution(object):\\n    def smallestNumber(self, pattern):\\n        stack = []\\n        res = []\\n        num = 1\\n\\n        for ch in pattern + 'I':\\n            stack.append(num)\\n            num += 1\\n            if ch == 'I':\\n                while stack:\\n                    res.append(str(stack.pop()))\\n        \\n        return ''.join(res)\\n\"",
  "3856_14631217_python": "\"class Solution(object):\\n    def maxWeight(self, n, edges, k, t):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type k: int\\n        :type t: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Mask to keep bits [0..t-1]\\n        mask = (1 << t) - 1\\n        \\n        # dp_prev[u]: bitset of achievable sums at node u using exactly e edges\\n        dp_prev = [1] * n  # bit-0 = 1 => 0-sum reachable with 0 edges\\n        \\n        # If k=0, only sum=0 with zero edges; check if 0 < t\\n        if k == 0:\\n            return 0 if t > 0 else -1\\n        \\n        # Iterate edge-count from 1 to k\\n        for _ in range(1, k + 1):\\n            dp_cur = [0] * n\\n            for u, v, w in edges:\\n                # shift dp_prev[u] by w, clip to < t, OR into dp_cur[v]\\n                dp_cur[v] |= (dp_prev[u] << w) & mask\\n            dp_prev = dp_cur\\n        \\n        # Combine all end‐node bitsets\\n        reachable = 0\\n        for bits in dp_prev:\\n            reachable |= bits\\n        \\n        # Remove bit-0 if no path at all? It's fine: if reachable==0, no sums.\\n        if reachable == 0:\\n            return -1\\n        \\n        # Highest set bit position is max achievable sum < t\\n        return reachable.bit_length() - 1\\n\"",
  "notification-status:lastModified": "1747318045",
  "1330_14631217_python-updated-time": "1746127700486",
  "2800_14631217_python": "\"class Solution(object):\\n    def minLength(self, s):\\n        stack = []\\n        for ch in s:\\n            if stack and ((stack[-1] == 'A' and ch == 'B') or (stack[-1] == 'C' and ch == 'D')):\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return len(stack)\\n\"",
  "3140_14631217_python-updated-time": "1747305475277",
  "852_14631217_python-updated-time": "1745879179960",
  "1411_14631217_python-updated-time": "1746260356769",
  "3704_14631217_python-updated-time": "1747670991146",
  "3374_14631217_python-updated-time": "1747423110314",
  "1587_14631217_python": "\"from itertools import combinations\\n\\nclass Solution(object):\\n    def minNumberOfSemesters(self, n, relations, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type relations: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        prereq = [0] * n\\n        for prev, nxt in relations:\\n            prereq[nxt - 1] |= 1 << (prev - 1)\\n\\n        memo = {}\\n\\n        def dp(mask):\\n            if mask == (1 << n) - 1:\\n                return 0  # All courses taken\\n\\n            if mask in memo:\\n                return memo[mask]\\n\\n            available = []\\n            for i in range(n):\\n                if (mask >> i) & 1 == 0 and (prereq[i] & mask) == prereq[i]:\\n                    available.append(i)\\n\\n            res = float('inf')\\n\\n            for subset in combinations(available, min(k, len(available))):\\n                new_mask = mask\\n                for course in subset:\\n                    new_mask |= 1 << course\\n                res = min(res, 1 + dp(new_mask))\\n\\n            memo[mask] = res\\n            return res\\n\\n        return dp(0)\\n\"",
  "QD_LAYOUT_JSON": "{\n\t\"type\": \"row\",\n\t\"children\": [\n\t\t{\n\t\t\t\"type\": \"tabset\",\n\t\t\t\"weight\": 40.086887835703,\n\t\t\t\"foldBeforeWeight\": 39.409356680371694,\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\"component\": \"description\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\"component\": \"editorial\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\"component\": \"solutions\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\"component\": \"submissions\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"selected\": 0\n\t\t},\n\t\t{\n\t\t\t\"type\": \"row\",\n\t\t\t\"weight\": 59.913112164297,\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tabset\",\n\t\t\t\t\t\"weight\": 38.731825525040385,\n\t\t\t\t\t\"foldBeforeWeight\": 35,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\t\t\"component\": \"code\",\n\t\t\t\t\t\t\t\"enableRenderOnDemand\": false\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"active\": true,\n\t\t\t\t\t\"selected\": 0\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"tabset\",\n\t\t\t\t\t\"weight\": 31.26817447495961,\n\t\t\t\t\t\"selected\": 0,\n\t\t\t\t\t\"foldBeforeWeight\": 35,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\t\t\"component\": \"testcase\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"tab\",\n\t\t\t\t\t\t\t\"component\": \"result\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}",
  "1723_14631217_python-updated-time": "1746443844415",
  "2619_14631217_python-updated-time": "1747060159121",
  "936_14631217_python": "\"class RLEIterator:\\n    def __init__(self, encoding):\\n        self.encoding = encoding\\n        self.i = 0\\n\\n    def next(self, n):\\n        while self.i < len(self.encoding):\\n            if self.encoding[self.i] >= n:\\n                self.encoding[self.i] -= n\\n                return self.encoding[self.i + 1]\\n            n -= self.encoding[self.i]\\n            self.i += 2\\n        return -1\\n\"",
  "2689_14631217_python-updated-time": "1747065113993",
  "1371_14631217_python": "\"class Solution:\\n    def minRemoveToMakeValid(self, s):\\n        stack = []\\n        to_remove = set()\\n\\n        for i, c in enumerate(s):\\n            if c == '(':\\n                stack.append(i)\\n            elif c == ')':\\n                if stack:\\n                    stack.pop()\\n                else:\\n                    to_remove.add(i)\\n\\n        to_remove = to_remove.union(set(stack))\\n        result = [c for i, c in enumerate(s) if i not in to_remove]\\n        return ''.join(result)\\n\"",
  "2530_14631217_python": "\"class Solution(object):\\n    def minimizeArrayValue(self, nums):\\n        prefix = 0\\n        res = 0\\n        for i, x in enumerate(nums):\\n            prefix += x\\n            # minimal max for this prefix is ceil(prefix/(i+1))\\n            # which is (prefix + i) // (i+1)\\n            val = (prefix + i) // (i + 1)\\n            if val > res:\\n                res = val\\n        return res\\n\"",
  "736_14631217_python-updated-time": "1745787444322",
  "3356_14631217_python-updated-time": "1747420533905",
  "70_14631217_python": "\"class Solution(object):\\n    def climbStairs(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if n <= 2:\\n            return n\\n\\n        first, second = 1, 2\\n\\n        for _ in range(3, n + 1):\\n            first, second = second, first + second\\n\\n        return second\\n\"",
  "1401_14631217_python": "\"class Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        # Let x be jumbo, y be small\\n        # 4x + 2y = tomatoSlices\\n        # x + y = cheeseSlices\\n\\n        # From above: x = tomatoSlices/2 - cheeseSlices\\n        #             y = 2*cheeseSlices - tomatoSlices/2\\n\\n        if tomatoSlices % 2 != 0:\\n            return []\\n\\n        x = tomatoSlices // 2 - cheeseSlices\\n        y = cheeseSlices - x\\n\\n        if x < 0 or y < 0:\\n            return []\\n\\n        return [x, y]\\n\"",
  "1261_14631217_python-updated-time": "1746126017017",
  "2131_14631217_python": "\"class Solution:\\n    def smallestMissingValueSubtree(self, parents, nums):\\n        n = len(nums)\\n        # Build children lists\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            children[parents[i]].append(i)\\n\\n        # Find the node with genetic value 1 (if any)\\n        idx1 = -1\\n        for i, v in enumerate(nums):\\n            if v == 1:\\n                idx1 = i\\n                break\\n\\n        # If there is no '1' in the entire tree, every subtree misses '1'\\n        if idx1 == -1:\\n            return [1] * n\\n\\n        # Prepare answer (default = 1) and a seen‐array for marking values 1..n+1\\n        ans = [1] * n\\n        seen = [False] * (n + 2)\\n        mex = 1\\n\\n        # Iterative DFS to mark an entire subtree rooted at u\\n        def dfs_mark(u):\\n            stack = [u]\\n            while stack:\\n                v = stack.pop()\\n                val = nums[v]\\n                if val <= n + 1 and not seen[val]:\\n                    seen[val] = True\\n                for w in children[v]:\\n                    stack.append(w)\\n\\n        # Walk from idx1 up to the root, merging in each ancestor's subtree\\n        node = idx1\\n        came_from = None\\n        while node != -1:\\n            if came_from is None:\\n                # First step: mark the whole subtree of idx1\\n                dfs_mark(node)\\n            else:\\n                # Mark the ancestor's own value\\n                val = nums[node]\\n                if val <= n + 1 and not seen[val]:\\n                    seen[val] = True\\n                # Mark every sibling‐subtree of the path‐child\\n                for c in children[node]:\\n                    if c != came_from:\\n                        dfs_mark(c)\\n\\n            # Advance mex until we find the first unseen integer\\n            while mex <= n + 1 and seen[mex]:\\n                mex += 1\\n            ans[node] = mex\\n\\n            came_from, node = node, parents[node]\\n\\n        return ans\\n\"",
  "3201_14631217_python": "\"class Solution:\\n    def distributeCandies(self, n, limit):\\n        def comb(n, k):\\n            if k < 0 or k > n:\\n                return 0\\n            res = 1\\n            for i in range(1, k + 1):\\n                res = res * (n - i + 1) // i\\n            return res\\n\\n        def count(x):\\n            return comb(x + 2, 2) if x >= 0 else 0\\n\\n        l = limit + 1\\n        total = count(n)\\n        over1 = count(n - l)\\n        over2 = count(n - 2 * l)\\n        over3 = count(n - 3 * l)\\n\\n        return total - 3 * over1 + 3 * over2 - over3\\n\"",
  "966_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def numSubarraysWithSum(self, nums, goal):\\n        count = defaultdict(int)\\n        count[0] = 1  # prefix sum 0 appears once\\n        prefix_sum = 0\\n        res = 0\\n\\n        for num in nums:\\n            prefix_sum += num\\n            res += count[prefix_sum - goal]\\n            count[prefix_sum] += 1\\n\\n        return res\\n\"",
  "3095_14631217_python-updated-time": "1747227560305",
  "1629_14631217_python-updated-time": "1746433238649",
  "2455_14631217_python": "\"class Solution(object):\\n    def edgeScore(self, edges):\\n        from collections import defaultdict\\n\\n        score = defaultdict(int)\\n        for i, v in enumerate(edges):\\n            score[v] += i\\n\\n        max_score = -1\\n        result = -1\\n\\n        for node in range(len(edges)):\\n            if score[node] > max_score or (score[node] == max_score and node < result):\\n                max_score = score[node]\\n                result = node\\n\\n        return result\\n\"",
  "3625_14631217_python": "\"class Solution(object):\\n    def canAliceWin(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if n < 10:\\n            return False\\n        \\n        stones = n\\n        stones -= 10  # Alice's first move\\n        if stones < 0:\\n            return False\\n        next_move = 9  # Bob's next move should be 9\\n        \\n        turn = 1  # 0 for Alice's turn, 1 for Bob's. But let's track whose turn it is. Wait, after Alice's first move, it's Bob's turn.\\n        \\n        while True:\\n            if turn % 2 == 1:  # Bob's turn\\n                if stones >= next_move:\\n                    stones -= next_move\\n                    next_move = next_move - 1\\n                    turn += 1\\n                else:\\n                    return True  # Bob can't move, Alice wins\\n            else:  # Alice's turn\\n                if stones >= next_move:\\n                    stones -= next_move\\n                    next_move = next_move - 1\\n                    turn += 1\\n                else:\\n                    return False  # Alice can't move, Bob wins\"",
  "3696_14631217_python": "\"class Solution(object):\\n    def countSubstrings(self, s):\\n        n = len(s)\\n        # Precompute running digit-sums mod 3 and mod 9\\n        sum3 = [0]*(n+1)\\n        sum9 = [0]*(n+1)\\n        for i,ch in enumerate(s):\\n            d = ord(ch)-48\\n            sum3[i+1] = (sum3[i] + d) % 3\\n            sum9[i+1] = (sum9[i] + d) % 9\\n\\n        # Precompute prefix value mod 7, and 10^t mod7 + their inverses\\n        pm7 = [0]*(n+1)\\n        for i,ch in enumerate(s):\\n            pm7[i+1] = (pm7[i]*10 + (ord(ch)-48)) % 7\\n\\n        P7 = [1]*6\\n        for t in range(1,6):\\n            P7[t] = (P7[t-1]*10) % 7\\n        # invP7[t] = modular inverse of P7[t] mod 7\\n        invP7 = [pow(P7[t], 5, 7) for t in range(6)]  # since φ(7)=6, inv = x^(φ-1)\\n\\n        # Counters for substrings by prefix‐state\\n        cnt3  = [0]*3;  cnt3[0] = 1\\n        cnt9  = [0]*9;  cnt9[0] = 1\\n        cnt7  = [[0]*7 for _ in range(6)]\\n        cnt7[0][0] = 1\\n\\n        ans = 0\\n        for j,ch in enumerate(s):\\n            d = ord(ch) - 48\\n\\n            if d == 0:\\n                # substrings ending in '0' are ineligible\\n                pass\\n\\n            elif d in (1,2,5):\\n                # always divisible if last digit is 1,2,5\\n                ans += (j+1)\\n\\n            elif d in (3,6):\\n                # divisible by 3 if digit‐sum mod3 matches a previous prefix\\n                r = sum3[j+1]\\n                ans += cnt3[r]\\n\\n            elif d == 9:\\n                # divisible by 9 if digit‐sum mod9 matches\\n                r = sum9[j+1]\\n                ans += cnt9[r]\\n\\n            elif d == 4:\\n                # divisibility by 4 depends only on the last two digits\\n                # length=1 always works; length>=2 works if last two %4==0\\n                add = 1\\n                if j >= 1:\\n                    two = ( (ord(s[j-1]) - 48)*10 + 4 )\\n                    if two % 4 == 0:\\n                        add += j\\n                ans += add\\n\\n            elif d == 8:\\n                # divisibility by 8 depends on last three digits\\n                add = 1\\n                if j >= 1:\\n                    two = ((ord(s[j-1]) - 48)*10 + 8)\\n                    if two % 8 == 0:\\n                        add += 1\\n                if j >= 2:\\n                    tri = ((ord(s[j-2]) - 48)*100 +\\n                           (ord(s[j-1]) - 48)*10 + 8)\\n                    if tri % 8 == 0:\\n                        add += (j-1)\\n                ans += add\\n\\n            else:  # d == 7\\n                # use the period-6 trick mod 7\\n                R = pm7[j+1]\\n                G = (j+1) % 6\\n                sub = 0\\n                for r_mod in range(6):\\n                    t = (G - r_mod) % 6\\n                    need = (R * invP7[t]) % 7\\n                    sub += cnt7[r_mod][need]\\n                ans += sub\\n\\n            # --- now update the prefix-state counters at position j+1 ---\\n            cnt3[ sum3[j+1] ] += 1\\n            cnt9[ sum9[j+1] ] += 1\\n            km = (j+1) % 6\\n            rv = pm7[j+1]\\n            cnt7[km][rv] += 1\\n\\n        return ans\\n\"",
  "1040_14631217_python-updated-time": "1746040816060",
  "2636_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def maxScore(self, nums1, nums2, k):\\n        # Pair up nums2 and nums1, sort by nums2 descending\\n        pairs = sorted(zip(nums2, nums1), reverse=True)\\n        \\n        min_heap = []\\n        sum1 = 0\\n        ans = 0\\n        \\n        for val2, val1 in pairs:\\n            # add this nums1 to heap\\n            heapq.heappush(min_heap, val1)\\n            sum1 += val1\\n            \\n            # keep only top k nums1 values\\n            if len(min_heap) > k:\\n                sum1 -= heapq.heappop(min_heap)\\n            \\n            # when we have k elements, compute score\\n            if len(min_heap) == k:\\n                ans = max(ans, sum1 * val2)\\n        \\n        return ans\\n\"",
  "3527_14631217_python": "\"from bisect import bisect_left, bisect_right, insort\\n\\nclass Fenwick:\\n    def __init__(self, n):\\n        self.n = n\\n        self.bit = [0]*(n+2)\\n    def add(self, idx, delta):\\n        while idx <= self.n:\\n            self.bit[idx] += delta\\n            idx += idx & -idx\\n    def pref(self, idx):\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n    def suffix(self, idx):\\n        return self.pref(self.n) - self.pref(idx)\\n\\nclass Solution(object):\\n    def _insert_interval(self, L, R):\\n        self.start2end[L] = R\\n        self.end2start[R] = L\\n        insort(self.starts, L)\\n        length = R - L + 1\\n        self.ft_freq.add(length,  1)\\n        self.ft_sum .add(length, length+1)\\n\\n    def _erase_interval(self, L, R):\\n        del self.start2end[L]\\n        del self.end2start[R]\\n        self.starts.pop(bisect_left(self.starts, L))\\n        length = R - L + 1\\n        self.ft_freq.add(length, -1)\\n        self.ft_sum .add(length, -(length+1))\\n\\n    def numberOfAlternatingGroups(self, colors, queries):\\n        n = len(colors)\\n        # Build the diff array: 1 where colors[i] != colors[i+1]\\n        diff = [colors[i] ^ colors[(i+1) % n] for i in range(n)]\\n\\n        # Build initial runs of consecutive 1's in diff (linear)\\n        self.start2end = {}\\n        self.end2start = {}\\n        self.starts     = []\\n        self.ft_freq    = Fenwick(n)   # freq of runs by length\\n        self.ft_sum     = Fenwick(n)   # sum of (length+1) by length\\n\\n        i = 0\\n        while i < n:\\n            if diff[i] == 1:\\n                j = i\\n                while j+1 < n and diff[j+1] == 1:\\n                    j += 1\\n                self._insert_interval(i, j)\\n                i = j+1\\n            else:\\n                i += 1\\n\\n        ans = []\\n\\n        # Count windows of t consecutive 1's that *wrap* from n-1→0\\n        def cross_windows(t):\\n            if not (diff[0] and diff[-1]):\\n                return 0\\n            L = self.end2start[n-1]   # the run that ends at n-1\\n            R = self.start2end.get(0, -1)\\n            # If there is no run starting at 0, then start2end[0] is missing\\n            # => no wrap-wide run, but diff[0]==1 implies run MUST start at 0\\n            # so get(0,-1) is just a safety; in practice 0∈start2end if diff[0]==1.\\n            if L == 0:\\n                # single run covers entire array\\n                return 0 if n < t else (t-1)\\n            a = n - L       # length of tail segment\\n            b = R + 1       # length of head segment\\n            total = max(0, a + b - t + 1)\\n            inside = max(0, a - t + 1) + max(0, b - t + 1)\\n            return max(0, total - inside)\\n\\n        # Flip diff[pos] to its new value, updating runs\\n        def flip(pos):\\n            old = diff[pos]\\n            new = colors[pos] ^ colors[(pos+1) % n]\\n            if old == new:\\n                return\\n\\n            # 0→1: we may insert, extend left/right, but *never* merge across boundary\\n            if new == 1:\\n                # only consider linear neighbors:\\n                left_one  = (pos > 0     and diff[pos-1] == 1)\\n                right_one = (pos < n-1   and diff[pos+1] == 1)\\n\\n                if not left_one and not right_one:\\n                    # brand new run [pos,pos]\\n                    self._insert_interval(pos, pos)\\n\\n                elif left_one and not right_one:\\n                    # extend the existing run that ends at pos-1\\n                    L = self.end2start[pos-1]\\n                    R = self.start2end[L]\\n                    self._erase_interval(L, R)\\n                    self._insert_interval(L, R+1)\\n\\n                elif not left_one and right_one:\\n                    # extend the existing run that starts at pos+1\\n                    R = self.start2end[pos+1]\\n                    L = self.end2start[R]\\n                    self._erase_interval(L, R)\\n                    self._insert_interval(pos, R)\\n\\n                else:\\n                    # both sides linear: merge two runs\\n                    L1 = self.end2start[pos-1]\\n                    R1 = self.start2end[L1]\\n                    L2 = pos+1\\n                    R2 = self.start2end[L2]\\n                    self._erase_interval(L1, R1)\\n                    self._erase_interval(L2, R2)\\n                    self._insert_interval(L1, R2)\\n\\n            # 1→0: we remove one cell from its run, possibly splitting\\n            else:\\n                idx_run = bisect_right(self.starts, pos) - 1\\n                L = self.starts[idx_run]\\n                R = self.start2end[L]\\n                self._erase_interval(L, R)\\n\\n                if L == R == pos:\\n                    # run disappears entirely\\n                    pass\\n                elif L == pos:\\n                    # chop off left end\\n                    self._insert_interval(L+1, R)\\n                elif R == pos:\\n                    # chop off right end\\n                    self._insert_interval(L, R-1)\\n                else:\\n                    # split into two runs\\n                    self._insert_interval(L, pos-1)\\n                    self._insert_interval(pos+1, R)\\n\\n            diff[pos] = new\\n\\n        # Process each query\\n        for q in queries:\\n            if q[0] == 1:\\n                k = q[1]\\n                t = k - 1\\n                # windows fully inside one run:\\n                S0 = self.ft_freq.suffix(t-1)\\n                S1 = self.ft_sum .suffix(t-1)\\n                inside = S1 - t * S0\\n                # plus any that cross the end ↔ start\\n                ans.append(inside + cross_windows(t))\\n            else:\\n                _, idx, col = q\\n                if colors[idx] != col:\\n                    # 1) update the tile color\\n                    colors[idx] = col\\n                    # 2) fix its two incident edges in diff\\n                    flip((idx-1) % n)\\n                    flip(idx)\\n\\n        return ans\\n\"",
  "1874_14631217_python-updated-time": "1746531774752",
  "992_14631217_python": "\"class Solution:\\n    def minDeletionSize(self, strs):\\n        n = len(strs)\\n        m = len(strs[0])\\n        kept = []\\n        res = 0\\n\\n        for col in range(m):\\n            # Check if adding this column keeps rows sorted\\n            if all(\\n                tuple(strs[i][k] for k in kept + [col]) >=\\n                tuple(strs[i - 1][k] for k in kept + [col])\\n                for i in range(1, n)\\n            ):\\n                kept.append(col)\\n            else:\\n                res += 1\\n\\n        return res\\n\"",
  "1003_14631217_python-updated-time": "1746039011605",
  "858_14631217_python": "\"class Solution(object):\\n    def maskPII(self, s):\\n        if '@' in s:\\n            name, domain = s.lower().split('@')\\n            return name[0] + '*****' + name[-1] + '@' + domain\\n        else:\\n            digits = [c for c in s if c.isdigit()]\\n            local = \\\"***-***-\\\" + ''.join(digits[-4:])\\n            if len(digits) == 10:\\n                return local\\n            else:\\n                return \\\"+\\\" + \\\"*\\\" * (len(digits) - 10) + \\\"-\\\" + local\\n\"",
  "35_14631217_python": "\"class Solution(object):\\n    def searchInsert(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return left\\n\"",
  "38_14631217_python": "\"class Solution(object):\\n    def countAndSay(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        result = \\\"1\\\"\\n        \\n        for _ in range(n - 1):\\n            current = \\\"\\\"\\n            count = 1\\n            for i in range(1, len(result)):\\n                if result[i] == result[i - 1]:\\n                    count += 1\\n                else:\\n                    current += str(count) + result[i - 1]\\n                    count = 1\\n            current += str(count) + result[-1]\\n            result = current\\n        \\n        return result\\n\"",
  "1376_14631217_python-updated-time": "1746882853865",
  "1990_14631217_python": "\"class Solution:\\n    def getBiggestThree(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        sums = set()\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # maximum possible \\\"radius\\\" k for a rhombus centered at (i,j)\\n                k_max = min(i, m - 1 - i, j, n - 1 - j)\\n                \\n                # k = 0 is just the single cell\\n                total = grid[i][j]\\n                sums.add(total)\\n                \\n                # try larger rhombi\\n                for k in range(1, k_max + 1):\\n                    border_sum = 0\\n                    # edge 1: top -> right\\n                    for t in range(0, k + 1):\\n                        r, c = i - k + t, j + t\\n                        border_sum += grid[r][c]\\n                    # edge 2: right -> bottom\\n                    for t in range(1, k + 1):\\n                        r, c = i + t, j + k - t\\n                        border_sum += grid[r][c]\\n                    # edge 3: bottom -> left\\n                    for t in range(1, k + 1):\\n                        r, c = i + k - t, j - t\\n                        border_sum += grid[r][c]\\n                    # edge 4: left -> top\\n                    for t in range(1, k):\\n                        r, c = i - t, j - k + t\\n                        border_sum += grid[r][c]\\n                    \\n                    sums.add(border_sum)\\n        \\n        # take the top three distinct sums\\n        return sorted(sums, reverse=True)[:3]\\n\"",
  "485_14631217_python": "\"class Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_count = count = 0\\n        for num in nums:\\n            if num == 1:\\n                count += 1\\n                max_count = max(max_count, count)\\n            else:\\n                count = 0\\n        return max_count\\n\"",
  "488_14631217_python-updated-time": "1745445756857",
  "3163_14631217_python": "\"class Solution(object):\\n    def sumCounts(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        res = 0\\n        for i in range(n):\\n            seen = set()\\n            for j in range(i, n):\\n                seen.add(nums[j])\\n                res += len(seen) ** 2\\n        return res\\n\"",
  "1440_14631217_python": "\"class Solution:\\n    def getNoZeroIntegers(self, n):\\n        def is_no_zero(x):\\n            while x:\\n                if x % 10 == 0:\\n                    return False\\n                x //= 10\\n            return True\\n\\n        for a in range(1, n):\\n            b = n - a\\n            if is_no_zero(a) and is_no_zero(b):\\n                return [a, b]\\n        # problem guarantees a solution exists, so we should never get here\\n\"",
  "3238_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, source, target, original, changed, cost):\\n        \\\"\\\"\\\"\\n        :type source: str\\n        :type target: str\\n        :type original: List[str]\\n        :type changed: List[str]\\n        :type cost: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(source)\\n        # group operations by length\\n        from collections import defaultdict\\n        ops_by_len = defaultdict(list)\\n        for o, c, w in zip(original, changed, cost):\\n            L = len(o)\\n            ops_by_len[L].append((o, c, w))\\n        \\n        # rolling-hash parameters\\n        base = 91138233\\n        mod1 = 10**9 + 7\\n        mod2 = 10**9 + 9\\n        \\n        # precompute powers\\n        pow1 = [1] * (n+1)\\n        pow2 = [1] * (n+1)\\n        for i in range(1, n+1):\\n            pow1[i] = (pow1[i-1] * base) % mod1\\n            pow2[i] = (pow2[i-1] * base) % mod2\\n        \\n        # prefix hashes for source and target\\n        h1_s = [0] * (n+1)\\n        h2_s = [0] * (n+1)\\n        h1_t = [0] * (n+1)\\n        h2_t = [0] * (n+1)\\n        for i, ch in enumerate(source, 1):\\n            v = ord(ch)\\n            h1_s[i] = (h1_s[i-1] * base + v) % mod1\\n            h2_s[i] = (h2_s[i-1] * base + v) % mod2\\n        for i, ch in enumerate(target, 1):\\n            v = ord(ch)\\n            h1_t[i] = (h1_t[i-1] * base + v) % mod1\\n            h2_t[i] = (h2_t[i-1] * base + v) % mod2\\n        \\n        # helper to get double-hash of substring [i:j)\\n        def sub_hash(h1, h2, i, j):\\n            x1 = (h1[j] - h1[i] * pow1[j-i]) % mod1\\n            x2 = (h2[j] - h2[i] * pow2[j-i]) % mod2\\n            return (x1, x2)\\n        \\n        INF = 10**30\\n        # for each length L, build graph and floyd-warshall all-pairs distances\\n        dist_by_len = {}\\n        hash_to_idx = {}\\n        for L, ops in ops_by_len.items():\\n            # collect all distinct node strings of length L\\n            nodes = {}\\n            idx = 0\\n            for o, c, _ in ops:\\n                if o not in nodes:\\n                    nodes[o] = idx; idx += 1\\n                if c not in nodes:\\n                    nodes[c] = idx; idx += 1\\n            N = idx\\n            # initialize dist matrix\\n            dist = [[INF]*N for _ in range(N)]\\n            for i in range(N):\\n                dist[i][i] = 0\\n            # add edges\\n            for o, c, w in ops:\\n                u = nodes[o]\\n                v = nodes[c]\\n                if w < dist[u][v]:\\n                    dist[u][v] = w\\n            # floyd-warshall\\n            for k in range(N):\\n                dk = dist[k]\\n                for i in range(N):\\n                    di = dist[i]\\n                    via = di[k]\\n                    if via == INF: continue\\n                    # unroll inner\\n                    for j in range(N):\\n                        nd = via + dk[j]\\n                        if nd < di[j]:\\n                            di[j] = nd\\n            # build hash->idx map for substrings of length L\\n            hmap = {}\\n            # compute hash for each node string\\n            for s_str, i_node in nodes.items():\\n                h1 = 0\\n                h2 = 0\\n                for ch in s_str:\\n                    v = ord(ch)\\n                    h1 = (h1 * base + v) % mod1\\n                    h2 = (h2 * base + v) % mod2\\n                hmap[(h1,h2)] = i_node\\n            dist_by_len[L] = dist\\n            hash_to_idx[L] = hmap\\n        \\n        # DP over prefix\\n        dp = [INF] * (n+1)\\n        dp[0] = 0\\n        for i in range(1, n+1):\\n            # trivial single char match\\n            if source[i-1] == target[i-1]:\\n                if dp[i-1] < dp[i]:\\n                    dp[i] = dp[i-1]\\n            # try each op-length segment ending at i\\n            for L, dist in dist_by_len.items():\\n                if L > i: \\n                    continue\\n                j = i - L\\n                # get substring hashes\\n                hs = sub_hash(h1_s, h2_s, j, i)\\n                ht = sub_hash(h1_t, h2_t, j, i)\\n                hmap = hash_to_idx[L]\\n                u = hmap.get(hs)\\n                if u is None:\\n                    continue\\n                v = hmap.get(ht)\\n                if v is None:\\n                    continue\\n                d = dist[u][v]\\n                if d < INF:\\n                    cost_here = dp[j] + d\\n                    if cost_here < dp[i]:\\n                        dp[i] = cost_here\\n        \\n        return dp[n] if dp[n] < INF else -1\\n\"",
  "2192_14631217_python": "\"class Solution:\\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\\n        sr, sc = startPos\\n        hr, hc = homePos\\n        cost = 0\\n        \\n        # Move vertically from sr to hr\\n        if sr < hr:\\n            for r in range(sr+1, hr+1):\\n                cost += rowCosts[r]\\n        else:\\n            for r in range(sr-1, hr-1, -1):\\n                cost += rowCosts[r]\\n        \\n        # Move horizontally from sc to hc\\n        if sc < hc:\\n            for c in range(sc+1, hc+1):\\n                cost += colCosts[c]\\n        else:\\n            for c in range(sc-1, hc-1, -1):\\n                cost += colCosts[c]\\n        \\n        return cost\\n\"",
  "973_14631217_python-updated-time": "1746004248499",
  "3798_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\nimport collections\\n\\nclass Solution(object):\\n    def longestSpecialPath(self, edges, nums):\\n        n = len(nums)\\n        # build adjacency and then children list rooted at 0\\n        adj = [[] for _ in range(n)]\\n        for u,v,w in edges:\\n            adj[u].append((v,w))\\n            adj[v].append((u,w))\\n        children = [[] for _ in range(n)]\\n        q = collections.deque([0])\\n        parent = [-1]*n\\n        parent[0] = 0\\n        while q:\\n            u = q.popleft()\\n            for v,w in adj[u]:\\n                if parent[v] == -1:\\n                    parent[v] = u\\n                    children[u].append((v,w))\\n                    q.append(v)\\n\\n        # sliding-window state\\n        maxval = max(nums) if nums else 0\\n        self.counts = [0]*(maxval+1)\\n        self.dup2 = 0\\n        self.dup3plus = 0\\n        self.ops = []        # stack of (\\\"inc\\\"/\\\"dec\\\", val)\\n        self.path = []       # node indices\\n        self.dists = []      # cumulative distances\\n        self.L = 0           # left index of valid window\\n        self.bestLen = 0\\n        self.bestNodes = 1\\n\\n        # define dfs as method\\n        def dfs(u, curDist):\\n            # snapshot\\n            snap_ops = len(self.ops)\\n            snap_L   = self.L\\n\\n            # push u\\n            self.path.append(u)\\n            self.dists.append(curDist)\\n            val = nums[u]\\n            # inc count\\n            self.counts[val] += 1\\n            if self.counts[val] == 2:\\n                self.dup2 += 1\\n            elif self.counts[val] == 3:\\n                self.dup2 -= 1\\n                self.dup3plus += 1\\n            self.ops.append((\\\"inc\\\", val))\\n\\n            # shrink from left until valid\\n            while self.dup2 > 1 or self.dup3plus > 0:\\n                wnode = self.path[self.L]\\n                wval = nums[wnode]\\n                # dec count\\n                self.counts[wval] -= 1\\n                if self.counts[wval] == 1:\\n                    self.dup2 -= 1\\n                elif self.counts[wval] == 2:\\n                    self.dup3plus -= 1\\n                    self.dup2 += 1\\n                self.ops.append((\\\"dec\\\", wval))\\n                self.L += 1\\n\\n            # update best\\n            windowLen = curDist - self.dists[self.L]\\n            windowNodes = len(self.path) - self.L\\n            if windowLen > self.bestLen:\\n                self.bestLen = windowLen\\n                self.bestNodes = windowNodes\\n            elif windowLen == self.bestLen and windowNodes < self.bestNodes:\\n                self.bestNodes = windowNodes\\n\\n            # recurse\\n            for v,w in children[u]:\\n                dfs(v, curDist + w)\\n\\n            # undo\\n            while len(self.ops) > snap_ops:\\n                typ, v = self.ops.pop()\\n                if typ == \\\"inc\\\":\\n                    # we had done counts[v] += 1\\n                    self.counts[v] -= 1\\n                    if self.counts[v] == 1:\\n                        self.dup2 -= 1\\n                    elif self.counts[v] == 2:\\n                        self.dup3plus -= 1\\n                        self.dup2 += 1\\n                else:\\n                    # we had done counts[v] -= 1\\n                    self.counts[v] += 1\\n                    if self.counts[v] == 2:\\n                        self.dup2 += 1\\n                    elif self.counts[v] == 3:\\n                        self.dup2 -= 1\\n                        self.dup3plus += 1\\n\\n            # restore L, pop path/dists\\n            self.L = snap_L\\n            self.path.pop()\\n            self.dists.pop()\\n\\n        # start DFS from root (0) with distance 0\\n        dfs(0, 0)\\n        return [self.bestLen, self.bestNodes]\\n\"",
  "792_14631217_python-updated-time": "1745786333313",
  "2903_14631217_python": "\"\\nclass Solution(object):\\n    def insertGreatestCommonDivisors(self, head):\\n        def compute_gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        curr = head\\n        while curr and curr.next:\\n            g = compute_gcd(curr.val, curr.next.val)\\n            new_node = ListNode(g, curr.next)\\n            curr.next = new_node\\n            curr = new_node.next\\n        return head\\n\"",
  "2620_14631217_python-updated-time": "1747060185390",
  "3541_14631217_python-updated-time": "1747572615197",
  "481_14631217_python-updated-time": "1745441628174",
  "3406_14631217_python": "\"class Solution(object):\\n    def numberOfStableArrays(self, zero, one, limit):\\n        MOD = 10**9 + 7\\n        Z, O, L = zero, one, limit\\n        N = Z + O\\n\\n        # Precompute factorials and inverse factorials up to N+N\\n        M = 2 * N + 5\\n        fact = [1] * M\\n        invfact = [1] * M\\n        for i in range(1, M):\\n            fact[i] = fact[i-1] * i % MOD\\n        invfact[M-1] = pow(fact[M-1], MOD-2, MOD)\\n        for i in range(M-2, -1, -1):\\n            invfact[i] = invfact[i+1] * (i+1) % MOD\\n\\n        def binom(n, k):\\n            if k < 0 or k > n:\\n                return 0\\n            return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD\\n\\n        # Count compositions of n into k positive parts, each ≤ L\\n        def count_bounded(n, k):\\n            if k == 0:\\n                return 1 if n == 0 else 0\\n            # sum_{j=0..floor((n-k)/L)} (-1)^j * C(k, j) * C(n - jL -1, k-1)\\n            res = 0\\n            maxj = (n - k) // L\\n            for j in range(maxj + 1):\\n                term = binom(k, j) * binom(n - j*L - 1, k - 1) % MOD\\n                if j & 1:\\n                    res = (res - term) % MOD\\n                else:\\n                    res = (res + term) % MOD\\n            return res\\n\\n        ans = 0\\n        # Try both possible starting bits s=0 or s=1\\n        for s in (0, 1):\\n            # total number of blocks K from 1 up to N\\n            for K in range(1, N+1):\\n                # zero-blocks / one-blocks depending on start\\n                if s == 0:\\n                    Zb = (K + 1) // 2\\n                    Ob = K // 2\\n                else:\\n                    Zb = K // 2\\n                    Ob = (K + 1) // 2\\n\\n                if Zb > Z or Ob > O:\\n                    continue\\n\\n                ways_z = count_bounded(Z, Zb)\\n                ways_o = count_bounded(O, Ob)\\n                ans = (ans + ways_z * ways_o) % MOD\\n\\n        return ans\\n\\n\"",
  "1698_14631217_python-updated-time": "1746438344969",
  "1139_14631217_python": "\"class Solution(object):\\n    def prevPermOpt1(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        \\n        # Step 1: Find the first index i such that arr[i] > arr[i + 1]\\n        for i in range(n - 2, -1, -1):\\n            if arr[i] > arr[i + 1]:\\n                break\\n        else:\\n            return arr  # Already smallest permutation\\n        \\n        # Step 2: Find the largest j > i such that arr[j] < arr[i]\\n        # and arr[j] is the largest possible such value (but if duplicates, take leftmost)\\n        j = n - 1\\n        while j > i:\\n            if arr[j] < arr[i]:\\n                # Move to the left to get the leftmost one if duplicates exist\\n                while j - 1 > i and arr[j] == arr[j - 1]:\\n                    j -= 1\\n                break\\n            j -= 1\\n\\n        # Step 3: Swap and return\\n        arr[i], arr[j] = arr[j], arr[i]\\n        return arr\\n\"",
  "2807_14631217_javascript-updated-time": "1747140792583",
  "1065_14631217_python-updated-time": "1746041640092",
  "2421_14631217_python-updated-time": "1746907474021",
  "3558_14631217_python-updated-time": "1747571535685",
  "993_14631217_python": "\"class Solution:\\n    def tallestBillboard(self, rods):\\n        dp = {0: 0}  # diff -> tallest shorter side\\n\\n        for r in rods:\\n            curr = dp.copy()\\n            for diff, height in curr.items():\\n                dp[diff + r] = max(dp.get(diff + r, 0), height)\\n                dp[abs(diff - r)] = max(dp.get(abs(diff - r), 0), height + min(r, diff))\\n        \\n        return dp[0]\\n\"",
  "3211_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def findMaximumLength(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # 1) Build prefix sums P\\n        P = [0] * (n + 1)\\n        for i, v in enumerate(nums, start=1):\\n            P[i] = P[i-1] + v\\n\\n        # heap:   (T_j,   dp[j]-j,   -P[j],   j)\\n        # pq:     (dp[j]-j,  -P[j],   j)\\n        heap = []\\n        pq   = []\\n\\n        # Base state j=0: dp[0]=0, last_sum[0]=0, so T0 = 0 + 0 = 0\\n        heapq.heappush(heap, (0, 0, 0, 0))\\n\\n        dp_n = None\\n\\n        for i in range(1, n+1):\\n            # 2) move all states with T_j <= P[i] into pq\\n            while heap and heap[0][0] <= P[i]:\\n                Tj, dpj_j, negPj, j = heapq.heappop(heap)\\n                heapq.heappush(pq, (dpj_j, negPj, j))\\n\\n            if not pq:\\n                # Should never happen (j=0 is always eligible once i>=1),\\n                # but if it did, we'd have to merge everything → 1 segment.\\n                dp_i = i - 1\\n            else:\\n                dpj_j, negPj, j = pq[0]\\n                # dp[i] = dp[j] + (i - j - 1)\\n                dp_i = (i - 1) + dpj_j\\n\\n            if i == n:\\n                dp_n = dp_i\\n\\n            # Compute last_sum[i] = sum(nums[j..i-1]) = P[i]-P[j]\\n            # where j is the argmin we just used (or 0 if pq was empty).\\n            # In the empty-pq fallback, j=0 and dpj_j=0 by construction.\\n            if pq:\\n                Pj = -negPj\\n            else:\\n                Pj = 0\\n            last_sum_i = P[i] - Pj\\n\\n            # New state's T_i = P[i] + last_sum_i\\n            T_i = P[i] + last_sum_i\\n            # And dp[i] - i = dpj_j - 1  (check: (i-1+dpj_j)-i = dpj_j-1)\\n            dp_i_minus_i = dpj_j - 1 if pq else -1\\n\\n            heapq.heappush(heap, (T_i, dp_i_minus_i, -P[i], i))\\n\\n        # dp_n is the minimum #merges. #segments = n - #merges.\\n        return n - dp_n\\n\"",
  "744_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def networkDelayTime(self, times, n, k):\\n        graph = [[] for _ in range(n + 1)]\\n        for u, v, w in times:\\n            graph[u].append((v, w))\\n        \\n        heap = [(0, k)]\\n        dist = [float('inf')] * (n + 1)\\n        dist[k] = 0\\n        \\n        while heap:\\n            time, node = heapq.heappop(heap)\\n            for nei, wt in graph[node]:\\n                if time + wt < dist[nei]:\\n                    dist[nei] = time + wt\\n                    heapq.heappush(heap, (dist[nei], nei))\\n        \\n        max_time = max(dist[1:])\\n        return max_time if max_time != float('inf') else -1\\n\"",
  "776_14631217_python": "\"class Solution(object):\\n    def postorder(self, root):\\n        if not root:\\n            return []\\n        stack, res = [root], []\\n        while stack:\\n            node = stack.pop()\\n            res.append(node.val)\\n            # push children onto stack to process before parent\\n            for child in node.children:\\n                stack.append(child)\\n        # reversed order gives postorder\\n        return res[::-1]\\n\"",
  "584_14631217_mysql-updated-time": "1745448055141",
  "3430_14631217_python-updated-time": "1747483985037",
  "1872_14631217_python-updated-time": "1746531309821",
  "3207_14631217_python": "\"\\nclass Solution(object):\\n    def findMinimumOperations(self, s1, s2, s3):\\n        \\\"\\\"\\\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = min(len(s1), len(s2), len(s3))\\n        common_len = 0\\n\\n        for i in range(n):\\n            if s1[i] == s2[i] == s3[i]:\\n                common_len += 1\\n            else:\\n                break\\n\\n        if common_len == 0:\\n            return -1\\n\\n        return (len(s1) - common_len) + (len(s2) - common_len) + (len(s3) - common_len)\\n\"",
  "59_14631217_python": "\"class Solution(object):\\n    def generateMatrix(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        matrix = [[0] * n for _ in range(n)]\\n        num = 1\\n        left, right, top, bottom = 0, n - 1, 0, n - 1\\n\\n        while left <= right and top <= bottom:\\n            for i in range(left, right + 1):\\n                matrix[top][i] = num\\n                num += 1\\n            top += 1\\n\\n            for i in range(top, bottom + 1):\\n                matrix[i][right] = num\\n                num += 1\\n            right -= 1\\n\\n            for i in range(right, left - 1, -1):\\n                matrix[bottom][i] = num\\n                num += 1\\n            bottom -= 1\\n\\n            for i in range(bottom, top - 1, -1):\\n                matrix[i][left] = num\\n                num += 1\\n            left += 1\\n\\n        return matrix\\n\"",
  "134_14631217_python-updated-time": "1745086716910",
  "2083_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def isThree(self, n):\\n        # Only perfect squares of a prime have exactly three divisors.\\n        m = int(math.sqrt(n))\\n        if m * m != n:\\n            return False\\n        if m < 2:\\n            return False\\n        # check primality of m\\n        r = int(math.sqrt(m))\\n        for d in range(2, r+1):\\n            if m % d == 0:\\n                return False\\n        return True\\n\"",
  "1573_14631217_python": "\"class Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        INF = float('inf')\\n        \\n        # min_len[i]: min length of subarray that ends at or before i with sum == target\\n        min_len = [INF] * n\\n        \\n        left = 0\\n        total = 0\\n        best = INF\\n        res = INF\\n        \\n        for right in range(n):\\n            total += arr[right]\\n            \\n            while total > target:\\n                total -= arr[left]\\n                left += 1\\n\\n            if total == target:\\n                curr_len = right - left + 1\\n                if left > 0 and min_len[left - 1] != INF:\\n                    res = min(res, curr_len + min_len[left - 1])\\n                best = min(best, curr_len)\\n\\n            min_len[right] = best\\n\\n        return res if res != INF else -1\\n\"",
  "35_14631217_python-updated-time": "1744988594160",
  "1390_14631217_mysql-updated-time": "1746259549583",
  "1156_14631217_python-updated-time": "1746107968272",
  "3566_14631217_python-updated-time": "1747580331328",
  "89_14631217_python-updated-time": "1745015594399",
  "3297_14631217_python-updated-time": "1747413471028",
  "3325_14631217_python-updated-time": "1747417898697",
  "901_14631217_python-updated-time": "1746001433870",
  "287_14631217_python": "\"class Solution(object):\\n    def findDuplicate(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        slow = nums[0]\\n        fast = nums[0]\\n\\n        # First phase: detect intersection\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        \\n        # Second phase: find the entrance to the cycle\\n        slow = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        \\n        return slow\\n\"",
  "822_14631217_python-updated-time": "1745878283938",
  "113_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def pathSum(self, root, targetSum):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :type targetSum: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n        \\n        def dfs(node, path, total):\\n            if not node:\\n                return\\n            path.append(node.val)\\n            total += node.val\\n            if not node.left and not node.right and total == targetSum:\\n                res.append(list(path))\\n            dfs(node.left, path, total)\\n            dfs(node.right, path, total)\\n            path.pop()\\n        \\n        dfs(root, [], 0)\\n        return res\\n\"",
  "1145_14631217_python": "\"class Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n\\n        # Precompute prefix sums for each row\\n        for row in matrix:\\n            for c in range(1, n):\\n                row[c] += row[c - 1]\\n\\n        # Fix column range [c1, c2]\\n        for c1 in range(n):\\n            for c2 in range(c1, n):\\n                counter = defaultdict(int)\\n                counter[0] = 1  # Base case\\n                curr_sum = 0\\n\\n                for r in range(m):\\n                    # Get sum of elements from column c1 to c2 in row r\\n                    row_sum = matrix[r][c2] - (matrix[r][c1 - 1] if c1 > 0 else 0)\\n                    curr_sum += row_sum\\n                    result += counter[curr_sum - target]\\n                    counter[curr_sum] += 1\\n\\n        return result\\n\"",
  "1509_14631217_mysql": "\"SELECT euni.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI euni\\nON e.id = euni.id;\\n\"",
  "3298_14631217_python-updated-time": "1747416398280",
  "3715_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maximumCoins(self, coins, k):\\n        \\\"\\\"\\\"\\n        :type coins: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # ------------------------------------------------------------------ #\\n        # 1. sort the (non-overlapping) segments\\n        coins.sort(key=lambda seg: seg[0])\\n\\n        # 2. build blocks: real segments + zero-valued gaps + sentinel block\\n        blocks = []                      # (length, value)\\n        prev = 1\\n        for l, r, c in coins:\\n            if l > prev:                     # gap before this segment\\n                blocks.append((l - prev, 0))\\n            blocks.append((r - l + 1, c))    # the segment itself\\n            prev = r + 1\\n        blocks.append((k, 0))                # sentinel of length ≥ k\\n\\n        # 3. prefix arrays (lengths and coin sums)\\n        pref_len = []\\n        pref_sum = []\\n        tot_len = tot_sum = 0\\n        for length, value in blocks:\\n            tot_len += length\\n            tot_sum += length * value\\n            pref_len.append(tot_len)\\n            pref_sum.append(tot_sum)\\n\\n        # helper: coin total on [L, R] in O(log n)\\n        def range_sum(L, R):\\n            i = bisect.bisect_left(pref_len, L)\\n            j = bisect.bisect_left(pref_len, R)\\n\\n            prev_L = pref_len[i - 1] if i else 0\\n            prev_R = pref_len[j - 1] if j else 0\\n            off_L  = L - prev_L - 1\\n            off_R  = R - prev_R - 1\\n\\n            if i == j:                                   # one block only\\n                return (R - L + 1) * blocks[i][1]\\n\\n            total  = (blocks[i][0] - off_L) * blocks[i][1]  # first block\\n            if j - i > 1:                                    # middle blocks\\n                total += pref_sum[j - 1] - pref_sum[i]\\n            total += (off_R + 1) * blocks[j][1]              # last block\\n            return total\\n\\n        # 4. candidate window starts  (sentinel **included**)\\n        candidates = set()\\n        coord = 1\\n        for length, _ in blocks:              #  <-- sentinel not skipped\\n            b = coord                         # start coordinate of this block\\n            for x in (b, b - 1, b - k + 1, b - k):\\n                if x >= 1:\\n                    candidates.add(x)\\n            coord += length                   # next block\\n        # 5. evaluate every candidate\\n        best = 0\\n        for s in candidates:\\n            e = s + k - 1\\n            if e > tot_len:                   # window would run past sentinel\\n                continue\\n            best = max(best, range_sum(s, e))\\n\\n        return best\\n\"",
  "2229_14631217_python": "\"class Solution:\\n    def maxTotalFruits(self, fruits, startPos, k):\\n        n = len(fruits)\\n        prefix = [0] * (n + 1)\\n        pos = [f[0] for f in fruits]\\n\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + fruits[i][1]\\n\\n        def range_sum(left, right):\\n            # Return total fruits from index `left` to `right` (inclusive)\\n            return prefix[right + 1] - prefix[left]\\n\\n        max_fruits = 0\\n\\n        # Two pointer window over sorted fruit positions\\n        i = 0\\n        for j in range(n):\\n            # shrink left bound `i` until window [i, j] fits in k steps\\n            while i <= j:\\n                left_pos = fruits[i][0]\\n                right_pos = fruits[j][0]\\n\\n                # walking from startPos to left_pos, then to right_pos\\n                dist = min(\\n                    abs(startPos - left_pos) + (right_pos - left_pos),\\n                    abs(startPos - right_pos) + (right_pos - left_pos)\\n                )\\n                if dist <= k:\\n                    break\\n                i += 1\\n\\n            if i <= j:\\n                max_fruits = max(max_fruits, range_sum(i, j))\\n\\n        return max_fruits\\n\"",
  "747_14631217_python-updated-time": "1745875453373",
  "2251_14631217_python": "\"class Solution:\\n    def numberOfWays(self, corridor):\\n        MOD = 10**9 + 7\\n        seats = [i for i, c in enumerate(corridor) if c == 'S']\\n        \\n        if len(seats) < 2 or len(seats) % 2 != 0:\\n            return 0\\n\\n        ways = 1\\n        for i in range(2, len(seats), 2):\\n            gap = seats[i] - seats[i - 1]\\n            ways = (ways * gap) % MOD\\n\\n        return ways\\n\"",
  "1488_14631217_python": "\"class Solution(object):\\n    def getKth(self, lo, hi, k):\\n        memo = {}\\n\\n        def power(x):\\n            if x == 1:\\n                return 0\\n            if x in memo:\\n                return memo[x]\\n            if x % 2 == 0:\\n                memo[x] = 1 + power(x // 2)\\n            else:\\n                memo[x] = 1 + power(3 * x + 1)\\n            return memo[x]\\n\\n        nums = list(range(lo, hi + 1))\\n        nums.sort(key=lambda x: (power(x), x))\\n        return nums[k - 1]\\n\"",
  "2820_14631217_javascript-updated-time": "1720874939212",
  "132_14631217_python": "\"class Solution(object):\\n    def minCut(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        \\n        # Create a table to store whether s[i:j+1] is a palindrome\\n        # palindrome[i][j] will be True if s[i...j] is a palindrome\\n        palindrome = [[False] * n for _ in range(n)]\\n        \\n        # All substrings of length 1 are palindromes\\n        for i in range(n):\\n            palindrome[i][i] = True\\n        \\n        # Check for substrings of length 2\\n        for i in range(n-1):\\n            if s[i] == s[i+1]:\\n                palindrome[i][i+1] = True\\n        \\n        # Check for substrings of length 3 or more\\n        for length in range(3, n+1):\\n            for i in range(n-length+1):\\n                j = i + length - 1\\n                if s[i] == s[j] and palindrome[i+1][j-1]:\\n                    palindrome[i][j] = True\\n        \\n        # dp[i] represents the minimum cuts needed for s[0:i+1]\\n        dp = [float('inf')] * n\\n        \\n        for i in range(n):\\n            # If the entire substring s[0:i+1] is a palindrome, no cuts needed\\n            if palindrome[0][i]:\\n                dp[i] = 0\\n            else:\\n                # Try all possible last cuts\\n                for j in range(i):\\n                    if palindrome[j+1][i]:\\n                        dp[i] = min(dp[i], dp[j] + 1)\\n        \\n        return dp[n-1]\"",
  "3362_14631217_python-updated-time": "1747424657587",
  "3729_14631217_python": "\"class Solution(object):\\n    def baseUnitConversions(self, conversions):\\n        \\\"\\\"\\\"\\n        :type conversions: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        \\n        # There are n units, and conversions has length n-1\\n        n = len(conversions) + 1\\n        \\n        # Build adjacency list from source -> (target, factor)\\n        graph = [[] for _ in range(n)]\\n        for src, tgt, factor in conversions:\\n            graph[src].append((tgt, factor))\\n        \\n        # Prepare result array; ans[i] = # of unit i per 1 unit of type 0\\n        ans = [0] * n\\n        ans[0] = 1\\n        \\n        # DFS (or BFS) from 0, propagating the multiplicative factor\\n        stack = [0]\\n        while stack:\\n            u = stack.pop()\\n            for v, f in graph[u]:\\n                # A single unit of u equals ans[u] units of type-0;\\n                # so a single unit of v equals ans[u] * f units of type-0.\\n                ans[v] = ans[u] * f % MOD\\n                stack.append(v)\\n        \\n        return ans\\n\"",
  "1570_14631217_python-updated-time": "1746432518382",
  "2603_14631217_python": "\"class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        pos = set(positive_feedback)\\n        neg = set(negative_feedback)\\n        score_map = {}\\n\\n        for i in range(len(report)):\\n            score = 0\\n            for word in report[i].split():\\n                if word in pos:\\n                    score += 3\\n                elif word in neg:\\n                    score -= 1\\n            score_map[student_id[i]] = score\\n\\n        return [sid for sid, _ in sorted(score_map.items(), key=lambda x: (-x[1], x[0]))[:k]]\\n\"",
  "907_14631217_python": "\"class Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        def can_eat_all(speed):\\n            return sum((pile + speed - 1) // speed for pile in piles) <= h\\n\\n        left, right = 1, max(piles)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_eat_all(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "854_14631217_python-updated-time": "1745879230358",
  "983_14631217_python": "\"class Solution:\\n    def validateStackSequences(self, pushed, popped):\\n        stack = []\\n        j = 0  # pointer for popped\\n        \\n        for x in pushed:\\n            stack.append(x)\\n            # pop while top matches the next in popped\\n            while stack and j < len(popped) and stack[-1] == popped[j]:\\n                stack.pop()\\n                j += 1\\n        \\n        # If we've matched all popped elements, it's valid\\n        return j == len(popped)\\n\"",
  "968_14631217_python-updated-time": "1746004006690",
  "3351_14631217_python-updated-time": "1747420491934",
  "2650_14631217_python": "\"class Solution(object):\\n    def splitNum(self, num):\\n        digits = sorted(str(num))\\n        num1, num2 = '', ''\\n        for i, d in enumerate(digits):\\n            if i % 2 == 0:\\n                num1 += d\\n            else:\\n                num2 += d\\n        return int(num1) + int(num2)\\n\"",
  "929_14631217_python": "\"class Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        seen = set()\\n        for word in words:\\n            even = sorted(word[::2])\\n            odd = sorted(word[1::2])\\n            seen.add((tuple(even), tuple(odd)))\\n        return len(seen)\\n\"",
  "1316_14631217_python-updated-time": "1746127278679",
  "2205_14631217_python-updated-time": "1746729809087",
  "1616_14631217_python-updated-time": "1746433314030",
  "3767_14631217_mysql": "\"SELECT\\n  d.student_id,\\n  d.subject,\\n  s_first.score  AS first_score,\\n  s_last.score   AS latest_score\\nFROM\\n  (\\n    -- find each student/subject’s earliest and latest exam_date,\\n    -- and only keep those with at least two different dates\\n    SELECT\\n      student_id,\\n      subject,\\n      MIN(exam_date) AS first_date,\\n      MAX(exam_date) AS last_date\\n    FROM Scores\\n    GROUP BY student_id, subject\\n    HAVING MIN(exam_date) < MAX(exam_date)\\n  ) AS d\\n  -- join once to get the first exam’s score\\n  JOIN Scores AS s_first\\n    ON s_first.student_id = d.student_id\\n   AND s_first.subject    = d.subject\\n   AND s_first.exam_date  = d.first_date\\n  -- and again to get the latest exam’s score\\n  JOIN Scores AS s_last\\n    ON s_last.student_id = d.student_id\\n   AND s_last.subject    = d.subject\\n   AND s_last.exam_date  = d.last_date\\nWHERE\\n  -- only those whose latest_score > first_score\\n  s_first.score < s_last.score\\nORDER BY\\n  d.student_id,\\n  d.subject;\\n\"",
  "1660_14631217_python": "\"class Solution(object):\\n    def thousandSeparator(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        return \\\"{:,}\\\".format(n).replace(\\\",\\\", \\\".\\\")\\n\"",
  "375_14631217_python": "\"class Solution:\\n    def getMoneyAmount(self, n):\\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\\n        \\n        for length in range(2, n + 1):\\n            for start in range(1, n - length + 2):\\n                end = start + length - 1\\n                dp[start][end] = float('inf')\\n                for pivot in range(start, end):\\n                    cost = pivot + max(dp[start][pivot - 1], dp[pivot + 1][end])\\n                    dp[start][end] = min(dp[start][end], cost)\\n        \\n        return dp[1][n]\\n\"",
  "1468_14631217_python-updated-time": "1746262010955",
  "3798_14631217_python-updated-time": "1747821231121",
  "856_14631217_python": "\"class Solution(object):\\n    def consecutiveNumbersSum(self, n):\\n        res = 0\\n        k = 1\\n        while k * (k + 1) // 2 <= n:\\n            if (n - k * (k + 1) // 2) % k == 0:\\n                res += 1\\n            k += 1\\n        return res\\n\"",
  "1659_14631217_python": "\"class Solution(object):\\n    def maxSum(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        i = j = 0\\n        sum1 = sum2 = result = 0\\n\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] < nums2[j]:\\n                sum1 += nums1[i]\\n                i += 1\\n            elif nums1[i] > nums2[j]:\\n                sum2 += nums2[j]\\n                j += 1\\n            else:\\n                result += max(sum1, sum2) + nums1[i]\\n                sum1 = sum2 = 0\\n                i += 1\\n                j += 1\\n\\n        while i < len(nums1):\\n            sum1 += nums1[i]\\n            i += 1\\n\\n        while j < len(nums2):\\n            sum2 += nums2[j]\\n            j += 1\\n\\n        result += max(sum1, sum2)\\n        return result % MOD\"",
  "1478_14631217_python-updated-time": "1746345123270",
  "2879_14631217_python": "\"class Solution(object):\\n    def minimumChanges(self, s, k):\\n        n = len(s)\\n        INF = 10**9\\n\\n        # pre[i][j] = min changes to make s[i..j] a semi-palindrome\\n        pre = [[INF] * n for _ in range(n)]\\n\\n        # helper to compute cost for substring [l,r]\\n        def cost_sub(l, r):\\n            m = r - l + 1\\n            best = INF\\n            for d in range(1, m):           # proper divisors only\\n                if m % d:                    # not a divisor\\n                    continue\\n                g_len = m // d\\n                cur = 0\\n                for g in range(d):           # each group 0..d-1\\n                    L, R = 0, g_len - 1\\n                    while L < R:\\n                        a = s[l + g + L * d]\\n                        b = s[l + g + R * d]\\n                        if a != b:\\n                            cur += 1\\n                        L += 1\\n                        R -= 1\\n                best = min(best, cur)\\n            return best\\n\\n        # fill pre table\\n        for i in range(n):\\n            for j in range(i + 1, n):        # length at least 2\\n                pre[i][j] = cost_sub(i, j)\\n\\n        # dp: dp[t] = min cost to split first t characters into some groups\\n        dp = [INF] * (n + 1)\\n        dp[0] = 0\\n        for _ in range(k):                   # perform k splits\\n            ndp = [INF] * (n + 1)\\n            for i in range(n + 1):\\n                if dp[i] == INF:\\n                    continue\\n                for j in range(i + 2, n + 1):   # substring length ≥2\\n                    c = pre[i][j - 1]\\n                    if c != INF:\\n                        ndp[j] = min(ndp[j], dp[i] + c)\\n            dp = ndp\\n\\n        return dp[n] if dp[n] != INF else -1\\n\"",
  "3822_14631217_python-updated-time": "1747684006548",
  "1022_14631217_python": "\"class Solution:\\n    def uniquePathsIII(self, grid):\\n        rows, cols = len(grid), len(grid[0])\\n        empty = 0\\n        start_x = start_y = 0\\n\\n        # Find the start and count non-obstacle squares\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    start_x, start_y = i, j\\n                if grid[i][j] != -1:\\n                    empty += 1\\n\\n        self.result = 0\\n\\n        def dfs(x, y, remain):\\n            if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == -1:\\n                return\\n            if grid[x][y] == 2:\\n                if remain == 1:\\n                    self.result += 1\\n                return\\n\\n            temp = grid[x][y]\\n            grid[x][y] = -1  # mark visited\\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                dfs(x + dx, y + dy, remain - 1)\\n            grid[x][y] = temp  # backtrack\\n\\n        dfs(start_x, start_y, empty)\\n        return self.result\\n\"",
  "1473_14631217_python": "\"class Solution(object):\\n    def findTheLongestSubstring(self, s):\\n        vowel_to_bit = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\\n        state = 0\\n        max_len = 0\\n        seen = {0: -1}  # bitmask -> first index\\n\\n        for i, ch in enumerate(s):\\n            if ch in vowel_to_bit:\\n                # Flip the corresponding bit using XOR\\n                state ^= (1 << vowel_to_bit[ch])\\n            if state in seen:\\n                max_len = max(max_len, i - seen[state])\\n            else:\\n                seen[state] = i\\n\\n        return max_len\\n\"",
  "2433_14631217_python-updated-time": "1746907668462",
  "3209_14631217_python": "\"class Solution(object):\\n    def minimumCoins(self, prices):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(prices)\\n        # dp[i] = minimum cost to cover fruits [0..i]\\n        dp = [float('inf')] * n\\n        \\n        for i in range(n):\\n            # any purchase at j covers up through index 2*j+1\\n            # we need j <= i and (2*j+1) >= i  => j >= ceil((i-1)/2)\\n            start_j = (i - 1 + 1) // 2  # ceil((i-1)/2)\\n            if start_j < 0:\\n                start_j = 0\\n            best = float('inf')\\n            for j in range(start_j, i + 1):\\n                prev = dp[j - 1] if j - 1 >= 0 else 0\\n                cost = prev + prices[j]\\n                if cost < best:\\n                    best = cost\\n            dp[i] = best\\n        \\n        return dp[n - 1]\\n\"",
  "2358_14631217_python": "\"class Solution:\\n    def waysToSplitArray(self, nums):\\n        total = sum(nums)\\n        count = 0\\n        prefix = 0\\n        # we can split at i for i in [0..n-2]\\n        for i in range(len(nums) - 1):\\n            prefix += nums[i]\\n            # check prefix >= suffix\\n            if prefix * 2 >= total:\\n                count += 1\\n        return count\\n\"",
  "3019_14631217_python": "\"class Solution(object):\\n    def furthestDistanceFromOrigin(self, moves):\\n        left = moves.count('L')\\n        right = moves.count('R')\\n        blanks = moves.count('_')\\n        return abs(left - right) + blanks\\n\"",
  "2311_14631217_python": "\"class Solution(object):\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n = len(floor)\\n        dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            for k in range(numCarpets + 1):\\n                dp[i][k] = dp[i - 1][k] + (floor[i - 1] == '1')\\n                if k > 0:\\n                    cover_start = max(0, i - carpetLen)\\n                    dp[i][k] = min(dp[i][k], dp[cover_start][k - 1])\\n        return dp[n][numCarpets]\\n\"",
  "153_14631217_python": "\"class Solution(object):\\n    def findMin(self, nums):\\n        left, right = 0, len(nums) - 1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n                \\n        return nums[left]\\n\"",
  "2564_14631217_python": "\"class Solution:\\n    def mostProfitablePath(self, edges, bob, amount):\\n        from collections import defaultdict, deque\\n        \\n        n = len(amount)\\n        # build tree\\n        adj = defaultdict(list)\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # find parent of each node via BFS from root 0\\n        parent = [-1]*n\\n        q = deque([0])\\n        parent[0] = 0\\n        while q:\\n            u = q.popleft()\\n            for v in adj[u]:\\n                if parent[v] == -1:\\n                    parent[v] = u\\n                    q.append(v)\\n        \\n        # compute when Bob arrives at each node on his path to root\\n        INF = 10**18\\n        bobTime = [INF]*n\\n        t = 0\\n        u = bob\\n        while True:\\n            bobTime[u] = t\\n            if u == 0:\\n                break\\n            u = parent[u]\\n            t += 1\\n        \\n        # DFS from root to find best profit\\n        maxProfit = -10**30\\n        stack = [(0, -1, 0, 0)]  # node, parent, curSum, depth (time)\\n        \\n        while stack:\\n            u, p, curSum, depth = stack.pop()\\n            # determine Alice's gain at this node\\n            if bobTime[u] < depth:\\n                gain = 0\\n            elif bobTime[u] == depth:\\n                gain = amount[u] // 2\\n            else:\\n                gain = amount[u]\\n            \\n            curSum += gain\\n            \\n            # check if leaf\\n            is_leaf = (u != 0 and len(adj[u]) == 1)\\n            if is_leaf:\\n                maxProfit = max(maxProfit, curSum)\\n            else:\\n                for v in adj[u]:\\n                    if v == p:\\n                        continue\\n                    stack.append((v, u, curSum, depth+1))\\n        \\n        return maxProfit\\n\"",
  "2591_14631217_python": "\"class Solution(object):\\n    def maxJump(self, stones):\\n        # initial jump for the first two stones\\n        res = stones[1] - stones[0]\\n        # consider jumps that skip one stone\\n        for i in range(2, len(stones)):\\n            res = max(res, stones[i] - stones[i-2])\\n        return res\\n\"",
  "342_14631217_python-updated-time": "1745256981566",
  "459_14631217_python": "\"class Solution:\\n    def repeatedSubstringPattern(self, s):\\n        return (s + s)[1:-1].find(s) != -1\\n\"",
  "684_14631217_python": "\"class Solution(object):\\n    def findRedundantConnection(self, edges):\\n        parent = [i for i in range(len(edges) + 1)]\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px == py:\\n                return False\\n            parent[px] = py\\n            return True\\n\\n        for u, v in edges:\\n            if not union(u, v):\\n                return [u, v]\\n\"",
  "3850_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def canPartitionGrid(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        total = 0\\n        right_cnt = Counter()\\n        for row in grid:\\n            total += sum(row)\\n            right_cnt.update(row)\\n\\n        # --- horizontal cuts ---\\n        top_sum = 0\\n        top_cnt = Counter()\\n        bot_sum = total\\n        bot_cnt = right_cnt\\n\\n        for k in range(m-1):\\n            row = grid[k]\\n            s = sum(row)\\n            top_sum += s\\n            bot_sum -= s\\n            top_cnt.update(row)\\n            for v in row:\\n                if bot_cnt[v] == 1:\\n                    del bot_cnt[v]\\n                else:\\n                    bot_cnt[v] -= 1\\n\\n            if top_sum == bot_sum:\\n                return True\\n\\n            A_sum, B_sum = (top_sum, bot_sum) if top_sum < bot_sum else (bot_sum, top_sum)\\n            delta = B_sum - A_sum\\n            heavier_is_bottom = (bot_sum > top_sum)\\n\\n            # how many rows in the heavier piece?\\n            if heavier_is_bottom:\\n                start_row = k+1\\n                end_row = m-1\\n            else:\\n                start_row = 0\\n                end_row = k\\n\\n            rows_cnt = end_row - start_row + 1\\n\\n            # if it's at least 2×2, any cell works\\n            if rows_cnt > 1 and n > 1:\\n                cnt = bot_cnt if heavier_is_bottom else top_cnt\\n                if cnt.get(delta, 0):\\n                    return True\\n            else:\\n                # it's a vertical strip: endpoints at (start_row,0) and (end_row,0)\\n                if grid[start_row][0] == delta or grid[end_row][0] == delta:\\n                    return True\\n\\n        # --- vertical cuts ---\\n        left_sum = 0\\n        left_cnt = Counter()\\n        right_sum = total\\n        right_cnt = Counter(v for row in grid for v in row)\\n\\n        for c in range(n-1):\\n            col_vals = [grid[r][c] for r in range(m)]\\n            s = sum(col_vals)\\n            left_sum += s\\n            right_sum -= s\\n            left_cnt.update(col_vals)\\n            for v in col_vals:\\n                if right_cnt[v] == 1:\\n                    del right_cnt[v]\\n                else:\\n                    right_cnt[v] -= 1\\n\\n            if left_sum == right_sum:\\n                return True\\n\\n            A_sum, B_sum = (left_sum, right_sum) if left_sum < right_sum else (right_sum, left_sum)\\n            delta = B_sum - A_sum\\n            heavier_is_right = (right_sum > left_sum)\\n\\n            if heavier_is_right:\\n                start_col = c+1\\n                end_col = n-1\\n            else:\\n                start_col = 0\\n                end_col = c\\n\\n            cols_cnt = end_col - start_col + 1\\n\\n            # at least 2×2\\n            if m > 1 and cols_cnt > 1:\\n                cnt = right_cnt if heavier_is_right else left_cnt\\n                if cnt.get(delta, 0):\\n                    return True\\n            else:\\n                # horizontal strip: endpoints at (0,start_col) and (m-1,start_col)\\n                if grid[0][start_col] == delta or grid[m-1][start_col] == delta:\\n                    return True\\n\\n        return False\\n\"",
  "3723_14631217_python": "\"class Solution(object):\\n    def sumOfGoodNumbers(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = 0\\n        n = len(nums)\\n        for i, v in enumerate(nums):\\n            good = True\\n            # compare to left neighbour k steps away, if it exists\\n            if i - k >= 0 and v <= nums[i - k]:\\n                good = False\\n            # compare to right neighbour k steps away, if it exists\\n            if i + k < n and v <= nums[i + k]:\\n                good = False\\n            if good:\\n                total += v\\n        return total\\n\"",
  "3230_14631217_python": "\"class Solution(object):\\n    def removeAlmostEqualCharacters(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        # No adjacent pairs at all if length < 2\\n        if n <= 1:\\n            return 0\\n\\n        # map each letter to 0..25\\n        w = [ord(c) - ord('a') for c in word]\\n        INF = 10**9\\n\\n        # dp[i][c] = min changes to fix word[0..i] ending with char c\\n        dp = [[INF]*26 for _ in range(n)]\\n\\n        # base case i = 0\\n        for c in range(26):\\n            dp[0][c] = (c != w[0])\\n\\n        # transitions\\n        for i in range(1, n):\\n            for c in range(26):\\n                cost = (c != w[i])\\n                best = INF\\n                for p in range(26):\\n                    if abs(c - p) >= 2:\\n                        best = min(best, dp[i-1][p])\\n                dp[i][c] = best + cost\\n\\n        # take the minimum over all endings\\n        return int(min(dp[n-1]))\\n\"",
  "1171_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n\\n        directions = [(-1, -1), (-1, 0), (-1, 1),\\n                      (0, -1),          (0, 1),\\n                      (1, -1),  (1, 0),  (1, 1)]\\n\\n        queue = deque([(0, 0, 1)])  # (x, y, path_length)\\n        visited = [[False] * n for _ in range(n)]\\n        visited[0][0] = True\\n\\n        while queue:\\n            x, y, length = queue.popleft()\\n            if x == n - 1 and y == n - 1:\\n                return length\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\\n                    visited[nx][ny] = True\\n                    queue.append((nx, ny, length + 1))\\n\\n        return -1\\n\"",
  "1472_14631217_python-updated-time": "1746345483257",
  "3812_14631217_python-updated-time": "1747683528583",
  "3525_14631217_python-updated-time": "1747502121241",
  "221_14631217_python-updated-time": "1745246647261",
  "2762_14631217_javascript": "\"class TimeLimitedCache {\\n  constructor() {\\n    this.cache = new Map(); // key -> { value, expiresAt }\\n  }\\n\\n  set(key, value, duration) {\\n    const now = Date.now();\\n    const exists = this.cache.has(key) && this.cache.get(key).expiresAt > now;\\n\\n    // Set/overwrite key with new value and expiration time\\n    this.cache.set(key, {\\n      value,\\n      expiresAt: now + duration\\n    });\\n\\n    return exists;\\n  }\\n\\n  get(key) {\\n    const now = Date.now();\\n    if (this.cache.has(key)) {\\n      const entry = this.cache.get(key);\\n      if (entry.expiresAt > now) {\\n        return entry.value;\\n      } else {\\n        this.cache.delete(key); // Clean up expired key\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  count() {\\n    const now = Date.now();\\n    let count = 0;\\n    for (const [key, { expiresAt }] of this.cache.entries()) {\\n      if (expiresAt > now) {\\n        count++;\\n      } else {\\n        this.cache.delete(key); // Optionally clean up expired entries\\n      }\\n    }\\n    return count;\\n  }\\n}\\n\"",
  "3813_14631217_python": "\"class Solution(object):\\n    def smallestPalindrome(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        # 1) Build half‐counts and optional middle character\\n        full = Counter(s)\\n        mid = \\\"\\\"\\n        cnt = {}\\n        for ch, freq in full.items():\\n            if freq % 2:\\n                mid = ch\\n            cnt[ch] = freq // 2\\n\\n        m = sum(cnt.values())\\n        if m == 0:\\n            return s if k == 1 else \\\"\\\"\\n\\n        # capped binomial C(n, r) but never exceeding cap\\n        def capped_comb(n, r, cap):\\n            r = min(r, n - r)\\n            res = 1\\n            for i in range(1, r + 1):\\n                res = res * (n - r + i) // i\\n                if res > cap:\\n                    return cap\\n            return res\\n\\n        # count permutations of the multiset 'cnt', but early‐exit at cap\\n        def count_perms(cnt, cap):\\n            rem = sum(cnt.values())\\n            total = 1\\n            for ch in sorted(cnt):\\n                c = cnt[ch]\\n                if c == 0:\\n                    continue\\n                ways = capped_comb(rem, c, cap)\\n                total *= ways\\n                if total >= cap:\\n                    return cap\\n                rem -= c\\n            return total\\n\\n        # 2) Greedily build the first half\\n        half = []\\n        letters = 'abcdefghijklmnopqrstuvwxyz'\\n        for _ in range(m):\\n            for c in letters:\\n                if cnt.get(c, 0) == 0:\\n                    continue\\n                cnt[c] -= 1\\n                num = count_perms(cnt, k)\\n                if num >= k:\\n                    half.append(c)\\n                    break\\n                else:\\n                    k -= num\\n                    cnt[c] += 1\\n            else:\\n                return \\\"\\\"    # fewer than k permutations\\n\\n        if k > 1:\\n            return \\\"\\\"\\n\\n        first_half = \\\"\\\".join(half)\\n        return first_half + mid + first_half[::-1]\\n\"",
  "607_14631217_mysql-updated-time": "1745448705912",
  "218_14631217_python-updated-time": "1745246407094",
  "312_14631217_python": "\"class Solution(object):\\n    def maxCoins(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums = [1] + nums + [1]\\n        n = len(nums)\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for length in range(2, n):\\n            for left in range(0, n - length):\\n                right = left + length\\n                for k in range(left + 1, right):\\n                    dp[left][right] = max(dp[left][right],\\n                                          nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right])\\n        \\n        return dp[0][n-1]\\n\"",
  "1292_14631217_mysql": "\"SELECT \\n    ROUND(100.0 * \\n        SUM(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) \\n        / COUNT(*), 2) AS immediate_percentage\\nFROM Delivery\\nWHERE (customer_id, order_date) IN (\\n    SELECT customer_id, MIN(order_date)\\n    FROM Delivery\\n    GROUP BY customer_id\\n);\\n\"",
  "1897_14631217_python": "\"class Solution(object):\\n    def longestPalindrome(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        s = word1 + word2\\n        n = len(s)\\n        \\n        # Build DP for longest palindromic subsequence\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = 2 + dp[i+1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        \\n        res = 0\\n        len1 = len(word1)\\n        \\n        # Try matching characters between word1 and word2\\n        for i in range(len1):\\n            for j in range(len(word2)):\\n                if word1[i] == word2[j]:\\n                    left = i\\n                    right = len1 + j\\n                    res = max(res, dp[left][right])\\n        \\n        return res\\n\"",
  "3493_14631217_python-updated-time": "1747488143731",
  "87_14631217_python-updated-time": "1745015505283",
  "1878_14631217_python": "\"class Solution(object):\\n    def check(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        count = 0\\n        n = len(nums)\\n\\n        for i in range(n):\\n            if nums[i] > nums[(i + 1) % n]:  # handle wrap-around\\n                count += 1\\n                if count > 1:\\n                    return False\\n\\n        return True\\n\"",
  "1887_14631217_python-updated-time": "1746531721551",
  "3364_14631217_python": "\"class Solution(object):\\n    def minimumValueSum(self, nums, andValues):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type andValues: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(nums), len(andValues)\\n        INF = float('inf')\\n        # dp_prev[j]: min sum for first j elements split into (i-1) segments\\n        dp_prev = [INF] * (n + 1)\\n        dp_prev[0] = 0\\n        # iterate over each segment i\\n        for i in range(1, m + 1):\\n            target = andValues[i - 1]\\n            dp_curr = [INF] * (n + 1)\\n            # prev_ands: list of tuples (and_val, best_prev_dp)\\n            prev_ands = []\\n            # build dp_curr by sweeping j\\n            for j in range(1, n + 1):\\n                x = nums[j - 1]\\n                # start new segment at j-1\\n                new_ands = [(x, dp_prev[j - 1])]\\n                # extend previous segments\\n                for (val, best_dp) in prev_ands:\\n                    new_val = val & x\\n                    # if merged with last AND in new_ands\\n                    if new_ands[-1][0] == new_val:\\n                        # keep minimal dp from possible starts\\n                        new_ands[-1] = (new_val, min(new_ands[-1][1], best_dp))\\n                    else:\\n                        new_ands.append((new_val, best_dp))\\n                # if target present as AND, update dp_curr[j]\\n                for (val, best_dp) in new_ands:\\n                    if val == target and best_dp != INF:\\n                        # segment value is nums[j-1]\\n                        dp_curr[j] = best_dp + nums[j - 1]\\n                        break  # only one target entry in new_ands\\n                # prepare for next j\\n                prev_ands = new_ands\\n            dp_prev = dp_curr\\n        res = dp_prev[n]\\n        return res if res < INF else -1\\n\\n# Example usage:\\n# sol = Solution()\\n# print(sol.minimumValueSum([1,4,3,3,2], [0,3,3,2]))  # 12\\n# print(sol.minimumValueSum([2,3,5,7,7,7,5], [0,7,5]))  # 17\\n# print(sol.minimumValueSum([1,2,3,4], [2]))           # -1\"",
  "2915_14631217_python-updated-time": "1747226882667",
  "1071_14631217_python-updated-time": "1746041705556",
  "1341_14631217_python-updated-time": "1746259078860",
  "623_14631217_python": "\"class Solution(object):\\n    def addOneRow(self, root, val, depth):\\n        if depth == 1:\\n            new_root = TreeNode(val)\\n            new_root.left = root\\n            return new_root\\n        \\n        def dfs(node, current_depth):\\n            if not node:\\n                return\\n            if current_depth == depth - 1:\\n                left = TreeNode(val)\\n                right = TreeNode(val)\\n                left.left = node.left\\n                right.right = node.right\\n                node.left = left\\n                node.right = right\\n            else:\\n                dfs(node.left, current_depth + 1)\\n                dfs(node.right, current_depth + 1)\\n        \\n        dfs(root, 1)\\n        return root\\n\"",
  "1445_14631217_python": "\"class Solution:\\n    def numOfSubarrays(self, arr, k, threshold):\\n        target = k * threshold\\n        window_sum = sum(arr[:k])\\n        count = 1 if window_sum >= target else 0\\n        \\n        for i in range(k, len(arr)):\\n            window_sum += arr[i] - arr[i - k]\\n            if window_sum >= target:\\n                count += 1\\n        \\n        return count\\n\"",
  "3072_14631217_pythondata-updated-time": "1747306050291",
  "3517_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def shortestDistanceAfterQueries(self, n, queries):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Build initial chain 0→1→2→…→n−1\\n        adj = [[] for _ in range(n)]\\n        for i in range(n-1):\\n            adj[i].append(i+1)\\n\\n        ans = []\\n        for u, v in queries:\\n            # add the new shortcut\\n            adj[u].append(v)\\n\\n            # BFS from 0\\n            dist = [-1]*n\\n            dq = deque([0])\\n            dist[0] = 0\\n            while dq:\\n                x = dq.popleft()\\n                if x == n-1:\\n                    break\\n                for y in adj[x]:\\n                    if dist[y] < 0:\\n                        dist[y] = dist[x] + 1\\n                        dq.append(y)\\n\\n            ans.append(dist[n-1])\\n        return ans\\n\"",
  "66_14631217_python": "\"class Solution(object):\\n    def plusOne(self, digits):\\n        \\\"\\\"\\\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(digits)\\n\\n        for i in range(n-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n\\n        return [1] + digits\\n\"",
  "2391_14631217_python": "\"class Solution:\\n    def strongPasswordCheckerII(self, password):\\n        # 1) Length at least 8\\n        if len(password) < 8:\\n            return False\\n        \\n        # 2) Flags for required character types\\n        has_lower = has_upper = has_digit = has_special = False\\n        specials = set(\\\"!@#$%^&*()-+\\\")\\n        \\n        # 3) Check adjacent duplicates\\n        prev = None\\n        \\n        for ch in password:\\n            if ch == prev:\\n                return False\\n            prev = ch\\n            \\n            if ch.islower():\\n                has_lower = True\\n            elif ch.isupper():\\n                has_upper = True\\n            elif ch.isdigit():\\n                has_digit = True\\n            elif ch in specials:\\n                has_special = True\\n            # other characters not possible by constraints\\n        \\n        # 4) All flags must be True\\n        return has_lower and has_upper and has_digit and has_special\\n\"",
  "883_14631217_python-updated-time": "1745953666345",
  "1469_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s, t):\\n        cnt_s = Counter(s)\\n        cnt_t = Counter(t)\\n        # We need to make up the deficit in t for each character\\n        return sum(max(0, cnt_s[ch] - cnt_t[ch]) for ch in cnt_s)\\n\"",
  "906_14631217_python-updated-time": "1746001530459",
  "1003_14631217_python": "\"import math\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        point_set = set(map(tuple, points))\\n        min_area = float('inf')\\n        n = len(points)\\n\\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i+1, n):\\n                x2, y2 = points[j]\\n                for k in range(j+1, n):\\n                    x3, y3 = points[k]\\n\\n                    # vectors\\n                    dx1, dy1 = x2 - x1, y2 - y1\\n                    dx2, dy2 = x3 - x1, y3 - y1\\n\\n                    # check for right angle at point i (dot product == 0)\\n                    if dx1 * dx2 + dy1 * dy2 != 0:\\n                        continue\\n\\n                    # compute the fourth point\\n                    x4, y4 = x3 + dx1, y3 + dy1\\n\\n                    if (x4, y4) in point_set:\\n                        area = math.hypot(dx1, dy1) * math.hypot(dx2, dy2)\\n                        min_area = min(min_area, area)\\n\\n        return 0 if min_area == float('inf') else min_area\\n\"",
  "1861_14631217_python-updated-time": "1746531166176",
  "2432_14631217_python-updated-time": "1746907695267",
  "78_14631217_python-updated-time": "1745015246336",
  "1138_14631217_python-updated-time": "1746107591860",
  "2372_14631217_python": "\"class Solution:\\n    def rearrangeCharacters(self, s, target):\\n        # Count frequencies in s\\n        freq_s = {}\\n        for ch in s:\\n            freq_s[ch] = freq_s.get(ch, 0) + 1\\n        \\n        # Count frequencies in target\\n        freq_t = {}\\n        for ch in target:\\n            freq_t[ch] = freq_t.get(ch, 0) + 1\\n        \\n        # For each character in target, compute how many copies s supports\\n        # The answer is the minimum over these quotas.\\n        copies = float('inf')\\n        for ch, needed in freq_t.items():\\n            copies = min(copies, freq_s.get(ch, 0) // needed)\\n        \\n        return copies if copies != float('inf') else 0\\n\"",
  "1829_14631217_python": "\"class Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        \\\"\\\"\\\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sort box types by units per box in descending order\\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\\n        \\n        total_units = 0\\n        remaining = truckSize\\n        \\n        for count, units in boxTypes:\\n            if remaining == 0:\\n                break\\n            # Take as many boxes of this type as we can\\n            take = min(count, remaining)\\n            total_units += take * units\\n            remaining -= take\\n        \\n        return total_units\\n\"",
  "1569_14631217_python-updated-time": "1746347938784",
  "2197_14631217_python-updated-time": "1746729207397",
  "1174_14631217_mysql-updated-time": "1746108153102",
  "620_14631217_mysql-updated-time": "1745780646906",
  "330_14631217_python": "\"class Solution(object):\\n    def minPatches(self, nums, n):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        patches = 0\\n        i = 0\\n        miss = 1\\n        while miss <= n:\\n            if i < len(nums) and nums[i] <= miss:\\n                miss += nums[i]\\n                i += 1\\n            else:\\n                miss += miss\\n                patches += 1\\n        return patches\\n\"",
  "2068_14631217_python-updated-time": "1746638444189",
  "3779_14631217_python": "\"class Solution(object):\\n    def maxWeight(self, pizzas):\\n        \\\"\\\"\\\"\\n        :type pizzas: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(pizzas)\\n        pizzas.sort()\\n        \\n        days = n // 4\\n        # Number of odd‐day picks (Z on odd days)\\n        odd_cnt = (days + 1) // 2\\n        # Number of even‐day picks (Y on even days)\\n        even_cnt = days // 2\\n        \\n        # 1) Pick the odd‐day gains: the largest `odd_cnt` pizzas\\n        total = sum(pizzas[n - odd_cnt:])\\n        \\n        # 2) From the remaining pizzas (all except those odd‐day Z’s),\\n        #    we need for each even day one Y (the 2nd largest of a 4)\\n        #    and one Z ≥ Y (which will be “wasted”).  To maximize the sum\\n        #    of the Y’s, we take the largest 2*even_cnt from what remains,\\n        #    pair them up in ascending order, and in each pair the smaller\\n        #    is our Y.\\n        rem = pizzas[:n - odd_cnt]\\n        # take the largest 2*even_cnt of rem\\n        S = rem[len(rem) - 2*even_cnt:]\\n        # sort is actually unnecessary since rem is sorted, and S is a suffix,\\n        # but we'll do it for clarity:\\n        S.sort()\\n        # sum every other starting at index 0 in that 2*even_cnt list\\n        total += sum(S[2*i] for i in range(even_cnt))\\n        \\n        return total\\n\"",
  "3443_14631217_python-updated-time": "1747485182451",
  "2504_14631217_python": "\"class Solution:\\n    def goodIndices(self, nums, k):\\n        n = len(nums)\\n        left = [1] * n\\n        for i in range(1, n):\\n            if nums[i-1] >= nums[i]:\\n                left[i] = left[i-1] + 1\\n        right = [1] * n\\n        for i in range(n-2, -1, -1):\\n            if nums[i] <= nums[i+1]:\\n                right[i] = right[i+1] + 1\\n        ans = []\\n        for i in range(k, n-k):\\n            if left[i-1] >= k and right[i+1] >= k:\\n                ans.append(i)\\n        return ans\\n\"",
  "632_14631217_python-updated-time": "1745782264365",
  "1087_14631217_python": "\"class Solution:\\n    def longestArithSeqLength(self, nums):\\n        n = len(nums)\\n        dp = [{} for _ in range(n)]\\n        res = 0\\n        for i in range(n):\\n            for j in range(i):\\n                d = nums[i] - nums[j]\\n                dp[i][d] = dp[j].get(d, 1) + 1\\n                res = max(res, dp[i][d])\\n        return res\\n\"",
  "2598_14631217_python": "\"class Solution:\\n    def closestTarget(self, words, target, startIndex):\\n        n = len(words)\\n        res = float('inf')\\n\\n        for i in range(n):\\n            if words[i] == target:\\n                dist = min(abs(i - startIndex), n - abs(i - startIndex))\\n                res = min(res, dist)\\n\\n        return res if res != float('inf') else -1\\n\"",
  "3794_14631217_python-updated-time": "1747682996070",
  "441_14631217_python": "\"class Solution:\\n    def arrangeCoins(self, n):\\n        left, right = 0, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            curr = mid * (mid + 1) // 2\\n            if curr == n:\\n                return mid\\n            if curr < n:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return right\\n\"",
  "92_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :type left: int\\n        :type right: int\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        curr = prev.next\\n        for _ in range(right - left):\\n            temp = curr.next\\n            curr.next = temp.next\\n            temp.next = prev.next\\n            prev.next = temp\\n\\n        return dummy.next\\n\"",
  "690_14631217_python-updated-time": "1745785564039",
  "3605_14631217_python": "\"class Solution(object):\\n    def minBitwiseArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        for num in nums:\\n            found = False\\n            for x in range(num):\\n                if (x | (x + 1)) == num:\\n                    res.append(x)\\n                    found = True\\n                    break\\n            if not found:\\n                res.append(-1)\\n        return res\\n\"",
  "363_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def maxSumSubmatrix(self, matrix, k):\\n        m, n = len(matrix), len(matrix[0])\\n        res = float('-inf')\\n        \\n        for left in range(n):\\n            row_sum = [0] * m\\n            for right in range(left, n):\\n                for i in range(m):\\n                    row_sum[i] += matrix[i][right]\\n                \\n                prefix_sums = [0]\\n                curr_sum = 0\\n                for sum_ in row_sum:\\n                    curr_sum += sum_\\n                    idx = bisect.bisect_left(prefix_sums, curr_sum - k)\\n                    if idx < len(prefix_sums):\\n                        res = max(res, curr_sum - prefix_sums[idx])\\n                    bisect.insort(prefix_sums, curr_sum)\\n        \\n        return res\\n\"",
  "2558_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minimumOperations(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ans = 0\\n        q = deque([root])\\n        \\n        while q:\\n            level_size = len(q)\\n            level_vals = []\\n            for _ in range(level_size):\\n                node = q.popleft()\\n                level_vals.append(node.val)\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            \\n            # To sort this level by minimal swaps, find how many swaps\\n            # needed to transform level_vals into its sorted order.\\n            # This is the size minus number of cycles in the permutation.\\n            sorted_vals = sorted(level_vals)\\n            idx_map = {v: i for i, v in enumerate(level_vals)}\\n            visited = [False] * level_size\\n            for i in range(level_size):\\n                if visited[i] or level_vals[i] == sorted_vals[i]:\\n                    continue\\n                # traverse the cycle\\n                cycle_len = 0\\n                j = i\\n                while not visited[j]:\\n                    visited[j] = True\\n                    cycle_len += 1\\n                    # value that should be here:\\n                    correct_val = sorted_vals[j]\\n                    # find where that value currently is:\\n                    j = idx_map[correct_val]\\n                # to fix a cycle of length L, needs (L - 1) swaps\\n                ans += cycle_len - 1\\n            \\n            # update idx_map for next level?\\n            # Not needed, rebuilt each level\\n            \\n        return ans\\n\"",
  "423_14631217_python-updated-time": "1745358472415",
  "1393_14631217_python-updated-time": "1746811026867",
  "2181_14631217_python-updated-time": "1746720566606",
  "3093_14631217_python-updated-time": "1747227472624",
  "2837_14631217_python": "\"class Solution:\\n    def makeTheIntegerZero(self, num1, num2):\\n        for k in range(1, 61):  # Try using k operations\\n            target = num1 - k * num2\\n            if target < k:\\n                continue\\n            if bin(target).count('1') <= k:\\n                return k\\n        return -1\\n\"",
  "3419_14631217_python": "\"class Solution(object):\\n    def maxPointsInsideSquare(self, points, s):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def is_valid(mid):\\n            seen = set()\\n            for i in range(len(points)):\\n                x, y = points[i]\\n                if max(abs(x), abs(y)) <= mid:\\n                    if s[i] in seen:\\n                        return False\\n                    seen.add(s[i])\\n            return True\\n\\n        low, high = 0, max(max(abs(x), abs(y)) for x, y in points)\\n        ans = 0\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if is_valid(mid):\\n                ans = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        # Now count the number of points inside the square of size `ans`\\n        seen = set()\\n        count = 0\\n        for i in range(len(points)):\\n            x, y = points[i]\\n            if max(abs(x), abs(y)) <= ans and s[i] not in seen:\\n                seen.add(s[i])\\n                count += 1\\n\\n        return count\\n\"",
  "1615_14631217_python-updated-time": "1746433284990",
  "602_14631217_mysql": "\"WITH AllFriends AS (\\n    SELECT requester_id AS id, accepter_id AS friend_id\\n    FROM RequestAccepted\\n    UNION ALL\\n    SELECT accepter_id AS id, requester_id AS friend_id\\n    FROM RequestAccepted\\n),\\nFriendCounts AS (\\n    SELECT\\n        id,\\n        COUNT(DISTINCT friend_id) AS num\\n    FROM AllFriends\\n    GROUP BY id\\n)\\nSELECT\\n    id,\\n    num\\nFROM FriendCounts\\nWHERE num = (\\n    SELECT MAX(num) FROM FriendCounts\\n);\\n\"",
  "517_14631217_python-updated-time": "1745446450102",
  "2312_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def mostFrequent(self, nums, key):\\n        count = defaultdict(int)\\n        \\n        for i in range(len(nums) - 1):\\n            if nums[i] == key:\\n                count[nums[i + 1]] += 1\\n\\n        return max(count, key=count.get)\\n\"",
  "3034_14631217_python-updated-time": "1747226964039",
  "3526_14631217_python-updated-time": "1747494413631",
  "2010_14631217_python": "\"class Solution:\\n    def isSumEqual(self, firstWord, secondWord, targetWord):\\n        def to_num(s):\\n            return int(''.join(str(ord(c) - ord('a')) for c in s))\\n        return to_num(firstWord) + to_num(secondWord) == to_num(targetWord)\\n\"",
  "3593_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\n# Ensure gcd compatibility\\ntry:\\n    from math import gcd\\nexcept ImportError:\\n    from fractions import gcd\\n\\nclass Solution(object):\\n    def maxTravelScore(self, n, k, stayScore, travelScore):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type stayScore: List[List[int]]\\n        :type travelScore: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp_prev = [0] * n\\n        for day in range(k):\\n            dp_cur = [0] * n\\n            for dest in range(n):\\n                stay = dp_prev[dest] + stayScore[day][dest]\\n                max_travel = max(dp_prev[p] + travelScore[p][dest] for p in range(n))\\n                dp_cur[dest] = max(stay, max_travel)\\n            dp_prev = dp_cur\\n        return max(dp_prev)\\n\\n    def possibleStringCount(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        runs = []\\n        cur_char, cur_len = None, 0\\n        for c in word:\\n            if c == cur_char:\\n                cur_len += 1\\n            else:\\n                if cur_len:\\n                    runs.append(cur_len)\\n                cur_char, cur_len = c, 1\\n        if cur_len:\\n            runs.append(cur_len)\\n        m = len(runs)\\n        total = 1\\n        for Li in runs:\\n            total = total * Li % mod\\n        if m >= k:\\n            return total\\n        dp = [0] * k\\n        dp[0] = 1\\n        for Li in runs:\\n            prefix = [0] * k\\n            prefix[0] = dp[0]\\n            for i in range(1, k):\\n                prefix[i] = (prefix[i-1] + dp[i]) % mod\\n            new_dp = [0] * k\\n            for t in range(1, k):\\n                a = prefix[t-1]\\n                b = prefix[t-1-Li] if t-1-Li >= 0 else 0\\n                new_dp[t] = (a - b) % mod\\n            dp = new_dp\\n        count_bad = sum(dp) % mod\\n        return (total - count_bad + mod) % mod\\n\\n    def maxScore(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def lcm(a, b):\\n            return a // gcd(a, b) * b\\n\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n\\n        prefix_g = [0] * n\\n        prefix_l = [0] * n\\n        suffix_g = [0] * n\\n        suffix_l = [0] * n\\n\\n        for i in range(n):\\n            if i == 0:\\n                prefix_g[i] = nums[i]\\n                prefix_l[i] = nums[i]\\n            else:\\n                prefix_g[i] = gcd(prefix_g[i-1], nums[i])\\n                prefix_l[i] = lcm(prefix_l[i-1], nums[i])\\n\\n        for i in range(n-1, -1, -1):\\n            if i == n-1:\\n                suffix_g[i] = nums[i]\\n                suffix_l[i] = nums[i]\\n            else:\\n                suffix_g[i] = gcd(suffix_g[i+1], nums[i])\\n                suffix_l[i] = lcm(suffix_l[i+1], nums[i])\\n\\n        max_score = prefix_g[n-1] * prefix_l[n-1]\\n\\n        for i in range(n):\\n            if n == 1:\\n                continue\\n            if i == 0:\\n                g = suffix_g[1]\\n                l = suffix_l[1]\\n            elif i == n-1:\\n                g = prefix_g[n-2]\\n                l = prefix_l[n-2]\\n            else:\\n                g = gcd(prefix_g[i-1], suffix_g[i+1])\\n                l = lcm(prefix_l[i-1], suffix_l[i+1])\\n            max_score = max(max_score, g * l)\\n\\n        return max_score\"",
  "2236_14631217_python": "\"class Solution:\\n    def pairSum(self, head):\\n        vals = []\\n        while head:\\n            vals.append(head.val)\\n            head = head.next\\n        max_sum = 0\\n        n = len(vals)\\n        for i in range(n // 2):\\n            max_sum = max(max_sum, vals[i] + vals[n - 1 - i])\\n        return max_sum\\n\"",
  "3405_14631217_python-updated-time": "1747424016108",
  "2061_14631217_python-updated-time": "1746638003207",
  "1637_14631217_python-updated-time": "1746434035093",
  "637_14631217_python-updated-time": "1745782351921",
  "2138_14631217_python-updated-time": "1746718135275",
  "811_14631217_python-updated-time": "1745877923993",
  "2301_14631217_python": "\"from collections import Counter\\n\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\nclass Solution:\\n    def countPairs(self, nums, k):\\n        count = Counter()\\n        res = 0\\n\\n        for num in nums:\\n            g = gcd(num, k)\\n            for x in count:\\n                if (g * x) % k == 0:\\n                    res += count[x]\\n            count[g] += 1\\n\\n        return res\\n\"",
  "93_14631217_python": "\"class Solution(object):\\n    def restoreIpAddresses(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(start, path):\\n            if len(path) == 4:\\n                if start == len(s):\\n                    res.append('.'.join(path))\\n                return\\n\\n            for l in range(1, 4):\\n                if start + l > len(s):\\n                    break\\n                segment = s[start:start+l]\\n                if (segment.startswith('0') and len(segment) > 1) or int(segment) > 255:\\n                    continue\\n                backtrack(start + l, path + [segment])\\n\\n        backtrack(0, [])\\n        return res\\n\"",
  "3485_14631217_python": "\"class Solution(object):\\n    def maxPossibleScore(self, start, d):\\n        # Build and sort intervals by their end = start + d\\n        intervals = sorted((s, s + d) for s in start)\\n\\n        def feasible(M):\\n            # Can we pick one point per interval so that any two are ≥ M apart?\\n            # Greedy schedule: treat each interval as a job with window [s,e],\\n            # requiring separation M between chosen points.\\n            current = -M\\n            for s, e in intervals:\\n                # next point must be ≥ s and ≥ current + M\\n                p = current + M\\n                if p < s:\\n                    p = s\\n                # if it exceeds the interval end, fail\\n                if p > e:\\n                    return False\\n                current = p\\n            return True\\n\\n        # Binary search max M\\n        lo, hi = 0, intervals[-1][1] - intervals[0][0]  # max possible span\\n        best = 0\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if feasible(mid):\\n                best = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n\\n        return best\\n\"",
  "2323_14631217_python": "\"class Solution(object):\\n    def minBitFlips(self, start, goal):\\n        x = start ^ goal\\n        cnt = 0\\n        while x:\\n            x &= x - 1\\n            cnt += 1\\n        return cnt\\n\"",
  "777_14631217_python": "\"class Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(m-1):\\n            for j in range(n-1):\\n                if matrix[i][j] != matrix[i+1][j+1]:\\n                    return False\\n        return True\\n\"",
  "1892_14631217_mysql": "\"SELECT\\n    event_day AS day,\\n    emp_id,\\n    SUM(out_time - in_time) AS total_time\\nFROM\\n    Employees\\nGROUP BY\\n    emp_id,\\n    event_day;\\n\"",
  "2599_14631217_python-updated-time": "1747059880248",
  "2732_14631217_javascript": "\"function createCounter(n) {\\n  return function() {\\n    return n++;\\n  };\\n}\\n\"",
  "2546_14631217_python-updated-time": "1746968201611",
  "3587_14631217_python-updated-time": "1747585267453",
  "715_14631217_python-updated-time": "1745786630468",
  "67_14631217_python": "\"class Solution(object):\\n    def addBinary(self, a, b):\\n        \\\"\\\"\\\"\\n        :type a: str\\n        :type b: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        res = []\\n        carry = 0\\n        i, j = len(a) - 1, len(b) - 1\\n\\n        while i >= 0 or j >= 0 or carry:\\n            total = carry\\n            if i >= 0:\\n                total += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                total += int(b[j])\\n                j -= 1\\n            res.append(str(total % 2))\\n            carry = total // 2\\n\\n        return ''.join(res[::-1])\\n\"",
  "2137_14631217_python": "\"class Solution:\\n    def finalValueAfterOperations(self, operations):\\n        x = 0\\n        for op in operations:\\n            if op[1] == '+':\\n                x += 1\\n            else:\\n                x -= 1\\n        return x\\n\"",
  "3055_14631217_python-updated-time": "1747227658172",
  "10_14631217_python": "\"class Solution(object):\\n    def isMatch(self, s, p):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\\n        dp[0][0] = True\\n\\n        for j in range(2, len(p) + 1):\\n            if p[j-1] == '*':\\n                dp[0][j] = dp[0][j-2]\\n\\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                if p[j-1] == '.' or p[j-1] == s[i-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == '*':\\n                    dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == '.'))\\n\\n        return dp[len(s)][len(p)]\\n\"",
  "985_14631217_python": "\"class Solution:\\n    def bagOfTokensScore(self, tokens, power):\\n        tokens.sort()\\n        l, r = 0, len(tokens) - 1\\n        score = 0\\n        max_score = 0\\n\\n        while l <= r:\\n            if power >= tokens[l]:\\n                power -= tokens[l]\\n                score += 1\\n                l += 1\\n                max_score = max(max_score, score)\\n            elif score > 0:\\n                # Sacrifice one score to gain power from the largest token\\n                power += tokens[r]\\n                score -= 1\\n                r -= 1\\n            else:\\n                break\\n\\n        return max_score\\n\"",
  "1284_14631217_python-updated-time": "1746346124217",
  "21_14631217_python-updated-time": "1744987617755",
  "3390_14631217_python-updated-time": "1747423610894",
  "1312_14631217_python-updated-time": "1746810277750",
  "3621_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If there's any element below k, we can never bring it up.\\n        if any(x < k for x in nums):\\n            return -1\\n        \\n        # Count how many distinct values exceed k.\\n        distinct_vals = set(nums)\\n        # Each distinct value > k will require exactly one chop.\\n        return sum(1 for v in distinct_vals if v > k)\\n\"",
  "1911_14631217_python": "\"class Solution(object):\\n    def minElements(self, nums, limit, goal):\\n        diff = abs(goal - sum(nums))\\n        return (diff + limit - 1) // limit\\n\"",
  "3243_14631217_python-updated-time": "1747392692087",
  "5_14631217_python-updated-time": "1744978949730",
  "947_14631217_python": "\"from bisect import bisect_right\\nfrom collections import defaultdict\\n\\nclass TopVotedCandidate:\\n    def __init__(self, persons, times):\\n        self.times = times\\n        self.lead = []\\n        \\n        count = defaultdict(int)\\n        current_lead = None\\n        max_count = 0\\n        \\n        for p in persons:\\n            count[p] += 1\\n            # if this candidate ties or exceeds the max, they become the leader\\n            if count[p] >= max_count:\\n                current_lead = p\\n                max_count = count[p]\\n            self.lead.append(current_lead)\\n\\n    def q(self, t):\\n        # find rightmost vote time <= t\\n        idx = bisect_right(self.times, t) - 1\\n        return self.lead[idx]\\n\"",
  "2450_14631217_python": "\"class Solution(object):\\n    def minimumReplacement(self, nums):\\n        n = len(nums)\\n        ops = 0\\n        prev = nums[-1]\\n\\n        for i in range(n - 2, -1, -1):\\n            if nums[i] <= prev:\\n                prev = nums[i]\\n            else:\\n                parts = (nums[i] + prev - 1) // prev\\n                ops += parts - 1\\n                prev = nums[i] // parts\\n\\n        return ops\\n\"",
  "2551_14631217_python": "\"class Solution(object):\\n    def applyOperations(self, nums):\\n        n = len(nums)\\n        # 1) Apply the n-1 operations in order\\n        for i in range(n-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] *= 2\\n                nums[i+1] = 0\\n        \\n        # 2) Shift all zeros to the end in-place\\n        write = 0\\n        for read in range(n):\\n            if nums[read] != 0:\\n                nums[write] = nums[read]\\n                write += 1\\n        # Fill the remainder with zeros\\n        for i in range(write, n):\\n            nums[i] = 0\\n        \\n        return nums\\n\"",
  "946_14631217_python": "\"class Solution:\\n    def smallestRangeII(self, nums, k):\\n        nums.sort()\\n        # initial score without changes\\n        ans = nums[-1] - nums[0]\\n        n = len(nums)\\n        # try splitting between i and i+1\\n        for i in range(n - 1):\\n            high = max(nums[i] + k, nums[-1] - k)\\n            low  = min(nums[0] + k, nums[i+1] - k)\\n            ans = min(ans, high - low)\\n        return ans\\n\"",
  "2254_14631217_python": "\"class Solution:\\n    def checkValid(self, matrix):\\n        n = len(matrix)\\n        required = set(range(1, n + 1))\\n\\n        for i in range(n):\\n            if set(matrix[i]) != required:\\n                return False\\n            if set(matrix[j][i] for j in range(n)) != required:\\n                return False\\n\\n        return True\\n\"",
  "2536_14631217_python": "\"class Solution(object):\\n    def haveConflict(self, event1, event2):\\n        def to_minutes(t):\\n            h, m = t.split(':')\\n            return int(h) * 60 + int(m)\\n        \\n        s1 = to_minutes(event1[0])\\n        e1 = to_minutes(event1[1])\\n        s2 = to_minutes(event2[0])\\n        e2 = to_minutes(event2[1])\\n        \\n        # They conflict if the later start is <= the earlier end\\n        return max(s1, s2) <= min(e1, e2)\\n\"",
  "1472_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def sortString(self, s):\\n        count = Counter(s)\\n        result = []\\n        \\n        while len(result) < len(s):\\n            # Step 1–3: ascending order\\n            for c in sorted(count.keys()):\\n                if count[c] > 0:\\n                    result.append(c)\\n                    count[c] -= 1\\n            # Step 4–6: descending order\\n            for c in sorted(count.keys(), reverse=True):\\n                if count[c] > 0:\\n                    result.append(c)\\n                    count[c] -= 1\\n\\n        return ''.join(result)\\n\"",
  "1019_14631217_python": "\"class Solution:\\n    def sortedSquares(self, nums):\\n        n = len(nums)\\n        result = [0] * n\\n        left, right = 0, n - 1\\n        i = n - 1\\n\\n        while left <= right:\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n            i -= 1\\n\\n        return result\\n\"",
  "1560_14631217_python": "\"class Solution(object):\\n    def busyStudent(self, startTime, endTime, queryTime):\\n        count = 0\\n        for s, e in zip(startTime, endTime):\\n            if s <= queryTime <= e:\\n                count += 1\\n        return count\\n\"",
  "2461_14631217_python-updated-time": "1746965121781",
  "2132_14631217_python": "\"class Solution(object):\\n    def construct2DArray(self, original, m, n):\\n        \\\"\\\"\\\"\\n        :type original: List[int]\\n        :type m: int\\n        :type n: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        if len(original) != m * n:\\n            return []\\n        \\n        result = []\\n        for i in range(m):\\n            row = original[i * n : (i + 1) * n]\\n            result.append(row)\\n        return result\\n\"",
  "3210_14631217_python": "\"class Solution(object):\\n    def beautifulSubstrings(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        vowels_set = set('aeiou')\\n        count = 0\\n        n = len(s)\\n\\n        for i in range(n):\\n            vowels = 0\\n            consonants = 0\\n            for j in range(i, n):\\n                if s[j] in vowels_set:\\n                    vowels += 1\\n                else:\\n                    consonants += 1\\n                if vowels == consonants and (vowels * consonants) % k == 0:\\n                    count += 1\\n\\n        return count\\n\"",
  "2048_14631217_python": "\"class Solution:\\n    def buildArray(self, nums):\\n        return [nums[nums[i]] for i in range(len(nums))]\\n\"",
  "2177_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :param word1: str\\n        :param word2: str\\n        :return: bool  # True if for every letter 'a'–'z', |freq1 - freq2| ≤ 3\\n        \\\"\\\"\\\"\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        # Check each lowercase letter\\n        for ch in map(chr, range(ord('a'), ord('z')+1)):\\n            if abs(c1[ch] - c2[ch]) > 3:\\n                return False\\n        return True\\n\"",
  "1486_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        arr2.sort()\\n        count = 0\\n        for x in arr1:\\n            idx = bisect.bisect_left(arr2, x)\\n            valid = True\\n            if idx < len(arr2) and abs(arr2[idx] - x) <= d:\\n                valid = False\\n            if idx > 0 and abs(arr2[idx - 1] - x) <= d:\\n                valid = False\\n            if valid:\\n                count += 1\\n        return count\\n\"",
  "782_14631217_python": "\"class Solution(object):\\n    def numJewelsInStones(self, jewels, stones):\\n        jewel_set = set(jewels)\\n        return sum(1 for stone in stones if stone in jewel_set)\\n\"",
  "3249_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from functools import reduce\\n        import operator\\n\\n        # XOR of all elements in the array\\n        xor_total = reduce(operator.xor, nums)\\n\\n        # XOR difference between desired value and current total\\n        xor_needed = xor_total ^ k\\n\\n        # Count the number of 1s in xor_needed — each 1 corresponds to a bit flip needed\\n        return bin(xor_needed).count('1')\\n\"",
  "307_14631217_python-updated-time": "1745255790148",
  "3689_14631217_python": "\"import bisect\\nfrom collections import defaultdict\\n\\nclass Fenwick:\\n    def __init__(self, n):\\n        # 1-indexed Fenwick tree over [0..n-1]\\n        self.n = n\\n        self.fw = [0]*(n+1)\\n    def add(self, i, v):\\n        # add v at index i (0-based)\\n        i += 1\\n        while i <= self.n:\\n            self.fw[i] += v\\n            i += i & -i\\n    def sum(self, i):\\n        # sum of [0..i] (0-based)\\n        i += 1\\n        s = 0\\n        while i>0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n    def range_sum(self, l, r):\\n        if l>r:\\n            return 0\\n        return self.sum(r) - (self.sum(l-1) if l>0 else 0)\\n\\nclass Solution(object):\\n    def maxRectangleArea(self, xCoord, yCoord):\\n        points = list(zip(xCoord, yCoord))\\n        n = len(points)\\n\\n        # 1) Build H and collect horizontal edges\\n        H = defaultdict(list)\\n        V = defaultdict(list)\\n        for x,y in points:\\n            H[y].append(x)\\n            V[x].append(y)\\n        for y in H: H[y].sort()\\n        for x in V: V[x].sort()\\n\\n        by_edge = defaultdict(list)  # keyed by (x1,x2) -> list of y's\\n        for y, xs in H.items():\\n            for i in range(len(xs)-1):\\n                x1, x2 = xs[i], xs[i+1]\\n                by_edge[(x1,x2)].append(y)\\n        for key in by_edge:\\n            by_edge[key].sort()\\n\\n        # 2) Gather candidate rectangles:\\n        #    only consecutive y's for each (x1,x2), and vertical edges must be clean\\n        def are_adj(lst, a, b):\\n            # check a,b are consecutive in sorted list lst\\n            ia = bisect.bisect_left(lst, a)\\n            ib = bisect.bisect_left(lst, b)\\n            return abs(ia-ib) == 1\\n\\n        cands = []  # (x1,x2,y1,y2,area)\\n        for (x1,x2), ylist in by_edge.items():\\n            for i in range(len(ylist)-1):\\n                y1 = ylist[i]\\n                y2 = ylist[i+1]\\n                # must be adjacent vertically too\\n                if not are_adj(V[x1], y1, y2): continue\\n                if not are_adj(V[x2], y1, y2): continue\\n                area = (x2-x1)*(y2-y1)\\n                if area>0:\\n                    cands.append((x1, x2, y1, y2, area))\\n\\n        if not cands:\\n            return -1\\n\\n        # 3) Prepare sweep: events to test interior emptiness\\n        # Each cand idx produces two events:\\n        #   at x1+1 with sign -1, at x2 with sign +1\\n        events = []  # (x_evt, y1, y2, sign, cand_idx)\\n        for idx, (x1,x2,y1,y2,_) in enumerate(cands):\\n            events.append((x1+1, y1, y2, -1, idx))\\n            events.append((x2,   y1, y2, +1, idx))\\n        events.sort(key=lambda e: e[0])\\n\\n        # 4) Fenwick over all y's\\n        all_y = sorted({y for _,y in points})\\n        fenw = Fenwick(len(all_y))\\n        # sort points by x for sweep\\n        pts_sorted = sorted(points, key=lambda p: p[0])\\n\\n        res_cnt = [0]*len(cands)\\n        pi = 0\\n        for x_evt, y1, y2, sign, ridx in events:\\n            # add all points with x < x_evt\\n            while pi < n and pts_sorted[pi][0] < x_evt:\\n                yy = pts_sorted[pi][1]\\n                yi = bisect.bisect_left(all_y, yy)\\n                fenw.add(yi, 1)\\n                pi += 1\\n            # count points with y in (y1, y2)\\n            # strictly inside: y1< y < y2\\n            i1 = bisect.bisect_right(all_y, y1)\\n            i2 = bisect.bisect_left(all_y, y2) - 1\\n            if i1 <= i2:\\n                cnt = fenw.range_sum(i1, i2)\\n            else:\\n                cnt = 0\\n            res_cnt[ridx] += sign * cnt\\n\\n        # 5) pick best area among those with res_cnt==0\\n        ans = -1\\n        for (x1,x2,y1,y2,area), cnt in zip(cands, res_cnt):\\n            if cnt == 0 and area>ans:\\n                ans = area\\n\\n        return ans\\n\"",
  "162_14631217_python-updated-time": "1745091277532",
  "89_14631217_python": "\"class Solution(object):\\n    def grayCode(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        result = [0]\\n        for i in range(n):\\n            result += [x | (1 << i) for x in reversed(result)]\\n        return result\\n\"",
  "2620_14631217_python": "\"class DataStream:\\n    def __init__(self, value, k):\\n        self.value = value\\n        self.k = k\\n        self.count = 0\\n\\n    def consec(self, num):\\n        if num == self.value:\\n            self.count += 1\\n        else:\\n            self.count = 0\\n        return self.count >= self.k\\n\"",
  "2294_14631217_python-updated-time": "1746803738668",
  "2201_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def validArrangement(self, pairs):\\n        \\\"\\\"\\\"\\n        :type pairs: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # Build graph and track in/out degrees\\n        adj = defaultdict(list)\\n        out_deg = defaultdict(int)\\n        in_deg = defaultdict(int)\\n        \\n        for u, v in pairs:\\n            adj[u].append(v)\\n            out_deg[u] += 1\\n            in_deg[v] += 1\\n        \\n        # Find start node: out_deg - in_deg = 1, if none, pick any u\\n        start = None\\n        for node in adj:\\n            if out_deg[node] - in_deg[node] == 1:\\n                start = node\\n                break\\n        if start is None:\\n            # Eulerian cycle case: start anywhere with outgoing edge\\n            start = pairs[0][0]\\n        \\n        # Hierholzer's algorithm to find Eulerian path\\n        stack = [start]\\n        path = []  # will hold nodes in reverse of the final path\\n        while stack:\\n            u = stack[-1]\\n            if adj[u]:\\n                v = adj[u].pop()\\n                stack.append(v)\\n            else:\\n                path.append(stack.pop())\\n        \\n        # path is reversed list of vertices; reverse it\\n        path.reverse()\\n        \\n        # Build edge list from consecutive vertices\\n        result = []\\n        for i in range(len(path) - 1):\\n            result.append([path[i], path[i+1]])\\n        \\n        return result\\n\"",
  "2872_14631217_python-updated-time": "1747222611395",
  "1805_14631217_python": "\"class Solution(object):\\n    def minMoves(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Collect the indices of 1's\\n        pos = [i for i, x in enumerate(nums) if x == 1]\\n        m = len(pos)\\n        # b[i] = pos[i] - i; this array is non‐decreasing\\n        b = [pos[i] - i for i in range(m)]\\n        # prefix sums of b\\n        prefix = [0] * (m + 1)\\n        for i in range(m):\\n            prefix[i+1] = prefix[i] + b[i]\\n        \\n        # Slide a window of length k over b to compute\\n        # sum of abs distances to the window's median in O(1) each.\\n        ans = float('inf')\\n        for i in range(m - k + 1):\\n            j = i + k - 1\\n            mid = i + k // 2\\n            median = b[mid]\\n            # # of elements to the left of median in window\\n            left_count = mid - i\\n            # # of elements to the right of median\\n            right_count = j - mid\\n            # sum of left segment\\n            left_sum = prefix[mid] - prefix[i]\\n            # sum of right segment\\n            right_sum = prefix[j+1] - prefix[mid+1]\\n            \\n            # cost = sum(median - b[l]) + sum(b[r] - median)\\n            cost = median * left_count - left_sum \\\\\\n                   + right_sum - median * right_count\\n            ans = min(ans, cost)\\n        \\n        # If k == 1, ans stays inf; but no moves needed\\n        return 0 if k == 1 else ans\\n\"",
  "905_14631217_python-updated-time": "1746001504262",
  "451_14631217_python-updated-time": "1745359250281",
  "2101_14631217_python-updated-time": "1746639484060",
  "1707_14631217_python": "\"class Solution(object):\\n    def isTransformable(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        if len(t) != n:\\n            return False\\n\\n        # record positions of each digit 0..9 in s\\n        positions = [[] for _ in range(10)]\\n        for i, ch in enumerate(s):\\n            positions[ord(ch) - ord('0')].append(i)\\n\\n        # pointers into each positions[d]: next alive occurrence\\n        head = [0] * 10\\n        removed = [False] * n\\n\\n        # try to match t[k] one by one\\n        for ch in t:\\n            d = ord(ch) - ord('0')\\n\\n            # skip over any already-removed positions for digit d\\n            while head[d] < len(positions[d]) and removed[positions[d][head[d]]]:\\n                head[d] += 1\\n            if head[d] == len(positions[d]):\\n                # no more of digit d to place\\n                return False\\n\\n            pos = positions[d][head[d]]\\n\\n            # check smaller digits e < d: none may lie alive to the left of pos\\n            for e in range(d):\\n                while head[e] < len(positions[e]) and removed[positions[e][head[e]]]:\\n                    head[e] += 1\\n                if head[e] < len(positions[e]) and positions[e][head[e]] < pos:\\n                    return False\\n\\n            # remove this occurrence of d\\n            removed[pos] = True\\n            head[d] += 1\\n\\n        return True\\n\"",
  "2280_14631217_python-updated-time": "1746803501384",
  "2557_14631217_python-updated-time": "1746969420721",
  "2295_14631217_python-updated-time": "1746803781002",
  "random-uuid": "0626aaef-e44c-6a50-2d17-8e97d1575b3c",
  "994_14631217_python-updated-time": "1746038821104",
  "2690_14631217_python-updated-time": "1747065041707",
  "462_14631217_python": "\"class Solution:\\n    def minMoves2(self, nums):\\n        nums.sort()\\n        median = nums[len(nums) // 2]\\n        return sum(abs(num - median) for num in nums)\\n\"",
  "2117_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def findOriginalArray(self, changed):\\n        if len(changed) % 2 != 0:\\n            return []\\n\\n        count = Counter(changed)\\n        changed.sort()\\n        original = []\\n\\n        for x in changed:\\n            if count[x] == 0:\\n                continue\\n            if count[2 * x] == 0:\\n                return []\\n            if x == 0 and count[x] < 2:\\n                return []\\n            original.append(x)\\n            count[x] -= 1\\n            count[2 * x] -= 1\\n\\n        return original\\n\"",
  "2734_14631217_javascript": "\"Array.prototype.last = function() {\\n  return this.length === 0 ? -1 : this[this.length - 1];\\n}\\n\"",
  "2696_14631217_python": "\"from collections import Counter, defaultdict\\n\\nclass Solution:\\n    def beautifulSubsets(self, nums, k):\\n        # Group numbers by modulo k to separate independent buckets\\n        buckets = defaultdict(list)\\n        for x in nums:\\n            buckets[x % k].append(x)\\n\\n        total_sets = 1\\n        # Process each bucket independently\\n        for arr in buckets.values():\\n            cnt = Counter(arr)\\n            # Sort unique values\\n            values = sorted(cnt)\\n\\n            # dp_no: ways for prefix without taking previous value\\n            # dp_yes: ways for prefix with taking previous value\\n            dp_no, dp_yes = 1, 0\\n            prev = None\\n            for v in values:\\n                c = cnt[v]\\n                # number of non-empty ways to choose from duplicates of v\\n                take_ways = (1 << c) - 1\\n\\n                # Check if current value conflicts with previous (difference == k)\\n                if prev is not None and v - prev == k:\\n                    # Conflict: can only take v if previous was not taken\\n                    new_dp_yes = dp_no * take_ways\\n                else:\\n                    # No conflict: can take v regardless of previous\\n                    new_dp_yes = (dp_no + dp_yes) * take_ways\\n\\n                # Whether we take v or not, the 'no' state accumulates all previous\\n                new_dp_no = dp_no + dp_yes\\n\\n                dp_no, dp_yes = new_dp_no, new_dp_yes\\n                prev = v\\n\\n            # Total subsets for this bucket = all 'yes' and 'no' states\\n            bucket_total = dp_no + dp_yes\\n            total_sets *= bucket_total\\n\\n        # Subtract the empty subset\\n        return total_sets - 1\"",
  "1140_14631217_python": "\"import heapq\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def rearrangeBarcodes(self, barcodes):\\n        \\\"\\\"\\\"\\n        :type barcodes: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        count = Counter(barcodes)\\n        # Max-heap based on frequency\\n        max_heap = [(-freq, num) for num, freq in count.items()]\\n        heapq.heapify(max_heap)\\n\\n        result = []\\n        \\n        while len(max_heap) >= 2:\\n            freq1, num1 = heapq.heappop(max_heap)\\n            freq2, num2 = heapq.heappop(max_heap)\\n            \\n            result.extend([num1, num2])\\n            \\n            if freq1 + 1 < 0:\\n                heapq.heappush(max_heap, (freq1 + 1, num1))\\n            if freq2 + 1 < 0:\\n                heapq.heappush(max_heap, (freq2 + 1, num2))\\n\\n        if max_heap:\\n            result.append(max_heap[0][1])\\n        \\n        return result\\n\"",
  "3571_14631217_python-updated-time": "1747571758849",
  "2278_14631217_python-updated-time": "1746803419248",
  "2053_14631217_python": "\"class Solution(object):\\n    def areOccurrencesEqual(self, s):\\n        freq = [0]*26\\n        for ch in s:\\n            freq[ord(ch)-97] += 1\\n        counts = [f for f in freq if f>0]\\n        return len(set(counts)) == 1\\n\"",
  "731_14631217_python-updated-time": "1745787164645",
  "1711_14631217_python": "\"class Solution:\\n    def restoreMatrix(self, rowSum, colSum):\\n        m, n = len(rowSum), len(colSum)\\n        # initialize m×n zero matrix\\n        ans = [[0]*n for _ in range(m)]\\n        i = j = 0\\n\\n        # march through rows and columns\\n        while i < m and j < n:\\n            # take the max we can here without overshooting\\n            take = min(rowSum[i], colSum[j])\\n            ans[i][j] = take\\n            rowSum[i]  -= take\\n            colSum[j]  -= take\\n\\n            # if we've satisfied row i, move to next row\\n            if rowSum[i] == 0:\\n                i += 1\\n            # if we've satisfied column j, move to next column\\n            if colSum[j] == 0:\\n                j += 1\\n\\n        return ans\\n\"",
  "108_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def sortedArrayToBST(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: Optional[TreeNode]\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return None\\n        \\n        mid = len(nums) // 2\\n        root = TreeNode(nums[mid])\\n        \\n        root.left = self.sortedArrayToBST(nums[:mid])\\n        root.right = self.sortedArrayToBST(nums[mid+1:])\\n        \\n        return root\\n\"",
  "3220_14631217_python-updated-time": "1747317248057",
  "1161_14631217_mysql": "\"SELECT \\n    p.project_id, \\n    ROUND(AVG(e.experience_years), 2) AS average_years\\nFROM \\n    Project p\\nJOIN \\n    Employee e ON p.employee_id = e.employee_id\\nGROUP BY \\n    p.project_id;\\n\"",
  "885_14631217_python": "\"import bisect\\n\\nclass ExamRoom(object):\\n    def __init__(self, n):\\n        self.n = n\\n        self.seats = []\\n\\n    def seat(self):\\n        if not self.seats:\\n            self.seats.append(0)\\n            return 0\\n        \\n        max_dist = self.seats[0]\\n        seat = 0\\n\\n        for i in range(len(self.seats) - 1):\\n            dist = (self.seats[i+1] - self.seats[i]) // 2\\n            if dist > max_dist:\\n                max_dist = dist\\n                seat = self.seats[i] + dist\\n\\n        if self.n - 1 - self.seats[-1] > max_dist:\\n            seat = self.n - 1\\n\\n        bisect.insort(self.seats, seat)\\n        return seat\\n\\n    def leave(self, p):\\n        self.seats.remove(p)\\n\"",
  "1512_14631217_python-updated-time": "1746346302539",
  "2204_14631217_python-updated-time": "1746729783056",
  "1566_14631217_python": "\"class Solution(object):\\n    def isPrefixOfWord(self, sentence, searchWord):\\n        words = sentence.split(\\\" \\\")\\n        for idx, w in enumerate(words, 1):\\n            if w.startswith(searchWord):\\n                return idx\\n        return -1\\n\"",
  "3272_14631217_python": "\"class Solution(object):\\n    def resultGrid(self, image, threshold):\\n        \\\"\\\"\\\"\\n        :type image: List[List[int]]\\n        :type threshold: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        m, n = len(image), len(image[0])\\n        from collections import defaultdict\\n\\n        pixel_sum = [[0] * n for _ in range(m)]\\n        pixel_count = [[0] * n for _ in range(m)]\\n\\n        def is_valid_region(i, j):\\n            for x in range(i, i + 3):\\n                for y in range(j, j + 3):\\n                    for dx, dy in ((0, 1), (1, 0)):\\n                        nx, ny = x + dx, y + dy\\n                        if i <= nx < i + 3 and j <= ny < j + 3:\\n                            if abs(image[x][y] - image[nx][ny]) > threshold:\\n                                return False\\n            return True\\n\\n        for i in range(m - 2):\\n            for j in range(n - 2):\\n                if is_valid_region(i, j):\\n                    total = 0\\n                    for x in range(i, i + 3):\\n                        for y in range(j, j + 3):\\n                            total += image[x][y]\\n                    avg = total // 9\\n                    for x in range(i, i + 3):\\n                        for y in range(j, j + 3):\\n                            pixel_sum[x][y] += avg\\n                            pixel_count[x][y] += 1\\n\\n        result = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if pixel_count[i][j] == 0:\\n                    result[i][j] = image[i][j]\\n                else:\\n                    result[i][j] = pixel_sum[i][j] // pixel_count[i][j]\\n        return result\\n\"",
  "352_14631217_python-updated-time": "1745257220843",
  "1711_14631217_python-updated-time": "1746443914283",
  "554_14631217_python": "\"class Solution(object):\\n    def leastBricks(self, wall):\\n        from collections import Counter\\n        edge_counts = Counter()\\n        for row in wall:\\n            cum_width = 0\\n            # exclude the last brick to avoid the right edge of the wall\\n            for width in row[:-1]:\\n                cum_width += width\\n                edge_counts[cum_width] += 1\\n        # if there are no internal edges, we must cross every row\\n        if not edge_counts:\\n            return len(wall)\\n        # draw the line through the position with the most edges\\n        max_edges = max(edge_counts.values())\\n        return len(wall) - max_edges\\n\"",
  "53_14631217_python-updated-time": "1745014256939",
  "3331_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        operations = 0\\n        for num in nums:\\n            if num >= k:\\n                break\\n            operations += 1\\n        return operations\\n\"",
  "1394_14631217_python-updated-time": "1746882217324",
  "1_0_python3": "\"class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range (0,9):\\n            \\n        \"",
  "2239_14631217_python-updated-time": "1746801704751",
  "2378_14631217_python-updated-time": "1746881586681",
  "1566_14631217_python-updated-time": "1746347762201",
  "1612_14631217_python-updated-time": "1746432888087",
  "2813_14631217_javascript-updated-time": "1747139760117",
  "870_14631217_python-updated-time": "1745879751960",
  "1503_14631217_python-updated-time": "1746346451617",
  "1292_14631217_mysql-updated-time": "1746126376808",
  "312_14631217_python-updated-time": "1745255931315",
  "1188_14631217_python": "\"class Solution(object):\\n    def braceExpansionII(self, expression):\\n        \\\"\\\"\\\"\\n        :type expression: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        def union(sets):\\n            res = set()\\n            for s in sets:\\n                res |= s\\n            return res\\n\\n        def multi_product(sets):\\n            res = set([\\\"\\\"])\\n            for s in sets:\\n                res = set(a + b for a in res for b in s)\\n            return res\\n\\n        def parse(i):\\n            res = []\\n            curr = [set([\\\"\\\"])]  # list of sets for concatenation\\n            while i < len(expression):\\n                if expression[i] == '{':\\n                    i, inner = parse(i + 1)\\n                    curr.append(inner)\\n                elif expression[i].isalpha():\\n                    curr.append(set([expression[i]]))\\n                    i += 1\\n                elif expression[i] == ',':\\n                    res.append(multi_product(curr))\\n                    curr = [set([\\\"\\\"])]\\n                    i += 1\\n                elif expression[i] == '}':\\n                    res.append(multi_product(curr))\\n                    return i + 1, union(res)\\n            res.append(multi_product(curr))\\n            return i, union(res)\\n\\n        _, result_set = parse(0)\\n        return sorted(result_set)\\n\"",
  "547_14631217_python-updated-time": "1745447089630",
  "3033_14631217_python-updated-time": "1747306384991",
  "127_14631217_python-updated-time": "1745084860425",
  "133_14631217_python-updated-time": "1745085308317",
  "2505_14631217_python-updated-time": "1746966676321",
  "1772_14631217_python-updated-time": "1746445229117",
  "3773_14631217_python-updated-time": "1747681723547",
  "393_14631217_python-updated-time": "1745355502869",
  "1441_14631217_python": "\"class Solution:\\n    def minFlips(self, a, b, c):\\n        flips = 0\\n        while a or b or c:\\n            ai = a & 1\\n            bi = b & 1\\n            ci = c & 1\\n\\n            if ci:\\n                # Need at least one of ai or bi to be 1\\n                if ai == 0 and bi == 0:\\n                    flips += 1\\n            else:\\n                # Both ai and bi must be 0\\n                flips += ai + bi\\n\\n            a >>= 1\\n            b >>= 1\\n            c >>= 1\\n\\n        return flips\\n\"",
  "475_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        houses.sort()\\n        heaters.sort()\\n        res = 0\\n        for house in houses:\\n            idx = bisect.bisect_left(heaters, house)\\n            right = heaters[idx] - house if idx < len(heaters) else float('inf')\\n            left = house - heaters[idx - 1] if idx > 0 else float('inf')\\n            res = max(res, min(left, right))\\n        return res\\n\"",
  "3828_14631217_mysql-updated-time": "1747741179524",
  "1667_14631217_python": "\"class Solution(object):\\n    def findKthBit(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        def helper(n, k):\\n            if n == 1:\\n                return '0'\\n            length = (1 << n) - 1  # Length of Sn = 2^n - 1\\n            mid = length // 2 + 1\\n            if k == mid:\\n                return '1'\\n            elif k < mid:\\n                return helper(n - 1, k)\\n            else:\\n                mirror = mid - (k - mid)\\n                return '1' if helper(n - 1, mirror) == '0' else '0'\\n\\n        return helper(n, k)\\n\"",
  "2023_14631217_python": "\"from sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\nclass MovieRentingSystem:\\n    def __init__(self, n, entries):\\n        self.available = defaultdict(SortedList)  # movie -> SortedList of (price, shop)\\n        self.prices = {}  # (shop, movie) -> price\\n        self.rented = SortedList()  # SortedList of (price, shop, movie)\\n\\n        for shop, movie, price in entries:\\n            self.available[movie].add((price, shop))\\n            self.prices[(shop, movie)] = price\\n\\n    def search(self, movie):\\n        return [shop for price, shop in self.available[movie][:5]]\\n\\n    def rent(self, shop, movie):\\n        price = self.prices[(shop, movie)]\\n        self.available[movie].remove((price, shop))\\n        self.rented.add((price, shop, movie))\\n\\n    def drop(self, shop, movie):\\n        price = self.prices[(shop, movie)]\\n        self.rented.remove((price, shop, movie))\\n        self.available[movie].add((price, shop))\\n\\n    def report(self):\\n        return [[shop, movie] for price, shop, movie in self.rented[:5]]\\n\"",
  "1039_14631217_python-updated-time": "1746040782326",
  "1875_14631217_python-updated-time": "1746531868417",
  "2013_14631217_python-updated-time": "1746626351383",
  "3817_14631217_python-updated-time": "1747681586186",
  "8_14631217_python-updated-time": "1744979115494",
  "3215_14631217_python": "\"class Solution:\\n    def areSimilar(self, mat, k):\\n        m, n = len(mat), len(mat[0])\\n        k = k % n  # Only k mod n matters, since it's cyclic\\n\\n        def shift_row(row, direction):\\n            if direction == 'left':\\n                return row[k:] + row[:k]\\n            else:\\n                return row[-k:] + row[:-k]\\n\\n        for i in range(m):\\n            if i % 2 == 0:\\n                shifted = shift_row(mat[i], 'left')\\n            else:\\n                shifted = shift_row(mat[i], 'right')\\n            if shifted != mat[i]:\\n                return False\\n        return True\\n\"",
  "3500_14631217_python-updated-time": "1747487336834",
  "3826_14631217_python-updated-time": "1747745147460",
  "1788_14631217_python": "\"class Solution(object):\\n    def stoneGameVI(self, aliceValues, bobValues):\\n        diffs = [(a + b, i) for i, (a, b) in enumerate(zip(aliceValues, bobValues))]\\n        diffs.sort(reverse=True)\\n        scoreA = scoreB = 0\\n        for turn, (_, i) in enumerate(diffs):\\n            if turn % 2 == 0:\\n                scoreA += aliceValues[i]\\n            else:\\n                scoreB += bobValues[i]\\n        if scoreA > scoreB:\\n            return 1\\n        if scoreA < scoreB:\\n            return -1\\n        return 0\\n\"",
  "3229_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        median = nums[n//2]\\n        s = str(median)\\n        L = len(s)\\n        half = (L + 1)//2\\n        \\n        # Build up to 3 palindromes by mirroring prefix-1, prefix, prefix+1\\n        prefix = int(s[:half])\\n        cands = set()\\n        for d in (-1, 0, 1):\\n            p2 = prefix + d\\n            if p2 <= 0:\\n                continue\\n            t = str(p2)\\n            if L % 2 == 0:\\n                pal = int(t + t[::-1])\\n            else:\\n                pal = int(t + t[:-1][::-1])\\n            if 1 <= pal < 10**9:\\n                cands.add(pal)\\n        \\n        # Also consider the largest (L-1)-digit palindrome 999…9\\n        if L > 1:\\n            cands.add(int('9'*(L-1)))\\n        # And the smallest (L+1)-digit palindrome 1 0…0 1 (if still <1e9)\\n        if L < 9:\\n            cands.add(int('1' + '0'*(L-1) + '1'))\\n        \\n        best = float('inf')\\n        # Only O(5) candidates, each cost is O(n)\\n        for p in cands:\\n            cost = 0\\n            for x in nums:\\n                cost += abs(x - p)\\n            if cost < best:\\n                best = cost\\n        \\n        return best\\n\"",
  "3845_14631217_python": "\"import sys\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def maxScore(self, n, edges):\\n        # Build adjacency\\n        G = [[] for _ in range(n)]\\n        for u,v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n\\n        m = len(edges)\\n        is_cycle = (m == n)\\n\\n        # 1) Extract the nodes in order:\\n        order = [0]*n\\n        if is_cycle:\\n            # pick node 0, then pick one neighbor to start\\n            start = 0\\n            nxt = G[start][0]\\n            order[0] = start\\n            order[1] = nxt\\n            for i in range(2, n):\\n                prev = order[i-2]\\n                cur  = order[i-1]\\n                # among neighbors of cur, pick the one that's not prev\\n                for w in G[cur]:\\n                    if w != prev:\\n                        order[i] = w\\n                        break\\n        else:\\n            # path: find a leaf (degree == 1)\\n            leaf = next(u for u in range(n) if len(G[u]) == 1)\\n            order[0] = leaf\\n            order[1] = G[leaf][0]\\n            for i in range(2, n):\\n                prev = order[i-2]\\n                cur  = order[i-1]\\n                # among neighbors, pick the one not prev\\n                for w in G[cur]:\\n                    if w != prev:\\n                        order[i] = w\\n                        break\\n\\n        # 2) Build the optimal value‐assignment for path or cycle\\n        perm = [0]*n\\n        if not is_cycle:\\n            # path:  1,3,5,..., (odd ascending) then (even descending)\\n            k = (n + 1)//2  # number of odds\\n            for i in range(k):\\n                perm[i] = 2*i + 1\\n            for i in range(k, n):\\n                # i=k maps to the largest even: 2*(n-k)\\n                perm[i] = 2*(n - i)\\n        else:\\n            # cycle: [1] + [2,4,6,...,2*m] + [odd descending except 1]\\n            m_even = n//2\\n            perm[0] = 1\\n            # fill evens ascending\\n            for j in range(m_even):\\n                perm[1+j] = 2*(j+1)\\n            # build all odds, drop the '1', reverse, then fill\\n            odds = [2*i-1 for i in range(1, n-m_even+1)]  # this is [1,3,5,...]\\n            odds.pop(0)       # remove the leading 1\\n            odds.reverse()    # now descending [..,5,3]\\n            for j, val in enumerate(odds):\\n                perm[1 + m_even + j] = val\\n\\n        # 3) Map back to nodes and sum edge‐products\\n        value = [0]*n\\n        for idx, node in enumerate(order):\\n            value[node] = perm[idx]\\n\\n        total = 0\\n        for u, v in edges:\\n            total += value[u] * value[v]\\n        return total\"",
  "1112_14631217_python-updated-time": "1746126106355",
  "1734_14631217_mysql-updated-time": "1746438691168",
  "1168_14631217_python-updated-time": "1746108175435",
  "2241_14631217_python-updated-time": "1746801760021",
  "1086_14631217_python": "\"class Solution:\\n    def divisorGame(self, n):\\n        return n % 2 == 0\\n\"",
  "3470_14631217_python": "\"class Solution(object):\\n    def maximumScore(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        # U[j][i] = sum of grid[0..i-1][j]\\n        U = [[0]*(n+1) for _ in range(n)]\\n        for j in range(n):\\n            for i in range(1, n+1):\\n                U[j][i] = U[j][i-1] + grid[i-1][j]\\n\\n        # dp_prev[p][c] = best score up through column j-1,\\n        # with r[j-2]=p and r[j-1]=c, where r[*]∈[0..n]\\n        INF = -10**30\\n        dp_prev = [[INF]*(n+1) for _ in range(n+1)]\\n        # Base: column -1 has r[-1]=0, so for j=0 we only set dp_prev[0][c]=0\\n        for c in range(n+1):\\n            dp_prev[0][c] = 0\\n\\n        # Transition for columns j=1..n-1\\n        for j in range(1, n):\\n            dp_curr = [[INF]*(n+1) for _ in range(n+1)]\\n            Ucol = U[j-1]  # prefix sums for column j-1\\n\\n            # For each possible old “cur” = r[j-1], build\\n            #   pm1[x] = max_{p ≤ x} dp_prev[p][cur]\\n            #   B2[p] = dp_prev[p][cur] + max(0, Ucol[p]-Ucol[cur])\\n            #   sm2[x] = max_{p ≥ x} B2[p]\\n            #\\n            # Then for each next r[j]=rn:\\n            #   delta1 = max(0, Ucol[rn]-Ucol[cur])\\n            #   best1 = pm1[rn] + delta1\\n            #   best2 = sm2[rn+1]\\n            #   dp_curr[cur][rn] = max(best1, best2)\\n            #\\n            for cur in range(n+1):\\n                # build pm1\\n                pm1 = [INF]*(n+1)\\n                m = INF\\n                for p in range(n+1):\\n                    if dp_prev[p][cur] > m:\\n                        m = dp_prev[p][cur]\\n                    pm1[p] = m\\n                # build B2 and its suffix max sm2\\n                B2 = [INF]*(n+1)\\n                for p in range(n+1):\\n                    delta = Ucol[p] - Ucol[cur]\\n                    if delta < 0:\\n                        delta = 0\\n                    B2[p] = dp_prev[p][cur] + delta\\n                sm2 = [INF]*(n+2)\\n                m2 = INF\\n                for p in range(n, -1, -1):\\n                    if B2[p] > m2:\\n                        m2 = B2[p]\\n                    sm2[p] = m2\\n\\n                # fill dp_curr for this cur\\n                for rn in range(n+1):\\n                    # one‐cut‐only on prev≤rn\\n                    d1 = Ucol[rn] - Ucol[cur]\\n                    if d1 < 0:\\n                        d1 = 0\\n                    best1 = pm1[rn] + d1\\n                    # two‐cut‐needed region\\n                    best2 = sm2[rn+1]\\n                    dp_curr[cur][rn] = best1 if best1 > best2 else best2\\n\\n            dp_prev = dp_curr\\n\\n        # Finally, add contribution of the last column j = n-1,\\n        # where neighbor on the right is “none” => r[n]=0\\n        Ulast = U[n-1]\\n        ans = 0\\n        for prev in range(n+1):\\n            for cur in range(n+1):\\n                base = dp_prev[prev][cur]\\n                if base < 0:\\n                    continue\\n                # M = max(prev, r[n]=0) = prev\\n                # add = max(0, Ulast[prev] - Ulast[cur])\\n                delta = Ulast[prev] - Ulast[cur]\\n                if delta > 0:\\n                    base += delta\\n                if base > ans:\\n                    ans = base\\n\\n        return ans\\n\"",
  "1188_14631217_python-updated-time": "1746108405915",
  "3221_14631217_python": "\"class Solution:\\n    def findPeaks(self, mountain):\\n        \\\"\\\"\\\"\\n        :type mountain: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(mountain)\\n        peaks = []\\n        # iterate from 1 to n-2 (cannot consider first or last element)\\n        for i in range(1, n - 1):\\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\\n                peaks.append(i)\\n        return peaks\\n\"",
  "841_14631217_python-updated-time": "1745878936943",
  "3587_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def maxScore(self, n, k, stayScore, travelScore):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type stayScore: List[List[int]]\\n        :type travelScore: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # dp_prev[j] will hold the max score ending at city j after previous day\\n        dp_prev = [0] * n\\n        # Iterate over each day\\n        for day in range(k):\\n            dp_cur = [0] * n\\n            # Compute dp for current day\\n            for dest in range(n):\\n                # Option 1: stay in city dest\\n                stay = dp_prev[dest] + stayScore[day][dest]\\n                # Option 2: travel from some city p to dest\\n                # Initialize with travel from city 0\\n                max_travel = dp_prev[0] + travelScore[0][dest]\\n                # Check travel from other cities\\n                for p in range(1, n):\\n                    val = dp_prev[p] + travelScore[p][dest]\\n                    if val > max_travel:\\n                        max_travel = val\\n                # Choose the better option\\n                dp_cur[dest] = stay if stay > max_travel else max_travel\\n            dp_prev = dp_cur\\n        # The answer is the best score among all cities after k days\\n        return max(dp_prev)\"",
  "821_14631217_python": "\"class Solution(object):\\n    def hitBricks(self, grid, hits):\\n        m, n = len(grid), len(grid[0])\\n        \\n        parent = [i for i in range(m * n + 1)]\\n        size = [1] * (m * n + 1)\\n        \\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            xr, yr = find(x), find(y)\\n            if xr == yr:\\n                return\\n            parent[xr] = yr\\n            size[yr] += size[xr]\\n        \\n        def idx(x, y):\\n            return x * n + y\\n        \\n        # Mark bricks to be removed\\n        for x, y in hits:\\n            if grid[x][y] == 1:\\n                grid[x][y] = 2\\n        \\n        # Connect the grid initially\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    if i == 0:\\n                        union(idx(i,j), m*n)\\n                    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                        ni, nj = i+dx, j+dy\\n                        if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\\n                            union(idx(i,j), idx(ni,nj))\\n        \\n        res = []\\n        for x, y in reversed(hits):\\n            prev = size[find(m*n)]\\n            if grid[x][y] == 0:\\n                res.append(0)\\n                continue\\n            grid[x][y] = 1\\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                ni, nj = x+dx, y+dy\\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\\n                    union(idx(x,y), idx(ni,nj))\\n            if x == 0:\\n                union(idx(x,y), m*n)\\n            curr = size[find(m*n)]\\n            res.append(max(0, curr - prev - 1))\\n        \\n        return res[::-1]\\n\"",
  "1585_14631217_python-updated-time": "1746432963308",
  "407_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def trapRainWater(self, heightMap):\\n        if not heightMap or not heightMap[0]:\\n            return 0\\n        \\n        m, n = len(heightMap), len(heightMap[0])\\n        visited = [[False] * n for _ in range(m)]\\n        heap = []\\n        \\n        # Add all the boundary cells to the heap\\n        for i in range(m):\\n            heapq.heappush(heap, (heightMap[i][0], i, 0))\\n            heapq.heappush(heap, (heightMap[i][n-1], i, n-1))\\n            visited[i][0] = visited[i][n-1] = True\\n        for j in range(1, n-1):\\n            heapq.heappush(heap, (heightMap[0][j], 0, j))\\n            heapq.heappush(heap, (heightMap[m-1][j], m-1, j))\\n            visited[0][j] = visited[m-1][j] = True\\n        \\n        water = 0\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n        \\n        while heap:\\n            height, x, y = heapq.heappop(heap)\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\\n                    visited[nx][ny] = True\\n                    water += max(0, height - heightMap[nx][ny])\\n                    heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny))\\n        \\n        return water\\n\"",
  "2017_14631217_python": "\"class Solution:\\n    def minFlips(self, s):\\n        n = len(s)\\n        s = s + s  # simulate rotations\\n        alt1 = ''.join(['0' if i % 2 == 0 else '1' for i in range(2 * n)])\\n        alt2 = ''.join(['1' if i % 2 == 0 else '0' for i in range(2 * n)])\\n        \\n        res = n\\n        diff1 = diff2 = 0\\n        left = 0\\n        \\n        for right in range(2 * n):\\n            if s[right] != alt1[right]:\\n                diff1 += 1\\n            if s[right] != alt2[right]:\\n                diff2 += 1\\n            if right - left + 1 > n:\\n                if s[left] != alt1[left]:\\n                    diff1 -= 1\\n                if s[left] != alt2[left]:\\n                    diff2 -= 1\\n                left += 1\\n            if right - left + 1 == n:\\n                res = min(res, diff1, diff2)\\n        \\n        return res\\n\"",
  "3225_14631217_python-updated-time": "1747317128046",
  "1651_14631217_python-updated-time": "1746433898176",
  "819_14631217_python-updated-time": "1745878136039",
  "1116_14631217_python-updated-time": "1746126135454",
  "2199_14631217_python-updated-time": "1746729258392",
  "1363_14631217_python-updated-time": "1746882311778",
  "507_14631217_python-updated-time": "1745446225755",
  "1045_14631217_python-updated-time": "1746040987210",
  "386_14631217_python-updated-time": "1745355253511",
  "2037_14631217_python-updated-time": "1746637787161",
  "1804_14631217_python-updated-time": "1746453660841",
  "1627_14631217_python-updated-time": "1746433172188",
  "2271_14631217_python": "\"class Solution:\\n    def rearrangeArray(self, nums):\\n        pos = [x for x in nums if x > 0]\\n        neg = [x for x in nums if x < 0]\\n        result = []\\n        for i in range(len(nums) // 2):\\n            result.append(pos[i])\\n            result.append(neg[i])\\n        return result\\n\"",
  "3428_14631217_python-updated-time": "1747483069437",
  "1018_14631217_python-updated-time": "1746040066333",
  "486_14631217_python-updated-time": "1745441801317",
  "1904_14631217_python-updated-time": "1746542817301",
  "1652_14631217_python-updated-time": "1746433922692",
  "354_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maxEnvelopes(self, envelopes):\\n        \\\"\\\"\\\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        heights = [h for _, h in envelopes]\\n        dp = []\\n        for h in heights:\\n            idx = bisect.bisect_left(dp, h)\\n            if idx == len(dp):\\n                dp.append(h)\\n            else:\\n                dp[idx] = h\\n        return len(dp)\\n\"",
  "2043_14631217_python-updated-time": "1746637331173",
  "3112_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution:\\n    def countPaths(self, n, edges):\\n        # 1) Sieve primes up to n\\n        is_prime = [True] * (n + 1)\\n        is_prime[0] = is_prime[1] = False\\n        for i in range(2, int(n**0.5) + 1):\\n            if is_prime[i]:\\n                for j in range(i * i, n + 1, i):\\n                    is_prime[j] = False\\n\\n        # 2) Build adjacency list\\n        g = [[] for _ in range(n + 1)]\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        # 3) Find connected components of the forest after removing primes\\n        comp_id = [0] * (n + 1)      # component id for each non-prime node\\n        comp_size = []               # comp_size[c] = size of component c\\n        visited = [False] * (n + 1)\\n\\n        cid = 0\\n        for u in range(1, n + 1):\\n            if not is_prime[u] and not visited[u]:\\n                # BFS/DFS from u over non-prime nodes\\n                cid += 1\\n                size = 0\\n                dq = deque([u])\\n                visited[u] = True\\n                comp_id[u] = cid\\n                while dq:\\n                    x = dq.popleft()\\n                    size += 1\\n                    for w in g[x]:\\n                        if not is_prime[w] and not visited[w]:\\n                            visited[w] = True\\n                            comp_id[w] = cid\\n                            dq.append(w)\\n                comp_size.append(size)  # comp_size[cid-1] = size\\n\\n        # 4) For each prime p, gather sizes of adjacent non-prime components\\n        ans = 0\\n        for p in range(1, n + 1):\\n            if not is_prime[p]:\\n                continue\\n            # collect sizes of each distinct non-prime component neighbor\\n            sizes = []\\n            for v in g[p]:\\n                if not is_prime[v]:\\n                    c = comp_id[v] - 1\\n                    sizes.append(comp_size[c])\\n            if not sizes:\\n                continue\\n\\n            S = sum(sizes)\\n            S2 = sum(s * s for s in sizes)\\n            # sum over i<j of s_i * s_j = (S^2 - S2) // 2\\n            pairs_between_comps = (S * S - S2) // 2\\n            pairs_with_p = S\\n            ans += pairs_between_comps + pairs_with_p\\n\\n        return ans\\n\"",
  "2797_14631217_javascript-updated-time": "1747138878675",
  "2266_14631217_python": "\"class Solution:\\n    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):\\n        def cost_to_type(s, digits):\\n            pos = str(s)\\n            total = 0\\n            for d in pos:\\n                d = int(d)\\n                if d != digits[0]:\\n                    total += moveCost\\n                    digits[0] = d\\n                total += pushCost\\n            return total\\n        \\n        res = float('inf')\\n        for m in range(100):\\n            s = targetSeconds - m * 60\\n            if 0 <= s <= 99:\\n                digits = []\\n                digits.extend(divmod(m, 10))\\n                digits.extend(divmod(s, 10))\\n                while digits and digits[0] == 0:\\n                    digits.pop(0)\\n                if not digits:\\n                    digits = [0]\\n                cost = 0\\n                pos = startAt\\n                for d in digits:\\n                    if d != pos:\\n                        cost += moveCost\\n                    cost += pushCost\\n                    pos = d\\n                res = min(res, cost)\\n        return res\\n\"",
  "1825_14631217_python-updated-time": "1746529851692",
  "190_14631217_python": "\"class Solution(object):\\n    def reverseBits(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = 0\\n        for _ in range(32):\\n            res = (res << 1) | (n & 1)\\n            n >>= 1\\n        return res\\n\"",
  "23_14631217_python-updated-time": "1744987685134",
  "2279_14631217_python-updated-time": "1746803453250",
  "2338_14631217_python-updated-time": "1746880477215",
  "3782_14631217_mysql-updated-time": "1747671629631",
  "3801_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    # Class-level variables for precomputation, initialized once.\\n    _precomputed_factors_done = False\\n    d_factors_static = []  # Stores (c2,c3,c5,c7) for each digit 0-9\\n    target_sum_factors_static = [] # Stores (sc2,sc3,sc5,sc7, has_other_prime_factor) for sums\\n\\n    # Caps for prime factor counts in product P, based on max requirements for any sum S <= 81\\n    C2_CAP = 6  # Max exponent for 2 in S (S=64 -> 2^6)\\n    C3_CAP = 4  # Max exponent for 3 in S (S=81 -> 3^4)\\n    C5_CAP = 2  # Max exponent for 5 in S (S=25,50,75 -> 5^2)\\n    C7_CAP = 2  # Max exponent for 7 in S (S=49 -> 7^2)\\n    \\n    # Max sum of digits for a number < 10^9 (at most 9 digits like 999,999,999) is 9*9 = 81.\\n    MAX_SUM_DIGITS = 81\\n\\n    def _get_digit_prime_factors(self, digit):\\n        # Manually provide factors for digits 0-9 for efficiency\\n        if digit == 0: return (0,0,0,0)\\n        if digit == 1: return (0,0,0,0)\\n        if digit == 2: return (1,0,0,0)\\n        if digit == 3: return (0,1,0,0)\\n        if digit == 4: return (2,0,0,0)\\n        if digit == 5: return (0,0,1,0)\\n        if digit == 6: return (1,1,0,0)\\n        if digit == 7: return (0,0,0,1)\\n        if digit == 8: return (3,0,0,0)\\n        if digit == 9: return (0,2,0,0)\\n        return (0,0,0,0) # Should not happen\\n\\n    def _get_target_sum_prime_factors(self, S):\\n        if S == 0: return (0,0,0,0, False) # Sum 0 not for positive integers\\n        \\n        sc2,sc3,sc5,sc7 = 0,0,0,0\\n        has_other_prime = False\\n        \\n        temp_S = S\\n        while temp_S > 0 and temp_S % 2 == 0: sc2+=1; temp_S //= 2\\n        while temp_S > 0 and temp_S % 3 == 0: sc3+=1; temp_S //= 3\\n        while temp_S > 0 and temp_S % 5 == 0: sc5+=1; temp_S //= 5\\n        while temp_S > 0 and temp_S % 7 == 0: sc7+=1; temp_S //= 7\\n        \\n        if temp_S > 1: has_other_prime = True # Remaining temp_S has prime factors > 7\\n        return (sc2,sc3,sc5,sc7, has_other_prime)\\n\\n    def _ensure_precomputation(self):\\n        if Solution._precomputed_factors_done:\\n            return\\n\\n        Solution.d_factors_static = [self._get_digit_prime_factors(d) for d in range(10)]\\n        \\n        Solution.target_sum_factors_static.append((0,0,0,0,False)) # For sum = 0\\n        for s_val in range(1, Solution.MAX_SUM_DIGITS + 1): \\n            Solution.target_sum_factors_static.append(self._get_target_sum_prime_factors(s_val))\\n        \\n        Solution._precomputed_factors_done = True\\n\\n    # Instance variables for a single _solve_N call context\\n    # self.memo, self.snum_str, self.D\\n    \\n    def _dp(self, idx, current_sum, pc2, pc3, pc5, pc7, tight, is_leading, has_zero):\\n        state = (idx, current_sum, pc2, pc3, pc5, pc7, tight, is_leading, has_zero)\\n        if state in self.memo:\\n            return self.memo[state]\\n\\n        if idx == self.D: # All digits placed\\n            if is_leading: # Number was \\\"0\\\" or \\\"00\\\" etc. Not positive.\\n                return 0\\n            \\n            # current_sum will be > 0 if not is_leading. Smallest positive number is 1 (sum=1).\\n            # An explicit check 'if current_sum == 0: return 0' is redundant here because\\n            # is_leading=False implies current_sum > 0.\\n            \\n            if has_zero: # Product of digits P is 0\\n                # 0 % current_sum == 0 is true, since current_sum > 0 for any valid number.\\n                return 1 \\n            \\n            # Product P is not zero. Check divisibility P % S == 0.\\n            s_sc2, s_sc3, s_sc5, s_sc7, s_has_other_prime = Solution.target_sum_factors_static[current_sum]\\n            \\n            if s_has_other_prime:\\n                # P (non-zero) has only 2,3,5,7 factors. Sum S has other factor(s) > 7. S cannot divide P.\\n                return 0 \\n            \\n            # Sum S has only 2,3,5,7 factors. Check if P has enough of these factors.\\n            if pc2 < s_sc2: return 0\\n            if pc3 < s_sc3: return 0\\n            if pc5 < s_sc5: return 0\\n            if pc7 < s_sc7: return 0\\n            \\n            return 1 # All checks passed: P is non-zero and S divides P.\\n\\n        ans = 0\\n        limit = int(self.snum_str[idx]) if tight else 9 # Max digit we can place\\n\\n        for digit in range(limit + 1):\\n            new_tight = tight and (digit == limit) # tight constraint for next state\\n            \\n            if is_leading and digit == 0:\\n                # Still placing leading zeros. State mostly unchanged.\\n                # has_zero flag is for non-leading zeros.\\n                ans += self._dp(idx + 1, current_sum, pc2, pc3, pc5, pc7, new_tight, True, False)\\n            else:\\n                # Prune if sum exceeds max possible (81 for N < 10^9)\\n                if current_sum + digit > Solution.MAX_SUM_DIGITS: \\n                     continue \\n\\n                # If digit is 0 (and not a leading zero), then new_has_zero becomes true.\\n                new_has_zero = has_zero or (digit == 0) \\n                \\n                d_c2, d_c3, d_c5, d_c7 = Solution.d_factors_static[digit]\\n                \\n                # Update product's prime factor counts.\\n                # These counts are only relevant if new_has_zero is False.\\n                # If new_has_zero is True, product P=0. We pass them along anyway for consistent state.\\n                new_pc2 = min(Solution.C2_CAP, pc2 + d_c2) \\n                new_pc3 = min(Solution.C3_CAP, pc3 + d_c3)\\n                new_pc5 = min(Solution.C5_CAP, pc5 + d_c5)\\n                new_pc7 = min(Solution.C7_CAP, pc7 + d_c7)\\n                \\n                ans += self._dp(idx + 1, current_sum + digit, \\\\\\n                              new_pc2, new_pc3, new_pc5, new_pc7, \\\\\\n                              new_tight, False, new_has_zero)\\n        \\n        self.memo[state] = ans\\n        return ans\\n\\n    def _solve_N(self, N_val):\\n        if N_val == 0: return 0 # No positive beautiful numbers up to 0.\\n        \\n        self.snum_str = str(N_val)\\n        self.D = len(self.snum_str) # Number of digits in N_val\\n        self.memo = {} # Clear memo for this specific N_val calculation.\\n        \\n        # Initial call: idx=0, sum=0, all pc_i=0, tight=True, is_leading=True, has_zero=False\\n        return self._dp(0, 0, 0,0,0,0, True, True, False)\\n\\n    def beautifulNumbers(self, l, r):\\n        # Ensure precomputation tables are ready (call once per Solution object or globally)\\n        self._ensure_precomputation()\\n        \\n        count_r = self._solve_N(r)\\n        count_l_minus_1 = self._solve_N(l - 1)\\n        \\n        return count_r - count_l_minus_1\"",
  "2015_14631217_python": "\"class Solution:\\n    def findRotation(self, mat, target):\\n        def rotate(matrix):\\n            # Rotate 90° clockwise: transpose + reverse rows\\n            return [list(row) for row in zip(*matrix[::-1])]\\n\\n        for _ in range(4):\\n            if mat == target:\\n                return True\\n            mat = rotate(mat)\\n        return False\\n\"",
  "2601_14631217_python": "\"class Solution:\\n    def countPartitions(self, nums, k):\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        total = sum(nums)\\n        \\n        # If total < 2k, impossible for both groups to reach k\\n        if total < 2 * k:\\n            return 0\\n        # If k == 0, every partition is valid\\n        if k == 0:\\n            return pow(2, n, mod)\\n        \\n        # Only \\\"small\\\" candies (value < k) can appear in a subset summing to < k.\\n        small = [v for v in nums if v < k]\\n        \\n        # dp[s] = number of subsets of `small` that sum to exactly s (for 0 <= s < k)\\n        dp = [0] * k\\n        dp[0] = 1\\n        \\n        for v in small:\\n            # update in reverse to avoid reuse\\n            for s in range(k - 1, v - 1, -1):\\n                dp[s] = (dp[s] + dp[s - v]) % mod\\n        \\n        # C = number of subsets of small with sum < k\\n        C = sum(dp) % mod\\n        \\n        total_partitions = pow(2, n, mod)\\n        # Subtract partitions where group A sum<k (C) or group B sum<k (C)\\n        # (they are disjoint when total >= 2k)\\n        ans = (total_partitions - 2 * C) % mod\\n        return ans\\n\"",
  "3240_14631217_python-updated-time": "1747399233110",
  "208_14631217_python": "\"class TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\nclass Trie(object):\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_end = True\\n\\n    def search(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return node.is_end\\n\\n    def startsWith(self, prefix):\\n        \\\"\\\"\\\"\\n        :type prefix: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        node = self.root\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return True\\n\"",
  "94_14631217_python-updated-time": "1745015725893",
  "179_14631217_python-updated-time": "1745092442535",
  "2362_14631217_python": "\"class Solution:\\n    def minimumRounds(self, tasks):\\n        from collections import Counter\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for f in cnt.values():\\n            if f == 1:\\n                return -1\\n            # minimum number of batches of size 2 or 3 to cover f tasks\\n            rounds += (f + 2) // 3\\n        return rounds\\n\"",
  "3150_14631217_python-updated-time": "1747307672741",
  "576_14631217_python": "\"class Solution(object):\\n    def findPaths(self, m, n, maxMove, startRow, startColumn):\\n        MOD = 10**9 + 7\\n        # dp[i][j]: number of ways to be at cell (i,j) after current number of moves\\n        dp = [[0] * n for _ in range(m)]\\n        dp[startRow][startColumn] = 1\\n        result = 0\\n\\n        for _ in range(maxMove):\\n            new_dp = [[0] * n for _ in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    ways = dp[i][j]\\n                    if ways:\\n                        # try all four directions\\n                        for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\\n                            ni, nj = i + di, j + dj\\n                            if 0 <= ni < m and 0 <= nj < n:\\n                                new_dp[ni][nj] = (new_dp[ni][nj] + ways) % MOD\\n                            else:\\n                                # moving out of bounds: count as a valid path\\n                                result = (result + ways) % MOD\\n            dp = new_dp\\n\\n        return result\\n\"",
  "1675_14631217_python": "\"class Solution(object):\\n    def maxDistance(self, position, m):\\n        \\\"\\\"\\\"\\n        :type position: List[int]\\n        :type m: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        position.sort()\\n\\n        def canPlaceBalls(min_dist):\\n            count = 1\\n            last = position[0]\\n            for i in range(1, len(position)):\\n                if position[i] - last >= min_dist:\\n                    count += 1\\n                    last = position[i]\\n                    if count == m:\\n                        return True\\n            return False\\n\\n        left, right = 1, position[-1] - position[0]\\n        result = 0\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if canPlaceBalls(mid):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\"",
  "2952_14631217_python-updated-time": "1747225136803",
  "2375_14631217_python-updated-time": "1746881853660",
  "120_14631217_python-updated-time": "1745081541498",
  "1222_14631217_python": "\"class Solution:\\n    def removeCoveredIntervals(self, intervals):\\n        # Sort by start ascending, and end descending\\n        intervals.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        count = 0\\n        prev_end = 0\\n        \\n        for start, end in intervals:\\n            if end > prev_end:\\n                count += 1\\n                prev_end = end  # Update to current end\\n            # else: interval is covered\\n        \\n        return count\\n\"",
  "2320_14631217_python-updated-time": "1746810240902",
  "2205_14631217_python": "\"class Solution:\\n    def goodDaysToRobBank(self, security, time):\\n        n = len(security)\\n        # If time == 0, every day is good\\n        if time == 0:\\n            return list(range(n))\\n        \\n        # left[i]: number of consecutive non-increasing days ending at i\\n        left = [0] * n\\n        for i in range(1, n):\\n            if security[i] <= security[i-1]:\\n                left[i] = left[i-1] + 1\\n        \\n        # right[i]: number of consecutive non-decreasing days starting at i\\n        right = [0] * n\\n        for i in range(n-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                right[i] = right[i+1] + 1\\n        \\n        res = []\\n        # A good day i needs at least 'time' before and after\\n        for i in range(time, n - time):\\n            if left[i] >= time and right[i] >= time:\\n                res.append(i)\\n        \\n        return res\\n\"",
  "1433_14631217_python-updated-time": "1746811258051",
  "2361_14631217_python": "\"class Solution:\\n    def digitSum(self, s, k):\\n        while len(s) > k:\\n            new_s = []\\n            # split into groups of size k\\n            for i in range(0, len(s), k):\\n                group = s[i:i+k]\\n                # sum the digits in this group\\n                total = sum(ord(c) - ord('0') for c in group)\\n                new_s.append(str(total))\\n            s = \\\"\\\".join(new_s)\\n        return s\\n\"",
  "239_14631217_python-updated-time": "1745247539491",
  "977_14631217_python-updated-time": "1746004403582",
  "1474_14631217_python": "\"class Solution(object):\\n    def longestZigZag(self, root):\\n        self.max_len = 0\\n\\n        def dfs(node, direction, length):\\n            if not node:\\n                return\\n            self.max_len = max(self.max_len, length)\\n            if direction == 'left':\\n                dfs(node.left, 'right', length + 1)\\n                dfs(node.right, 'left', 1)\\n            else:\\n                dfs(node.right, 'left', length + 1)\\n                dfs(node.left, 'right', 1)\\n\\n        dfs(root.left, 'right', 1)\\n        dfs(root.right, 'left', 1)\\n\\n        return self.max_len\\n\"",
  "3113_14631217_python-updated-time": "1747227893192",
  "3754_14631217_python-updated-time": "1747675764422",
  "825_14631217_python-updated-time": "1745878376438",
  "976_14631217_python": "\"class Solution:\\n    def minAreaRect(self, points):\\n        point_set = set(map(tuple, points))\\n        min_area = float('inf')\\n\\n        n = len(points)\\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                # Must form a diagonal (not same row or column)\\n                if x1 != x2 and y1 != y2:\\n                    # Check if the other two corners exist\\n                    if (x1, y2) in point_set and (x2, y1) in point_set:\\n                        area = abs(x1 - x2) * abs(y1 - y2)\\n                        min_area = min(min_area, area)\\n\\n        return 0 if min_area == float('inf') else min_area\\n\"",
  "3682_14631217_python-updated-time": "1747653240203",
  "1480_14631217_mysql": "\"-- 1) Find the user with the most distinct movie ratings (break ties by lexicographically smaller name)\\nWITH UserRatings AS (\\n  SELECT\\n    u.name,\\n    COUNT(*) AS cnt\\n  FROM MovieRating mr\\n  JOIN Users u\\n    ON mr.user_id = u.user_id\\n  GROUP BY u.user_id, u.name\\n),\\nTopUser AS (\\n  SELECT name\\n  FROM UserRatings\\n  ORDER BY cnt DESC, name ASC\\n  LIMIT 1\\n),\\n\\n-- 2) Find the movie with the highest average rating in February 2020 (break ties by lexicographically smaller title)\\nFebRatings AS (\\n  SELECT\\n    mr.movie_id,\\n    AVG(mr.rating) AS avg_rating\\n  FROM MovieRating mr\\n  WHERE mr.created_at BETWEEN '2020-02-01' AND '2020-02-29'\\n  GROUP BY mr.movie_id\\n),\\nTopMovie AS (\\n  SELECT\\n    m.title\\n  FROM FebRatings fr\\n  JOIN Movies m\\n    ON fr.movie_id = m.movie_id\\n  ORDER BY fr.avg_rating DESC, m.title ASC\\n  LIMIT 1\\n)\\n\\n-- Combine results into a single column\\nSELECT name    AS results FROM TopUser\\nUNION ALL\\nSELECT title   AS results FROM TopMovie;\\n\"",
  "1010_14631217_python": "\"class Solution:\\n    def powerfulIntegers(self, x, y, bound):\\n        result = set()\\n        i = 0\\n        while x ** i <= bound:\\n            j = 0\\n            while y ** j <= bound:\\n                val = x ** i + y ** j\\n                if val <= bound:\\n                    result.add(val)\\n                else:\\n                    break\\n                if y == 1:\\n                    break\\n                j += 1\\n            if x == 1:\\n                break\\n            i += 1\\n        return list(result)\\n\"",
  "1664_14631217_lang": "\"mysql\"",
  "3459_14631217_python-updated-time": "1747485906724",
  "3469_14631217_python-updated-time": "1747486191755",
  "80_14631217_python": "\"class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        insert_pos = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[insert_pos - 2]:\\n                nums[insert_pos] = nums[i]\\n                insert_pos += 1\\n\\n        return insert_pos\\n\"",
  "857_14631217_python-updated-time": "1745879305807",
  "1653_14631217_python-updated-time": "1746433953229",
  "407_14631217_python-updated-time": "1745356074765",
  "3415_14631217_python": "\"class Solution(object):\\n    def satisfiesConditions(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # Check equality with the cell below\\n                if i + 1 < m and grid[i][j] != grid[i + 1][j]:\\n                    return False\\n                # Check inequality with the cell to the right\\n                if j + 1 < n and grid[i][j] == grid[i][j + 1]:\\n                    return False\\n        \\n        return True\\n\"",
  "3617_14631217_python": "\"class Solution(object):\\n    def findAnswer(self, parent, s):\\n        \\\"\\\"\\\"\\n        :type parent: List[int]\\n        :type s: str\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        n = len(parent)\\n        # For the new problem: count possible original strings for final word\\n        # using at most one long-press event\\n    def possibleStringCount(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Compress the final word into groups of identical characters\\n        count = 1  # case with no long-press\\n        i = 0\\n        n = len(word)\\n        while i < n:\\n            j = i\\n            while j < n and word[j] == word[i]:\\n                j += 1\\n            f = j - i\\n            # if this group could be the long-pressed one (needs at least one extra char)\\n            if f >= 2:\\n                # intended group size can be from 1 to f-1\\n                count += f - 1\\n            i = j\\n        return count\"",
  "1987_14631217_python-updated-time": "1746626090661",
  "1024_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def countTriplets(self, nums):\\n        count = Counter()\\n        \\n        # Precompute all pairwise ANDs and their frequencies\\n        for a in nums:\\n            for b in nums:\\n                count[a & b] += 1\\n\\n        result = 0\\n        for k in nums:\\n            for val, freq in count.items():\\n                if val & k == 0:\\n                    result += freq\\n        return result\\n\"",
  "1726_14631217_python": "\"import math\\n\\nclass Solution:\\n    def bestCoordinate(self, towers, radius):\\n        # Precompute radius squared\\n        r2 = radius * radius\\n        \\n        # Find bounds for search\\n        max_x = max(x for x, y, q in towers)\\n        max_y = max(y for x, y, q in towers)\\n        \\n        best_q = -1\\n        best_x = 0\\n        best_y = 0\\n        \\n        # Scan all non-negative integer coords within [0..max_x+radius] x [0..max_y+radius]\\n        for x in range(max_x + radius + 1):\\n            for y in range(max_y + radius + 1):\\n                total = 0\\n                # Sum contributions from each tower\\n                for tx, ty, tq in towers:\\n                    dx = tx - x\\n                    dy = ty - y\\n                    d2 = dx*dx + dy*dy\\n                    if d2 <= r2:\\n                        d = math.sqrt(d2)\\n                        total += int(tq / (1 + d))\\n                # Update best if we found a strictly larger quality,\\n                # or same quality but lexicographically smaller coordinate\\n                if total > best_q or (total == best_q and (x < best_x or (x == best_x and y < best_y))):\\n                    best_q = total\\n                    best_x = x\\n                    best_y = y\\n        \\n        return [best_x, best_y]\\n\"",
  "200_14631217_python": "\"class Solution(object):\\n    def numIslands(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not grid:\\n            return 0\\n\\n        rows, cols = len(grid), len(grid[0])\\n        islands = 0\\n\\n        def dfs(r, c):\\n            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == \\\"0\\\":\\n                return\\n            grid[r][c] = \\\"0\\\"\\n            dfs(r + 1, c)\\n            dfs(r - 1, c)\\n            dfs(r, c + 1)\\n            dfs(r, c - 1)\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == \\\"1\\\":\\n                    islands += 1\\n                    dfs(r, c)\\n\\n        return islands\\n\"",
  "18_14631217_python-updated-time": "1744980805650",
  "2147_14631217_python": "\"class Solution(object):\\n    def scoreOfStudents(self, s, answers):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type answers: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def evaluate(expr):\\n            nums = []\\n            i = 0\\n            while i < len(expr):\\n                if expr[i].isdigit():\\n                    nums.append(int(expr[i]))\\n                elif expr[i] == '*':\\n                    a = nums.pop()\\n                    b = int(expr[i + 1])\\n                    nums.append(a * b)\\n                    i += 1\\n                elif expr[i] == '+':\\n                    nums.append('+')\\n                i += 1\\n            res = nums[0]\\n            i = 1\\n            while i < len(nums):\\n                if nums[i] == '+':\\n                    res += nums[i + 1]\\n                    i += 2\\n                else:\\n                    i += 1\\n            return res\\n\\n        # Tokenize\\n        tokens = []\\n        for ch in s:\\n            if ch.isdigit():\\n                tokens.append(int(ch))\\n            else:\\n                tokens.append(ch)\\n\\n        memo = {}\\n\\n        def dfs(l, r):\\n            key = (l, r)\\n            if key in memo:\\n                return memo[key]\\n            if l == r:\\n                return set([tokens[l]])\\n            results = set()\\n            for i in range(l + 1, r, 2):\\n                op = tokens[i]\\n                left = dfs(l, i - 1)\\n                right = dfs(i + 1, r)\\n                for a in left:\\n                    for b in right:\\n                        if op == '+':\\n                            val = a + b\\n                        else:\\n                            val = a * b\\n                        if 0 <= val <= 1000:\\n                            results.add(val)\\n            memo[key] = results\\n            return results\\n\\n        correct = evaluate(s)\\n        wrong_set = dfs(0, len(tokens) - 1)\\n        if correct in wrong_set:\\n            wrong_set.remove(correct)\\n\\n        score = 0\\n        for ans in answers:\\n            if ans == correct:\\n                score += 5\\n            elif ans in wrong_set:\\n                score += 2\\n        return score\\n\"",
  "144_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n\\n        while stack:\\n            node = stack.pop()\\n            output.append(node.val)\\n\\n            # Push right first so that left is processed first\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n\\n        return output\\n\"",
  "1443_14631217_python-updated-time": "1746261277594",
  "1239_14631217_python": "\"class Solution(object):\\n    def largest1BorderedSquare(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        # dp[i][j] = [horizontal 1s ending at (i,j), vertical 1s ending at (i,j)]\\n        hor = [[0]*n for _ in range(m)]\\n        ver = [[0]*n for _ in range(m)]\\n        max_side = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    hor[i][j] = hor[i][j-1] + 1 if j > 0 else 1\\n                    ver[i][j] = ver[i-1][j] + 1 if i > 0 else 1\\n\\n                    # Try to form the biggest square with (i,j) as bottom-right\\n                    small = min(hor[i][j], ver[i][j])\\n                    while small > 0:\\n                        if hor[i - small + 1][j] >= small and ver[i][j - small + 1] >= small:\\n                            max_side = max(max_side, small)\\n                            break\\n                        small -= 1\\n\\n        return max_side * max_side\\n\"",
  "1737_14631217_python": "\"class Solution:\\n    def maxDepth(self, s):\\n        depth = 0\\n        max_depth = 0\\n        for c in s:\\n            if c == '(':\\n                depth += 1\\n                if depth > max_depth:\\n                    max_depth = depth\\n            elif c == ')':\\n                depth -= 1\\n        return max_depth\\n\"",
  "3209_14631217_python-updated-time": "1747312574122",
  "1397_14631217_python-updated-time": "1746260021709",
  "1947_14631217_python-updated-time": "1746543854842",
  "2662_14631217_python": "\"class Solution(object):\\n    def checkValidGrid(self, grid):\\n        n = len(grid)\\n        total = n * n\\n        # record positions by move index\\n        pos = [None] * total\\n        for i in range(n):\\n            for j in range(n):\\n                idx = grid[i][j]\\n                pos[idx] = (i, j)\\n        # start at (0,0)\\n        if pos[0] != (0, 0):\\n            return False\\n        # knight moves\\n        for k in range(1, total):\\n            x1, y1 = pos[k-1]\\n            x2, y2 = pos[k]\\n            dx = abs(x1 - x2)\\n            dy = abs(y1 - y2)\\n            if not ((dx == 1 and dy == 2) or (dx == 2 and dy == 1)):\\n                return False\\n        return True\"",
  "1477_14631217_python-updated-time": "1746345101595",
  "1485_14631217_python-updated-time": "1746345446500",
  "3709_14631217_python": "\"class Solution(object):\\n    def hasSpecialSubstring(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        for i in range(n - k + 1):\\n            # Candidate window s[i:i+k]\\n            c = s[i]\\n            # 1) all k chars are c?\\n            if any(s[j] != c for j in range(i, i + k)):\\n                continue\\n            # 2) boundary checks\\n            if i > 0 and s[i - 1] == c:\\n                continue\\n            if i + k < n and s[i + k] == c:\\n                continue\\n            # found a valid special substring\\n            return True\\n        return False\\n\"",
  "3701_14631217_python": "\"import sys\\nclass Solution(object):\\n    def minCostGoodCaption(self, caption):\\n        n = len(caption)\\n        INF = sys.maxint  # Python2's large int\\n        # Compute prefix sums of cost to change to each char c\\n        # pre_c[c][i] = sum of cost to change caption[0..i-1] to 'a'+c\\n        pre_c = [[0]*(n+1) for _ in xrange(26)]\\n        for c in xrange(26):\\n            s = 0\\n            for i in xrange(n):\\n                s += abs(ord(caption[i]) - (ord('a') + c))\\n                pre_c[c][i+1] = s\\n\\n        # dp[i] = min cost to cover caption[0..i-1] with good blocks\\n        dp = [INF] * (n+1)\\n        dp[0] = 0\\n        # best[c] = min(dp[k] - pre_c[c][k]) for k <= i-3\\n        best = [INF] * 26\\n        best_k = [-1] * 26\\n        # For reconstruction\\n        prev = [-1] * (n+1)\\n        let = [-1] * (n+1)\\n\\n        for i in xrange(1, n+1):\\n            # At i, before computing dp[i], update bests from k = i-3\\n            k = i - 3\\n            if k >= 0:\\n                for c in xrange(26):\\n                    val = dp[k] - pre_c[c][k]\\n                    if val < best[c]:\\n                        best[c] = val\\n                        best_k[c] = k\\n            # Compute dp[i]\\n            dp_i = INF\\n            sel_c = -1\\n            sel_k = -1\\n            if i >= 3:\\n                for c in xrange(26):\\n                    # cost for a block (k..i-1) -> char c\\n                    v = best[c] + pre_c[c][i]\\n                    if v < dp_i:\\n                        dp_i = v\\n                        sel_c = c\\n                        sel_k = best_k[c]\\n            dp[i] = dp_i\\n            let[i] = sel_c\\n            prev[i] = sel_k\\n\\n        # If impossible, return empty\\n        if dp[n] >= INF:\\n            return \\\"\\\"\\n        # Reconstruct the string\\n        res = [''] * n\\n        i = n\\n        while i > 0:\\n            c = let[i]\\n            k = prev[i]\\n            # fill positions k..i-1 with char c\\n            for j in xrange(k, i):\\n                res[j] = chr(ord('a') + c)\\n            i = k\\n        return ''.join(res)\\n\"",
  "474_14631217_python": "\"class Solution:\\n    def findMaxForm(self, strs, m, n):\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for s in strs:\\n            zeros = s.count('0')\\n            ones = s.count('1')\\n            for i in range(m, zeros - 1, -1):\\n                for j in range(n, ones - 1, -1):\\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - zeros][j - ones])\\n\\n        return dp[m][n]\\n\"",
  "304_14631217_python-updated-time": "1745255723652",
  "3553_14631217_python-updated-time": "1747570456856",
  "3612_14631217_python": "\"class Solution(object):\\n    def hasIncreasingSubarrays(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        \\n        def is_strictly_increasing(start):\\n            for i in range(start + 1, start + k):\\n                if nums[i] <= nums[i - 1]:\\n                    return False\\n            return True\\n        \\n        for i in range(n - 2 * k + 1):\\n            if is_strictly_increasing(i) and is_strictly_increasing(i + k):\\n                return True\\n        \\n        return False\\n\"",
  "3399_14631217_python": "\"class Solution(object):\\n    def minimumAddedInteger(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        A = sorted(nums1)\\n        B = sorted(nums2)\\n        m = len(A)\\n        n = len(B)  # = m - 2\\n\\n        ans = float('inf')\\n        # Try removing A[i] and A[j]\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                x = None\\n                valid = True\\n                # walk through A skipping i,j\\n                t = 0  # index in B\\n                for k in range(m):\\n                    if k == i or k == j:\\n                        continue\\n                    diff = B[t] - A[k]\\n                    if x is None:\\n                        x = diff\\n                    elif diff != x:\\n                        valid = False\\n                        break\\n                    t += 1\\n                if valid:\\n                    ans = min(ans, x)\\n\\n        return ans\\n\"",
  "3629_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\n# Ensure gcd compatibility\\ntry:\\n    from math import gcd\\nexcept ImportError:\\n    from fractions import gcd\\n\\nclass Solution(object):\\n    def maxTravelScore(self, n, k, stayScore, travelScore):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type stayScore: List[List[int]]\\n        :type travelScore: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp_prev = [0] * n\\n        for day in range(k):\\n            dp_cur = [0] * n\\n            for dest in range(n):\\n                stay = dp_prev[dest] + stayScore[day][dest]\\n                max_travel = max(dp_prev[p] + travelScore[p][dest] for p in range(n))\\n                dp_cur[dest] = max(stay, max_travel)\\n            dp_prev = dp_cur\\n        return max(dp_prev)\\n\\n    def possibleStringCount(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        runs = []\\n        cur_char, cur_len = None, 0\\n        for c in word:\\n            if c == cur_char:\\n                cur_len += 1\\n            else:\\n                if cur_len:\\n                    runs.append(cur_len)\\n                cur_char, cur_len = c, 1\\n        if cur_len:\\n            runs.append(cur_len)\\n        m = len(runs)\\n        total = 1\\n        for Li in runs:\\n            total = total * Li % mod\\n        if m >= k:\\n            return total\\n        dp = [0] * k\\n        dp[0] = 1\\n        for Li in runs:\\n            prefix = [0] * k\\n            prefix[0] = dp[0]\\n            for i in range(1, k):\\n                prefix[i] = (prefix[i-1] + dp[i]) % mod\\n            new_dp = [0] * k\\n            for t_idx in range(1, k):\\n                a = prefix[t_idx-1]\\n                b = prefix[t_idx-1-Li] if t_idx-1-Li >= 0 else 0\\n                new_dp[t_idx] = (a - b) % mod\\n            dp = new_dp\\n        count_bad = sum(dp) % mod\\n        return (total - count_bad + mod) % mod\\n\\n    def maxScore(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def lcm(a, b):\\n            return a // gcd(a, b) * b\\n\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n\\n        prefix_g = [0] * n\\n        prefix_l = [0] * n\\n        suffix_g = [0] * n\\n        suffix_l = [0] * n\\n\\n        for i in range(n):\\n            if i == 0:\\n                prefix_g[i] = nums[i]\\n                prefix_l[i] = nums[i]\\n            else:\\n                prefix_g[i] = gcd(prefix_g[i-1], nums[i])\\n                prefix_l[i] = lcm(prefix_l[i-1], nums[i])\\n\\n        for i in range(n-1, -1, -1):\\n            if i == n-1:\\n                suffix_g[i] = nums[i]\\n                suffix_l[i] = nums[i]\\n            else:\\n                suffix_g[i] = gcd(suffix_g[i+1], nums[i])\\n                suffix_l[i] = lcm(suffix_l[i+1], nums[i])\\n\\n        max_score = prefix_g[n-1] * prefix_l[n-1]\\n\\n        for i in range(n):\\n            if n == 1:\\n                continue\\n            if i == 0:\\n                g = suffix_g[1]\\n                l = suffix_l[1]\\n            elif i == n-1:\\n                g = prefix_g[n-2]\\n                l = prefix_l[n-2]\\n            else:\\n                g = gcd(prefix_g[i-1], suffix_g[i+1])\\n                l = lcm(prefix_l[i-1], suffix_l[i+1])\\n            max_score = max(max_score, g * l)\\n\\n        return max_score\\n\\n    def lengthAfterTransformations(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        # dp[c] = length contribution of char c after current transformations\\n        # initialize for t=0: each char contributes 1\\n        dp = [1] * 26\\n        for _ in range(t):\\n            new_dp = [0] * 26\\n            # for 'a' to 'y', next char\\n            for i in range(25):\\n                new_dp[i] = dp[i+1]\\n            # for 'z', becomes 'a' + 'b'\\n            new_dp[25] = (dp[0] + dp[1]) % mod\\n            dp = new_dp\\n        # sum contributions for initial string\\n        result = 0\\n        for ch in s:\\n            result = (result + dp[ord(ch) - ord('a')]) % mod\\n        return result\"",
  "443_14631217_python-updated-time": "1745359017661",
  "822_14631217_python": "\"class Solution(object):\\n    def uniqueMorseRepresentations(self, words):\\n        morse = [\\\".-\\\",\\\"-...\\\",\\\"-.-.\\\",\\\"-..\\\",\\\".\\\",\\\"..-.\\\",\\\"--.\\\",\\\"....\\\",\\\"..\\\",\\n                 \\\".---\\\",\\\"-.-\\\",\\\".-..\\\",\\\"--\\\",\\\"-.\\\",\\\"---\\\",\\\".--.\\\",\\\"--.-\\\",\\\".-.\\\",\\n                 \\\"...\\\",\\\"-\\\",\\\"..-\\\",\\\"...-\\\",\\\".--\\\",\\\"-..-\\\",\\\"-.--\\\",\\\"--..\\\"]\\n        seen = set()\\n        for word in words:\\n            seen.add(''.join(morse[ord(c) - ord('a')] for c in word))\\n        return len(seen)\\n\"",
  "1500_14631217_python": "\"class Solution(object):\\n    def countLargestGroup(self, n):\\n        from collections import Counter\\n\\n        def digit_sum(x):\\n            return sum(int(d) for d in str(x))\\n\\n        count = Counter(digit_sum(i) for i in range(1, n + 1))\\n        max_size = max(count.values())\\n        return sum(1 for v in count.values() if v == max_size)\\n\"",
  "994_14631217_python": "\"class Solution:\\n    def prisonAfterNDays(self, cells, n):\\n        seen = {}\\n        is_cycle = False\\n\\n        while n > 0:\\n            state = tuple(cells)\\n            if state in seen:\\n                cycle_len = seen[state] - n\\n                n %= cycle_len\\n            else:\\n                seen[state] = n\\n\\n            if n == 0:\\n                break\\n\\n            n -= 1\\n            cells = [0] + [int(cells[i - 1] == cells[i + 1]) for i in range(1, 7)] + [0]\\n\\n        return cells\\n\"",
  "1111_14631217_python-updated-time": "1746042497359",
  "2174_14631217_python-updated-time": "1746720202858",
  "155_14631217_python-updated-time": "1745091169477",
  "3306_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def unmarkedSumArray(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Min-heap of all (value, index)\\n        heap = [(nums[i], i) for i in range(n)]\\n        heapq.heapify(heap)\\n        \\n        marked = [False] * n\\n        unmarked_sum = sum(nums)\\n        \\n        answer = []\\n        for idx, k in queries:\\n            # 1) Mark the specific index if unmarked\\n            if not marked[idx]:\\n                marked[idx] = True\\n                unmarked_sum -= nums[idx]\\n            # 2) Mark k smallest unmarked elements\\n            to_mark = k\\n            while to_mark > 0 and heap:\\n                v, i = heapq.heappop(heap)\\n                if marked[i]:\\n                    continue\\n                # mark it\\n                marked[i] = True\\n                unmarked_sum -= v\\n                to_mark -= 1\\n            # 3) Record current unmarked sum\\n            answer.append(unmarked_sum)\\n        \\n        return answer\\n\"",
  "2300_14631217_python": "\"from collections import Counter\\nimport heapq\\n\\nclass Solution:\\n    def repeatLimitedString(self, s, repeatLimit):\\n        count = Counter(s)\\n        max_heap = [(-ord(c), c, count[c]) for c in count]\\n        heapq.heapify(max_heap)\\n\\n        res = []\\n\\n        while max_heap:\\n            _, ch, freq = heapq.heappop(max_heap)\\n            use = min(freq, repeatLimit)\\n            res.append(ch * use)\\n            freq -= use\\n\\n            if freq > 0:\\n                if not max_heap:\\n                    break\\n                _, next_ch, next_freq = heapq.heappop(max_heap)\\n                res.append(next_ch)\\n                if next_freq > 1:\\n                    heapq.heappush(max_heap, (-ord(next_ch), next_ch, next_freq - 1))\\n                heapq.heappush(max_heap, (-ord(ch), ch, freq))\\n\\n        return ''.join(res)\\n\"",
  "1267_14631217_python": "\"class Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix_sum = 0\\n        seen = {}\\n\\n        # First pass: store the last occurrence of each prefix sum\\n        node = dummy\\n        while node:\\n            prefix_sum += node.val\\n            seen[prefix_sum] = node\\n            node = node.next\\n\\n        # Second pass: skip nodes between same prefix sums\\n        prefix_sum = 0\\n        node = dummy\\n        while node:\\n            prefix_sum += node.val\\n            node.next = seen[prefix_sum].next\\n            node = node.next\\n\\n        return dummy.next\"",
  "2183_14631217_python-updated-time": "1746720719738",
  "1041_14631217_python": "\"class Solution:\\n    def numRookCaptures(self, board):\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == 'R':\\n                    x, y = i, j\\n                    break\\n\\n        result = 0\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]  # up, down, left, right\\n\\n        for dx, dy in directions:\\n            nx, ny = x, y\\n            while 0 <= nx + dx < 8 and 0 <= ny + dy < 8:\\n                nx += dx\\n                ny += dy\\n                if board[nx][ny] == 'B':\\n                    break\\n                if board[nx][ny] == 'p':\\n                    result += 1\\n                    break\\n\\n        return result\\n\"",
  "2198_14631217_python-updated-time": "1746729231993",
  "2380_14631217_python": "\"import bisect\\n\\nclass BookMyShow:\\n    def __init__(self, n, m):\\n        self.n = n\\n        self.m = m\\n        # each row i has a list of free intervals [[l0,r0],[l1,r1],...]\\n        self.free = [[[0, m-1]] for _ in range(n)]\\n        # segment tree arrays\\n        size = 1\\n        while size < n: size <<= 1\\n        self.size = size\\n        # sum of free seats in segment\\n        self.segSum = [0] * (2*size)\\n        # max free-interval length in segment\\n        self.segMax = [0] * (2*size)\\n        \\n        # initialize leaves\\n        for i in range(n):\\n            length = m  # one interval [0,m-1]\\n            p = size + i\\n            self.segSum[p] = length\\n            self.segMax[p] = length\\n        # build internal nodes\\n        for p in range(size-1, 0, -1):\\n            self.segSum[p] = self.segSum[2*p] + self.segSum[2*p+1]\\n            self.segMax[p] = max(self.segMax[2*p], self.segMax[2*p+1])\\n    \\n    def _update_row(self, row):\\n        \\\"\\\"\\\"Recompute segSum and segMax at leaf row and push up.\\\"\\\"\\\"\\n        p = self.size + row\\n        total = 0\\n        mx = 0\\n        for l,r in self.free[row]:\\n            length = r - l + 1\\n            total += length\\n            if length > mx:\\n                mx = length\\n        self.segSum[p] = total\\n        self.segMax[p] = mx\\n        p //= 2\\n        while p:\\n            self.segSum[p] = self.segSum[2*p] + self.segSum[2*p+1]\\n            self.segMax[p] = max(self.segMax[2*p], self.segMax[2*p+1])\\n            p //= 2\\n    \\n    def _query_sum(self, row_lo, row_hi):\\n        \\\"\\\"\\\"Sum of free seats in [row_lo..row_hi].\\\"\\\"\\\"\\n        lo = row_lo + self.size\\n        hi = row_hi + self.size\\n        s = 0\\n        while lo <= hi:\\n            if lo & 1:\\n                s += self.segSum[lo]\\n                lo += 1\\n            if not (hi & 1):\\n                s += self.segSum[hi]\\n                hi -= 1\\n            lo //= 2\\n            hi //= 2\\n        return s\\n    \\n    def _find_first_max(self, k, row_lo, row_hi):\\n        \\\"\\\"\\\"\\n        Find the smallest row index in [row_lo..row_hi]\\n        whose segMax >= k. Return -1 if none.\\n        \\\"\\\"\\\"\\n        def dfs(p, start, end):\\n            if start > row_hi or end < row_lo or self.segMax[p] < k:\\n                return -1\\n            if start == end:\\n                return start\\n            mid = (start + end)//2\\n            res = dfs(2*p, start, mid)\\n            if res != -1:\\n                return res\\n            return dfs(2*p+1, mid+1, end)\\n        \\n        return dfs(1, 0, self.size-1)\\n    \\n    def _find_first_sum(self, row_lo, row_hi):\\n        \\\"\\\"\\\"\\n        Find smallest row in [row_lo..row_hi] with segSum >= 1.\\n        \\\"\\\"\\\"\\n        def dfs(p, start, end):\\n            if start > row_hi or end < row_lo or self.segSum[p] < 1:\\n                return -1\\n            if start == end:\\n                return start\\n            mid = (start + end)//2\\n            res = dfs(2*p, start, mid)\\n            if res != -1:\\n                return res\\n            return dfs(2*p+1, mid+1, end)\\n        \\n        return dfs(1, 0, self.size-1)\\n    \\n    def gather(self, k, maxRow):\\n        # find row with a free interval of length >= k\\n        row = self._find_first_max(k, 0, maxRow)\\n        if row == -1:\\n            return []\\n        # in that row, find the first interval with length >= k\\n        intervals = self.free[row]\\n        for idx, (l, r) in enumerate(intervals):\\n            length = r - l + 1\\n            if length >= k:\\n                start_seat = l\\n                # allocate [l, l+k-1]\\n                if length == k:\\n                    intervals.pop(idx)\\n                else:\\n                    intervals[idx][0] += k\\n                break\\n        \\n        # update segment tree for this row\\n        self._update_row(row)\\n        return [row, start_seat]\\n    \\n    def scatter(self, k, maxRow):\\n        # check total seats available\\n        available = self._query_sum(0, maxRow)\\n        if available < k:\\n            return False\\n        \\n        # allocate k seats greedily\\n        while k > 0:\\n            row = self._find_first_sum(0, maxRow)\\n            # there's guaranteed to be one\\n            intervals = self.free[row]\\n            l, r = intervals[0]\\n            length = r - l + 1\\n            take = min(length, k)\\n            # allocate [l, l+take-1]\\n            if length == take:\\n                intervals.pop(0)\\n            else:\\n                intervals[0][0] += take\\n            k -= take\\n            self._update_row(row)\\n        \\n        return True\\n\"",
  "68_14631217_python-updated-time": "1745014901784",
  "2156_14631217_python-updated-time": "1746719549857",
  "303_14631217_python-updated-time": "1745255670012",
  "69_14631217_python": "\"class Solution(object):\\n    def mySqrt(self, x):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if x < 2:\\n            return x\\n\\n        left, right = 1, x // 2\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return right\\n\"",
  "2882_14631217_python-updated-time": "1747222560692",
  "3325_14631217_python": "\"class Solution(object):\\n    def largestSquareArea(self, bottomLeft, topRight):\\n        \\\"\\\"\\\"\\n        :type bottomLeft: List[List[int]]\\n        :type topRight:   List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(bottomLeft)\\n        max_side = 0\\n        \\n        for i in range(n):\\n            x1_i, y1_i = bottomLeft[i]\\n            x2_i, y2_i = topRight[i]\\n            for j in range(i+1, n):\\n                x1_j, y1_j = bottomLeft[j]\\n                x2_j, y2_j = topRight[j]\\n                \\n                # intersection coords\\n                x_left   = max(x1_i, x1_j)\\n                y_bottom = max(y1_i, y1_j)\\n                x_right  = min(x2_i, x2_j)\\n                y_top    = min(y2_i, y2_j)\\n                \\n                w = x_right - x_left\\n                h = y_top   - y_bottom\\n                if w > 0 and h > 0:\\n                    max_side = max(max_side, min(w, h))\\n        \\n        return max_side * max_side\\n\"",
  "1218_14631217_python": "\"class Solution(object):\\n    def lcaDeepestLeaves(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        def dfs(node):\\n            if not node:\\n                return (0, None)\\n            left_depth, left_lca = dfs(node.left)\\n            right_depth, right_lca = dfs(node.right)\\n            if left_depth > right_depth:\\n                return (left_depth + 1, left_lca)\\n            elif right_depth > left_depth:\\n                return (right_depth + 1, right_lca)\\n            else:\\n                return (left_depth + 1, node)\\n\\n        return dfs(root)[1]\\n\"",
  "3761_14631217_python": "\"import sys\\n\\nclass Solution(object):\\n    def maxDifference(self, s, k):\\n        N = len(s)\\n        C = 5 # Characters '0' through '4'\\n\\n        # counts[char_code][prefix_len]: count of char_code in s[0...prefix_len-1]\\n        counts = [[0] * (N + 1) for _ in xrange(C)]\\n        # parity_masks_P[prefix_len]: parity mask for s[0...prefix_len-1]\\n        parity_masks_P = [0] * (N + 1) \\n\\n        # Base case for empty prefix (length 0): counts are 0, parity_mask is 0.\\n        # These are already initialized by Python's default list/int creation.\\n\\n        for i in xrange(N):\\n            char_code = int(s[i]) # Map '0'->0, '1'->1, ..., '4'->4\\n            \\n            # Copy counts from previous prefix length\\n            for c_idx in xrange(C):\\n                counts[c_idx][i+1] = counts[c_idx][i]\\n            \\n            counts[char_code][i+1] += 1 # Increment count for current character\\n            \\n            # Update parity mask for prefix of length i+1\\n            # P[i+1] = P[i] XOR (1 << char_code_of_s[i])\\n            parity_masks_P[i+1] = parity_masks_P[i] ^ (1 << char_code)\\n\\n        max_overall_diff = -N - 1 # Initialize with a value smaller than any possible valid difference\\n        found_any = False # To track if any valid substring satisfying conditions is found\\n\\n        for ca_idx in xrange(C):       # Index for character 'a'\\n            for cb_idx in xrange(C):   # Index for character 'b'\\n                if ca_idx == cb_idx:\\n                    continue\\n\\n                # min_val_for_parity_mask[mask] stores min(counts[ca_idx][j_l] - counts[cb_idx][j_l])\\n                # for prefixes s[0...j_l-1] (length j_l) having parity 'mask'.\\n                # Using a list of size 2^C as C is small and fixed.\\n                min_val_for_parity_mask = [sys.maxint] * (1 << C)\\n\\n                # j_r: length of prefix s[0...j_r-1]. Substring ends at s[j_r-1].\\n                # Smallest j_r for a substring of length k is k itself (substring s[0...k-1]).\\n                for j_r in xrange(k, N + 1):\\n                    # Current substring is s[j_l_start_idx ... j_r-1].\\n                    # Its length is (j_r-1) - j_l_start_idx + 1 = j_r - j_l_start_idx.\\n                    # The prefix corresponding to j_l_start_idx is s[0...j_l_start_idx-1], indexed by j_l_start_idx.\\n                    # Let j_l be the length of prefix s[0...j_l-1].\\n                    # Condition: length j_r - j_l >= k  =>  j_l <= j_r - k.\\n                    \\n                    # The prefix whose length is j_l_for_update = j_r - k becomes relevant.\\n                    # This is s[0...(j_r-k)-1].\\n                    j_l_for_update = j_r - k\\n                    \\n                    mask_at_j_l_update = parity_masks_P[j_l_for_update]\\n                    val_at_j_l_update = counts[ca_idx][j_l_for_update] - counts[cb_idx][j_l_for_update]\\n                    \\n                    if val_at_j_l_update < min_val_for_parity_mask[mask_at_j_l_update]:\\n                        min_val_for_parity_mask[mask_at_j_l_update] = val_at_j_l_update\\n                    \\n                    # Query using current P[j_r] and counts for prefix of length j_r\\n                    current_mask_j_r = parity_masks_P[j_r]\\n                    \\n                    # Target parity for P[j_l]_ca, for ca's freq in substring to be odd:\\n                    # (P[j_r]_ca ^ P[j_l]_ca) == 1  => P[j_l]_ca == (P[j_r]_ca ^ 1)\\n                    target_parity_P_j_l_ca = ((current_mask_j_r >> ca_idx) & 1) ^ 1\\n                    \\n                    # Target parity for P[j_l]_cb, for cb's freq in substring to be even:\\n                    # (P[j_r]_cb ^ P[j_l]_cb) == 0  => P[j_l]_cb == P[j_r]_cb\\n                    target_parity_P_j_l_cb = (current_mask_j_r >> cb_idx) & 1 # No ^0 needed\\n\\n                    current_val_at_j_r = counts[ca_idx][j_r] - counts[cb_idx][j_r]\\n\\n                    # Iterate over all possible_mask_j_l (0 to 2^C - 1)\\n                    for possible_mask_j_l in xrange(1 << C):\\n                        min_val_j_l = min_val_for_parity_mask[possible_mask_j_l]\\n                        if min_val_j_l == sys.maxint: # No prefix j_l seen with this mask for this (ca,cb) pair\\n                            continue\\n\\n                        # Extract parities of ca and cb from possible_mask_j_l\\n                        parity_P_j_l_ca = (possible_mask_j_l >> ca_idx) & 1\\n                        parity_P_j_l_cb = (possible_mask_j_l >> cb_idx) & 1\\n\\n                        if parity_P_j_l_ca == target_parity_P_j_l_ca and \\\\\\n                           parity_P_j_l_cb == target_parity_P_j_l_cb:\\n                            \\n                            # This P[j_l] is a valid candidate for left part of value calculation\\n                            diff = current_val_at_j_r - min_val_j_l\\n                            if not found_any or diff > max_overall_diff:\\n                                max_overall_diff = diff\\n                            found_any = True # Mark that at least one valid diff was computed\\n        \\n        # If no substring satisfied all conditions, max_overall_diff remains its initial -N-1.\\n        # The problem examples imply that valid negative results (like -1) are possible.\\n        # The problem constraint \\\"at least one substring has a character with an even frequency \\n        # and a character with an odd frequency\\\" might not guarantee this substring also meets length k.\\n        # So, found_any could theoretically be false. If this can happen, the specific return value\\n        # for \\\"not found\\\" would be needed from problem spec (e.g. 0, -1, or error).\\n        # Given typical contest styles, returning the calculated max_overall_diff (even if it's the initial -N-1)\\n        # is standard unless specified otherwise.\\n        return max_overall_diff\"",
  "959_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def threeSumMulti(self, arr, target):\\n        MOD = 10**9 + 7\\n        count = Counter(arr)\\n        keys = sorted(count)\\n        ans = 0\\n\\n        for i, x in enumerate(keys):\\n            for j, y in enumerate(keys[i:], i):\\n                z = target - x - y\\n                if z < y:\\n                    continue\\n                if z not in count:\\n                    continue\\n\\n                cx, cy, cz = count[x], count[y], count[z]\\n\\n                if x == y == z:\\n                    ans += cx * (cx - 1) * (cx - 2) // 6\\n                elif x == y != z:\\n                    ans += cx * (cx - 1) // 2 * cz\\n                elif x < y == z:\\n                    ans += cx * cy * (cy - 1) // 2\\n                elif x < y < z:\\n                    ans += cx * cy * cz\\n\\n                ans %= MOD\\n\\n        return ans\\n\"",
  "929_14631217_python-updated-time": "1746002112673",
  "100_14631217_python-updated-time": "1745080899498",
  "1859_14631217_python-updated-time": "1746530525727",
  "357_14631217_python-updated-time": "1745354233006",
  "3238_14631217_python-updated-time": "1747319130180",
  "934_14631217_python": "\"class Solution:\\n    def subarrayBitwiseORs(self, arr):\\n        res = set()\\n        cur = set()\\n        for num in arr:\\n            cur = {num | x for x in cur} | {num}\\n            res |= cur\\n        return len(res)\\n\"",
  "2415_14631217_python": "\"class Solution:\\n    def idealArrays(self, n, maxValue):\\n        MOD = 10**9 + 7\\n        \\n        # 1) Precompute divisors for each v in [1..maxValue]\\n        divisors = [[] for _ in range(maxValue+1)]\\n        for d in range(1, maxValue+1):\\n            for multiple in range(d, maxValue+1, d):\\n                divisors[multiple].append(d)\\n        \\n        # 2) Precompute factorials and inv factorials up to n\\n        fact = [1] * (n+1)\\n        inv_fact = [1] * (n+1)\\n        for i in range(1, n+1):\\n            fact[i] = fact[i-1] * i % MOD\\n        inv_fact[n] = pow(fact[n], MOD-2, MOD)\\n        for i in range(n, 0, -1):\\n            inv_fact[i-1] = inv_fact[i] * i % MOD\\n        \\n        def comb(a, b):\\n            # C(a, b) = 0 if b<0 or b>a\\n            if b < 0 or b > a:\\n                return 0\\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a-b] % MOD\\n        \\n        # 3) DP over chain-length k\\n        # f_cur[v] = # of divisor-chains of length k ending at v\\n        f_cur = [1] * (maxValue+1)\\n        sum_chains = [0] * (n+1)\\n        sum_chains[1] = maxValue\\n        \\n        max_k = 1\\n        for k in range(2, n+1):\\n            f_next = [0] * (maxValue+1)\\n            total_k = 0\\n            for v in range(1, maxValue+1):\\n                s = 0\\n                for u in divisors[v]:\\n                    if u == v:\\n                        break\\n                    s += f_cur[u]\\n                if s:\\n                    s %= MOD\\n                    f_next[v] = s\\n                    total_k += s\\n            total_k %= MOD\\n            if total_k == 0:\\n                break\\n            sum_chains[k] = total_k\\n            max_k = k\\n            f_cur = f_next\\n        \\n        # 4) Combine chains with placements\\n        ans = 0\\n        for k in range(1, max_k+1):\\n            ans = (ans + sum_chains[k] * comb(n-1, k-1)) % MOD\\n        \\n        return ans\\n\"",
  "2318_14631217_python": "\"class Solution(object):\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        self.maxScore = 0\\n        self.best = [0] * 12\\n\\n        def dfs(i, arrowsLeft, score, bob):\\n            if i == 12:\\n                if score > self.maxScore:\\n                    self.maxScore = score\\n                    self.best = bob[:]\\n                    self.best[0] += arrowsLeft  # put leftover arrows somewhere\\n                return\\n\\n            # Option 1: Bob tries to win this section\\n            need = aliceArrows[i] + 1\\n            if arrowsLeft >= need:\\n                bob[i] = need\\n                dfs(i + 1, arrowsLeft - need, score + i, bob)\\n                bob[i] = 0  # backtrack\\n\\n            # Option 2: Bob skips this section\\n            dfs(i + 1, arrowsLeft, score, bob)\\n\\n        dfs(0, numArrows, 0, [0] * 12)\\n        return self.best\\n\"",
  "2433_14631217_python": "\"class Solution:\\n    def bestHand(self, ranks, suits):\\n        # Check for Flush: all suits the same\\n        first_suit = suits[0]\\n        if all(s == first_suit for s in suits):\\n            return \\\"Flush\\\"\\n        \\n        # Count ranks\\n        count = {}\\n        for r in ranks:\\n            count[r] = count.get(r, 0) + 1\\n        \\n        # Three of a Kind?\\n        if any(c >= 3 for c in count.values()):\\n            return \\\"Three of a Kind\\\"\\n        \\n        # Pair?\\n        if any(c >= 2 for c in count.values()):\\n            return \\\"Pair\\\"\\n        \\n        # Otherwise\\n        return \\\"High Card\\\"\\n\"",
  "1062_14631217_python": "\"class Solution:\\n    def canThreePartsEqualSum(self, arr):\\n        total = sum(arr)\\n        if total % 3 != 0:\\n            return False\\n\\n        target = total // 3\\n        count, curr_sum = 0, 0\\n\\n        for num in arr:\\n            curr_sum += num\\n            if curr_sum == target:\\n                count += 1\\n                curr_sum = 0\\n\\n        return count >= 3\\n\"",
  "1605_14631217_python": "\"class Solution(object):\\n    def minDays(self, bloomDay, m, k):\\n        \\\"\\\"\\\"\\n        :type bloomDay: List[int]\\n        :type m: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(bloomDay)\\n        if m * k > n:\\n            return -1  # Not enough flowers\\n\\n        def canMake(day):\\n            bouquets = 0\\n            flowers = 0\\n            for bloom in bloomDay:\\n                if bloom <= day:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquets += 1\\n                        flowers = 0\\n                else:\\n                    flowers = 0\\n            return bouquets >= m\\n\\n        low, high = min(bloomDay), max(bloomDay)\\n        result = -1\\n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if canMake(mid):\\n                result = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        return result\\n\"",
  "2756_14631217_python-updated-time": "1747139836389",
  "3317_14631217_python": "\"class Solution(object):\\n    def maxPalindromesAfterOperations(self, words):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        # 1) Count total pairs available in the global pool of letters\\n        total_counts = Counter()\\n        for w in words:\\n            total_counts.update(w)\\n        total_pairs = sum(v // 2 for v in total_counts.values())\\n\\n        # 2) For each word, compute how many pairs it needs to become a palindrome\\n        #    A palindrome of length L requires floor(L/2) matching pairs\\n        needed_pairs = [len(w) // 2 for w in words]\\n\\n        # 3) Greedily take words needing the fewest pairs first\\n        needed_pairs.sort()\\n        used = 0\\n        count = 0\\n        for need in needed_pairs:\\n            if used + need <= total_pairs:\\n                used += need\\n                count += 1\\n            else:\\n                break\\n\\n        return count\\n\"",
  "3208_14631217_python": "\"from collections import defaultdict\\nimport math\\n\\nclass Solution:\\n    def beautifulSubstrings(self, s, k):\\n        # 1) compute g = ∏ p^{ceil(e/2)} for k's prime factorization\\n        g = 1\\n        temp = k\\n        p = 2\\n        while p * p <= temp:\\n            if temp % p == 0:\\n                e = 0\\n                while temp % p == 0:\\n                    temp //= p\\n                    e += 1\\n                g *= p ** ((e + 1) // 2)\\n            p += 1\\n        if temp > 1:\\n            # remaining prime factor\\n            g *= temp\\n\\n        # 2) scan prefixes\\n        freq = defaultdict(int)\\n        D = 0    # vowel_count - consonant_count\\n        V = 0    # vowel count\\n        # empty prefix at position 0:\\n        freq[(0, 0)] = 1\\n\\n        res = 0\\n        vowels = set('aeiou')\\n\\n        for ch in s:\\n            if ch in vowels:\\n                V += 1\\n                D += 1\\n            else:\\n                D -= 1\\n\\n            r = V % g\\n            # all previous prefixes with same (D, r) form valid substrings\\n            res += freq[(D, r)]\\n            freq[(D, r)] += 1\\n\\n        return res\\n\"",
  "92_14631217_python-updated-time": "1745015677505",
  "168_14631217_python-updated-time": "1745091509883",
  "86_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :type x: int\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        before = ListNode(0)\\n        after = ListNode(0)\\n        before_head = before\\n        after_head = after\\n\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n\\n        after.next = None\\n        before.next = after_head.next\\n\\n        return before_head.next\\n\"",
  "1248_14631217_python-updated-time": "1746125808810",
  "672_14631217_python": "\"class Solution(object):\\n    def flipLights(self, n, presses):\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            return 3 if presses == 1 else 4\\n        if presses == 1:\\n            return 4\\n        if presses == 2:\\n            return 7\\n        return 8\\n\"",
  "2747_14631217_javascript-updated-time": "1747135717718",
  "811_14631217_python": "\"class Solution(object):\\n    def numSubarrayBoundedMax(self, nums, left, right):\\n        res = 0\\n        prev_count = 0\\n        j = 0\\n        \\n        for i in range(len(nums)):\\n            if left <= nums[i] <= right:\\n                prev_count = i - j + 1\\n                res += prev_count\\n            elif nums[i] < left:\\n                res += prev_count\\n            else:\\n                prev_count = 0\\n                j = i + 1\\n        \\n        return res\\n\"",
  "2884_14631217_python-updated-time": "1747222449026",
  "3616_14631217_python": "\"class Solution(object):\\n    def countValidSelections(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        res = 0\\n\\n        for start in range(n):\\n            if nums[start] != 0:\\n                continue\\n            for direction in (-1, 1):\\n                arr = nums[:]      # copy\\n                curr = start\\n                d = direction\\n                # simulate until we step out of [0..n-1]\\n                while 0 <= curr < n:\\n                    if arr[curr] == 0:\\n                        curr += d\\n                    else:\\n                        # decrement, reverse, and step\\n                        arr[curr] -= 1\\n                        d = -d\\n                        curr += d\\n                # after exiting, check if all zero\\n                if all(v == 0 for v in arr):\\n                    res += 1\\n\\n        return res\\n\"",
  "2602_14631217_python": "\"class Solution:\\n    def captureForts(self, forts):\\n        max_captured = 0\\n        n = len(forts)\\n        prev = -1\\n\\n        for i in range(n):\\n            if forts[i] != 0:\\n                if prev != -1 and forts[i] != forts[prev]:\\n                    max_captured = max(max_captured, i - prev - 1)\\n                prev = i\\n\\n        return max_captured\\n\"",
  "807_14631217_python": "\"class Solution(object):\\n    def customSortString(self, order, s):\\n        count = {}\\n        for ch in s:\\n            count[ch] = count.get(ch, 0) + 1\\n        \\n        res = []\\n        for ch in order:\\n            if ch in count:\\n                res.append(ch * count[ch])\\n                del count[ch]\\n        \\n        for ch in count:\\n            res.append(ch * count[ch])\\n        \\n        return ''.join(res)\\n\"",
  "3338_14631217_python-updated-time": "1747420254305",
  "630_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def scheduleCourse(self, courses):\\n        courses.sort(key=lambda x: x[1])\\n        heap = []\\n        total = 0\\n        \\n        for duration, lastDay in courses:\\n            total += duration\\n            heapq.heappush(heap, -duration)\\n            if total > lastDay:\\n                total += heapq.heappop(heap)\\n                \\n        return len(heap)\\n\"",
  "3189_14631217_python-updated-time": "1747309801031",
  "2641_14631217_python-updated-time": "1747064968106",
  "1452_14631217_mysql": "\"WITH daily AS (\\n  SELECT\\n    visited_on,\\n    SUM(amount) AS daily_amount,\\n    ROW_NUMBER() OVER (ORDER BY visited_on) AS rn,\\n    SUM(SUM(amount)) OVER (\\n      ORDER BY visited_on\\n      ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\\n    ) AS window_sum\\n  FROM Customer\\n  GROUP BY visited_on\\n)\\nSELECT\\n  visited_on,\\n  window_sum    AS amount,\\n  ROUND(window_sum / 7.0, 2) AS average_amount\\nFROM daily\\nWHERE rn >= 7\\nORDER BY visited_on;\\n\"",
  "3771_14631217_python-updated-time": "1747739161217",
  "113_14631217_python-updated-time": "1745081327886",
  "1263_14631217_python": "\"class Solution(object):\\n    def numRollsToTarget(self, n, k, target):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        memo = {}\\n\\n        def dp(dice, total):\\n            if dice == 0:\\n                return 1 if total == 0 else 0\\n            if total < 0:\\n                return 0\\n            if (dice, total) in memo:\\n                return memo[(dice, total)]\\n\\n            res = 0\\n            for face in range(1, k + 1):\\n                res = (res + dp(dice - 1, total - face)) % MOD\\n\\n            memo[(dice, total)] = res\\n            return res\\n\\n        return dp(n, target)\\n\"",
  "1034_14631217_python-updated-time": "1746040621674",
  "566_14631217_python": "\"class Solution(object):\\n    def matrixReshape(self, mat, r, c):\\n        m = len(mat)\\n        n = len(mat[0]) if mat else 0\\n        # if the total number of elements doesn't match, return original\\n        if m * n != r * c:\\n            return mat\\n        # flatten in row-traversing order\\n        flat = []\\n        for row in mat:\\n            for num in row:\\n                flat.append(num)\\n        # build the reshaped matrix\\n        res = []\\n        for i in range(r):\\n            res.append(flat[i * c:(i + 1) * c])\\n        return res\\n\"",
  "2132_14631217_python-updated-time": "1746719389544",
  "1777_14631217_python-updated-time": "1746445451852",
  "2450_14631217_python-updated-time": "1746964759449",
  "3081_14631217_python-updated-time": "1747227278032",
  "2178_14631217_python": "\"class Robot:\\n    def __init__(self, width, height):\\n        \\\"\\\"\\\"\\n        Pre-compute the perimeter cycle.\\n        After the first move, the robot keeps looping over this cycle:\\n          length L = 2*width + 2*height − 4\\n        \\\"\\\"\\\"\\n        self.cycle = []\\n\\n        # 1) bottom edge, going East\\n        for x in range(1, width):\\n            self.cycle.append((x, 0, \\\"East\\\"))\\n\\n        # 2) right edge, going North\\n        for y in range(1, height):\\n            self.cycle.append((width - 1, y, \\\"North\\\"))\\n\\n        # 3) top edge, going West\\n        for x in range(width - 2, -1, -1):\\n            self.cycle.append((x, height - 1, \\\"West\\\"))\\n\\n        # 4) left edge, going South\\n        for y in range(height - 2, -1, -1):\\n            self.cycle.append((0, y, \\\"South\\\"))\\n\\n        self.L = len(self.cycle)      # perimeter length\\n        self.t = 0                    # total steps taken so far\\n\\n    # ----------------------------------------------------------\\n\\n    def step(self, num):\\n        \\\"\\\"\\\"Move forward num steps.\\\"\\\"\\\"\\n        self.t += num                 # just accumulate — Python int is unbounded\\n\\n    # ----------------------------------------------------------\\n\\n    def getPos(self):\\n        \\\"\\\"\\\"Return [x, y] of current cell.\\\"\\\"\\\"\\n        if self.t == 0:\\n            return [0, 0]             # still at the start\\n        x, y, _ = self.cycle[(self.t - 1) % self.L]\\n        return [x, y]\\n\\n    # ----------------------------------------------------------\\n\\n    def getDir(self):\\n        \\\"\\\"\\\"Return current facing direction.\\\"\\\"\\\"\\n        if self.t == 0:\\n            return \\\"East\\\"\\n        return self.cycle[(self.t - 1) % self.L][2]\\n\"",
  "3750_14631217_python-updated-time": "1747682708065",
  "572_14631217_python-updated-time": "1745447877703",
  "105_14631217_python-updated-time": "1745081096523",
  "945_14631217_python": "\"class Solution:\\n    def snakesAndLadders(self, board):\\n        n = len(board)\\n        \\n        def label_to_pos(s):\\n            quot, rem = divmod(s - 1, n)\\n            row = n - 1 - quot\\n            if quot % 2 == 0:\\n                col = rem\\n            else:\\n                col = n - 1 - rem\\n            return row, col\\n        \\n        from collections import deque\\n        visited = set([1])\\n        q = deque([(1, 0)])  # (square, moves)\\n        \\n        while q:\\n            s, moves = q.popleft()\\n            if s == n * n:\\n                return moves\\n            for s2 in range(s + 1, min(s + 6, n * n) + 1):\\n                r, c = label_to_pos(s2)\\n                dest = board[r][c] if board[r][c] != -1 else s2\\n                if dest not in visited:\\n                    visited.add(dest)\\n                    q.append((dest, moves + 1))\\n        return -1\\n\"",
  "2894_14631217_python-updated-time": "1747225268272",
  "3380_14631217_python": "\"class Solution(object):\\n    def minimumSubarrayLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # If k == 0, any nonempty subarray has OR >= 0\\n        if k == 0:\\n            return 1\\n        \\n        # bit‐counts in current window [L..R]\\n        count = [0] * 31\\n        OR_cur = 0\\n        best = float('inf')\\n        L = 0\\n        \\n        for R, v in enumerate(nums):\\n            # Add nums[R]\\n            for b in range(31):\\n                if (v >> b) & 1:\\n                    if count[b] == 0:\\n                        OR_cur |= (1 << b)\\n                    count[b] += 1\\n            \\n            # Try to shrink from left while OR_cur >= k\\n            while L <= R and OR_cur >= k:\\n                # Can we drop nums[L]?\\n                vL = nums[L]\\n                # simulate flipping off bits that would go to zero\\n                new_or = OR_cur\\n                for b in range(31):\\n                    if (vL >> b) & 1 and count[b] == 1:\\n                        new_or ^= (1 << b)\\n                if new_or >= k:\\n                    # actually drop it\\n                    for b in range(31):\\n                        if (vL >> b) & 1:\\n                            count[b] -= 1\\n                            if count[b] == 0:\\n                                OR_cur ^= (1 << b)\\n                    L += 1\\n                else:\\n                    break\\n            \\n            # After shrinking, if OR_cur >= k record length\\n            if OR_cur >= k:\\n                best = min(best, R - L + 1)\\n        \\n        return best if best != float('inf') else -1\\n\"",
  "3093_14631217_python": "\"class Solution(object):\\n    def sumIndicesWithKSetBits(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return sum(num for i, num in enumerate(nums) if bin(i).count('1') == k)\\n\"",
  "2538_14631217_python-updated-time": "1746968237604",
  "140_14631217_python": "\"class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        word_set = set(wordDict)\\n        memo = {}\\n\\n        def dfs(start):\\n            if start == len(s):\\n                return [\\\"\\\"]  # Return list with empty string to start joining words\\n\\n            if start in memo:\\n                return memo[start]\\n\\n            sentences = []\\n\\n            for end in range(start + 1, len(s) + 1):\\n                word = s[start:end]\\n                if word in word_set:\\n                    for subsentence in dfs(end):\\n                        if subsentence:\\n                            sentences.append(word + \\\" \\\" + subsentence)\\n                        else:\\n                            sentences.append(word)\\n\\n            memo[start] = sentences\\n            return sentences\\n\\n        return dfs(0)\\n\"",
  "2300_14631217_python-updated-time": "1746803611902",
  "668_14631217_python-updated-time": "1745783216375",
  "2163_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def kthDistinct(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[str]\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Count how many times each string appears\\n        cnt = Counter(arr)\\n        \\n        # Iterate in original order, picking those with count==1\\n        distinct_seen = 0\\n        for s in arr:\\n            if cnt[s] == 1:\\n                distinct_seen += 1\\n                if distinct_seen == k:\\n                    return s\\n        \\n        # If fewer than k distinct strings, return empty\\n        return \\\"\\\"\\n\"",
  "624_14631217_python": "\"class Solution(object):\\n    def maxDistance(self, arrays):\\n        min_val = arrays[0][0]\\n        max_val = arrays[0][-1]\\n        result = 0\\n        for i in range(1, len(arrays)):\\n            result = max(result, abs(arrays[i][-1] - min_val), abs(max_val - arrays[i][0]))\\n            min_val = min(min_val, arrays[i][0])\\n            max_val = max(max_val, arrays[i][-1])\\n        return result\\n\"",
  "3142_14631217_python-updated-time": "1747307505318",
  "367_14631217_python-updated-time": "1745354465113",
  "599_14631217_python": "\"class Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \\\"\\\"\\\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        # Map each string in list1 to its index\\n        index_map = {s: i for i, s in enumerate(list1)}\\n        best_sum = float('inf')\\n        result = []\\n        \\n        # Iterate through list2 and look for common strings\\n        for j, s in enumerate(list2):\\n            if s in index_map:\\n                i = index_map[s]\\n                idx_sum = i + j\\n                # Found a smaller index sum: reset result\\n                if idx_sum < best_sum:\\n                    best_sum = idx_sum\\n                    result = [s]\\n                # Found an equal index sum: append to result\\n                elif idx_sum == best_sum:\\n                    result.append(s)\\n        \\n        return result\\n\"",
  "3869_14631217_python-updated-time": "1747681928964",
  "670_14631217_python": "\"class Solution(object):\\n    def maximumSwap(self, num):\\n        num = list(str(num))\\n        last = {int(x): i for i, x in enumerate(num)}\\n        \\n        for i, x in enumerate(num):\\n            for d in range(9, int(x), -1):\\n                if last.get(d, -1) > i:\\n                    num[i], num[last[d]] = num[last[d]], num[i]\\n                    return int(''.join(num))\\n        \\n        return int(''.join(num))\\n\"",
  "866_14631217_python-updated-time": "1745879478985",
  "1955_14631217_python-updated-time": "1746544561713",
  "2125_14631217_python-updated-time": "1746717477172",
  "3544_14631217_python": "\"class Solution:\\n    def countPairs(self, nums):\\n        # frequency of each number\\n        freq = {}\\n        for x in nums:\\n            freq[x] = freq.get(x, 0) + 1\\n\\n        vals = list(freq.keys())\\n        U = len(vals)\\n        idx = {v: i for i, v in enumerate(vals)}\\n        f = [freq[v] for v in vals]\\n\\n        # count identical pairs\\n        ans = 0\\n        for c in f:\\n            ans += c * (c - 1) // 2\\n\\n        # prepare digit lists\\n        s_list = [list(str(v)) for v in vals]\\n\\n        # directed neighbors in 1 swap\\n        d1 = [set() for _ in range(U)]\\n        for u in range(U):\\n            s = s_list[u]\\n            L = len(s)\\n            orig = vals[u]\\n            for i in range(L):\\n                for j in range(i + 1, L):\\n                    t = s[:]\\n                    t[i], t[j] = t[j], t[i]\\n                    w = int(''.join(t))\\n                    if w != orig and w in idx:\\n                        d1[u].add(idx[w])\\n\\n        # directed neighbors in exactly 2 swaps (excluding d1 and self)\\n        d2 = [set() for _ in range(U)]\\n        for u in range(U):\\n            s = s_list[u]\\n            L = len(s)\\n            orig = vals[u]\\n            seen = set()\\n            for i1 in range(L):\\n                for j1 in range(i1 + 1, L):\\n                    t1 = s[:]\\n                    t1[i1], t1[j1] = t1[j1], t1[i1]\\n                    for i2 in range(L):\\n                        for j2 in range(i2 + 1, L):\\n                            t2 = t1[:]\\n                            t2[i2], t2[j2] = t2[j2], t2[i2]\\n                            w = int(''.join(t2))\\n                            if w != orig and w not in seen:\\n                                seen.add(w)\\n                                v = idx.get(w)\\n                                if v is not None and v not in d1[u]:\\n                                    d2[u].add(v)\\n\\n        # symmetrize to undirected adjacency\\n        d1u = [set() for _ in range(U)]\\n        d2u = [set() for _ in range(U)]\\n        for u in range(U):\\n            for v in d1[u]:\\n                d1u[u].add(v)\\n                d1u[v].add(u)\\n            for v in d2[u]:\\n                d2u[u].add(v)\\n                d2u[v].add(u)\\n\\n        # count one-swap and two-swap pairs\\n        for u in range(U):\\n            cu = f[u]\\n            for v in d1u[u]:\\n                if u < v:\\n                    ans += cu * f[v]\\n            for v in d2u[u]:\\n                if u < v:\\n                    ans += cu * f[v]\\n\\n        return ans\\n\"",
  "3154_14631217_python": "\"class Solution(object):\\n    def maximumTripletValue(self, nums):\\n        n = len(nums)\\n        res = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                diff = nums[i] - nums[j]\\n                if diff <= 0:\\n                    continue\\n                for k in range(j+1, n):\\n                    val = diff * nums[k]\\n                    if val > res:\\n                        res = val\\n        return res\"",
  "1542_14631217_python-updated-time": "1746347525743",
  "194_14631217_bash": "\"# Read from the file file.txt and print its transposed content to stdout.\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i] = (NR == 1 ? $i : a[i] \\\" \\\" $i)\\n    }\\n}\\nEND {\\n    for (i = 1; i <= length(a); i++) {\\n        print a[i]\\n    }\\n}\\n' file.txt\\n\"",
  "3171_14631217_python": "\"class Solution(object):\\n    def minSum(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        s1 = sum(x for x in nums1 if x != 0)\\n        n1 = nums1.count(0)\\n        s2 = sum(x for x in nums2 if x != 0)\\n        n2 = nums2.count(0)\\n\\n        # The smallest target sum S must satisfy:\\n        #   S >= s1 + n1  (so nums1's zeros can sum to S - s1 >= n1*1)\\n        #   S >= s2 + n2\\n        S = max(s1 + n1, s2 + n2)\\n\\n        # Check feasibility: if an array has no zeros, its sum must already equal S.\\n        if (n1 > 0 or s1 == S) and (n2 > 0 or s2 == S):\\n            return S\\n        return -1\\n\"",
  "2478_14631217_python": "\"class Solution:\\n    def longestNiceSubarray(self, nums):\\n        l = 0\\n        curr = 0\\n        ans = 1\\n        for r, x in enumerate(nums):\\n            # If x conflicts with current window, shrink from left\\n            while (curr & x) != 0:\\n                curr ^= nums[l]\\n                l += 1\\n            # Add x into window\\n            curr |= x\\n            ans = max(ans, r - l + 1)\\n        return ans\\n\"",
  "2151_14631217_python-updated-time": "1746719886620",
  "1769_14631217_python": "\"class Solution:\\n    def getMaximumGenerated(self, n):\\n        if n == 0:\\n            return 0\\n        nums = [0] * (n + 1)\\n        nums[1] = 1\\n        maximum = 1\\n        for i in range(2, n + 1):\\n            if i % 2 == 0:\\n                nums[i] = nums[i // 2]\\n            else:\\n                nums[i] = nums[i // 2] + nums[i // 2 + 1]\\n            if nums[i] > maximum:\\n                maximum = nums[i]\\n        return maximum\\n\"",
  "1516_14631217_python-updated-time": "1746346795685",
  "2048_14631217_python-updated-time": "1746637493474",
  "1276_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def closestDivisors(self, num):\\n        def find_closest(n):\\n            for i in range(int(math.sqrt(n)), 0, -1):\\n                if n % i == 0:\\n                    return [i, n // i]\\n            return []\\n\\n        res1 = find_closest(num + 1)\\n        res2 = find_closest(num + 2)\\n        return res1 if abs(res1[0] - res1[1]) <= abs(res2[0] - res2[1]) else res2\\n\"",
  "2902_14631217_python-updated-time": "1747225298608",
  "318_14631217_python-updated-time": "1745256128531",
  "3386_14631217_python-updated-time": "1747424183594",
  "670_14631217_python-updated-time": "1745783260237",
  "3612_14631217_python-updated-time": "1747587551101",
  "3555_14631217_python": "\"class Solution(object):\\n    def getFinalState(self, nums, k, multiplier):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type multiplier: int\\n        :rtype: List[int]\\n        Perform k operations: each time find the first minimum element and multiply it.\\n        \\\"\\\"\\\"\\n        # Copy list to avoid mutating input\\n        arr = list(nums)\\n        n = len(arr)\\n        for _ in range(k):\\n            # Find index of first minimum\\n            min_val = arr[0]\\n            min_idx = 0\\n            for i in range(1, n):\\n                if arr[i] < min_val:\\n                    min_val = arr[i]\\n                    min_idx = i\\n            # Multiply\\n            arr[min_idx] = arr[min_idx] * multiplier\\n        return arr\"",
  "805_14631217_python-updated-time": "1745877710197",
  "3722_14631217_python-updated-time": "1747682459737",
  "292_14631217_python-updated-time": "1745255039724",
  "1633_14631217_python-updated-time": "1746433850738",
  "2919_14631217_python-updated-time": "1747223513125",
  "3412_14631217_python-updated-time": "1747481614817",
  "3438_14631217_python": "\"class Fenwick:\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0]*(n+1)\\n    def add(self, i, v):\\n        # add v at index i (0-based)\\n        i += 1\\n        while i <= self.n:\\n            self.fw[i] += v\\n            i += i & -i\\n    def sum(self, i):\\n        # sum[0..i] inclusive, i may be -1\\n        i += 1\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n    def range_sum(self, l, r):\\n        if l > r: return 0\\n        return self.sum(r) - self.sum(l-1)\\n\\nclass Solution(object):\\n    def countOfPeaks(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # 1) build initial peak[] and Fenwick\\n        peak = [0]*n\\n        fw = Fenwick(n)\\n        for i in range(1, n-1):\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\n                peak[i] = 1\\n                fw.add(i, 1)\\n\\n        ans = []\\n        for typ, x, y in queries:\\n            if typ == 1:\\n                l, r = x, y\\n                # peaks can only occur at i in [l+1..r-1]\\n                if r - l < 2:\\n                    ans.append(0)\\n                else:\\n                    ans.append(fw.range_sum(l+1, r-1))\\n            else:\\n                idx, val = x, y\\n                nums[idx] = val\\n                # recheck positions idx-1, idx, idx+1\\n                for i in (idx-1, idx, idx+1):\\n                    if 1 <= i < n-1:\\n                        newp = 1 if (nums[i] > nums[i-1] and nums[i] > nums[i+1]) else 0\\n                        if newp != peak[i]:\\n                            fw.add(i, newp - peak[i])\\n                            peak[i] = newp\\n\\n        return ans\\n\"",
  "2707_14631217_python-updated-time": "1747065731854",
  "279_14631217_python": "\"class Solution(object):\\n    def numSquares(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [float('inf')] * (n + 1)\\n        dp[0] = 0\\n        for i in range(1, n + 1):\\n            j = 1\\n            while j * j <= i:\\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\\n                j += 1\\n        return dp[n]\\n\"",
  "3225_14631217_python": "\"class Solution(object):\\n    def maxSubarrayLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n        \\n        freq = defaultdict(int)\\n        left = 0\\n        max_len = 0\\n        \\n        for right, x in enumerate(nums):\\n            freq[x] += 1\\n            # If x exceeds k, shrink from left until freq[x] <= k\\n            while freq[x] > k:\\n                freq[nums[left]] -= 1\\n                left += 1\\n            # Now window [left..right] is good\\n            max_len = max(max_len, right - left + 1)\\n        \\n        return max_len\\n\"",
  "114_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def flatten(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \\\"\\\"\\\"\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                prev = curr.left\\n                while prev.right:\\n                    prev = prev.right\\n                prev.right = curr.right\\n                curr.right = curr.left\\n                curr.left = None\\n            curr = curr.right\\n\"",
  "2033_14631217_python": "\"class Solution:\\n    def numberOfRounds(self, loginTime, logoutTime):\\n        def to_minutes(t):\\n            h, m = map(int, t.split(\\\":\\\"))\\n            return h * 60 + m\\n\\n        start = to_minutes(loginTime)\\n        end = to_minutes(logoutTime)\\n\\n        if end < start:\\n            end += 24 * 60  # next day\\n\\n        # round up start to the next 15-minute mark\\n        if start % 15 != 0:\\n            start += 15 - (start % 15)\\n        # round down end to the previous 15-minute mark\\n        end -= end % 15\\n\\n        return max(0, (end - start) // 15)\\n\"",
  "315_14631217_python": "\"class Solution(object):\\n    def countSmaller(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        counts = [0] * len(nums)\\n        indexed_nums = list(enumerate(nums))\\n        \\n        def merge_sort(enum):\\n            mid = len(enum) // 2\\n            if mid:\\n                left, right = merge_sort(enum[:mid]), merge_sort(enum[mid:])\\n                m, n = len(left), len(right)\\n                i = j = 0\\n                sorted_enum = []\\n                while i < m or j < n:\\n                    if j == n or (i < m and left[i][1] <= right[j][1]):\\n                        counts[left[i][0]] += j\\n                        sorted_enum.append(left[i])\\n                        i += 1\\n                    else:\\n                        sorted_enum.append(right[j])\\n                        j += 1\\n                return sorted_enum\\n            else:\\n                return enum\\n        \\n        merge_sort(indexed_nums)\\n        return counts\\n\"",
  "3557_14631217_python": "\"class Solution(object):\\n    def minValidStrings(self, words, target):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(target)\\n        # 1) rolling‐hash parameters\\n        mod1, mod2 = 10**9+7, 10**9+9\\n        base1, base2 = 91138233, 97266353\\n\\n        # 2) determine max prefix length we care about\\n        max_w = 0\\n        for w in words:\\n            if len(w) > max_w:\\n                max_w = len(w)\\n        max_pref = min(max_w, n)\\n        if max_pref == 0:\\n            # If all words are empty or target empty (target nonempty by constraints),\\n            # we can’t match any nonempty prefix → impossible\\n            return -1\\n\\n        # 3) precompute powers up to max_pref\\n        p1 = [1] * (max_pref + 1)\\n        p2 = [1] * (max_pref + 1)\\n        for i in range(max_pref):\\n            p1[i+1] = (p1[i] * base1) % mod1\\n            p2[i+1] = (p2[i] * base2) % mod2\\n\\n        # 4) build a list of sets: prefix_hash_sets[ℓ] = { all hashes of word‐prefixes of length ℓ }\\n        prefix_hash_sets = [set() for _ in range(max_pref + 1)]\\n        for w in words:\\n            h1 = h2 = 0\\n            limit = min(len(w), max_pref)\\n            for j in range(limit):\\n                c = ord(w[j])\\n                h1 = (h1 * base1 + c) % mod1\\n                h2 = (h2 * base2 + c) % mod2\\n                prefix_hash_sets[j+1].add((h1, h2))\\n\\n        # 5) rolling‐hash the target\\n        H1 = [0] * (n+1)\\n        H2 = [0] * (n+1)\\n        for i, ch in enumerate(target):\\n            c = ord(ch)\\n            H1[i+1] = (H1[i] * base1 + c) % mod1\\n            H2[i+1] = (H2[i] * base2 + c) % mod2\\n\\n        def substring_hash(i, length):\\n            \\\"\\\"\\\"Hash of target[i:i+length].\\\"\\\"\\\"\\n            x1 = (H1[i+length] - H1[i] * p1[length]) % mod1\\n            x2 = (H2[i+length] - H2[i] * p2[length]) % mod2\\n            return (x1, x2)\\n\\n        # 6) for each i, binary‐search the longest valid prefix length ℓ\\n        j_max = [i for i in range(n)]\\n        for i in range(n):\\n            rem = n - i\\n            hi = min(max_pref, rem)\\n            # quick reject\\n            if (substring_hash(i, 1) not in prefix_hash_sets[1]):\\n                continue\\n\\n            lo = 1\\n            # find the largest ℓ in [1..hi] with prefix_hash_sets[ℓ] containing target[i:i+ℓ]\\n            while lo < hi:\\n                mid = (lo + hi + 1) // 2\\n                if substring_hash(i, mid) in prefix_hash_sets[mid]:\\n                    lo = mid\\n                else:\\n                    hi = mid - 1\\n            j_max[i] = i + lo\\n\\n        # 7) Jump‐Game II greedy to cover [0..n] with min jumps\\n        jumps = 0\\n        cur_end = 0\\n        farthest = 0\\n        for i in range(n):\\n            farthest = max(farthest, j_max[i])\\n            if i == cur_end:\\n                # need to take a new jump here\\n                if farthest <= i:\\n                    return -1\\n                jumps += 1\\n                cur_end = farthest\\n                if cur_end >= n:\\n                    break\\n\\n        return jumps\\n\"",
  "636_14631217_python-updated-time": "1745782323987",
  "237_14631217_python-updated-time": "1745247462054",
  "2339_14631217_python": "\"class Solution:\\n    def countDistinct(self, nums, k, p):\\n        \\\"\\\"\\\"\\n        Count distinct subarrays of nums with at most k elements divisible by p.\\n        \\\"\\\"\\\"\\n        root = {}   # trie root\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            node = root\\n            cnt = 0\\n            for j in range(i, n):\\n                x = nums[j]\\n                if x % p == 0:\\n                    cnt += 1\\n                    if cnt > k:\\n                        break\\n                # Insert nums[j] into trie if not already present\\n                if x not in node:\\n                    node[x] = {}\\n                    ans += 1\\n                node = node[x]\\n        \\n        return ans\\n\"",
  "440_14631217_python-updated-time": "1745358896967",
  "3575_14631217_python": "\"class Solution(object):\\n    def maxValue(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        B = 1 << 7  # masks 0..127\\n\\n        # forward DP: dpA[p][a] = set of OR-masks picking p from nums[0:a]\\n        dp_prev = [ {0} for _ in range(n+1) ]\\n        for p in range(1, k+1):\\n            dp_curr = [set() for _ in range(n+1)]\\n            dp_curr[0] = set()\\n            for a in range(1, n+1):\\n                # skip a-th\\n                dp_curr[a] = dp_curr[a-1].copy()\\n                # take a-th\\n                na = nums[a-1]\\n                for m in dp_prev[a-1]:\\n                    dp_curr[a].add(m | na)\\n            dp_prev = dp_curr\\n        dpA = dp_prev  # dpA[a] = all OR-masks for first half ending by index a\\n\\n        # backward DP: dpB[p][a] = set of OR-masks picking p from nums[a-1:n]\\n        dp_prev = [ {0} for _ in range(n+2) ]\\n        for p in range(1, k+1):\\n            dp_curr = [set() for _ in range(n+2)]\\n            dp_curr[n+1] = set()\\n            for a in range(n, 0, -1):\\n                dp_curr[a] = dp_curr[a+1].copy()\\n                na = nums[a-1]\\n                for m in dp_prev[a+1]:\\n                    dp_curr[a].add(m | na)\\n            dp_prev = dp_curr\\n        dpB = dp_prev  # dpB[a] = all OR-masks for second half starting at index a\\n\\n        # combine at every pivot t: pick k in [0..t-1] and k in [t..n-1]\\n        ans = 0\\n        for t in range(k, n - k + 1):\\n            A = dpA[t]\\n            Bset = dpB[t+1]\\n            # brute-force XOR over two small sets (≤128 each)\\n            for m1 in A:\\n                for m2 in Bset:\\n                    v = m1 ^ m2\\n                    if v > ans:\\n                        ans = v\\n        return ans\\n\"",
  "3580_14631217_python": "\"class Solution(object):\\n    def minStartingIndex(self, s, pattern):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type pattern: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(s), len(pattern)\\n        if m > n:\\n            return -1\\n\\n        def z_algorithm(st):\\n            \\\"\\\"\\\"Return Z-array for st in O(len(st)).\\\"\\\"\\\"\\n            Z = [0] * len(st)\\n            Z[0] = len(st)\\n            l = r = 0\\n            for i in xrange(1, len(st)):\\n                if i <= r:\\n                    # we are inside a Z-box\\n                    k = i - l\\n                    Z[i] = min(Z[k], r - i + 1)\\n                # try to extend\\n                while i + Z[i] < len(st) and st[Z[i]] == st[i + Z[i]]:\\n                    Z[i] += 1\\n                if i + Z[i] - 1 > r:\\n                    l, r = i, i + Z[i] - 1\\n            return Z\\n\\n        # 1) forward Z to get ℓ[i] = Z at position (m+1+i)\\n        comb = pattern + '#' + s\\n        Z1 = z_algorithm(comb)\\n        # ℓ[i] = longest match of pattern[0..] with s[i..]\\n        # starts at index (m+1) in Z1\\n        L = Z1[m+1 : m+1 + n]\\n\\n        # 2) reverse both, do Z again to get suffix matches\\n        rs = s[::-1]\\n        rp = pattern[::-1]\\n        comb2 = rp + '#' + rs\\n        Z2 = z_algorithm(comb2)\\n        # for window at s[i..i+m-1], its reversed suffix starts at\\n        # rev index (n-1 - (i+m-1)) = n-m - i, which in comb2 is at m+1 + (n-m-i)\\n        R = [0] * (n - m + 1)\\n        base = m + 1\\n        for i in xrange(n - m + 1):\\n            R[i] = Z2[ base + (n - m - i) ]\\n\\n        # 3) scan for the first i with at most one mismatch\\n        for i in xrange(n - m + 1):\\n            if L[i] == m or L[i] + R[i] >= m - 1:\\n                return i\\n        return -1\"",
  "2442_14631217_python-updated-time": "1746964784975",
  "659_14631217_python-updated-time": "1745782947083",
  "2609_14631217_python": "\"class Solution:\\n    def distinctPrimeFactors(self, nums):\\n        primes = set()\\n        \\n        for x in nums:\\n            n = x\\n            d = 2\\n            while d * d <= n:\\n                if n % d == 0:\\n                    primes.add(d)\\n                    while n % d == 0:\\n                        n //= d\\n                d += 1\\n            if n > 1:\\n                primes.add(n)\\n        \\n        return len(primes)\\n\"",
  "166_14631217_python": "\"class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0:\\n            return \\\"0\\\"\\n        \\n        res = []\\n        \\n        if (numerator < 0) ^ (denominator < 0):\\n            res.append('-')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0:\\n            return ''.join(res)\\n        \\n        res.append('.')\\n        map_remainder = {}\\n        \\n        while remainder != 0:\\n            if remainder in map_remainder:\\n                res.insert(map_remainder[remainder], '(')\\n                res.append(')')\\n                break\\n            map_remainder[remainder] = len(res)\\n            remainder *= 10\\n            res.append(str(remainder // denominator))\\n            remainder %= denominator\\n        \\n        return ''.join(res)\\n\"",
  "2080_14631217_python-updated-time": "1746638967285",
  "223_14631217_python": "\"class Solution(object):\\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\\n        \\\"\\\"\\\"\\n        :type ax1: int\\n        :type ay1: int\\n        :type ax2: int\\n        :type ay2: int\\n        :type bx1: int\\n        :type by1: int\\n        :type bx2: int\\n        :type by2: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        area1 = (ax2 - ax1) * (ay2 - ay1)\\n        area2 = (bx2 - bx1) * (by2 - by1)\\n        \\n        # Calculate overlap area\\n        overlap_width = max(0, min(ax2, bx2) - max(ax1, bx1))\\n        overlap_height = max(0, min(ay2, by2) - max(ay1, by1))\\n        overlap_area = overlap_width * overlap_height\\n        \\n        return area1 + area2 - overlap_area\\n\"",
  "1270_14631217_python": "\"import heapq\\n\\nclass DinnerPlates(object):\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.stacks = []\\n        self.push_heap = []  # min-heap of indices that can accept pushes\\n        self.rightmost = -1\\n\\n    def push(self, val):\\n        # Clean up invalid heap entries (full stacks)\\n        while self.push_heap and self.push_heap[0] < len(self.stacks) and len(self.stacks[self.push_heap[0]]) == self.capacity:\\n            heapq.heappop(self.push_heap)\\n        \\n        if self.push_heap:\\n            idx = heapq.heappop(self.push_heap)\\n            self.stacks[idx].append(val)\\n            heapq.heappush(self.push_heap, idx)\\n        else:\\n            self.stacks.append([val])\\n            idx = len(self.stacks) - 1\\n            if self.capacity > 1:\\n                heapq.heappush(self.push_heap, idx)\\n\\n        self.rightmost = max(self.rightmost, idx)\\n\\n    def pop(self):\\n        while self.rightmost >= 0 and (self.rightmost >= len(self.stacks) or not self.stacks[self.rightmost]):\\n            self.rightmost -= 1\\n        if self.rightmost < 0:\\n            return -1\\n        val = self.stacks[self.rightmost].pop()\\n        heapq.heappush(self.push_heap, self.rightmost)\\n        return val\\n\\n    def popAtStack(self, index):\\n        if index >= len(self.stacks) or not self.stacks[index]:\\n            return -1\\n        val = self.stacks[index].pop()\\n        heapq.heappush(self.push_heap, index)\\n        if index == self.rightmost and not self.stacks[index]:\\n            while self.rightmost >= 0 and (self.rightmost >= len(self.stacks) or not self.stacks[self.rightmost]):\\n                self.rightmost -= 1\\n        return val\\n\"",
  "1159_14631217_python": "\"class Solution(object):\\n    def smallestSubsequence(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        last_index = {ch: i for i, ch in enumerate(s)}\\n        stack = []\\n        seen = set()\\n\\n        for i, ch in enumerate(s):\\n            if ch in seen:\\n                continue\\n            while stack and ch < stack[-1] and i < last_index[stack[-1]]:\\n                seen.remove(stack.pop())\\n            stack.append(ch)\\n            seen.add(ch)\\n\\n        return ''.join(stack)\\n\"",
  "2204_14631217_python": "\"class Solution:\\n    def maxSubsequence(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Pair each number with its index\\n        paired = [(num, i) for i, num in enumerate(nums)]\\n        # Sort by num descending; tie-breaker idx ascending doesn't matter\\n        paired.sort(key=lambda x: x[0], reverse=True)\\n        # Take top k elements\\n        topk = paired[:k]\\n        # Sort those by original index to restore subsequence order\\n        topk.sort(key=lambda x: x[1])\\n        # Extract the numbers\\n        return [num for num, _ in topk]\\n\"",
  "1285_14631217_python": "\"class Solution(object):\\n    def balanceBST(self, root):\\n        def inorder(node):\\n            if not node:\\n                return []\\n            return inorder(node.left) + [node.val] + inorder(node.right)\\n\\n        def build_balanced_tree(vals):\\n            if not vals:\\n                return None\\n            mid = len(vals) // 2\\n            node = TreeNode(vals[mid])\\n            node.left = build_balanced_tree(vals[:mid])\\n            node.right = build_balanced_tree(vals[mid+1:])\\n            return node\\n\\n        sorted_vals = inorder(root)\\n        return build_balanced_tree(sorted_vals)\\n\"",
  "1715_14631217_python": "\"class Solution(object):\\n    def maxUniqueSplit(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        self.ans = 0\\n        n = len(s)\\n        \\n        def dfs(start, used, count):\\n            # Prune if even using minimal-length substrings (length=1),\\n            # we cannot exceed current best\\n            if count + (n - start) <= self.ans:\\n                return\\n            if start == n:\\n                self.ans = max(self.ans, count)\\n                return\\n            # Try all end positions for the next substring\\n            for end in range(start + 1, n + 1):\\n                sub = s[start:end]\\n                if sub not in used:\\n                    used.add(sub)\\n                    dfs(end, used, count + 1)\\n                    used.remove(sub)\\n        \\n        dfs(0, set(), 0)\\n        return self.ans\\n\"",
  "1726_14631217_python-updated-time": "1746444432939",
  "958_14631217_python": "\"class Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j = 0, 1\\n        n = len(nums)\\n\\n        while i < n and j < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 2\\n                j += 2\\n\\n        return nums\\n\"",
  "1906_14631217_python-updated-time": "1746542929497",
  "2040_14631217_python": "\"class Solution(object):\\n    def minCost(self, maxTime, edges, passingFees):\\n        n = len(passingFees)\\n        INF = 10**18\\n        # adjacency list for quick iteration\\n        adj = [[] for _ in range(n)]\\n        for u, v, t in edges:\\n            adj[u].append((v, t))\\n            adj[v].append((u, t))\\n\\n        # dp[node][time] = min cost to reach node in exactly 'time' minutes\\n        dp = [ [INF] * (maxTime + 1) for _ in range(n) ]\\n        dp[0][0] = passingFees[0]\\n\\n        for t in range(maxTime + 1):\\n            for u in range(n):\\n                cost_u_t = dp[u][t]\\n                if cost_u_t == INF:\\n                    continue\\n                # try all outgoing roads\\n                for v, travel in adj[u]:\\n                    nt = t + travel\\n                    if nt <= maxTime:\\n                        c = cost_u_t + passingFees[v]\\n                        if c < dp[v][nt]:\\n                            dp[v][nt] = c\\n\\n        # answer is min cost to reach city n-1 in any time <= maxTime\\n        res = min(dp[n-1])\\n        return res if res < INF else -1\\n\"",
  "2680_14631217_python-updated-time": "1747061927665",
  "3384_14631217_python-updated-time": "1747478812952",
  "1534_14631217_python-updated-time": "1746346944764",
  "1515_14631217_python-updated-time": "1746346770917",
  "1520_14631217_python": "\"class Solution(object):\\n    def numSteps(self, s):\\n        steps = 0\\n        carry = 0\\n        n = len(s)\\n\\n        for i in range(n - 1, 0, -1):\\n            bit = int(s[i])\\n            if bit + carry == 1:\\n                carry = 1\\n                steps += 2  # add 1 and divide by 2\\n            else:\\n                steps += 1  # just divide by 2\\n\\n        return steps + carry\\n\"",
  "920_14631217_python-updated-time": "1746001832229",
  "124_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        self.max_sum = float('-inf')\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            \\n            # Recursively get max path sum from left and right\\n            left_gain = max(dfs(node.left), 0)  # we ignore negative paths\\n            right_gain = max(dfs(node.right), 0)\\n            \\n            # Price of the new path starting from this node\\n            price_newpath = node.val + left_gain + right_gain\\n            \\n            # Update the global max_sum\\n            self.max_sum = max(self.max_sum, price_newpath)\\n            \\n            # For recursion: return the max gain if continue the same path\\n            return node.val + max(left_gain, right_gain)\\n        \\n        dfs(root)\\n        return self.max_sum\\n\"",
  "12_14631217_python-updated-time": "1744980123665",
  "2101_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def latestDayToCross(self, row, col, cells):\\n        # Helper: can cross on day d (1-based days, d=0 means no water yet)\\n        def can(d):\\n            # build water grid\\n            flooded = [[False]*col for _ in range(row)]\\n            for i in range(d):\\n                r, c = cells[i]\\n                flooded[r-1][c-1] = True\\n\\n            # BFS from all land in top row\\n            q = deque()\\n            seen = [[False]*col for _ in range(row)]\\n            for c0 in range(col):\\n                if not flooded[0][c0]:\\n                    q.append((0, c0))\\n                    seen[0][c0] = True\\n\\n            dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n            while q:\\n                r0, c0 = q.popleft()\\n                if r0 == row-1:\\n                    return True\\n                for dr, dc in dirs:\\n                    nr, nc = r0+dr, c0+dc\\n                    if 0 <= nr < row and 0 <= nc < col and not flooded[nr][nc] and not seen[nr][nc]:\\n                        seen[nr][nc] = True\\n                        q.append((nr, nc))\\n            return False\\n\\n        n = len(cells)\\n        lo, hi = 0, n\\n        # binary search for max day\\n        while lo < hi:\\n            mid = (lo + hi + 1)//2\\n            if can(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n\"",
  "1649_14631217_python": "\"class Solution(object):\\n    def maxNonOverlapping(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seen = set([0])\\n        count = 0\\n        curr_sum = 0\\n\\n        for num in nums:\\n            curr_sum += num\\n            if curr_sum - target in seen:\\n                count += 1\\n                seen = set([0])\\n                curr_sum = 0\\n            else:\\n                seen.add(curr_sum)\\n\\n        return count\\n\"",
  "869_14631217_python": "\"class Solution(object):\\n    def numSimilarGroups(self, strs):\\n        parent = {}\\n        \\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            parent[find(x)] = find(y)\\n        \\n        def is_similar(a, b):\\n            diff = 0\\n            for i in range(len(a)):\\n                if a[i] != b[i]:\\n                    diff += 1\\n            return diff == 2 or diff == 0\\n        \\n        n = len(strs)\\n        for word in strs:\\n            parent[word] = word\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if is_similar(strs[i], strs[j]):\\n                    union(strs[i], strs[j])\\n        \\n        groups = set()\\n        for word in strs:\\n            groups.add(find(word))\\n        \\n        return len(groups)\\n\"",
  "1730_14631217_python-updated-time": "1746443978458",
  "2708_14631217_python-updated-time": "1747066022483",
  "828_14631217_python": "\"class Solution(object):\\n    def xorGame(self, nums):\\n        xor_sum = 0\\n        for num in nums:\\n            xor_sum ^= num\\n        return xor_sum == 0 or len(nums) % 2 == 0\\n\"",
  "1400_14631217_python-updated-time": "1746260059722",
  "1392_14631217_python": "\"class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        return [list(s1 - s2), list(s2 - s1)]\\n\"",
  "58_14631217_python": "\"class Solution(object):\\n    def lengthOfLastWord(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        i = len(s) - 1\\n        length = 0\\n\\n        while i >= 0 and s[i] == ' ':\\n            i -= 1\\n\\n        while i >= 0 and s[i] != ' ':\\n            length += 1\\n            i -= 1\\n\\n        return length\\n\"",
  "3329_14631217_python": "\"class TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n\\nclass Solution(object):\\n    def longestCommonPrefix(self, arr1, arr2):\\n        def insert(trie, num_str):\\n            node = trie\\n            for ch in num_str:\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n\\n        def longest_match(trie, num_str):\\n            node = trie\\n            lcp = 0\\n            for ch in num_str:\\n                if ch in node.children:\\n                    lcp += 1\\n                    node = node.children[ch]\\n                else:\\n                    break\\n            return lcp\\n\\n        trie = TrieNode()\\n        for num in arr2:\\n            insert(trie, str(num))\\n\\n        max_len = 0\\n        for num in arr1:\\n            max_len = max(max_len, longest_match(trie, str(num)))\\n        return max_len\\n\"",
  "1261_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxRepOpt1(self, text):\\n        \\\"\\\"\\\"\\n        :type text: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total_count = Counter(text)\\n        groups = []\\n        i = 0\\n        n = len(text)\\n\\n        # Collect groups of consecutive characters\\n        while i < n:\\n            j = i\\n            while j < n and text[j] == text[i]:\\n                j += 1\\n            groups.append((text[i], j - i))\\n            i = j\\n\\n        res = 0\\n        for i in range(len(groups)):\\n            char, count = groups[i]\\n            # Case 1: Use one swap to extend current group if there are extra chars\\n            res = max(res, min(count + 1, total_count[char]))\\n\\n            # Case 2: Merge two groups separated by one different character\\n            if i + 2 < len(groups) and groups[i + 1][1] == 1 and groups[i][0] == groups[i + 2][0]:\\n                merged = groups[i][1] + groups[i + 2][1]\\n                if total_count[char] > merged:\\n                    merged += 1\\n                res = max(res, merged)\\n\\n        return res\\n\"",
  "2561_14631217_python-updated-time": "1746969076381",
  "2573_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        # reverse the linked list\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        # prev is the head of reversed list\\n        max_so_far = 0\\n        dummy = ListNode(0)\\n        tail = dummy\\n        curr = prev\\n        # keep nodes >= max_so_far\\n        while curr:\\n            if curr.val >= max_so_far:\\n                max_so_far = curr.val\\n                tail.next = curr\\n                tail = curr\\n            curr = curr.next\\n        tail.next = None\\n        # reverse back\\n        prev = None\\n        curr = dummy.next\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\"",
  "882_14631217_python-updated-time": "1745953640470",
  "2863_14631217_javascript": "\"class Calculator {\\n    constructor(value) {\\n        this.result = value;\\n    }\\n\\n    add(value) {\\n        this.result += value;\\n        return this;\\n    }\\n\\n    subtract(value) {\\n        this.result -= value;\\n        return this;\\n    }\\n\\n    multiply(value) {\\n        this.result *= value;\\n        return this;\\n    }\\n\\n    divide(value) {\\n        if (value === 0) throw new Error(\\\"Division by zero is not allowed\\\");\\n        this.result /= value;\\n        return this;\\n    }\\n\\n    power(value) {\\n        this.result **= value;\\n        return this;\\n    }\\n\\n    getResult() {\\n        return this.result;\\n    }\\n}\\n\"",
  "201_14631217_python": "\"class Solution(object):\\n    def rangeBitwiseAnd(self, left, right):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        shift = 0\\n        while left < right:\\n            left >>= 1\\n            right >>= 1\\n            shift += 1\\n        return left << shift\\n\"",
  "1913_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def minChanges(self, nums, k):\\n        MAXX = 1 << 10  # Since nums[i] < 2^10\\n        dp = [float('inf')] * MAXX\\n        dp[0] = 0\\n\\n        for i in range(k):\\n            count = Counter()\\n            total = 0\\n            for j in range(i, len(nums), k):\\n                count[nums[j]] += 1\\n                total += 1\\n\\n            min_dp = min(dp)\\n            ndp = [min_dp + total] * MAXX\\n\\n            for mask in range(MAXX):\\n                for x in count:\\n                    ndp[mask] = min(ndp[mask], dp[mask ^ x] + total - count[x])\\n\\n            dp = ndp\\n\\n        return dp[0]\\n\"",
  "3107_14631217_python": "\"class Solution:\\n    def maxSpending(self, values):\\n        \\\"\\\"\\\"\\n        :type values: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m = len(values)\\n        n = len(values[0]) if m else 0\\n        # Min-heap of (weight, shop_index, idx_in_shop)\\n        heap = []\\n        for i in range(m):\\n            # j = n-1 is the rightmost (smallest) available\\n            heap.append((values[i][n-1], i, n-1))\\n        heapq.heapify(heap)\\n\\n        total = 0\\n        day = 1\\n        # We will schedule exactly m * n items\\n        for _ in range(m * n):\\n            w, i, j = heapq.heappop(heap)\\n            total += w * day\\n            day += 1\\n            # Advance to the next item in shop i, if any\\n            if j - 1 >= 0:\\n                heapq.heappush(heap, (values[i][j-1], i, j-1))\\n\\n        return total\\n\"",
  "3748_14631217_python-updated-time": "1747678905047",
  "3223_14631217_python": "\"class Solution(object):\\n    def countCompleteSubstrings(self, word, k):\\n        n = len(word)\\n        res = 0\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and abs(ord(word[j]) - ord(word[j-1])) <= 2:\\n                j += 1\\n            m = j - i\\n            if m >= k:\\n                seg = word[i:j]\\n                for d in range(1, min(26, m // k) + 1):\\n                    L = d * k\\n                    arr = [0] * 26\\n                    distinct = exact = 0\\n                    for x in seg[:L]:\\n                        arr[ord(x)-97] += 1\\n                    for cnt in arr:\\n                        if cnt > 0: distinct += 1\\n                        if cnt == k: exact += 1\\n                    if distinct == exact == d:\\n                        res += 1\\n                    for s in range(1, m - L + 1):\\n                        r = ord(seg[s-1]) - 97\\n                        o = arr[r]\\n                        arr[r] = o - 1\\n                        if o == 1: distinct -= 1\\n                        if o == k: exact -= 1\\n                        if o == k+1: exact += 1\\n                        a = ord(seg[s+L-1]) - 97\\n                        o = arr[a]\\n                        arr[a] = o + 1\\n                        if o == 0: distinct += 1\\n                        if o == k-1: exact += 1\\n                        if o == k: exact -= 1\\n                        if distinct == exact == d:\\n                            res += 1\\n            i = j\\n        return res\\n\"",
  "673_14631217_python": "\"class Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        n = len(nums)\\n        dp = [1] * n\\n        count = [1] * n\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        count[i] = count[j]\\n                    elif dp[j] + 1 == dp[i]:\\n                        count[i] += count[j]\\n        \\n        max_len = max(dp)\\n        return sum(c for i, c in enumerate(count) if dp[i] == max_len)\\n\"",
  "2393_14631217_python-updated-time": "1746882097024",
  "2357_14631217_python": "\"import bisect\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        # Sorted lists of interval starts and ends (inclusive)\\n        self.starts = []\\n        self.ends = []\\n        self.total = 0\\n\\n    def add(self, left, right):\\n        # We'll merge [left, right] with any overlapping intervals\\n        s, e = left, right\\n        # Find insertion point\\n        i = bisect.bisect_left(self.starts, s)\\n        \\n        # Check if the previous interval overlaps or is adjacent\\n        if i > 0 and self.ends[i-1] >= s - 1:\\n            i -= 1\\n        \\n        # Merge forward through all overlapping/adjacent intervals\\n        j = i\\n        while j < len(self.starts) and self.starts[j] <= e + 1:\\n            # Expand our merged interval\\n            s = min(s, self.starts[j])\\n            e = max(e, self.ends[j])\\n            # Subtract out the old interval's covered length\\n            self.total -= (self.ends[j] - self.starts[j] + 1)\\n            j += 1\\n        \\n        # Remove the intervals we've merged [i:j]\\n        if j > i:\\n            del self.starts[i:j]\\n            del self.ends[i:j]\\n        \\n        # Insert the merged interval\\n        self.starts.insert(i, s)\\n        self.ends.insert(i, e)\\n        # Add its coverage\\n        self.total += (e - s + 1)\\n\\n    def count(self):\\n        return self.total\\n\"",
  "1524_14631217_python": "\"class Solution(object):\\n    def stringMatching(self, words):\\n        result = []\\n        for i in range(len(words)):\\n            for j in range(len(words)):\\n                if i != j and words[i] in words[j]:\\n                    result.append(words[i])\\n                    break\\n        return result\\n\"",
  "1367_14631217_python-updated-time": "1746453155022",
  "3600_14631217_python-updated-time": "1747575307493",
  "2720_14631217_python": "\"class Solution:\\n    def minimizeMax(self, nums, p):\\n        nums.sort()\\n\\n        def can_form_pairs(max_diff):\\n            count = 0\\n            i = 1\\n            while i < len(nums):\\n                if nums[i] - nums[i - 1] <= max_diff:\\n                    count += 1\\n                    i += 2  # Skip both elements used in the pair\\n                else:\\n                    i += 1\\n            return count >= p\\n\\n        left, right = 0, nums[-1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_form_pairs(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "1824_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def eatenApples(self, apples, days):\\n        \\\"\\\"\\\"\\n        :type apples: List[int]\\n        :type days:   List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(apples)\\n        heap = []       # min-heap of (expire_day, count)\\n        day = 0\\n        eaten = 0\\n        \\n        # Continue while there are days left to grow apples or the heap is non-empty\\n        while day < n or heap:\\n            # 1) Add today's new batch if any\\n            if day < n and apples[day] > 0:\\n                expire = day + days[day]\\n                heapq.heappush(heap, (expire, apples[day]))\\n            \\n            # 2) Discard all rotten batches\\n            while heap and heap[0][0] <= day:\\n                heapq.heappop(heap)\\n            \\n            # 3) Eat one apple from the batch that rots soonest\\n            if heap:\\n                expire, cnt = heapq.heappop(heap)\\n                # eat one\\n                eaten += 1\\n                if cnt > 1:\\n                    # push back with one fewer apple\\n                    heapq.heappush(heap, (expire, cnt - 1))\\n            \\n            # 4) Move to the next day\\n            day += 1\\n        \\n        return eaten\\n\"",
  "1555_14631217_python": "\"class Solution(object):\\n    def ways(self, pizza, k):\\n        mod = 10**9 + 7\\n        rows, cols = len(pizza), len(pizza[0])\\n        # suffix sum of apples\\n        apples = [[0]*(cols+1) for _ in range(rows+1)]\\n        for i in range(rows-1, -1, -1):\\n            for j in range(cols-1, -1, -1):\\n                apples[i][j] = (1 if pizza[i][j]=='A' else 0) + apples[i+1][j] + apples[i][j+1] - apples[i+1][j+1]\\n        # dp[c][i][j]: ways to cut starting at (i,j) into c pieces\\n        dp = [[[0]*cols for _ in range(rows)] for _ in range(k+1)]\\n        # base: one piece, must have at least one apple\\n        for i in range(rows):\\n            for j in range(cols):\\n                if apples[i][j] > 0:\\n                    dp[1][i][j] = 1\\n        # build up\\n        for c in range(2, k+1):\\n            for i in range(rows):\\n                for j in range(cols):\\n                    # horizontal cuts\\n                    for ni in range(i+1, rows):\\n                        if apples[i][j] - apples[ni][j] > 0:\\n                            dp[c][i][j] = (dp[c][i][j] + dp[c-1][ni][j]) % mod\\n                    # vertical cuts\\n                    for nj in range(j+1, cols):\\n                        if apples[i][j] - apples[i][nj] > 0:\\n                            dp[c][i][j] = (dp[c][i][j] + dp[c-1][i][nj]) % mod\\n        return dp[k][0][0]\\n\"",
  "1135_14631217_mysql-updated-time": "1746042870414",
  "2557_14631217_python": "\"import math\\n\\nclass Solution:\\n    def subarrayLCM(self, nums, k):\\n        # helper gcd in case math.gcd isn't available\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        n = len(nums)\\n        ans = 0\\n\\n        for i in range(n):\\n            cur_lcm = 1\\n            for j in range(i, n):\\n                x = nums[j]\\n                # if x doesn't divide k, no subarray from i.. can reach LCM = k\\n                if k % x != 0:\\n                    break\\n                # update LCM safely using custom gcd\\n                cur_lcm = cur_lcm * x // gcd(cur_lcm, x)\\n                # if we've exceeded k, we can stop (since x|k and cur_lcm|k, won't exceed)\\n                # but as x divides k, cur_lcm will always divide k, so no need to check >k\\n                if cur_lcm == k:\\n                    ans += 1\\n            # next i\\n        return ans\"",
  "1036_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def orangesRotting(self, grid):\\n        rows, cols = len(grid), len(grid[0])\\n        queue = deque()\\n        fresh = 0\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 2:\\n                    queue.append((r, c, 0))  # (row, col, time)\\n                elif grid[r][c] == 1:\\n                    fresh += 1\\n\\n        time = 0\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n\\n        while queue:\\n            r, c, t = queue.popleft()\\n            time = max(time, t)\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\\n                    grid[nr][nc] = 2\\n                    fresh -= 1\\n                    queue.append((nr, nc, t + 1))\\n\\n        return time if fresh == 0 else -1\\n\"",
  "3551_14631217_python": "\"class Solution(object):\\n    def maximumSubarrayXor(self, nums, queries):\\n        n = len(nums)\\n\\n        # Group queries by right endpoint\\n        qs_by_r = [[] for _ in range(n)]\\n        for qi, (l, r) in enumerate(queries):\\n            qs_by_r[r].append((l, qi))\\n        answer = [0] * len(queries)\\n\\n        # prev_diag will hold f[i][(d-1)-i] for i=0..d-1\\n        prev_diag = []\\n\\n        # prev_best[l] will be the maximum score for any subarray\\n        # inside [l..d-1], so we can extend it to [l..d].\\n        prev_best = []\\n\\n        # Process diagonals d=0..n-1, which correspond to subarrays ending at r=d\\n        for d in range(n):\\n            # Build current diagonal: f[i][d-i] for i=0..d\\n            cur_diag = [0] * (d + 1)\\n            # Fill from i=d down to 0 so cur_diag[i+1] is ready when needed\\n            for i in range(d, -1, -1):\\n                length_minus1 = d - i  # this is m-1 where m = length\\n                if length_minus1 == 0:\\n                    # subarray of length 1\\n                    cur_diag[i] = nums[i]\\n                else:\\n                    # recurrence f(i,m) = f(i,m-1) XOR f(i+1,m-1)\\n                    cur_diag[i] = prev_diag[i] ^ cur_diag[i+1]\\n\\n            # Compute suffix-max of cur_diag so\\n            # end_max[i] = max_{start ≥ i, end=d} score(start..d)\\n            end_max = [0] * (d + 1)\\n            for i in range(d, -1, -1):\\n                if i == d:\\n                    end_max[i] = cur_diag[i]\\n                else:\\n                    end_max[i] = max(cur_diag[i], end_max[i+1])\\n\\n            # Build the new best array for subarrays in [l..d]\\n            new_best = [0] * (d + 1)\\n            for l in range(d, -1, -1):\\n                if l == d:\\n                    # only one subarray [d..d]\\n                    new_best[l] = cur_diag[l]\\n                else:\\n                    # either we take the best entirely within [l..d-1],\\n                    # or we take one that ends exactly at d (captured in end_max[l])\\n                    new_best[l] = max(prev_best[l], end_max[l])\\n\\n            # Answer all queries with right endpoint = d\\n            for (l, qi) in qs_by_r[d]:\\n                answer[qi] = new_best[l]\\n\\n            # Slide the window: current becomes previous for the next diagonal\\n            prev_diag = cur_diag\\n            prev_best = new_best\\n\\n        return answer\\n\"",
  "6_14631217_python": "\"class Solution(object):\\n    def convert(self, s, numRows):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n\\n        rows = [''] * numRows\\n        index, step = 0, 1\\n\\n        for char in s:\\n            rows[index] += char\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step\\n\\n        return ''.join(rows)\\n\"",
  "2844_14631217_python-updated-time": "1747222328638",
  "1295_14631217_python-updated-time": "1746638864009",
  "2503_14631217_python-updated-time": "1746966599781",
  "2628_14631217_python": "\"class Solution:\\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        lcm = divisor1 * divisor2 // gcd(divisor1, divisor2)\\n\\n        def enough(x):\\n            a = x - x // divisor1\\n            b = x - x // divisor2\\n            both = x - x // lcm\\n            return a >= uniqueCnt1 and b >= uniqueCnt2 and both >= uniqueCnt1 + uniqueCnt2\\n\\n        left, right = 1, 10**18\\n        while left < right:\\n            mid = (left + right) // 2\\n            if enough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "3676_14631217_python-updated-time": "1747595781635",
  "3709_14631217_python-updated-time": "1747680298645",
  "230_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def kthSmallest(self, root, k):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        stack = []\\n        \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            k -= 1\\n            if k == 0:\\n                return root.val\\n            root = root.right\\n\"",
  "3468_14631217_python": "\"class Solution(object):\\n    def getEncryptedString(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        k %= n\\n        return s[k:] + s[:k]\\n\"",
  "3803_14631217_mysql": "\"SELECT *\\nFROM products\\nWHERE description REGEXP '(^|[^A-Za-z0-9])SN[0-9]{4}-[0-9]{4}([^0-9]|$)'\\nORDER BY product_id;\\n\"",
  "326_14631217_python-updated-time": "1745256345956",
  "1567_14631217_python-updated-time": "1746347781344",
  "2465_14631217_python": "\"class Solution(object):\\n    def shiftingLetters(self, s, shifts):\\n        n = len(s)\\n        delta = [0] * (n + 1)\\n\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                delta[start] += 1\\n                delta[end + 1] -= 1\\n            else:\\n                delta[start] -= 1\\n                delta[end + 1] += 1\\n\\n        for i in range(1, n):\\n            delta[i] += delta[i - 1]\\n\\n        res = []\\n        for i in range(n):\\n            shift = (ord(s[i]) - ord('a') + delta[i]) % 26\\n            res.append(chr(ord('a') + shift))\\n\\n        return ''.join(res)\\n\"",
  "2883_14631217_python-updated-time": "1747222129154",
  "863_14631217_python": "\"class Solution(object):\\n    def sumOfDistancesInTree(self, n, edges):\\n        from collections import defaultdict\\n        tree = defaultdict(list)\\n        for u, v in edges:\\n            tree[u].append(v)\\n            tree[v].append(u)\\n\\n        res = [0] * n\\n        count = [1] * n\\n\\n        def dfs(node, parent):\\n            for child in tree[node]:\\n                if child != parent:\\n                    dfs(child, node)\\n                    count[node] += count[child]\\n                    res[node] += res[child] + count[child]\\n\\n        def dfs2(node, parent):\\n            for child in tree[node]:\\n                if child != parent:\\n                    res[child] = res[node] - count[child] + (n - count[child])\\n                    dfs2(child, node)\\n\\n        dfs(0, -1)\\n        dfs2(0, -1)\\n        return res\\n\"",
  "274_14631217_python-updated-time": "1745248256507",
  "315_14631217_python-updated-time": "1745256016006",
  "1359_14631217_python-updated-time": "1746259351032",
  "352_14631217_python": "\"class SummaryRanges(object):\\n    def __init__(self):\\n        self.nums = set()\\n\\n    def addNum(self, value):\\n        \\\"\\\"\\\"\\n        :type value: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        self.nums.add(value)\\n\\n    def getIntervals(self):\\n        \\\"\\\"\\\"\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        sorted_nums = sorted(self.nums)\\n        res = []\\n        for num in sorted_nums:\\n            if not res or res[-1][1] + 1 < num:\\n                res.append([num, num])\\n            else:\\n                res[-1][1] = num\\n        return res\\n\"",
  "2430_14631217_python": "\"class Solution:\\n    def countExcellentPairs(self, nums, k):\\n        # Only unique values matter\\n        nums = set(nums)\\n        \\n        # Count how many numbers have each popcount\\n        from collections import Counter\\n        cnt = Counter(bin(x).count(\\\"1\\\") for x in nums)\\n        \\n        # Build a sorted list of (popcount, frequency)\\n        # but since popcounts range only up to ~30, we can use an array\\n        maxc = max(cnt) if cnt else 0\\n        freq = [0] * (maxc + 1)\\n        for c, f in cnt.items():\\n            freq[c] = f\\n        \\n        # Build suffix sums: suff[c] = sum_{j>=c} freq[j]\\n        n = len(freq)\\n        suff = [0] * (n + 2)\\n        for c in range(n - 1, -1, -1):\\n            suff[c] = suff[c+1] + freq[c]\\n        \\n        # For each popcount c1, we need popcount c2 >= k - c1\\n        ans = 0\\n        for c1, f1 in enumerate(freq):\\n            if f1 == 0:\\n                continue\\n            need = k - c1\\n            if need <= 0:\\n                # any c2 works\\n                ans += f1 * len(nums)\\n            elif need < len(suff):\\n                ans += f1 * suff[need]\\n            # else need > max popcount => no contribution\\n        \\n        return ans\\n\"",
  "601_14631217_mysql-updated-time": "1745448587879",
  "652_14631217_python": "\"class Solution(object):\\n    def findDuplicateSubtrees(self, root):\\n        from collections import defaultdict\\n        count = defaultdict(int)\\n        res = []\\n        \\n        def serialize(node):\\n            if not node:\\n                return \\\"#\\\"\\n            serial = \\\"{},{},{}\\\".format(node.val, serialize(node.left), serialize(node.right))\\n            count[serial] += 1\\n            if count[serial] == 2:\\n                res.append(node)\\n            return serial\\n        \\n        serialize(root)\\n        return res\\n\"",
  "1961_14631217_python": "\"class Solution(object):\\n    def maxIceCream(self, costs, coins):\\n        # counting sort histogram\\n        max_cost = max(costs)\\n        freq = [0] * (max_cost + 1)\\n        for c in costs:\\n            freq[c] += 1\\n\\n        bars = 0\\n        for price in range(1, max_cost + 1):\\n            if coins < price:\\n                break\\n            count = freq[price]\\n            # buy as many as possible at this price\\n            can_buy = min(count, coins // price)\\n            bars += can_buy\\n            coins -= can_buy * price\\n        return bars\\n\"",
  "2383_14631217_python": "\"class Solution:\\n    def sum(self, num1, num2):\\n        return num1 + num2\\n\"",
  "2785_14631217_python-updated-time": "1747140576905",
  "1122_14631217_python-updated-time": "1746042830806",
  "3316_14631217_python": "\"class Solution(object):\\n    def sumOfPowers(self, nums, k):\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        \\n        # 1) build sorted unique list of all gaps\\n        D = []\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                D.append(nums[j] - nums[i])\\n        D = sorted(set(D))\\n        m = len(D)\\n        \\n        # 2) Precompute, for each G = D[idx], how many k-subsequences\\n        #    have ALL adjacent diffs >= G.\\n        cnt_ge = [0] * (m + 1)  # we will leave cnt_ge[m] = 0\\n        import bisect\\n        \\n        for idx, G in enumerate(D):\\n            # dp[t][i]: ways to pick t elements ending at i\\n            dp = [[0]*n for _ in range(k+1)]\\n            # prefix sums of dp[t] for O(1) range sums\\n            prefix = [[0]*n for _ in range(k+1)]\\n            \\n            # base: t=1\\n            for i in range(n):\\n                dp[1][i] = 1\\n                prefix[1][i] = (prefix[1][i-1] + 1) if i>0 else 1\\n            \\n            # build up t = 2..k\\n            for t in range(2, k+1):\\n                for i in range(n):\\n                    # find largest j < i with nums[j] <= nums[i] - G\\n                    limit = nums[i] - G\\n                    j = bisect.bisect_right(nums, limit, 0, i) - 1\\n                    if j >= 0:\\n                        dp[t][i] = prefix[t-1][j]\\n                    # update prefix[t][i]\\n                    prefix[t][i] = (prefix[t][i-1] + dp[t][i]) if i>0 else dp[t][i]\\n            \\n            # total ways for t=k is sum dp[k][i]\\n            cnt = sum(dp[k][i] for i in range(n)) % MOD\\n            cnt_ge[idx] = cnt\\n        \\n        # 3) apply “difference” to get exact counts and sum up\\n        ans = 0\\n        for i in range(m):\\n            ways_exact = (cnt_ge[i] - cnt_ge[i+1]) % MOD\\n            ans = (ans + D[i] * ways_exact) % MOD\\n        \\n        return ans\\n\"",
  "3141_14631217_python-updated-time": "1747305406764",
  "137_14631217_python": "\"class Solution(object):\\n    def singleNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        result = 0\\n        for i in range(32):  # Go through each bit\\n            bit_sum = 0\\n            for num in nums:\\n                if (num >> i) & 1:\\n                    bit_sum += 1\\n            if bit_sum % 3 != 0:\\n                result |= (1 << i)\\n        \\n        # Handle negative numbers\\n        if result >= 2**31:\\n            result -= 2**32\\n        \\n        return result\\n\"",
  "1464_14631217_python-updated-time": "1746261731298",
  "1896_14631217_python-updated-time": "1746531981887",
  "1584_14631217_python": "\"class Solution(object):\\n    def average(self, salary):\\n        \\\"\\\"\\\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        total = sum(salary) - min(salary) - max(salary)\\n        count = len(salary) - 2\\n        return float(total) / count\\n\"",
  "1044_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, words):\\n        common = Counter(words[0])\\n        for word in words[1:]:\\n            common &= Counter(word)\\n        result = []\\n        for char, freq in common.items():\\n            result.extend([char] * freq)\\n        return result\\n\"",
  "122_14631217_python-updated-time": "1745081595955",
  "759_14631217_python": "\"class Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        res = []\\n        \\n        for start, end in intervals:\\n            count = 0\\n            for x in reversed(res):\\n                if start <= x <= end:\\n                    count += 1\\n                if count == 2:\\n                    break\\n            needed = 2 - count\\n            for i in range(needed):\\n                res.append(end - i)\\n        \\n        return len(res)\\n\"",
  "798_14631217_python-updated-time": "1745877417724",
  "2274_14631217_python-updated-time": "1746802741480",
  "3510_14631217_python-updated-time": "1747572962556",
  "3330_14631217_python": "\"class Solution(object):\\n    def modifiedMatrix(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        m, n = len(matrix), len(matrix[0])\\n        # compute max of each column ignoring -1\\n        col_max = []\\n        for j in range(n):\\n            mj = matrix[0][j]\\n            for i in range(1, m):\\n                v = matrix[i][j]\\n                if v > mj:\\n                    mj = v\\n            # if mj is -1 (all -1), but problem guarantees at least one non-negative per column\\n            col_max.append(mj)\\n        # build answer\\n        answer = [row[:] for row in matrix]\\n        for i in range(m):\\n            for j in range(n):\\n                if answer[i][j] == -1:\\n                    answer[i][j] = col_max[j]\\n        return answer\\n\"",
  "1660_14631217_python-updated-time": "1746434549506",
  "2096_14631217_python-updated-time": "1746639328419",
  "516_14631217_python-updated-time": "1745446427225",
  "2108_14631217_python-updated-time": "1746715769768",
  "94_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res, stack = [], []\\n        current = root\\n        \\n        while current or stack:\\n            while current:\\n                stack.append(current)\\n                current = current.left\\n            current = stack.pop()\\n            res.append(current.val)\\n            current = current.right\\n        \\n        return res\\n\"",
  "2344_14631217_python-updated-time": "1746880419032",
  "688_14631217_python-updated-time": "1745785470565",
  "477_14631217_python": "\"class Solution:\\n    def totalHammingDistance(self, nums):\\n        total = 0\\n        n = len(nums)\\n        for i in range(32):  # Since nums[i] <= 10^9, only 32 bits needed\\n            count_ones = sum((num >> i) & 1 for num in nums)\\n            total += count_ones * (n - count_ones)\\n        return total\\n\"",
  "143_14631217_python-updated-time": "1745087090232",
  "3266_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Gather lengths of consecutive runs for each character\\n        runs = {}\\n        i = 0\\n        while i < n:\\n            ch = s[i]\\n            j = i + 1\\n            while j < n and s[j] == ch:\\n                j += 1\\n            length = j - i\\n            runs.setdefault(ch, []).append(length)\\n            i = j\\n        \\n        best = 0\\n        \\n        # For each character, binary-search the maximum k with at least 3 occurrences of c^k\\n        for ch, lengths in runs.items():\\n            total = sum(lengths)\\n            if total < 3:\\n                continue  # can't get 3 substrings of even length 1\\n            \\n            lo, hi = 1, max(lengths)\\n            # f(k) = total number of substrings equal to c^k\\n            #       = sum_{L in lengths} max(0, L - k + 1)\\n            def count_k(k):\\n                cnt = 0\\n                for L in lengths:\\n                    if L >= k:\\n                        cnt += L - k + 1\\n                        if cnt >= 3:\\n                            break\\n                return cnt\\n            \\n            # Find largest k such that count_k(k) >= 3\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                if count_k(mid) >= 3:\\n                    best = max(best, mid)\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n        \\n        return best if best > 0 else -1\\n\"",
  "207_14631217_python-updated-time": "1745245939735",
  "2734_14631217_javascript-updated-time": "1747135120135",
  "332_14631217_python": "\"import collections\\nimport heapq\\n\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \\\"\\\"\\\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        graph = collections.defaultdict(list)\\n        for src, dst in tickets:\\n            heapq.heappush(graph[src], dst)\\n        \\n        route = []\\n        \\n        def visit(airport):\\n            while graph[airport]:\\n                next_airport = heapq.heappop(graph[airport])\\n                visit(next_airport)\\n            route.append(airport)\\n        \\n        visit('JFK')\\n        return route[::-1]\\n\"",
  "3272_14631217_python-updated-time": "1747413523216",
  "3337_14631217_python": "\"class Solution(object):\\n    def countSubstrings(self, s, c):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type c: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        k = s.count(c)\\n        # Number of ways to choose start and end among k occurrences,\\n        # allowing start == end: k * (k + 1) / 2\\n        return k * (k + 1) // 2\\n\"",
  "606_14631217_python-updated-time": "1745448678541",
  "1473_14631217_python-updated-time": "1746345509354",
  "3819_14631217_python": "\"from collections import defaultdict\\nimport bisect\\n\\nclass Solution(object):\\n    def countCoveredBuildings(self, n, buildings):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type buildings: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) Gather rows and columns\\n        rows = defaultdict(list)\\n        cols = defaultdict(list)\\n        for x, y in buildings:\\n            rows[x].append(y)\\n            cols[y].append(x)\\n        \\n        # 2) Sort each\\n        for x in rows:\\n            rows[x].sort()\\n        for y in cols:\\n            cols[y].sort()\\n        \\n        # 3) Check each building\\n        covered = 0\\n        for x, y in buildings:\\n            row = rows[x]\\n            col = cols[y]\\n            # Positions in the sorted lists\\n            i = bisect.bisect_left(row, y)\\n            j = bisect.bisect_left(col, x)\\n            \\n            # Need one smaller and one larger on both\\n            has_left  = (i > 0)\\n            has_right = (i < len(row) - 1)\\n            has_up    = (j > 0)\\n            has_down  = (j < len(col) - 1)\\n            \\n            if has_left and has_right and has_up and has_down:\\n                covered += 1\\n        \\n        return covered\\n\"",
  "3074_14631217_pythondata-updated-time": "1747305612232",
  "1812_14631217_python-updated-time": "1746453203198",
  "3754_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxDistance(self, s, k):\\n        # unit-step vectors\\n        dx = {'N':0, 'S':0, 'E':1, 'W':-1}\\n        dy = {'N':1, 'S':-1, 'E':0, 'W':0}\\n\\n        max_global = 0\\n\\n        # try all four sign-pairs (s_x, s_y)\\n        for sx, sy in ((1,1), (1,-1), (-1,1), (-1,-1)):\\n            # precompute each direction's signed weight, and the best possible step\\n            weight = {c: sx*dx[c] + sy*dy[c] for c in 'NSEW'}\\n            best_step = max(weight.values())\\n\\n            signed_sum = 0   # running dot-product\\n            sum_sel    = 0   # sum of the top-k improvements so far\\n            selected   = []  # min-heap of selected r's\\n            eligible   = []  # max-heap (via negatives) of the rest\\n\\n            best_this_pass = 0\\n\\n            for c in s:\\n                w = weight[c]\\n                signed_sum += w\\n\\n                # improvement if we changed this move to the best possible one\\n                r = best_step - w\\n                if r > 0:\\n                    heapq.heappush(eligible, -r)\\n\\n                # if we still have room, pull the best from eligible\\n                while len(selected) < k and eligible:\\n                    rr = -heapq.heappop(eligible)\\n                    heapq.heappush(selected, rr)\\n                    sum_sel += rr\\n\\n                # if there's a better candidate than our current worst in selected, swap\\n                if eligible and selected and -eligible[0] > selected[0]:\\n                    rr = -heapq.heappop(eligible)\\n                    rs = heapq.heapreplace(selected, rr)\\n                    sum_sel += rr - rs\\n\\n                # current achievable dot = exact prefix + best k edits\\n                curr = signed_sum + sum_sel\\n                if curr > best_this_pass:\\n                    best_this_pass = curr\\n\\n            # update across all sign-pairs\\n            if best_this_pass > max_global:\\n                max_global = best_this_pass\\n\\n        return max_global\\n\"",
  "1773_14631217_mysql-updated-time": "1746444872099",
  "1933_14631217_python": "\"import re\\n\\nclass Solution(object):\\n    def numDifferentIntegers(self, word):\\n        parts = re.findall(r'\\\\d+', word)\\n        seen = set()\\n        for p in parts:\\n            p = p.lstrip('0')\\n            if p == '':\\n                p = '0'\\n            seen.add(p)\\n        return len(seen)\\n\"",
  "2759_14631217_javascript": "\"function flat(arr, n) {\\n  const result = [];\\n\\n  function helper(subArr, depth) {\\n    for (const el of subArr) {\\n      if (Array.isArray(el) && depth < n) {\\n        helper(el, depth + 1);\\n      } else {\\n        result.push(el);\\n      }\\n    }\\n  }\\n\\n  helper(arr, 0);\\n  return result;\\n}\\n\"",
  "3170_14631217_python": "\"class Solution(object):\\n    def findIndices(self, nums, indexDifference, valueDifference):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type indexDifference: int\\n        :type valueDifference: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        d, v = indexDifference, valueDifference\\n\\n        # Edge case: any pair works if both diffs are zero\\n        if d == 0 and v == 0:\\n            return [0, 0]\\n\\n        # Build prefix max/min with their indices\\n        pref_max = [0] * n\\n        pref_min = [0] * n\\n        pref_max_idx = [0] * n\\n        pref_min_idx = [0] * n\\n\\n        curr_max = nums[0]\\n        curr_min = nums[0]\\n        imax = imin = 0\\n        pref_max[0], pref_min[0] = curr_max, curr_min\\n        pref_max_idx[0], pref_min_idx[0] = 0, 0\\n        for i in range(1, n):\\n            if nums[i] > curr_max:\\n                curr_max, imax = nums[i], i\\n            if nums[i] < curr_min:\\n                curr_min, imin = nums[i], i\\n            pref_max[i], pref_max_idx[i] = curr_max, imax\\n            pref_min[i], pref_min_idx[i] = curr_min, imin\\n\\n        # Build suffix max/min with their indices\\n        suff_max = [0] * n\\n        suff_min = [0] * n\\n        suff_max_idx = [0] * n\\n        suff_min_idx = [0] * n\\n\\n        curr_max = nums[-1]\\n        curr_min = nums[-1]\\n        imax = imin = n - 1\\n        suff_max[-1], suff_min[-1] = curr_max, curr_min\\n        suff_max_idx[-1], suff_min_idx[-1] = imax, imin\\n        for i in range(n - 2, -1, -1):\\n            if nums[i] > curr_max:\\n                curr_max, imax = nums[i], i\\n            if nums[i] < curr_min:\\n                curr_min, imin = nums[i], i\\n            suff_max[i], suff_max_idx[i] = curr_max, imax\\n            suff_min[i], suff_min_idx[i] = curr_min, imin\\n\\n        # For each i, check prefix [0..i-d] and suffix [i+d..n-1]\\n        for i in range(n):\\n            # prefix side\\n            j = i - d\\n            if j >= 0:\\n                # check against prefix max\\n                if abs(nums[i] - pref_max[j]) >= v:\\n                    return [i, pref_max_idx[j]]\\n                # check against prefix min\\n                if abs(nums[i] - pref_min[j]) >= v:\\n                    return [i, pref_min_idx[j]]\\n            # suffix side\\n            j = i + d\\n            if j < n:\\n                if abs(suff_max[j] - nums[i]) >= v:\\n                    return [i, suff_max_idx[j]]\\n                if abs(suff_min[j] - nums[i]) >= v:\\n                    return [i, suff_min_idx[j]]\\n\\n        return [-1, -1]\\n\"",
  "2606_14631217_python": "\"class Solution(object):\\n    def onesMinusZeros(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        onesRow = [sum(row) for row in grid]\\n        onesCol = [0] * n\\n        for row in grid:\\n            for j, v in enumerate(row):\\n                onesCol[j] += v\\n        res = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j] = 2 * onesRow[i] + 2 * onesCol[j] - m - n\\n        return res\\n\"",
  "2728_14631217_python": "\"class Solution(object):\\n    def matrixSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        for row in nums:\\n            row.sort()\\n        \\n        score = 0\\n        cols = len(nums[0])\\n        \\n        for col in range(cols):\\n            max_in_col = 0\\n            for row in nums:\\n                max_in_col = max(max_in_col, row[col])\\n            score += max_in_col\\n        \\n        return score\\n\"",
  "1230_14631217_python": "\"class Solution(object):\\n    def maxAbsValExpr(self, arr1, arr2):\\n        \\\"\\\"\\\"\\n        :type arr1: List[int]\\n        :type arr2: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(arr1)\\n        res = 0\\n\\n        for p, q in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\\n            min_val = float('inf')\\n            max_val = float('-inf')\\n\\n            for i in range(n):\\n                val = p * arr1[i] + q * arr2[i] + i\\n                min_val = min(min_val, val)\\n                max_val = max(max_val, val)\\n\\n            res = max(res, max_val - min_val)\\n\\n        return res\\n\"",
  "592_14631217_python": "\"import re\\n\\nclass Solution(object):\\n    def fractionAddition(self, expression):\\n        # helper gcd for Python versions without math.gcd\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        # Extract all signed fractions\\n        tokens = re.findall(r'[+-]?\\\\d+/\\\\d+', expression)\\n\\n        # Start with 0/1\\n        num, den = 0, 1\\n\\n        for token in tokens:\\n            a_str, b_str = token.split('/')\\n            a, b = int(a_str), int(b_str)\\n            # Add a/b to num/den:\\n            #   num/den + a/b = (num*b + a*den) / (den*b)\\n            num = num * b + a * den\\n            den = den * b\\n            # Reduce\\n            g = gcd(abs(num), den)\\n            num //= g\\n            den //= g\\n\\n        # If result is zero, force denominator = 1\\n        if num == 0:\\n            den = 1\\n\\n        return str(num) + '/' + str(den)\\n\"",
  "396_14631217_python": "\"class Solution:\\n    def maxRotateFunction(self, nums):\\n        n = len(nums)\\n        total_sum = sum(nums)\\n        f = sum(i * num for i, num in enumerate(nums))\\n        res = f\\n        \\n        for i in range(n - 1, 0, -1):\\n            f = f + total_sum - n * nums[i]\\n            res = max(res, f)\\n        \\n        return res\\n\"",
  "1334_14631217_python-updated-time": "1746882379003",
  "940_14631217_python-updated-time": "1746002750352",
  "2457_14631217_python-updated-time": "1746964951243",
  "1884_14631217_python-updated-time": "1746531640964",
  "2477_14631217_python-updated-time": "1746965798568",
  "3686_14631217_python-updated-time": "1747596966297",
  "1827_14631217_mysql": "\"SELECT\\n  tweet_id\\nFROM\\n  Tweets\\nWHERE\\n  CHAR_LENGTH(content) > 15;\\n\"",
  "577_14631217_mysql-updated-time": "1745447965695",
  "274_14631217_python": "\"class Solution(object):\\n    def hIndex(self, citations):\\n        \\\"\\\"\\\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        citations.sort(reverse=True)\\n        h = 0\\n        for i, c in enumerate(citations):\\n            if c >= i + 1:\\n                h = i + 1\\n            else:\\n                break\\n        return h\\n\"",
  "3442_14631217_python": "\"class Solution(object):\\n    def maxTotalReward(self, rewardValues):\\n        \\\"\\\"\\\"\\n        :type rewardValues: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Only one copy of each value can ever be used\\n        arr = sorted(set(rewardValues))\\n        cap = arr[-1]           # we'll only track sums j < cap\\n        dp = [False] * cap      # dp[j] = True iff we can build a superincreasing\\n                                # subset of processed values summing exactly to j\\n        dp[0] = True\\n        ans = 0\\n\\n        for v in arr:\\n            # 1) see what's the best prefix‐sum we can get that is < v\\n            bestPrev = 0\\n            for j in range(v - 1, -1, -1):\\n                if dp[j]:\\n                    bestPrev = j\\n                    break\\n            # combining that prefix with v itself gives total v + bestPrev\\n            ans = max(ans, v + bestPrev)\\n\\n            # 2) now incorporate v into our dp (for future values)\\n            #    we can only append v onto prefixes of sum j < v,\\n            #    and we only care about sums < cap\\n            #    so j must satisfy j <= min(v-1, cap-1-v)\\n            if v < cap:\\n                jMax = min(v - 1, cap - 1 - v)\\n                for j in range(jMax, -1, -1):\\n                    if dp[j]:\\n                        dp[j + v] = True\\n\\n        return ans\\n\"",
  "2447_14631217_python": "\"class Solution(object):\\n    def mergeSimilarItems(self, items1, items2):\\n        from collections import defaultdict\\n\\n        weight_map = defaultdict(int)\\n\\n        for v, w in items1:\\n            weight_map[v] += w\\n        for v, w in items2:\\n            weight_map[v] += w\\n\\n        return sorted([[v, weight_map[v]] for v in weight_map])\\n\"",
  "1728_14631217_python": "\"class Fancy:\\n    MOD = 10**9 + 7\\n\\n    def __init__(self):\\n        # Sequence of tuples: (val, mul_at_append, add_at_append, inv_mul_at_append)\\n        self.data = []\\n        # Global affine transformation parameters:\\n        #   x -> x * curr_mul + curr_add\\n        self.curr_mul = 1\\n        self.curr_add = 0\\n        # Maintain inverse of curr_mul so we can \\\"undo\\\" prefix multipliers\\n        self.inv_mul = 1\\n\\n    def append(self, val):\\n        # Record the raw val and the current transformation state\\n        self.data.append((\\n            val,\\n            self.curr_mul,\\n            self.curr_add,\\n            self.inv_mul\\n        ))\\n\\n    def addAll(self, inc):\\n        # x -> x + inc\\n        self.curr_add = (self.curr_add + inc) % self.MOD\\n\\n    def multAll(self, m):\\n        # x -> x * m\\n        self.curr_mul = self.curr_mul * m % self.MOD\\n        self.curr_add = self.curr_add * m % self.MOD\\n        # Update inv_mul *= inverse(m) mod\\n        inv_m = pow(m, self.MOD - 2, self.MOD)\\n        self.inv_mul = self.inv_mul * inv_m % self.MOD\\n\\n    def getIndex(self, idx):\\n        if idx < 0 or idx >= len(self.data):\\n            return -1\\n\\n        val, mul0, add0, inv_mul0 = self.data[idx]\\n        # Compute the net multiplier since append:\\n        #   gm_ratio = curr_mul / mul0  mod => curr_mul * inv(mul0)\\n        gm_ratio = self.curr_mul * inv_mul0 % self.MOD\\n        # Compute the net addition:\\n        #   ga_ratio = curr_add - add0 * gm_ratio\\n        ga_ratio = (self.curr_add - add0 * gm_ratio) % self.MOD\\n\\n        # Apply to the raw value\\n        return (val * gm_ratio + ga_ratio) % self.MOD\\n\"",
  "16_14631217_python": "\"class Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        closest = float('inf')\\n        n = len(nums)\\n\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                if abs(total - target) < abs(closest - target):\\n                    closest = total\\n                if total < target:\\n                    left += 1\\n                elif total > target:\\n                    right -= 1\\n                else:\\n                    return target\\n\\n        return closest\\n\"",
  "874_14631217_python": "\"class Solution(object):\\n    def backspaceCompare(self, s, t):\\n        i, j = len(s) - 1, len(t) - 1\\n        skip_s = skip_t = 0\\n        \\n        while i >= 0 or j >= 0:\\n            # find next valid char in s\\n            while i >= 0:\\n                if s[i] == '#':\\n                    skip_s += 1\\n                    i -= 1\\n                elif skip_s > 0:\\n                    skip_s -= 1\\n                    i -= 1\\n                else:\\n                    break\\n            \\n            # find next valid char in t\\n            while j >= 0:\\n                if t[j] == '#':\\n                    skip_t += 1\\n                    j -= 1\\n                elif skip_t > 0:\\n                    skip_t -= 1\\n                    j -= 1\\n                else:\\n                    break\\n            \\n            # compare characters\\n            if i >= 0 and j >= 0:\\n                if s[i] != t[j]:\\n                    return False\\n            elif i >= 0 or j >= 0:\\n                return False\\n            \\n            i -= 1\\n            j -= 1\\n        \\n        return True\\n\"",
  "3058_14631217_python-updated-time": "1747305181125",
  "1043_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def gridIllumination(self, n, lamps, queries):\\n        lamp_set = set()\\n        row = defaultdict(int)\\n        col = defaultdict(int)\\n        diag = defaultdict(int)\\n        anti_diag = defaultdict(int)\\n\\n        for r, c in lamps:\\n            if (r, c) in lamp_set:\\n                continue\\n            lamp_set.add((r, c))\\n            row[r] += 1\\n            col[c] += 1\\n            diag[r - c] += 1\\n            anti_diag[r + c] += 1\\n\\n        ans = []\\n        for r, c in queries:\\n            if row[r] > 0 or col[c] > 0 or diag[r - c] > 0 or anti_diag[r + c] > 0:\\n                ans.append(1)\\n            else:\\n                ans.append(0)\\n\\n            for dx in (-1, 0, 1):\\n                for dy in (-1, 0, 1):\\n                    nr, nc = r + dx, c + dy\\n                    if (nr, nc) in lamp_set:\\n                        lamp_set.remove((nr, nc))\\n                        row[nr] -= 1\\n                        col[nc] -= 1\\n                        diag[nr - nc] -= 1\\n                        anti_diag[nr + nc] -= 1\\n\\n        return ans\\n\"",
  "638_14631217_python-updated-time": "1745782376327",
  "892_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def shortestSubarray(self, nums, k):\\n        n = len(nums)\\n        prefix = [0] * (n + 1)\\n        for i in range(n):\\n            prefix[i+1] = prefix[i] + nums[i]\\n        \\n        dq = deque()\\n        res = n + 1\\n\\n        for i in range(n + 1):\\n            while dq and prefix[i] - prefix[dq[0]] >= k:\\n                res = min(res, i - dq.popleft())\\n            while dq and prefix[i] <= prefix[dq[-1]]:\\n                dq.pop()\\n            dq.append(i)\\n        \\n        return res if res <= n else -1\\n\"",
  "1160_14631217_python": "\"class Solution(object):\\n    def numTilePossibilities(self, tiles):\\n        \\\"\\\"\\\"\\n        :type tiles: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        count = Counter(tiles)\\n        self.res = 0\\n\\n        def backtrack(counter):\\n            for ch in counter:\\n                if counter[ch] == 0:\\n                    continue\\n                self.res += 1\\n                counter[ch] -= 1\\n                backtrack(counter)\\n                counter[ch] += 1\\n\\n        backtrack(count)\\n        return self.res\\n\"",
  "1876_14631217_python-updated-time": "1746531802411",
  "1831_14631217_python-updated-time": "1746454005766",
  "1386_14631217_python-updated-time": "1746259659810",
  "2457_14631217_python": "\"class Solution(object):\\n    def countSpecialNumbers(self, n):\\n        digits = list(map(int, str(n)))\\n        length = len(digits)\\n        res = 0\\n\\n        # Count special numbers with length less than len(n)\\n        for i in range(1, length):\\n            count = 9\\n            available = 9\\n            for j in range(i - 1):\\n                count *= available\\n                available -= 1\\n            res += count\\n\\n        # Count special numbers with same length as n\\n        seen = set()\\n        for i in range(length):\\n            for d in range(0 if i else 1, digits[i]):\\n                if d in seen:\\n                    continue\\n                count = 1\\n                available = 9 - i\\n                for j in range(i + 1, length):\\n                    count *= available\\n                    available -= 1\\n                res += count\\n            if digits[i] in seen:\\n                break\\n            seen.add(digits[i])\\n        else:\\n            res += 1\\n\\n        return res\\n\"",
  "2491_14631217_python-updated-time": "1746966440409",
  "3632_14631217_python-updated-time": "1747596689404",
  "2495_14631217_mysql-updated-time": "1746907937547",
  "1288_14631217_python": "\"class Solution(object):\\n    def maximumSum(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        no_del = [0] * n\\n        one_del = [0] * n\\n        \\n        no_del[0] = arr[0]\\n        one_del[0] = float('-inf')\\n        res = arr[0]\\n        \\n        for i in range(1, n):\\n            no_del[i] = max(arr[i], no_del[i-1] + arr[i])\\n            one_del[i] = max(one_del[i-1] + arr[i], no_del[i-1])  # delete current or one before\\n            res = max(res, no_del[i], one_del[i])\\n        \\n        return res\\n\"",
  "1128_14631217_python": "\"class Solution:\\n    def removeDuplicates(self, s):\\n        stack = []\\n        for ch in s:\\n            if stack and stack[-1] == ch:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return ''.join(stack)\\n\"",
  "1880_14631217_python-updated-time": "1746531563779",
  "1256_14631217_python-updated-time": "1746261575007",
  "3790_14631217_python-updated-time": "1747681333927",
  "643_14631217_python-updated-time": "1745782526657",
  "592_14631217_python-updated-time": "1745448376971",
  "3891_14631217_mysql": "\"WITH UserCategories AS (\\n  -- get each (user, category) only once\\n  SELECT DISTINCT\\n    pp.user_id,\\n    pi.category\\n  FROM ProductPurchases AS pp\\n  JOIN ProductInfo       AS pi\\n    ON pp.product_id = pi.product_id\\n)\\n\\nSELECT\\n  uc1.category      AS category1,\\n  uc2.category      AS category2,\\n  COUNT(*)          AS customer_count\\nFROM UserCategories AS uc1\\nJOIN UserCategories AS uc2\\n  ON uc1.user_id = uc2.user_id\\n  -- only take each unordered pair once:\\n  AND uc1.category < uc2.category\\nGROUP BY\\n  uc1.category,\\n  uc2.category\\nHAVING\\n  customer_count >= 3\\nORDER BY\\n  customer_count DESC,\\n  category1      ASC,\\n  category2      ASC;\\n\"",
  "3423_14631217_python-updated-time": "1747483917713",
  "2787_14631217_python-updated-time": "1747220653213",
  "1211_14631217_python-updated-time": "1746260274404",
  "1550_14631217_python-updated-time": "1746347293207",
  "1782_14631217_python": "\"class Solution:\\n    def getSmallestString(self, n, k):\\n        # Start with all 'a's: total value = n\\n        res = ['a'] * n\\n        rem = k - n  # remaining value to distribute\\n\\n        # Fill from the end with as large letters as needed\\n        i = n - 1\\n        while rem > 0:\\n            add = min(25, rem)  # can increase 'a' by up to 25 to reach 'z'\\n            res[i] = chr(ord('a') + add)\\n            rem -= add\\n            i -= 1\\n\\n        return \\\"\\\".join(res)\\n\"",
  "2284_14631217_python-updated-time": "1746803093266",
  "3712_14631217_python-updated-time": "1747659027183",
  "896_14631217_python-updated-time": "1746001302721",
  "647_14631217_python": "\"class Solution(object):\\n    def countSubstrings(self, s):\\n        n = len(s)\\n        count = 0\\n        \\n        for center in range(2 * n - 1):\\n            left = center // 2\\n            right = left + center % 2\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                count += 1\\n                left -= 1\\n                right += 1\\n        \\n        return count\\n\"",
  "2206_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs):\\n        \\\"\\\"\\\"\\n        :type bombs: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(bombs)\\n        # Build graph: edge i->j if bomb j is within range of bomb i\\n        adj = [[] for _ in range(n)]\\n        for i in range(n):\\n            x_i, y_i, r_i = bombs[i]\\n            r2 = r_i * r_i\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                x_j, y_j, _ = bombs[j]\\n                dx = x_j - x_i\\n                dy = y_j - y_i\\n                if dx*dx + dy*dy <= r2:\\n                    adj[i].append(j)\\n        \\n        def bfs(start):\\n            # Count how many bombs can be detonated starting from 'start'\\n            seen = {start}\\n            q = deque([start])\\n            while q:\\n                u = q.popleft()\\n                for v in adj[u]:\\n                    if v not in seen:\\n                        seen.add(v)\\n                        q.append(v)\\n            return len(seen)\\n        \\n        # Try detonating each bomb and take the maximum reach\\n        ans = 0\\n        for i in range(n):\\n            ans = max(ans, bfs(i))\\n        \\n        return ans\\n\"",
  "3562_14631217_python-updated-time": "1747656387545",
  "2387_14631217_python-updated-time": "1746881916338",
  "861_14631217_python-updated-time": "1745879361390",
  "2095_14631217_python-updated-time": "1746639299546",
  "489_14631217_python-updated-time": "1746445124203",
  "965_14631217_python": "\"class Solution:\\n    def numUniqueEmails(self, emails):\\n        seen = set()\\n\\n        for email in emails:\\n            local, domain = email.split('@')\\n            # Ignore everything after first '+' and remove all '.'\\n            local = local.split('+')[0].replace('.', '')\\n            normalized = local + '@' + domain\\n            seen.add(normalized)\\n\\n        return len(seen)\\n\"",
  "1900_14631217_python-updated-time": "1746532144675",
  "204_14631217_python": "\"class Solution(object):\\n    def countPrimes(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if n < 2:\\n            return 0\\n        is_prime = [True] * n\\n        is_prime[0] = is_prime[1] = False\\n        for i in range(2, int(n**0.5) + 1):\\n            if is_prime[i]:\\n                for j in range(i*i, n, i):\\n                    is_prime[j] = False\\n        return sum(is_prime)\\n\"",
  "2647_14631217_python-updated-time": "1747066679702",
  "2827_14631217_python-updated-time": "1747140073493",
  "3487_14631217_python-updated-time": "1747578095940",
  "3076_14631217_pythondata": "\"import pandas as pd\\n\\n# Assuming `players` is your DataFrame\\ndef getDataframeSize(df):\\n    \\\"\\\"\\\"\\n    Returns the number of rows and columns of the DataFrame as a list: [n_rows, n_columns].\\n    \\\"\\\"\\\"\\n    return list(df.shape)\"",
  "1559_14631217_python": "\"class Solution(object):\\n    def cherryPickup(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        rows, cols = len(grid), len(grid[0])\\n        # dp[c1][c2] = max cherries collected when robot1 is at column c1\\n        # and robot2 is at column c2 on the current row\\n        # initialize for row 0\\n        dp = [[-float('inf')] * cols for _ in range(cols)]\\n        dp[0][cols-1] = grid[0][0] + grid[0][cols-1]\\n        \\n        for r in range(1, rows):\\n            new_dp = [[-float('inf')] * cols for _ in range(cols)]\\n            for c1 in range(cols):\\n                for c2 in range(cols):\\n                    if dp[c1][c2] < 0:\\n                        continue\\n                    # try all moves for both robots\\n                    for nc1 in (c1-1, c1, c1+1):\\n                        for nc2 in (c2-1, c2, c2+1):\\n                            if 0 <= nc1 < cols and 0 <= nc2 < cols:\\n                                val = dp[c1][c2] + grid[r][nc1]\\n                                if nc1 != nc2:\\n                                    val += grid[r][nc2]\\n                                if val > new_dp[nc1][nc2]:\\n                                    new_dp[nc1][nc2] = val\\n            dp = new_dp\\n        \\n        # answer is the max over final positions\\n        ans = 0\\n        for c1 in range(cols):\\n            for c2 in range(cols):\\n                if dp[c1][c2] > ans:\\n                    ans = dp[c1][c2]\\n        return ans\\n\"",
  "2286_14631217_python-updated-time": "1746803174174",
  "529_14631217_python-updated-time": "1745446732624",
  "2766_14631217_python": "\"class Solution(object):\\n    def findThePrefixCommonArray(self, A, B):\\n        \\\"\\\"\\\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(A)\\n        # Track seen elements in A and B\\n        seenA = [False] * (n + 1)\\n        seenB = [False] * (n + 1)\\n        common = 0\\n        result = [0] * n\\n\\n        for i in range(n):\\n            a = A[i]\\n            b = B[i]\\n            # Mark A[i]\\n            seenA[a] = True\\n            if seenB[a]:  # A[i] already appeared in B prefix\\n                common += 1\\n            # Mark B[i]\\n            seenB[b] = True\\n            if seenA[b]:  # B[i] already appeared in A prefix\\n                common += 1\\n            # If a == b, we counted only once because seenB[a] was false before\\n            result[i] = common\\n\\n        return result\\n\"",
  "3640_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxFrequency(self, nums, k, numOperations):\\n        n = len(nums)\\n        freq = Counter(nums)\\n        events = []\\n        for v in nums:\\n            L = v - k\\n            R = v + k\\n            events.append((L, 1))\\n            events.append((R + 1, -1))\\n        events.sort()\\n        queries = sorted(freq)\\n        cnt_cover = {}\\n        C = 0\\n        i = 0\\n        best_cover = 0\\n        for q in queries:\\n            while i < len(events) and events[i][0] <= q:\\n                C += events[i][1]\\n                i += 1\\n            cnt_cover[q] = C\\n        while i < len(events):\\n            C += events[i][1]\\n            i += 1\\n        best_cover = 0\\n        curr = 0\\n        for pos, delta in events:\\n            curr += delta\\n            if curr > best_cover:\\n                best_cover = curr\\n        ans = min(best_cover, numOperations)\\n        for t, c0 in freq.items():\\n            c = cnt_cover.get(t, 0)\\n            val = c0 + (numOperations if c - c0 >= numOperations else c - c0)\\n            if val > ans:\\n                ans = val\\n        return ans\\n\"",
  "2542_14631217_python": "\"class Solution:\\n    def averageValue(self, nums):\\n        total = 0\\n        count = 0\\n        for x in nums:\\n            if x % 6 == 0:\\n                total += x\\n                count += 1\\n        return total // count if count else 0\\n\"",
  "328_14631217_python": "\"# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def oddEvenList(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        if not head or not head.next:\\n            return head\\n        \\n        odd = head\\n        even = head.next\\n        even_head = even\\n        \\n        while even and even.next:\\n            odd.next = even.next\\n            odd = odd.next\\n            even.next = odd.next\\n            even = even.next\\n        \\n        odd.next = even_head\\n        return head\\n\"",
  "1956_14631217_python-updated-time": "1746544596699",
  "2400_14631217_python-updated-time": "1746883620812",
  "1352_14631217_python-updated-time": "1746259298856",
  "2552_14631217_python": "\"class Solution(object):\\n    def maximumSubarraySum(self, nums, k):\\n        from collections import defaultdict\\n        \\n        freq = defaultdict(int)\\n        curr_sum = 0\\n        dup = 0\\n        ans = 0\\n        \\n        # Initialize first window\\n        for i in range(k):\\n            x = nums[i]\\n            curr_sum += x\\n            freq[x] += 1\\n            if freq[x] == 2:\\n                dup += 1\\n        \\n        if dup == 0:\\n            ans = curr_sum\\n        \\n        # Slide the window\\n        for i in range(k, len(nums)):\\n            # Remove outgoing\\n            out = nums[i-k]\\n            freq[out] -= 1\\n            if freq[out] == 1:\\n                dup -= 1\\n            curr_sum -= out\\n            \\n            # Add incoming\\n            inc = nums[i]\\n            curr_sum += inc\\n            freq[inc] += 1\\n            if freq[inc] == 2:\\n                dup += 1\\n            \\n            # If no duplicates, consider sum\\n            if dup == 0 and curr_sum > ans:\\n                ans = curr_sum\\n        \\n        return ans\\n\"",
  "3461_14631217_python": "\"class Solution(object):\\n    def minimumArea(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # initialize boundaries to extreme values\\n        min_row = float('inf')\\n        max_row = -float('inf')\\n        min_col = float('inf')\\n        max_col = -float('inf')\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # scan the grid to update boundaries\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1:\\n                    if r < min_row:\\n                        min_row = r\\n                    if r > max_row:\\n                        max_row = r\\n                    if c < min_col:\\n                        min_col = c\\n                    if c > max_col:\\n                        max_col = c\\n        \\n        # compute height and width of the enclosing rectangle\\n        height = max_row - min_row + 1\\n        width  = max_col - min_col + 1\\n        \\n        return height * width\\n\"",
  "729_14631217_python": "\"class MyCalendar(object):\\n    def __init__(self):\\n        # List to store booked events as (start, end) tuples\\n        self.events = []\\n\\n    def book(self, start, end):\\n        \\\"\\\"\\\"\\n        :type start: int\\n        :type end: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # Check for overlap with any existing event\\n        for s0, e0 in self.events:\\n            # Overlap exists if start < e0 and s0 < end\\n            if start < e0 and s0 < end:\\n                return False\\n        # No overlap; add the new event\\n        self.events.append((start, end))\\n        return True\\n\"",
  "2893_14631217_python": "\"class Solution:\\n    def maxScore(self, nums, x):\\n        n = len(nums)\\n        even = odd = float('-inf')\\n        if nums[0] % 2 == 0:\\n            even = nums[0]\\n        else:\\n            odd = nums[0]\\n        \\n        for i in range(1, n):\\n            val = nums[i]\\n            if val % 2 == 0:\\n                even = max(even + val, odd + val - x)\\n            else:\\n                odd = max(odd + val, even + val - x)\\n        \\n        return max(even, odd)\\n\"",
  "2725_14631217_python-updated-time": "1747134564176",
  "3450_14631217_python": "\"class Solution(object):\\n    def numberOfChild(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # One full back-and-forth takes 2*(n-1) passes\\n        period = 2 * (n - 1)\\n        r = k % period\\n        # If r ≤ n-1, we're moving right from 0; otherwise we’re on the return leg.\\n        if r <= n - 1:\\n            return r\\n        else:\\n            return period - r\\n\"",
  "1276_14631217_python-updated-time": "1746345331760",
  "1461_14631217_python-updated-time": "1746345264415",
  "1983_14631217_python-updated-time": "1746624888089",
  "2246_14631217_python-updated-time": "1746801873386",
  "2254_14631217_python-updated-time": "1746802033349",
  "3583_14631217_python-updated-time": "1747577563313",
  "3150_14631217_python": "\"class Solution(object):\\n    def shortestBeautifulSubstring(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # record positions of '1's\\n        ones = [i for i, ch in enumerate(s) if ch == '1']\\n        if len(ones) < k:\\n            return \\\"\\\"\\n        # find minimal window length over every k consecutive ones\\n        min_len = n + 1\\n        substrings = []\\n        for i in range(len(ones) - k + 1):\\n            start = ones[i]\\n            end = ones[i + k - 1]\\n            length = end - start + 1\\n            if length < min_len:\\n                min_len = length\\n                substrings = [s[start:end+1]]\\n            elif length == min_len:\\n                substrings.append(s[start:end+1])\\n        # return lexicographically smallest among them\\n        return min(substrings)\\n\"",
  "2411_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def spiralMatrix(self, m, n, head):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :type head: Optional[ListNode]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # Initialize m x n matrix filled with -1\\n        matrix = [[-1] * n for _ in range(m)]\\n        \\n        top, bottom = 0, m - 1\\n        left, right = 0, n - 1\\n        curr = head\\n        \\n        while curr and top <= bottom and left <= right:\\n            # Traverse from left to right along the top row\\n            for col in range(left, right + 1):\\n                if not curr:\\n                    break\\n                matrix[top][col] = curr.val\\n                curr = curr.next\\n            top += 1\\n            if not curr:\\n                break\\n            \\n            # Traverse from top to bottom along the right column\\n            for row in range(top, bottom + 1):\\n                if not curr:\\n                    break\\n                matrix[row][right] = curr.val\\n                curr = curr.next\\n            right -= 1\\n            if not curr:\\n                break\\n            \\n            # Traverse from right to left along the bottom row\\n            if top <= bottom:\\n                for col in range(right, left - 1, -1):\\n                    if not curr:\\n                        break\\n                    matrix[bottom][col] = curr.val\\n                    curr = curr.next\\n                bottom -= 1\\n            if not curr:\\n                break\\n            \\n            # Traverse from bottom to top along the left column\\n            if left <= right:\\n                for row in range(bottom, top - 1, -1):\\n                    if not curr:\\n                        break\\n                    matrix[row][left] = curr.val\\n                    curr = curr.next\\n                left += 1\\n        \\n        return matrix\\n\"",
  "2025_14631217_python-updated-time": "1746627065135",
  "2955_14631217_python": "\"class Solution(object):\\n    def accountBalanceAfterPurchase(self, purchaseAmount):\\n        rounded = int((purchaseAmount + 5) / 10) * 10\\n        return 100 - rounded\\n\"",
  "2078_14631217_python-updated-time": "1746638640494",
  "2027_14631217_python": "\"class Solution:\\n    def maximumRemovals(self, s, p, removable):\\n        def is_subsequence(removed):\\n            i = j = 0\\n            while i < len(s) and j < len(p):\\n                if i in removed:\\n                    i += 1\\n                    continue\\n                if s[i] == p[j]:\\n                    j += 1\\n                i += 1\\n            return j == len(p)\\n\\n        left, right = 0, len(removable)\\n        ans = 0\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            removed = set(removable[:mid])\\n            if is_subsequence(removed):\\n                ans = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return ans\\n\"",
  "2779_14631217_python-updated-time": "1747137316003",
  "1497_14631217_python": "\"class CustomStack(object):\\n    def __init__(self, maxSize):\\n        self.stack = []\\n        self.inc = [0] * maxSize\\n        self.maxSize = maxSize\\n\\n    def push(self, x):\\n        if len(self.stack) < self.maxSize:\\n            self.stack.append(x)\\n\\n    def pop(self):\\n        if not self.stack:\\n            return -1\\n        i = len(self.stack) - 1\\n        if i > 0:\\n            self.inc[i - 1] += self.inc[i]\\n        res = self.stack.pop() + self.inc[i]\\n        self.inc[i] = 0\\n        return res\\n\\n    def increment(self, k, val):\\n        i = min(k, len(self.stack)) - 1\\n        if i >= 0:\\n            self.inc[i] += val\\n\"",
  "2374_14631217_python": "\"class Solution:\\n    def totalSteps(self, nums):\\n        stack = []  # pairs of (value, steps_to_remove)\\n        ans = 0\\n        \\n        for x in nums:\\n            popped_max = 0\\n            popped_any = False\\n            \\n            # Pop all elements that are <= current, they will be \\\"shielded\\\" by x\\n            while stack and stack[-1][0] <= x:\\n                popped_any = True\\n                popped_max = max(popped_max, stack[-1][1])\\n                stack.pop()\\n            \\n            if not stack:\\n                # No larger to the left, this x never causes a removal chain\\n                steps = 0\\n            else:\\n                # There's a larger to the left, so x will be removed after popped_max+1 steps\\n                steps = popped_max + 1\\n            \\n            # Track the maximum steps over all elements\\n            ans = max(ans, steps)\\n            # Push current with its computed removal step count\\n            stack.append((x, steps))\\n        \\n        return ans\\n\"",
  "853_14631217_python": "\"class Solution(object):\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        worker.sort()\\n        res = 0\\n        best = i = 0\\n        \\n        for w in worker:\\n            while i < len(jobs) and jobs[i][0] <= w:\\n                best = max(best, jobs[i][1])\\n                i += 1\\n            res += best\\n        return res\\n\"",
  "1474_14631217_python-updated-time": "1746345537586",
  "3464_14631217_python-updated-time": "1747485810701",
  "3493_14631217_python": "\"class Solution(object):\\n    def maxOperations(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # 1) Collect positions of '1'\\n        P = [i for i,ch in enumerate(s) if ch == '1']\\n        m = len(P)\\n        if m == 0:\\n            return 0\\n        \\n        ans = 0\\n        # 2) For each 1-indexed j=1..m, compute its gap_j\\n        #    and add j if gap_j > 0\\n        # gap_1 is zeros between P[0] and left boundary? No: it's between P[0] and nothing,\\n        # but we only use gaps to the right of each '1', so gap_j for j=1..m:\\n        #   gap_j is zeros to the right of the j-th one.\\n        for j in range(1, m+1):\\n            if j < m:\\n                gap = P[j] - P[j-1] - 1\\n            else:\\n                gap = (n - 1) - P[m-1]\\n            if gap > 0:\\n                ans += j\\n        \\n        return ans\\n\"",
  "1647_14631217_python": "\"class Solution(object):\\n    def canConvertString(self, s, t, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if len(s) != len(t):\\n            return False\\n\\n        shift_count = [0] * 26\\n\\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n            if diff == 0:\\n                continue\\n            times_needed = shift_count[diff]\\n            move = diff + 26 * times_needed\\n            if move > k:\\n                return False\\n            shift_count[diff] += 1\\n\\n        return True\\n\"",
  "1604_14631217_python": "\"import collections\\nimport heapq\\n\\nclass Solution(object):\\n    def findLeastNumOfUniqueInts(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        freq = collections.Counter(arr)\\n        min_heap = list(freq.values())\\n        heapq.heapify(min_heap)\\n\\n        while k > 0 and min_heap:\\n            cnt = heapq.heappop(min_heap)\\n            k -= cnt\\n\\n        return len(min_heap) + (1 if k < 0 else 0)\\n\"",
  "1935_14631217_python": "\"class Solution(object):\\n    def reinitializePermutation(self, n):\\n        def h(j):\\n            if j < n // 2:\\n                return 2 * j\\n            else:\\n                return 2 * (j - n // 2) + 1\\n\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        visited = [False] * n\\n        res = 1\\n        for i in range(n):\\n            if not visited[i]:\\n                cnt = 0\\n                j = i\\n                while not visited[j]:\\n                    visited[j] = True\\n                    j = h(j)\\n                    cnt += 1\\n                if cnt > 0:\\n                    res = res * cnt / gcd(res, cnt)\\n        return res\\n\"",
  "1617_14631217_python-updated-time": "1746433388784",
  "3141_14631217_python": "\"class Solution(object):\\n    def minSizeSubarray(self, nums, target):\\n        n = len(nums)\\n        S = sum(nums)\\n        k, rem = divmod(target, S)\\n        if rem == 0:\\n            return k * n\\n        # Two-pointer on nums concatenated twice, window length <= n\\n        arr = nums + nums\\n        L_rem = float('inf')\\n        curr = 0\\n        l = 0\\n        for r, v in enumerate(arr):\\n            curr += v\\n            # shrink while sum too big or window too long\\n            while l <= r and (curr > rem or r - l + 1 > n):\\n                curr -= arr[l]\\n                l += 1\\n            if curr == rem:\\n                L_rem = min(L_rem, r - l + 1)\\n        if L_rem == float('inf'):\\n            return -1\\n        return k * n + L_rem\\n\"",
  "3578_14631217_python": "\"class Solution(object):\\n    def constructGridLayout(self, n, edges):\\n        from collections import deque, defaultdict\\n\\n        # build adjacency and degree\\n        adj = [[] for _ in range(n)]\\n        deg = [0]*n\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n            deg[u] += 1\\n            deg[v] += 1\\n\\n        # --- Case 1: it's a 1×n path if exactly two nodes have degree 1 ---\\n        if sum(1 for d in deg if d == 1) == 2:\\n            # find one endpoint\\n            start = next(i for i, d in enumerate(deg) if d == 1)\\n            path = [start]\\n            visited = {start}\\n            cur = start\\n            # walk the unique path\\n            while True:\\n                for nei in adj[cur]:\\n                    if nei not in visited:\\n                        visited.add(nei)\\n                        path.append(nei)\\n                        cur = nei\\n                        break\\n                else:\\n                    break\\n            return [path]\\n\\n        # --- Case 2: it's an r×c rectangle ---\\n        # find the 4 corner-nodes (degree 2) and count degree-3 nodes\\n        corners = [i for i, d in enumerate(deg) if d == 2]\\n        k3 = sum(1 for d in deg if d == 3)\\n\\n        # r + c = (k3 / 2) + 4, and r*c = n  → solve quadratic\\n        S = (k3 // 2) + 4\\n        D = S*S - 4*n\\n        sqrtD = int(D**0.5)\\n        # smaller root = r, larger = c\\n        r = (S - sqrtD)//2\\n        c = (S + sqrtD)//2\\n\\n        # BFS from one corner u = (0,0)\\n        u = corners[0]\\n        du = [-1]*n\\n        q = deque([u]); du[u] = 0\\n        while q:\\n            v = q.popleft()\\n            for w in adj[v]:\\n                if du[w] < 0:\\n                    du[w] = du[v] + 1\\n                    q.append(w)\\n\\n        # find the corner at distance c-1  → (0,c-1)\\n        corner_c = next((v for v in corners if v != u and du[v] == c-1), None)\\n        if corner_c is None:\\n            # maybe we guessed r,c swapped\\n            r, c = c, r\\n            corner_c = next(v for v in corners if v != u and du[v] == c-1)\\n\\n        # BFS from corner_c\\n        d2 = [-1]*n\\n        q = deque([corner_c]); d2[corner_c] = 0\\n        while q:\\n            v = q.popleft()\\n            for w in adj[v]:\\n                if d2[w] < 0:\\n                    d2[w] = d2[v] + 1\\n                    q.append(w)\\n\\n        # assign each node to (y,x) in an r×c grid\\n        grid = [[-1]*c for _ in range(r)]\\n        for v in range(n):\\n            # solve\\n            # du[v]   = x + y\\n            # d2[v]   = (c-1 - x) + y\\n            # ⇒ y = (du[v] + d2[v] - (c-1)) / 2\\n            y = (du[v] + d2[v] - (c - 1)) // 2\\n            x = du[v] - y\\n            grid[y][x] = v\\n\\n        return grid\\n\"",
  "1902_14631217_python-updated-time": "1746532226992",
  "3446_14631217_python-updated-time": "1747483431984",
  "778_14631217_python": "\"import heapq\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def reorganizeString(self, s):\\n        count = Counter(s)\\n        heap = [(-freq, char) for char, freq in count.items()]\\n        heapq.heapify(heap)\\n        \\n        if any(freq > (len(s) + 1) // 2 for freq in count.values()):\\n            return \\\"\\\"\\n        \\n        res = []\\n        while len(heap) >= 2:\\n            freq1, char1 = heapq.heappop(heap)\\n            freq2, char2 = heapq.heappop(heap)\\n            res.extend([char1, char2])\\n            if freq1 + 1 < 0:\\n                heapq.heappush(heap, (freq1 + 1, char1))\\n            if freq2 + 1 < 0:\\n                heapq.heappush(heap, (freq2 + 1, char2))\\n        \\n        if heap:\\n            res.append(heapq.heappop(heap)[1])\\n        \\n        return ''.join(res)\\n\"",
  "111_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def minDepth(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not root:\\n            return 0\\n        if not root.left and not root.right:\\n            return 1\\n        if not root.left:\\n            return 1 + self.minDepth(root.right)\\n        if not root.right:\\n            return 1 + self.minDepth(root.left)\\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\\n\"",
  "2025_14631217_python": "\"class Solution:\\n    def makeEqual(self, words):\\n        from collections import Counter\\n        total = Counter()\\n        for word in words:\\n            total.update(word)\\n        n = len(words)\\n        for count in total.values():\\n            if count % n != 0:\\n                return False\\n        return True\\n\"",
  "1321_14631217_python": "\"class Solution(object):\\n    def equalSubstring(self, s, t, maxCost):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :type maxCost: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left = 0\\n        cost = 0\\n        max_len = 0\\n\\n        for right in range(len(s)):\\n            cost += abs(ord(s[right]) - ord(t[right]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n\\n        return max_len\\n\"",
  "3387_14631217_python": "\"class Solution(object):\\n    def minOperationsToMakeMedianK(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        m = n // 2  # index of the “larger” median\\n        ops = 0\\n        \\n        # Any too‐large values at or before the median must be lowered to k\\n        for i in range(m+1):\\n            if nums[i] > k:\\n                ops += nums[i] - k\\n        \\n        # Any too‐small values at or after the median must be raised to k\\n        for i in range(m, n):\\n            if nums[i] < k:\\n                ops += k - nums[i]\\n        \\n        return ops\\n\"",
  "1065_14631217_python": "\"class Solution:\\n    def queryString(self, s, n):\\n        seen = set()\\n        max_len = min(len(s), n.bit_length())\\n\\n        for length in range(1, max_len + 1):\\n            for i in range(len(s) - length + 1):\\n                num = int(s[i:i+length], 2)\\n                if 1 <= num <= n:\\n                    seen.add(num)\\n            # Early exit if we've found all numbers\\n            if len(seen) == n:\\n                return True\\n\\n        return len(seen) == n\\n\"",
  "3374_14631217_python": "\"class Solution(object):\\n    def countAlternatingSubarrays(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        total = 0\\n        curr_len = 1  # length of current maximal alternating segment\\n        \\n        for i in range(1, n):\\n            if nums[i] != nums[i-1]:\\n                # still alternating, extend segment\\n                curr_len += 1\\n            else:\\n                # segment ends here\\n                total += curr_len * (curr_len + 1) // 2\\n                curr_len = 1\\n        \\n        # add the last segment\\n        total += curr_len * (curr_len + 1) // 2\\n        \\n        return total\\n\"",
  "2469_14631217_python-updated-time": "1746965378187",
  "866_14631217_python": "\"class Solution(object):\\n    def isRectangleOverlap(self, rec1, rec2):\\n        return not (rec1[2] <= rec2[0] or  # rec1 right <= rec2 left\\n                    rec1[0] >= rec2[2] or  # rec1 left >= rec2 right\\n                    rec1[3] <= rec2[1] or  # rec1 top <= rec2 bottom\\n                    rec1[1] >= rec2[3])    # rec1 bottom >= rec2 top\\n\"",
  "1812_14631217_python": "\"class Solution(object):\\n    def reformatNumber(self, number):\\n        # remove non-digit characters\\n        digits = [c for c in number if c.isdigit()]\\n        res = []\\n        i, n = 0, len(digits)\\n        # take blocks of 3 while more than 4 remain\\n        while n - i > 4:\\n            res.append(''.join(digits[i:i+3]))\\n            i += 3\\n        # handle the last 4 or fewer digits\\n        rem = n - i\\n        if rem == 4:\\n            res.append(''.join(digits[i:i+2]))\\n            res.append(''.join(digits[i+2:i+4]))\\n        else:\\n            res.append(''.join(digits[i:]))\\n        return '-'.join(res)\\n\"",
  "1989_14631217_python": "\"class Solution:\\n    def minimumXORSum(self, nums1, nums2):\\n        n = len(nums1)\\n        N = 1 << n\\n\\n        # precompute bit counts for masks 0..(2^n - 1)\\n        bits = [0] * N\\n        for mask in range(1, N):\\n            bits[mask] = bits[mask >> 1] + (mask & 1)\\n\\n        INF = 10**18\\n        dp = [INF] * N\\n        dp[0] = 0\\n\\n        # dp[mask] = min XOR-sum pairing the set bits of mask in nums2\\n        # with the first bits=popcount(mask) elements of nums1\\n        for mask in range(N):\\n            k = bits[mask]  # next index in nums1 to pair\\n            for j in range(n):\\n                if not (mask & (1 << j)):\\n                    new_mask = mask | (1 << j)\\n                    cost = dp[mask] + (nums1[k] ^ nums2[j])\\n                    if cost < dp[new_mask]:\\n                        dp[new_mask] = cost\\n\\n        return dp[N - 1]\\n\"",
  "3402_14631217_python-updated-time": "1747480646456",
  "749_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def shortestCompletingWord(self, licensePlate, words):\\n        count = Counter(c.lower() for c in licensePlate if c.isalpha())\\n        res = None\\n        for word in words:\\n            word_count = Counter(word)\\n            if all(word_count[c] >= count[c] for c in count):\\n                if res is None or len(word) < len(res):\\n                    res = word\\n        return res\\n\"",
  "1968_14631217_python-updated-time": "1746544490174",
  "1722_14631217_python-updated-time": "1746443775347",
  "718_14631217_python-updated-time": "1745786690176",
  "2594_14631217_python": "\"class Solution:\\n    def similarPairs(self, words):\\n        from collections import Counter\\n        masks = Counter()\\n\\n        for word in words:\\n            mask = 0\\n            for ch in set(word):\\n                mask |= 1 << (ord(ch) - ord('a'))\\n            masks[mask] += 1\\n\\n        count = 0\\n        for v in masks.values():\\n            count += v * (v - 1) // 2\\n        return count\\n\"",
  "2324_14631217_python": "\"class Solution(object):\\n    def triangularSum(self, nums):\\n        while len(nums) > 1:\\n            nums = [(nums[i] + nums[i+1]) % 10 for i in xrange(len(nums) - 1)]\\n        return nums[0]\\n\"",
  "2689_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def minCost(self, basket1, basket2):\\n        freq = collections.Counter(basket1)\\n        freq.update(basket2)\\n        for v, c in freq.iteritems():\\n            if c % 2:\\n                return -1\\n\\n        freq1 = collections.Counter(basket1)\\n        freq2 = collections.Counter(basket2)\\n        surplus1, surplus2 = [], []\\n        for v in freq:\\n            d = freq1[v] - freq2[v]\\n            if d > 0:\\n                surplus1.extend([v] * (d // 2))\\n            elif d < 0:\\n                surplus2.extend([v] * ((-d) // 2))\\n\\n        if not surplus1:\\n            return 0\\n\\n        surplus1.sort()\\n        surplus2.sort(reverse=True)\\n        min_val = min(freq)\\n        cost = 0\\n        for x, y in zip(surplus1, surplus2):\\n            cost += min(x, y, 2 * min_val)\\n        return cost\\n\"",
  "1127_14631217_python-updated-time": "1746042931756",
  "1830_14631217_python": "\"class Solution(object):\\n    def countPairs(self, deliciousness):\\n        MOD = 10**9 + 7\\n        from collections import defaultdict\\n        \\n        # Precompute powers of two up to 2^21\\n        powers = [1 << k for k in range(22)]\\n        \\n        count = defaultdict(int)\\n        ans = 0\\n        \\n        for val in deliciousness:\\n            for target in powers:\\n                need = target - val\\n                if need in count:\\n                    ans = (ans + count[need]) % MOD\\n            count[val] += 1\\n        \\n        return ans\\n\"",
  "1253_14631217_python-updated-time": "1746261510714",
  "2290_14631217_python": "\"class Solution:\\n    def minimumRemoval(self, beans):\\n        beans.sort()\\n        total = sum(beans)\\n        res = float('inf')\\n        n = len(beans)\\n        for i, val in enumerate(beans):\\n            res = min(res, total - val * (n - i))\\n        return res\\n\"",
  "938_14631217_python": "\"class Solution:\\n    def atMostNGivenDigitSet(self, digits, n):\\n        n_str = str(n)\\n        n_len = len(n_str)\\n        d_len = len(digits)\\n        \\n        total = 0\\n        for i in range(1, n_len):\\n            total += d_len ** i\\n        \\n        for i in range(n_len):\\n            smaller = sum(c < n_str[i] for c in digits)\\n            total += smaller * (d_len ** (n_len - i - 1))\\n            if n_str[i] not in digits:\\n                return total\\n        return total + 1\\n\"",
  "3199_14631217_python-updated-time": "1747309982249",
  "1_14631217_python": "\"class Solution(object):\\n    def twoSum(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        num_to_index = {}\\n        for i, num in enumerate(nums):\\n            diff = target - num\\n            if diff in num_to_index:\\n                return [num_to_index[diff], i]\\n            num_to_index[num] = i\\n\"",
  "1615_14631217_python": "\"class Solution(object):\\n    def rangeSum(self, nums, n, left, right):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type n: int\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        sub_sums = []\\n\\n        # Generate all subarray sums\\n        for i in range(n):\\n            total = 0\\n            for j in range(i, n):\\n                total += nums[j]\\n                sub_sums.append(total)\\n\\n        sub_sums.sort()\\n\\n        # Sum from left to right (1-based index)\\n        return sum(sub_sums[left - 1:right]) % MOD\\n\"",
  "1055_14631217_python-updated-time": "1746041351639",
  "3620_14631217_python": "\"class Solution(object):\\n    def maxDistinctElements(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Build list of intervals [a-k, a+k] for each element a.\\n        intervals = [(a - k, a + k) for a in nums]\\n        # Sort by right endpoint\\n        intervals.sort(key=lambda x: x[1])\\n\\n        parent = {}  # for union-find “next free” pointers\\n\\n        def find(x):\\n            # Return smallest integer ≥ x that is not yet occupied\\n            if x not in parent:\\n                return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def occupy(x):\\n            # Mark x as used, so next time find(x) returns ≥ x+1\\n            parent[x] = x + 1\\n\\n        matches = 0\\n        for L, R in intervals:\\n            x = find(L)\\n            if x <= R:\\n                occupy(x)\\n                matches += 1\\n\\n        return matches\\n\"",
  "898_14631217_python": "\"class Solution(object):\\n    def transpose(self, matrix):\\n        return [[row[i] for row in matrix] for i in range(len(matrix[0]))]\\n\"",
  "3379_14631217_lang": "\"python3\"",
  "2265_14631217_python-updated-time": "1746802943138",
  "2401_14631217_python": "\"class Solution:\\n    def countAsterisks(self, s):\\n        in_bar = False\\n        count = 0\\n        for ch in s:\\n            if ch == '|':\\n                in_bar = not in_bar\\n            elif ch == '*' and not in_bar:\\n                count += 1\\n        return count\\n\"",
  "434_14631217_python": "\"class Solution:\\n    def countSegments(self, s):\\n        return len(s.split())\\n\"",
  "3501_14631217_python-updated-time": "1747487255726",
  "3809_14631217_python": "\"class Solution(object):\\n    def numberOfComponents(self, properties, k):\\n        \\\"\\\"\\\"\\n        :type properties: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(properties)\\n        # Convert each list to a set of distinct integers\\n        sets = [set(p) for p in properties]\\n        \\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # count intersection size\\n                if len(sets[i] & sets[j]) >= k:\\n                    adj[i].append(j)\\n                    adj[j].append(i)\\n        \\n        # Count connected components via DFS\\n        seen = [False]*n\\n        def dfs(u):\\n            seen[u] = True\\n            for v in adj[u]:\\n                if not seen[v]:\\n                    dfs(v)\\n        \\n        components = 0\\n        for i in range(n):\\n            if not seen[i]:\\n                components += 1\\n                dfs(i)\\n        \\n        return components\\n\"",
  "2529_14631217_python": "\"class Solution(object):\\n    def productQueries(self, n, queries):\\n        MOD = 10**9 + 7\\n        \\n        # Build the 'powers' array: the list of 2^k for each set bit in n\\n        powers = []\\n        bit = 0\\n        temp = n\\n        while temp:\\n            if temp & 1:\\n                powers.append(1 << bit)\\n            bit += 1\\n            temp >>= 1\\n        \\n        # Build prefix products of powers\\n        m = len(powers)\\n        prefix = [0]*m\\n        prefix[0] = powers[0] % MOD\\n        for i in range(1, m):\\n            prefix[i] = prefix[i-1] * powers[i] % MOD\\n        \\n        # Precompute modular inverses of prefix[i]\\n        inv_prefix = [0]*m\\n        inv_prefix[-1] = pow(prefix[-1], MOD-2, MOD)\\n        # Then inv_prefix[i-1] = inv_prefix[i] * powers[i] % MOD\\n        for i in range(m-1, 0, -1):\\n            inv_prefix[i-1] = inv_prefix[i] * powers[i] % MOD\\n        \\n        # Answer queries\\n        ans = []\\n        for l, r in queries:\\n            if l == 0:\\n                ans.append(prefix[r])\\n            else:\\n                # prefix[r] / prefix[l-1]  mod = prefix[r] * inv_prefix[l-1]\\n                res = prefix[r] * inv_prefix[l-1] % MOD\\n                ans.append(res)\\n        \\n        return ans\\n\"",
  "675_14631217_python-updated-time": "1745783386688",
  "3576_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def findSubtreeSizes(self, parent, s):\\n        \\\"\\\"\\\"\\n        :type parent: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(parent)\\n        \\n        # Build original tree adjacency\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            p = parent[i]\\n            children[p].append(i)\\n\\n        # Initialize new_parent with original parent\\n        new_parent = parent[:]\\n        # Stacks to track the latest ancestor for each character\\n        stacks = [[] for _ in range(26)]\\n\\n        # DFS to determine new_parent for each node\\n        def dfs(u):\\n            idx = ord(s[u]) - ord('a')\\n            # If an ancestor with same character exists, reattach\\n            if stacks[idx]:\\n                new_parent[u] = stacks[idx][-1]\\n            # Push current node onto its character's stack\\n            stacks[idx].append(u)\\n            # Recurse into children\\n            for v in children[u]:\\n                dfs(v)\\n            # Pop when backtracking\\n            stacks[idx].pop()\\n\\n        # Run DFS from root (0)\\n        dfs(0)\\n\\n        # Build final tree adjacency based on new_parent\\n        final_children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            p = new_parent[i]\\n            final_children[p].append(i)\\n\\n        # Compute subtree sizes with iterative post-order traversal\\n        sizes = [0] * n\\n        stack = [(0, False)]  # (node, visited_flag)\\n        while stack:\\n            u, visited = stack.pop()\\n            if not visited:\\n                # Postpone processing until after children\\n                stack.append((u, True))\\n                for v in final_children[u]:\\n                    stack.append((v, False))\\n            else:\\n                # All children have been processed\\n                total = 1\\n                for v in final_children[u]:\\n                    total += sizes[v]\\n                sizes[u] = total\\n\\n        return sizes\\n\"",
  "2130_14631217_python-updated-time": "1746717643948",
  "1808_14631217_python-updated-time": "1746453123345",
  "3738_14631217_python": "\"class Solution(object):\\n    def maximumPossibleSize(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        # Number of cuts we make between segments\\n        cuts = 0\\n        \\n        # Maximum of the last completed segment (conceptually -inf)\\n        last_max = float('-inf')\\n        # Maximum of the current (in-progress) segment\\n        curr_max = nums[0]\\n        \\n        # Try to cut before each position i = 1..n-1\\n        for i in range(1, n):\\n            x = nums[i]\\n            if x >= curr_max:\\n                # We can end the previous segment here:\\n                #   its max = curr_max ≤ x ≤ eventual max of next segment\\n                cuts += 1\\n                last_max = curr_max\\n                curr_max = x\\n            else:\\n                # Must absorb x into current segment to keep its max ≥ x\\n                # (and thus be able to compare to the next segment later)\\n                curr_max = max(curr_max, x)\\n        \\n        # Segments = cuts + 1 → that's the maximum non-decreasing size\\n        return cuts + 1\\n\"",
  "2494_14631217_python": "\"class TrieNode:\\n    __slots__ = ('count', 'children')\\n    def __init__(self):\\n        self.count = 0\\n        self.children = {}\\n\\nclass Solution:\\n    def sumPrefixScores(self, words):\\n        # Build trie with counts\\n        root = TrieNode()\\n        for w in words:\\n            node = root\\n            for ch in w:\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n                node.count += 1\\n\\n        # For each word, sum counts along its prefixes\\n        answer = []\\n        for w in words:\\n            node = root\\n            total = 0\\n            for ch in w:\\n                node = node.children[ch]\\n                total += node.count\\n            answer.append(total)\\n\\n        return answer\\n\"",
  "802_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, arr, k):\\n        n = len(arr)\\n        heap = []\\n        for i in range(n - 1):\\n            heapq.heappush(heap, (float(arr[i]) / arr[n-1], i, n-1))\\n        \\n        for _ in range(k-1):\\n            val, i, j = heapq.heappop(heap)\\n            if j - 1 > i:\\n                heapq.heappush(heap, (float(arr[i]) / arr[j-1], i, j-1))\\n        \\n        val, i, j = heapq.heappop(heap)\\n        return [arr[i], arr[j]]\\n\"",
  "971_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def shortestBridge(self, grid):\\n        n = len(grid)\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n        visited = [[0]*n for _ in range(n)]\\n        queue = deque()\\n\\n        # DFS to mark the first island and collect its border\\n        def dfs(x, y):\\n            if x < 0 or x >= n or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0:\\n                return\\n            visited[x][y] = 1\\n            queue.append((x, y, 0))  # enqueue with step count\\n            for dx, dy in directions:\\n                dfs(x + dx, y + dy)\\n\\n        # Find first island and start DFS\\n        found = False\\n        for i in range(n):\\n            if found:\\n                break\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    dfs(i, j)\\n                    found = True\\n                    break\\n\\n        # BFS to expand to the second island\\n        while queue:\\n            x, y, d = queue.popleft()\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:\\n                    if grid[nx][ny] == 1:\\n                        return d  # reached second island\\n                    visited[nx][ny] = 1\\n                    queue.append((nx, ny, d + 1))\\n\\n        return -1  # Should never be reached\\n\"",
  "1493_14631217_python": "\"class Solution(object):\\n    def frogPosition(self, n, edges, t, target):\\n        from collections import defaultdict, deque\\n\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        visited = [False] * (n + 1)\\n        def dfs(node, time, prob):\\n            if time > t:\\n                return 0.0\\n            visited[node] = True\\n            unvisited_children = [nei for nei in graph[node] if not visited[nei]]\\n            if time == t or not unvisited_children:\\n                return prob if node == target else 0.0\\n            res = 0.0\\n            for nei in unvisited_children:\\n                res += dfs(nei, time + 1, prob / len(unvisited_children))\\n            return res\\n\\n        return dfs(1, 0, 1.0)\\n\"",
  "610_14631217_mysql-updated-time": "1745448785058",
  "336_14631217_python": "\"class Solution(object):\\n    def palindromePairs(self, words):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        word_to_index = {word: i for i, word in enumerate(words)}\\n        res = []\\n        \\n        def is_palindrome(word):\\n            return word == word[::-1]\\n        \\n        for i, word in enumerate(words):\\n            for j in range(len(word)+1):\\n                prefix, suffix = word[:j], word[j:]\\n                if is_palindrome(prefix):\\n                    back = suffix[::-1]\\n                    if back in word_to_index and word_to_index[back] != i:\\n                        res.append([word_to_index[back], i])\\n                if j != len(word) and is_palindrome(suffix):\\n                    front = prefix[::-1]\\n                    if front in word_to_index and word_to_index[front] != i:\\n                        res.append([i, word_to_index[front]])\\n        \\n        return res\\n\"",
  "410_14631217_python": "\"class Solution:\\n    def splitArray(self, nums, k):\\n        def can_split(max_sum):\\n            count, current_sum = 1, 0\\n            for num in nums:\\n                if current_sum + num > max_sum:\\n                    count += 1\\n                    current_sum = num\\n                else:\\n                    current_sum += num\\n            return count <= k\\n        \\n        left, right = max(nums), sum(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_split(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "2596_14631217_python-updated-time": "1747059154219",
  "3067_14631217_pythondata": "\"import pandas as pd\\n\\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame employees with columns ['name', 'salary'],\\n    modifies the DataFrame in-place so that each salary is doubled,\\n    and returns it.\\n    \\\"\\\"\\\"\\n    employees['salary'] = employees['salary'] * 2\\n    return employees\\n\"",
  "561_14631217_python": "\"class Solution(object):\\n    def arrayPairSum(self, nums):\\n        nums.sort()\\n        return sum(nums[::2])\\n\"",
  "2904_14631217_python-updated-time": "1747225649864",
  "2189_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        \\\"\\\"\\\"\\n        :param values: List[int]         # node values\\n        :param edges: List[List[int]]    # [u, v, time] undirected\\n        :param maxTime: int              # time budget\\n        :return: int                     # maximum quality\\n        \\\"\\\"\\\"\\n        n = len(values)\\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for u, v, t in edges:\\n            adj[u].append((v, t))\\n            adj[v].append((u, t))\\n        \\n        visited = [False] * n\\n        visited[0] = True\\n        self.max_quality = values[0]\\n        curr_sum = values[0]\\n        \\n        def dfs(u, time_used, curr_sum):\\n            # If we're back at node 0, consider updating answer\\n            if u == 0:\\n                self.max_quality = max(self.max_quality, curr_sum)\\n            # Try all neighbors\\n            for v, t in adj[u]:\\n                new_time = time_used + t\\n                if new_time > maxTime:\\n                    continue\\n                added = 0\\n                if not visited[v]:\\n                    visited[v] = True\\n                    added = values[v]\\n                    curr_sum += added\\n                dfs(v, new_time, curr_sum)\\n                if added:\\n                    # backtrack\\n                    visited[v] = False\\n                    curr_sum -= added\\n        \\n        # Start DFS from node 0 at time 0\\n        dfs(0, 0, curr_sum)\\n        return self.max_quality\\n\"",
  "3421_14631217_python": "\"class Solution(object):\\n    def countCompleteDayPairs(self, hours):\\n        \\\"\\\"\\\"\\n        :type hours: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        freq = [0] * 24\\n        count = 0\\n        for h in hours:\\n            r = h % 24\\n            c = (-r) % 24            # the remainder needed to make (r + c) ≡ 0 mod 24\\n            count += freq[c]\\n            freq[r] += 1\\n        return count\\n\"",
  "3320_14631217_python-updated-time": "1747413824337",
  "2016_14631217_python": "\"class Solution:\\n    def reductionOperations(self, nums):\\n        nums.sort(reverse=True)\\n        res = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]:\\n                res += i\\n        return res\\n\"",
  "2277_14631217_python-updated-time": "1746803388753",
  "1685_14631217_python-updated-time": "1746443664203",
  "3399_14631217_python-updated-time": "1747424546586",
  "520_14631217_python-updated-time": "1745446512844",
  "913_14631217_python-updated-time": "1745446491087",
  "2011_14631217_python": "\"class Solution:\\n    def maxValue(self, n, x):\\n        s = str(n)\\n        c = str(x)\\n        if s[0] != '-':\\n            for i in range(len(s)):\\n                if s[i] < c:\\n                    return s[:i] + c + s[i:]\\n            return s + c\\n        for i in range(1, len(s)):\\n            if s[i] > c:\\n                return s[:i] + c + s[i:]\\n        return s + c\\n\"",
  "2193_14631217_python-updated-time": "1746729554999",
  "2261_14631217_python-updated-time": "1746802776404",
  "2042_14631217_python-updated-time": "1746637304317",
  "2520_14631217_python": "\"class Solution(object):\\n    def robotWithString(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Precompute suffix minimum characters\\n        # suffix_min[i] = min(s[i], s[i+1], ..., s[n-1])\\n        suffix_min = [''] * (n + 1)\\n        suffix_min[n] = '{'  # character after 'z' in ASCII\\n        for i in range(n - 1, -1, -1):\\n            suffix_min[i] = min(s[i], suffix_min[i + 1])\\n\\n        t_stack = []\\n        result = []\\n\\n        for i, ch in enumerate(s):\\n            # Operation 1: push from s to t\\n            t_stack.append(ch)\\n            # Operation 2: pop from t to result while optimal\\n            # We pop while the top of t_stack <= min of remaining s\\n            while t_stack and t_stack[-1] <= suffix_min[i + 1]:\\n                result.append(t_stack.pop())\\n\\n        # Flush remaining from t_stack\\n        while t_stack:\\n            result.append(t_stack.pop())\\n\\n        return ''.join(result)\\n\"",
  "2389_14631217_python-updated-time": "1746881996243",
  "3657_14631217_python": "\"class Solution(object):\\n    def checkValidCuts(self, n, rectangles):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def can_split(intervals):\\n            m = len(intervals)\\n            if m < 3:\\n                return False\\n            # sort by start then end\\n            intervals.sort(key=lambda x: (x[0], x[1]))\\n            pre_max = [0] * (m + 1)\\n            for i in range(1, m + 1):\\n                pre_max[i] = max(pre_max[i-1], intervals[i-1][1])\\n            suf_min = [0] * (m + 1)\\n            suf_min[m] = float('inf')\\n            for i in range(m-1, -1, -1):\\n                suf_min[i] = min(suf_min[i+1], intervals[i][0])\\n            # count valid split positions\\n            count = 0\\n            for k in range(1, m):\\n                if pre_max[k] <= suf_min[k]:\\n                    count += 1\\n                    if count >= 2:\\n                        return True\\n            return False\\n\\n        # extract x-intervals and y-intervals\\n        x_ints = [(x1, x2) for x1, y1, x2, y2 in rectangles]\\n        y_ints = [(y1, y2) for x1, y1, x2, y2 in rectangles]\\n\\n        # check either horizontal or vertical\\n        return can_split(x_ints) or can_split(y_ints)\\n\"",
  "224_14631217_python": "\"class Solution(object):\\n    def calculate(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        stack = []\\n        operand = 0\\n        result = 0  # For the on-going result\\n        sign = 1    # 1 means positive, -1 means negative\\n\\n        for ch in s:\\n            if ch.isdigit():\\n                operand = (operand * 10) + int(ch)\\n            elif ch == '+':\\n                result += sign * operand\\n                sign = 1\\n                operand = 0\\n            elif ch == '-':\\n                result += sign * operand\\n                sign = -1\\n                operand = 0\\n            elif ch == '(':\\n                # Push the result and sign onto the stack for later\\n                stack.append(result)\\n                stack.append(sign)\\n                sign = 1\\n                result = 0\\n            elif ch == ')':\\n                result += sign * operand\\n                result *= stack.pop()  # stack.pop() is the sign before the parenthesis\\n                result += stack.pop()  # stack.pop() now is the result calculated before the parenthesis\\n                operand = 0\\n\\n        return result + (sign * operand)\\n\"",
  "337_14631217_python": "\"\\n\\nclass Solution(object):\\n    def rob(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def dfs(node):\\n            if not node:\\n                return (0, 0)\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            rob = node.val + left[1] + right[1]\\n            not_rob = max(left) + max(right)\\n            return (rob, not_rob)\\n        \\n        return max(dfs(root))\\n\"",
  "3211_14631217_python-updated-time": "1747316752875",
  "1845_14631217_python-updated-time": "1746529988347",
  "3388_14631217_python": "\"class Solution(object):\\n    def numberOfRightTriangles(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        # Precompute row and column totals of 1s\\n        row_counts = [sum(row) for row in grid]\\n        col_counts = [sum(grid[i][j] for i in range(m)) for j in range(n)]\\n        \\n        total = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    # pick one other 1 in this row and one other in this column\\n                    total += (row_counts[i] - 1) * (col_counts[j] - 1)\\n        return total\\n\"",
  "1988_14631217_python": "\"class Solution:\\n    def minPairSum(self, nums):\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        for i in range(n // 2):\\n            ans = max(ans, nums[i] + nums[-1 - i])\\n        return ans\\n\"",
  "2318_14631217_python-updated-time": "1746810609370",
  "2094_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minStoneSum(self, piles, k):\\n        # Use a max-heap by pushing negatives\\n        heap = [-p for p in piles]\\n        heapq.heapify(heap)\\n        \\n        for _ in range(k):\\n            # Pop the largest pile\\n            p = -heapq.heappop(heap)\\n            # Remove floor(p/2), new size is ceil(p/2)\\n            new_p = (p + 1) // 2\\n            # Push back\\n            heapq.heappush(heap, -new_p)\\n        \\n        # Sum remaining stones\\n        return -sum(heap)\\n\"",
  "2191_14631217_python-updated-time": "1746729482586",
  "3197_14631217_python": "\"class BinaryTrie:\\n    __slots__ = ('child', 'count')\\n    def __init__(self):\\n        self.child = [None, None]\\n        self.count = 0\\n        \\nclass Solution(object):\\n    def maximumStrongPairXor(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return 0\\n\\n        nums.sort()\\n        n = len(nums)\\n\\n        # Trie for 20-bit numbers (nums[i] <= 2^20-1)\\n        root = BinaryTrie()\\n\\n        def insert(x):\\n            node = root\\n            node.count += 1\\n            for b in reversed(range(20)):  # bits 19..0\\n                bit = (x >> b) & 1\\n                if node.child[bit] is None:\\n                    node.child[bit] = BinaryTrie()\\n                node = node.child[bit]\\n                node.count += 1\\n\\n        def remove(x):\\n            node = root\\n            node.count -= 1\\n            for b in reversed(range(20)):\\n                bit = (x >> b) & 1\\n                nxt = node.child[bit]\\n                node = nxt\\n                node.count -= 1\\n\\n        def max_xor_with(x):\\n            node = root\\n            res = 0\\n            for b in reversed(range(20)):\\n                bit = (x >> b) & 1\\n                toggled = bit ^ 1\\n                # prefer opposite bit if available\\n                child = node.child[toggled]\\n                if child is not None and child.count > 0:\\n                    res |= (1 << b)\\n                    node = child\\n                else:\\n                    node = node.child[bit]\\n            return res\\n\\n        best = 0\\n        l = 0\\n        r = 0\\n\\n        for i, x in enumerate(nums):\\n            # expand r while nums[r] <= 2*x\\n            while r < n and nums[r] <= 2 * x:\\n                insert(nums[r])\\n                r += 1\\n            # shrink l while nums[l] < ceil(x/2)\\n            half = (x + 1) // 2\\n            while l < n and nums[l] < half:\\n                remove(nums[l])\\n                l += 1\\n\\n            # query max xor with x in current window\\n            # window guaranteed to contain x itself\\n            curr = max_xor_with(x)\\n            if curr > best:\\n                best = curr\\n\\n        return best\"",
  "3404_14631217_python-updated-time": "1747424097191",
  "542_14631217_python-updated-time": "1745447001301",
  "1519_14631217_python-updated-time": "1746346475592",
  "417_14631217_python": "\"class Solution:\\n    def pacificAtlantic(self, heights):\\n        if not heights or not heights[0]:\\n            return []\\n        \\n        m, n = len(heights), len(heights[0])\\n        pacific = set()\\n        atlantic = set()\\n        \\n        def dfs(r, c, visited, prev_height):\\n            if (r < 0 or r >= m or c < 0 or c >= n or \\n                (r, c) in visited or heights[r][c] < prev_height):\\n                return\\n            visited.add((r, c))\\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                dfs(r + dr, c + dc, visited, heights[r][c])\\n        \\n        for i in range(m):\\n            dfs(i, 0, pacific, heights[i][0])\\n            dfs(i, n-1, atlantic, heights[i][n-1])\\n        \\n        for j in range(n):\\n            dfs(0, j, pacific, heights[0][j])\\n            dfs(m-1, j, atlantic, heights[m-1][j])\\n        \\n        return list(pacific & atlantic)\\n\"",
  "1057_14631217_python-updated-time": "1746041429527",
  "498_14631217_python": "\"class Solution:\\n    def findDiagonalOrder(self, mat):\\n        if not mat or not mat[0]:\\n            return []\\n\\n        m, n = len(mat), len(mat[0])\\n        result = []\\n        for d in range(m + n - 1):\\n            temp = []\\n            r = 0 if d < n else d - n + 1\\n            c = d if d < n else n - 1\\n\\n            while r < m and c >= 0:\\n                temp.append(mat[r][c])\\n                r += 1\\n                c -= 1\\n\\n            if d % 2 == 0:\\n                result.extend(temp[::-1])\\n            else:\\n                result.extend(temp)\\n\\n        return result\\n\"",
  "647_14631217_python-updated-time": "1745782616199",
  "438_14631217_python-updated-time": "1745358870438",
  "1442_14631217_python-updated-time": "1746261246849",
  "2646_14631217_python-updated-time": "1747066501859",
  "814_14631217_python": "\"class Solution(object):\\n    def bestRotation(self, nums):\\n        n = len(nums)\\n        diff = [0] * (n + 1)\\n        \\n        for i, num in enumerate(nums):\\n            low = (i + 1) % n\\n            high = (i - num + n + 1) % n\\n            diff[low] += 1\\n            diff[high] -= 1\\n            if low >= high:\\n                diff[0] += 1\\n        \\n        max_score = -1\\n        best_k = 0\\n        score = 0\\n        for k in range(n):\\n            score += diff[k]\\n            if score > max_score:\\n                max_score = score\\n                best_k = k\\n        return best_k\\n\"",
  "1829_14631217_python-updated-time": "1746453944551",
  "3386_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def findAnswer(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for idx, (u, v, w) in enumerate(edges):\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n        \\n        def dijkstra(start):\\n            dist = [float('inf')] * n\\n            dist[start] = 0\\n            heap = [(0, start)]\\n            while heap:\\n                d, u = heapq.heappop(heap)\\n                if d > dist[u]:\\n                    continue\\n                for v, w in adj[u]:\\n                    nd = d + w\\n                    if nd < dist[v]:\\n                        dist[v] = nd\\n                        heapq.heappush(heap, (nd, v))\\n            return dist\\n        \\n        # Distances from 0 and from n-1\\n        dist0 = dijkstra(0)\\n        distN = dijkstra(n-1)\\n        target = dist0[n-1]\\n        \\n        # If no path exists, none are on a shortest path\\n        if target == float('inf'):\\n            return [False] * len(edges)\\n        \\n        answer = []\\n        for u, v, w in edges:\\n            # Check either direction\\n            on_path = (\\n                dist0[u] + w + distN[v] == target or\\n                dist0[v] + w + distN[u] == target\\n            )\\n            answer.append(on_path)\\n        \\n        return answer\\n\"",
  "2010_14631217_python-updated-time": "1746626216941",
  "3850_14631217_python-updated-time": "1747758282438",
  "1945_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def findingUsersActiveMinutes(self, logs, k):\\n        user_minutes = defaultdict(set)\\n        for user_id, t in logs:\\n            user_minutes[user_id].add(t)\\n        answer = [0] * k\\n        for minutes in user_minutes.values():\\n            uam = len(minutes)\\n            if 1 <= uam <= k:\\n                answer[uam - 1] += 1\\n        return answer\\n\"",
  "3423_14631217_python": "\"class Solution(object):\\n    def maximumSumSubsequence(self, nums, queries):\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        NEG_INF = -10**18\\n\\n        # merge two DP-states in O(1)\\n        def merge(A, B):\\n            A00, A01, A10, A11 = A\\n            B00, B01, B10, B11 = B\\n            C00 = max(A00 + B00, A00 + B10, A01 + B00)\\n            C01 = max(A00 + B01, A00 + B11, A01 + B01)\\n            C10 = max(A10 + B00, A10 + B10, A11 + B00)\\n            C11 = max(A10 + B01, A10 + B11, A11 + B01)\\n            return (C00, C01, C10, C11)\\n\\n        # tree will hold 4*n nodes\\n        tree = [None] * (4 * n)\\n\\n        # build the segment tree over [l..r]\\n        def build(node, l, r):\\n            if l == r:\\n                v = nums[l]\\n                # leaf: you either pick nothing (00→0) or pick v (11→v)\\n                tree[node] = (0, NEG_INF, NEG_INF, v)\\n            else:\\n                mid = (l + r) // 2\\n                build(node*2,     l,   mid)\\n                build(node*2 + 1, mid+1, r)\\n                tree[node] = merge(tree[node*2], tree[node*2 + 1])\\n\\n        # point‐update\\n        def update(node, l, r, idx, val):\\n            if l == r:\\n                tree[node] = (0, NEG_INF, NEG_INF, val)\\n            else:\\n                mid = (l + r) // 2\\n                if idx <= mid:\\n                    update(node*2,     l,   mid, idx, val)\\n                else:\\n                    update(node*2 + 1, mid+1, r, idx, val)\\n                tree[node] = merge(tree[node*2], tree[node*2 + 1])\\n\\n        # build once\\n        build(1, 0, n-1)\\n\\n        ans = 0\\n        for pos, x in queries:\\n            update(1, 0, n-1, pos, x)\\n            # after each update, the root (node 1) holds the 4 states for [0..n-1]\\n            ans = (ans + max(tree[1])) % MOD\\n\\n        return ans\\n\"",
  "1297_14631217_python-updated-time": "1746126691946",
  "2749_14631217_javascript": "\"function timeLimit(fn, t) {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => \\n        setTimeout(() => reject(\\\"Time Limit Exceeded\\\"), t)\\n      )\\n    ]);\\n  };\\n}\\n\"",
  "985_14631217_python-updated-time": "1746004786510",
  "1097_14631217_python": "\"from collections import deque\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        self.max_len = 0\\n        for w in words:\\n            node = self.root\\n            self.max_len = max(self.max_len, len(w))\\n            # insert reversed word\\n            for ch in reversed(w):\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n            node.is_word = True\\n        self.stream = deque()\\n\\n    def query(self, letter):\\n        self.stream.append(letter)\\n        if len(self.stream) > self.max_len:\\n            self.stream.popleft()\\n        node = self.root\\n        # traverse reversed: from newest to oldest\\n        for ch in reversed(self.stream):\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n            if node.is_word:\\n                return True\\n        return False\"",
  "1915_14631217_python-updated-time": "1746542684086",
  "1437_14631217_python-updated-time": "1746261059811",
  "306_14631217_python": "\"class Solution(object):\\n    def isAdditiveNumber(self, num):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(num)\\n        \\n        for i in range(1, n):\\n            for j in range(i+1, n):\\n                num1, num2 = num[:i], num[i:j]\\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\\n                    continue\\n                n1, n2 = int(num1), int(num2)\\n                k = j\\n                while k < n:\\n                    n3 = n1 + n2\\n                    n3_str = str(n3)\\n                    if not num.startswith(n3_str, k):\\n                        break\\n                    k += len(n3_str)\\n                    n1, n2 = n2, n3\\n                if k == n:\\n                    return True\\n        return False\\n\"",
  "2640_14631217_python": "\"class Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        banned_set = set(banned)\\n        total = count = 0\\n        for i in xrange(1, n + 1):\\n            if i in banned_set:\\n                continue\\n            if total + i > maxSum:\\n                break\\n            total += i\\n            count += 1\\n        return count\\n\"",
  "3246_14631217_python-updated-time": "1747319194989",
  "2859_14631217_javascript": "\"/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const val1 = await promise1;\\n    const val2 = await promise2;\\n    return val1 + val2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n\"",
  "3376_14631217_python-updated-time": "1747422667765",
  "67_14631217_python-updated-time": "1745014878519",
  "1704_14631217_python-updated-time": "1746438496598",
  "2083_14631217_python-updated-time": "1746638753225",
  "214_14631217_python-updated-time": "1745246205142",
  "2114_14631217_python-updated-time": "1746716981015",
  "1277_14631217_python-updated-time": "1746345358426",
  "975_14631217_python": "\"class Solution:\\n    def rangeSumBST(self, root, low, high):\\n        if not root:\\n            return 0\\n\\n        if root.val < low:\\n            return self.rangeSumBST(root.right, low, high)\\n        elif root.val > high:\\n            return self.rangeSumBST(root.left, low, high)\\n        else:\\n            return (root.val +\\n                    self.rangeSumBST(root.left, low, high) +\\n                    self.rangeSumBST(root.right, low, high))\\n\"",
  "3347_14631217_python": "\"class Solution(object):\\n    def resultArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        arr1 = [nums[0]]\\n        arr2 = [nums[1]]\\n        for x in nums[2:]:\\n            if arr1[-1] > arr2[-1]:\\n                arr1.append(x)\\n            else:\\n                arr2.append(x)\\n        return arr1 + arr2\\n\"",
  "1577_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def getProbability(self, balls):\\n        \\\"\\\"\\\"\\n        :type balls: List[int]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        k = len(balls)\\n        half = sum(balls) // 2\\n\\n        # simple comb implementation\\n        def comb(n, r):\\n            if r < 0 or r > n:\\n                return 0\\n            r = min(r, n - r)\\n            num = den = 1\\n            for i in range(1, r + 1):\\n                num *= n - r + i\\n                den *= i\\n            return num // den\\n\\n        def dfs(i, count, d1, d2):\\n            # returns (total_ways, favorable_ways)\\n            if i == k:\\n                if count == half:\\n                    return (1, 1) if d1 == d2 else (1, 0)\\n                return (0, 0)\\n            tot = fav = 0\\n            for x in range(balls[i] + 1):\\n                if count + x > half:\\n                    break\\n                w = comb(balls[i], x)\\n                t, f = dfs(\\n                    i + 1,\\n                    count + x,\\n                    d1 + (1 if x     > 0 else 0),\\n                    d2 + (1 if balls[i] - x > 0 else 0)\\n                )\\n                tot += w * t\\n                fav += w * f\\n            return tot, fav\\n\\n        total, favorable = dfs(0, 0, 0, 0)\\n        # <-- force float division:\\n        return favorable / float(total)\\n\"",
  "1788_14631217_python-updated-time": "1746452972214",
  "1354_14631217_python": "\"class Solution(object):\\n    def findWinners(self, matches):\\n        loss = {}\\n        players = set()\\n        for w, l in matches:\\n            players.add(w)\\n            players.add(l)\\n            loss[l] = loss.get(l, 0) + 1\\n        no_loss = []\\n        one_loss = []\\n        for p in sorted(players):\\n            cnt = loss.get(p, 0)\\n            if cnt == 0:\\n                no_loss.append(p)\\n            elif cnt == 1:\\n                one_loss.append(p)\\n        return [no_loss, one_loss]\\n\"",
  "1701_14631217_python-updated-time": "1746438439124",
  "79_14631217_python": "\"class Solution(object):\\n    def exist(self, board, word):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(i, j, k):\\n            if k == len(word):\\n                return True\\n            if i < 0 or j < 0 or i >= m or j >= n or board[i][j] != word[k]:\\n                return False\\n\\n            temp = board[i][j]\\n            board[i][j] = '#'\\n\\n            found = (dfs(i+1, j, k+1) or\\n                     dfs(i-1, j, k+1) or\\n                     dfs(i, j+1, k+1) or\\n                     dfs(i, j-1, k+1))\\n\\n            board[i][j] = temp\\n            return found\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0] and dfs(i, j, 0):\\n                    return True\\n        return False\\n\"",
  "1989_14631217_python-updated-time": "1746626194534",
  "3490_14631217_python-updated-time": "1747486248075",
  "1411_14631217_python": "\"class Solution:\\n    def getDecimalValue(self, head):\\n        num = 0\\n        while head:\\n            num = (num << 1) | head.val  # Left shift and add current bit\\n            head = head.next\\n        return num\\n\"",
  "2498_14631217_python": "\"class Solution:\\n    def smallestSubarrays(self, nums):\\n        n = len(nums)\\n        # next_pos[b] = the smallest index >= i where bit b is set\\n        # Initialize to n (meaning \\\"not seen\\\")\\n        next_pos = [n] * 32\\n        answer = [1] * n\\n\\n        # Process from right to left\\n        for i in range(n - 1, -1, -1):\\n            x = nums[i]\\n            # Update next_pos for bits set in nums[i]\\n            b = 0\\n            while x:\\n                if x & 1:\\n                    next_pos[b] = i\\n                x >>= 1\\n                b += 1\\n\\n            # Determine the farthest needed index to cover all bits\\n            farthest = i\\n            for pos in next_pos:\\n                if pos < n and pos > farthest:\\n                    farthest = pos\\n\\n            answer[i] = farthest - i + 1\\n\\n        return answer\\n\"",
  "3478_14631217_python-updated-time": "1747494289439",
  "2921_14631217_python-updated-time": "1747223844481",
  "1171_14631217_python-updated-time": "1746108223871",
  "3683_14631217_python-updated-time": "1747653043107",
  "2686_14631217_python-updated-time": "1747136963432",
  "132_14631217_python-updated-time": "1745085269558",
  "2788_14631217_javascript-updated-time": "1747136284791",
  "1305_14631217_python": "\"class Solution(object):\\n    def canSeePersonsCount(self, heights):\\n        n = len(heights)\\n        ans = [0] * n\\n        stack = []\\n        for i in range(n - 1, -1, -1):\\n            h = heights[i]\\n            # Pop all shorter people; each pop is one visible person\\n            while stack and h > stack[-1]:\\n                ans[i] += 1\\n                stack.pop()\\n            # If there's still someone taller or equal, you see that one too\\n            if stack:\\n                ans[i] += 1\\n            # Add yourself to the stack\\n            stack.append(h)\\n        return ans\\n\"",
  "3743_14631217_python": "\"class Solution(object):\\n    def maxFreeTime(self, eventTime, k, startTime, endTime):\\n        \\\"\\\"\\\"\\n        :type eventTime: int\\n        :type k: int\\n        :type startTime: List[int]\\n        :type endTime: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(startTime)\\n        # compute the slack segments g[0..n]:\\n        # g[0] = free time before first meeting,\\n        # g[i] = free time between meeting i-1 and i,\\n        # g[n] = free time after last meeting.\\n        g = [0] * (n + 1)\\n        g[0] = startTime[0]\\n        for i in range(1, n):\\n            g[i] = startTime[i] - endTime[i - 1]\\n        g[n] = eventTime - endTime[n - 1]\\n\\n        # We can merge up to k+1 consecutive slack segments by moving k meetings:\\n        w = min(k + 1, n + 1)\\n\\n        # sliding window of length w over g to find max sum\\n        curr = sum(g[:w])\\n        ans = curr\\n        for i in range(w, n + 1):\\n            curr += g[i] - g[i - w]\\n            if curr > ans:\\n                ans = curr\\n\\n        return ans\\n\"",
  "2293_14631217_python": "\"class Solution(object):\\n    def minSteps(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        count_s = Counter(s)\\n        count_t = Counter(t)\\n\\n        steps = 0\\n        for ch in set(count_s.keys()).union(count_t.keys()):\\n            steps += abs(count_s.get(ch, 0) - count_t.get(ch, 0))\\n\\n        return steps\\n\"",
  "1120_14631217_python-updated-time": "1746042754940",
  "2818_14631217_python-updated-time": "1747140362442",
  "202_14631217_python": "\"class Solution(object):\\n    def isHappy(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        seen = set()\\n        while n != 1 and n not in seen:\\n            seen.add(n)\\n            n = sum(int(digit) ** 2 for digit in str(n))\\n        return n == 1\\n\"",
  "784_14631217_python-updated-time": "1745786212868",
  "640_14631217_python": "\"class Solution(object):\\n    def solveEquation(self, equation):\\n        def parse(side):\\n            coef = 0\\n            const = 0\\n            i = 0\\n            sign = 1\\n            while i < len(side):\\n                if side[i] == '+':\\n                    sign = 1\\n                    i += 1\\n                elif side[i] == '-':\\n                    sign = -1\\n                    i += 1\\n                else:\\n                    num = 0\\n                    is_num = False\\n                    while i < len(side) and side[i].isdigit():\\n                        num = num * 10 + int(side[i])\\n                        i += 1\\n                        is_num = True\\n                    if i < len(side) and side[i] == 'x':\\n                        if not is_num:\\n                            num = 1\\n                        coef += sign * num\\n                        i += 1\\n                    else:\\n                        const += sign * num\\n            return coef, const\\n        \\n        left, right = equation.split('=')\\n        lcoef, lconst = parse(left)\\n        rcoef, rconst = parse(right)\\n        \\n        coef = lcoef - rcoef\\n        const = rconst - lconst\\n        \\n        if coef == 0:\\n            if const == 0:\\n                return \\\"Infinite solutions\\\"\\n            else:\\n                return \\\"No solution\\\"\\n        else:\\n            return \\\"x=\\\" + str(const // coef)\\n\"",
  "95_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \\\"\\\"\\\"\\n        if n == 0:\\n            return []\\n        \\n        def build_trees(start, end):\\n            if start > end:\\n                return [None]\\n            \\n            all_trees = []\\n            for i in range(start, end + 1):\\n                left_trees = build_trees(start, i - 1)\\n                right_trees = build_trees(i + 1, end)\\n                \\n                for l in left_trees:\\n                    for r in right_trees:\\n                        root = TreeNode(i)\\n                        root.left = l\\n                        root.right = r\\n                        all_trees.append(root)\\n            return all_trees\\n        \\n        return build_trees(1, n)\\n\"",
  "1766_14631217_python": "\"class Solution:\\n    def minimumMountainRemovals(self, nums):\\n        n = len(nums)\\n        # 1) Compute L[i]: LIS ending at i\\n        L = [1]*n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if L[j] + 1 > L[i]:\\n                        L[i] = L[j] + 1\\n        \\n        # 2) Compute R[i]: LIS (from right) starting at i = LDS from i\\n        R = [1]*n\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, i, -1):\\n                if nums[j] < nums[i]:\\n                    if R[j] + 1 > R[i]:\\n                        R[i] = R[j] + 1\\n        \\n        # 3) Find best mountain\\n        best = 0\\n        for i in range(1, n-1):\\n            if L[i] > 1 and R[i] > 1:  # valid peak\\n                length = L[i] + R[i] - 1\\n                if length > best:\\n                    best = length\\n        \\n        # 4) Answer = remove the rest\\n        return n - best\\n\"",
  "2605_14631217_python-updated-time": "1747059416565",
  "1924_14631217_python": "\"class Solution(object):\\n    def maxHappyGroups(self, batchSize, groups):\\n        zero = 0\\n        counts = [0] * batchSize\\n        for g in groups:\\n            r = g % batchSize\\n            if r == 0:\\n                zero += 1\\n            else:\\n                counts[r] += 1\\n\\n        memo = {}\\n        def dfs(counts_tuple, curr_rem):\\n            key = (counts_tuple, curr_rem)\\n            if key in memo:\\n                return memo[key]\\n            counts_list = list(counts_tuple)\\n            if sum(counts_list) == 0:\\n                return 0\\n            best = 0\\n            for r in range(1, batchSize):\\n                if counts_list[r] > 0:\\n                    counts_list[r] -= 1\\n                    next_rem = (curr_rem + r) % batchSize\\n                    inc = 1 if curr_rem == 0 else 0\\n                    val = inc + dfs(tuple(counts_list), next_rem)\\n                    if val > best:\\n                        best = val\\n                    counts_list[r] += 1\\n            memo[key] = best\\n            return best\\n\\n        return zero + dfs(tuple(counts), 0)\\n\"",
  "1028_14631217_python": "\"class Solution:\\n    def intervalIntersection(self, firstList, secondList):\\n        i, j = 0, 0\\n        result = []\\n\\n        while i < len(firstList) and j < len(secondList):\\n            a_start, a_end = firstList[i]\\n            b_start, b_end = secondList[j]\\n\\n            # Compute the intersection\\n            start = max(a_start, b_start)\\n            end = min(a_end, b_end)\\n\\n            if start <= end:\\n                result.append([start, end])\\n\\n            # Move the pointer with the smaller end time\\n            if a_end < b_end:\\n                i += 1\\n            else:\\n                j += 1\\n\\n        return result\\n\"",
  "2400_14631217_python": "\"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(10000)          # allow deep recursions (n ≤ 1000)\\n\\nclass Solution:\\n    def minimumScore(self, nums, edges):\\n        n = len(nums)\\n\\n        # ------------- build adjacency -------------\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        parent = [-1] * n\\n        subxor = nums[:]          # subtree xor\\n        tin    = [0] * n          # DFS entry time\\n        tout   = [0] * n          # DFS exit  time\\n        timer  = [0]              # mutable integer\\n\\n        # -------- DFS: parent, subtree xor, Euler times --------\\n        def dfs(u, p):\\n            parent[u] = p\\n            tin[u] = timer[0]\\n            timer[0] += 1\\n            for v in g[u]:\\n                if v == p:\\n                    continue\\n                dfs(v, u)\\n                subxor[u] ^= subxor[v]\\n            tout[u] = timer[0]\\n            timer[0] += 1\\n\\n        dfs(0, -1)\\n        total = subxor[0]\\n\\n        def is_ancestor(a, b):\\n            \\\"\\\"\\\"True if a lies on the path root→…→b (a is ancestor of b).\\\"\\\"\\\"\\n            return tin[a] <= tin[b] and tout[b] <= tout[a]\\n\\n        # Each edge is uniquely identified by its child node (parent[child] ≠ -1)\\n        children = [v for v in range(1, n)]    # node 0 has no parent edge\\n\\n        best = float('inf')\\n        m = len(children)\\n\\n        for i in range(m):\\n            u = children[i]        # first cut edge = (parent[u], u)\\n            Xu = subxor[u]\\n\\n            for j in range(i + 1, m):\\n                v = children[j]    # second cut edge = (parent[v], v)\\n                Xv = subxor[v]\\n\\n                if is_ancestor(u, v):          # u-subtree strictly contains v-subtree\\n                    comp1 = Xv\\n                    comp2 = Xu ^ Xv\\n                    comp3 = total ^ Xu\\n                elif is_ancestor(v, u):        # v-subtree strictly contains u-subtree\\n                    comp1 = Xu\\n                    comp2 = Xv ^ Xu\\n                    comp3 = total ^ Xv\\n                else:                          # two disjoint subtrees\\n                    comp1 = Xu\\n                    comp2 = Xv\\n                    comp3 = total ^ Xu ^ Xv\\n\\n                diff = max(comp1, comp2, comp3) - min(comp1, comp2, comp3)\\n                best = min(best, diff)\\n\\n        return best\\n\"",
  "2724_14631217_python-updated-time": "1747134533340",
  "1119_14631217_python": "\"class Solution:\\n    def isRobotBounded(self, instructions):\\n        x = y = 0\\n        dx, dy = 0, 1  # facing north\\n        for ch in instructions:\\n            if ch == 'G':\\n                x += dx\\n                y += dy\\n            elif ch == 'L':\\n                dx, dy = -dy, dx\\n            else:  # 'R'\\n                dx, dy = dy, -dx\\n        return (x == 0 and y == 0) or (dx, dy) != (0, 1)\\n\"",
  "1498_14631217_python": "\"class Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        if original is None:\\n            return None\\n        if original == target:\\n            return cloned\\n        left = self.getTargetCopy(original.left, cloned.left, target)\\n        if left:\\n            return left\\n        return self.getTargetCopy(original.right, cloned.right, target)\\n\"",
  "420_14631217_python": "\"class Solution:\\n    def strongPasswordChecker(self, password):\\n        n = len(password)\\n        \\n        has_lower = has_upper = has_digit = False\\n        for c in password:\\n            if c.islower():\\n                has_lower = True\\n            elif c.isupper():\\n                has_upper = True\\n            elif c.isdigit():\\n                has_digit = True\\n        \\n        missing_types = 3 - (has_lower + has_upper + has_digit)\\n        \\n        repeats = []\\n        i = 2\\n        while i < n:\\n            if password[i] == password[i-1] == password[i-2]:\\n                j = i\\n                while j < n and password[j] == password[i-1]:\\n                    j += 1\\n                repeats.append(j - (i-2))\\n                i = j\\n            else:\\n                i += 1\\n        \\n        if n < 6:\\n            return max(missing_types, 6 - n)\\n        \\n        replace = sum(length // 3 for length in repeats)\\n        \\n        if n <= 20:\\n            return max(missing_types, replace)\\n        \\n        # Need to delete (n-20) chars\\n        delete = n - 20\\n        \\n        for idx in range(len(repeats)):\\n            if delete == 0:\\n                break\\n            length = repeats[idx]\\n            if length < 3:\\n                continue\\n            if length % 3 == 0:\\n                reduce = min(delete, 1)\\n                repeats[idx] -= reduce\\n                delete -= reduce\\n        \\n        for idx in range(len(repeats)):\\n            if delete == 0:\\n                break\\n            length = repeats[idx]\\n            if length < 3:\\n                continue\\n            if length % 3 == 1:\\n                reduce = min(delete, 2)\\n                repeats[idx] -= reduce\\n                delete -= reduce\\n        \\n        for idx in range(len(repeats)):\\n            if delete == 0:\\n                break\\n            length = repeats[idx]\\n            if length < 3:\\n                continue\\n            reduce = min(delete, length - 2)\\n            repeats[idx] -= reduce\\n            delete -= reduce\\n        \\n        replace = sum(length // 3 for length in repeats if length >= 3)\\n        \\n        return (n - 20) + max(missing_types, replace)\\n\"",
  "3816_14631217_mysql-updated-time": "1747682498422",
  "2355_14631217_python": "\"class Solution:\\n    def maxConsecutive(self, bottom, top, special):\\n        special.sort()\\n        prev = bottom - 1\\n        ans = 0\\n        for s in special:\\n            # floors between prev+1 and s-1 inclusive\\n            gap = s - prev - 1\\n            if gap > ans:\\n                ans = gap\\n            prev = s\\n        # after last special to top\\n        tail_gap = top - prev\\n        if tail_gap > ans:\\n            ans = tail_gap\\n        return ans\\n\"",
  "626_14631217_mysql": "\"SELECT \\n    CASE \\n        WHEN id % 2 = 1 AND id + 1 <= (SELECT MAX(id) FROM Seat) THEN id + 1\\n        WHEN id % 2 = 0 THEN id - 1\\n        ELSE id\\n    END AS id,\\n    student\\nFROM Seat\\nORDER BY id;\\n\"",
  "650_14631217_python": "\"class Solution(object):\\n    def minSteps(self, n):\\n        res = 0\\n        d = 2\\n        while n > 1:\\n            while n % d == 0:\\n                res += d\\n                n //= d\\n            d += 1\\n        return res\\n\"",
  "1610_14631217_python": "\"class Solution(object):\\n    def xorOperation(self, n, start):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type start: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = 0\\n        for i in range(n):\\n            res ^= start + 2 * i\\n        return res\\n\"",
  "1757_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden = set(forbidden)\\n        if x == 0:\\n            return 0\\n        \\n        # Upper bound on positions we’ll consider\\n        limit = max(forbidden | {x}) + a + b\\n        \\n        # BFS queue: (position, last_was_backward)\\n        q = deque([(0, False)])\\n        visited = {(0, False)}\\n        \\n        jumps = 0\\n        while q:\\n            for _ in range(len(q)):\\n                pos, came_back = q.popleft()\\n                if pos == x:\\n                    return jumps\\n                \\n                # 1) Try forward jump\\n                fwd = pos + a\\n                if fwd <= limit and fwd not in forbidden and (fwd, False) not in visited:\\n                    visited.add((fwd, False))\\n                    q.append((fwd, False))\\n                \\n                # 2) Try backward jump (only if we didn’t just come backward)\\n                if not came_back:\\n                    back = pos - b\\n                    if back >= 0 and back not in forbidden and (back, True) not in visited:\\n                        visited.add((back, True))\\n                        q.append((back, True))\\n            \\n            jumps += 1\\n        \\n        return -1\\n\"",
  "303_14631217_python": "\"class NumArray(object):\\n    def __init__(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        \\\"\\\"\\\"\\n        self.prefix = [0]\\n        for num in nums:\\n            self.prefix.append(self.prefix[-1] + num)\\n\\n    def sumRange(self, left, right):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self.prefix[right + 1] - self.prefix[left]\\n\"",
  "231_14631217_python-updated-time": "1745247198340",
  "2525_14631217_python-updated-time": "1746968045358",
  "3063_14631217_pythondata": "\"import pandas as pd\\n\\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\\n    return animals[animals['weight'] > 100].sort_values('weight', ascending=False)[['name']]\\n\"",
  "390_14631217_python": "\"class Solution:\\n    def lastRemaining(self, n):\\n        head = 1\\n        step = 1\\n        left_to_right = True\\n        \\n        while n > 1:\\n            if left_to_right or n % 2 == 1:\\n                head += step\\n            step *= 2\\n            n //= 2\\n            left_to_right = not left_to_right\\n        \\n        return head\\n\"",
  "2917_14631217_python-updated-time": "1747225521906",
  "1630_14631217_python-updated-time": "1746433766414",
  "908_14631217_python-updated-time": "1746001576916",
  "3559_14631217_python": "\"class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False  # indicates a valid prefix\\n\\nclass Solution(object):\\n    def minValidStrings(self, words, target):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        root = TrieNode()\\n        \\n        # insert all prefixes of each word into trie\\n        for word in words:\\n            node = root\\n            for ch in word:\\n                if ch not in node.children:\\n                    node.children[ch] = TrieNode()\\n                node = node.children[ch]\\n                node.end = True  # mark every prefix as valid\\n\\n        n = len(target)\\n        INF = float('inf')\\n        dp = [INF] * (n + 1)\\n        dp[0] = 0\\n\\n        for i in range(n):\\n            if dp[i] == INF:\\n                continue\\n            node = root\\n            for j in range(i, n):\\n                c = target[j]\\n                if c not in node.children:\\n                    break\\n                node = node.children[c]\\n                if node.end:\\n                    dp[j + 1] = min(dp[j + 1], dp[i] + 1)\\n\\n        return dp[n] if dp[n] != INF else -1\\n\"",
  "1217_14631217_python-updated-time": "1746109021309",
  "3174_14631217_python-updated-time": "1747308462628",
  "1562_14631217_python": "\"class Solution:\\n    def peopleIndexes(self, favoriteCompanies):\\n        n = len(favoriteCompanies)\\n        sets = [set(lst) for lst in favoriteCompanies]\\n        res = []\\n        for i, s_i in enumerate(sets):\\n            is_subset = False\\n            for j, s_j in enumerate(sets):\\n                if i == j or len(s_i) > len(s_j):\\n                    continue\\n                if s_i.issubset(s_j):\\n                    is_subset = True\\n                    break\\n            if not is_subset:\\n                res.append(i)\\n        return res\\n\"",
  "1765_14631217_python-updated-time": "1746445897626",
  "2586_14631217_python": "\"class Solution:\\n    def longestSquareStreak(self, nums):\\n        nums_set = set(nums)\\n        nums.sort()\\n        max_len = -1\\n\\n        for num in nums:\\n            streak = 1\\n            val = num\\n            while val * val in nums_set:\\n                val *= val\\n                streak += 1\\n            if streak >= 2:\\n                max_len = max(max_len, streak)\\n\\n        return max_len\\n\"",
  "1336_14631217_python-updated-time": "1746639213029",
  "768_14631217_python-updated-time": "1745876035093",
  "372_14631217_python": "\"class Solution:\\n    def superPow(self, a, b):\\n        if not b:\\n            return 1\\n        last_digit = b.pop()\\n        part1 = pow(a, last_digit, 1337)\\n        part2 = pow(self.superPow(a, b), 10, 1337)\\n        return (part1 * part2) % 1337\\n\"",
  "554_14631217_python-updated-time": "1745447479514",
  "2481_14631217_python-updated-time": "1746965601950",
  "3810_14631217_python": "\"import sys\\n\\nclass Solution(object):\\n    def countNumbers(self, l_str, r_str, b):\\n        self.MOD = 10**9 + 7\\n        self.memo = {}  # Memoization table for DP states\\n        self.base_for_dp = 0  # Stores the current base 'b' for access in _actual_solve\\n        \\n        # It's good practice to ensure recursion limit is sufficient.\\n        # Python's default is often 1000. Max recursion depth is number of digits in base b,\\n        # which can be up to ~333 for b=2 and a 100-digit base-10 number. This should be fine.\\n        # current_recursion_limit = sys.getrecursionlimit()\\n        # required_limit = 400 # Max digits in base b + some buffer\\n        # if current_recursion_limit < required_limit:\\n        #    sys.setrecursionlimit(required_limit)\\n\\n\\n        count_r = self._get_count_le_s(r_str, b)\\n        \\n        l_val = int(l_str)\\n        l_minus_1_val = l_val - 1\\n        \\n        # Since l_str >= \\\"1\\\", l_val >= 1, so l_minus_1_val >= 0.\\n        # str(l_minus_1_val) will correctly convert this non-negative integer to string.\\n        count_l_minus_1 = self._get_count_le_s(str(l_minus_1_val), b)\\n\\n        result = (count_r - count_l_minus_1 + self.MOD) % self.MOD\\n        return result\\n\\n    def _int_to_base_b_digits(self, n_val, base):\\n        if n_val == 0:\\n            return [0]\\n        \\n        digits = []\\n        while n_val > 0:\\n            digits.append(n_val % base)\\n            n_val //= base # Integer division (works in Python 2 and 3)\\n        return digits[::-1] # Return digits in correct order (MSD first)\\n\\n    def _actual_solve(self, s_digits_b, pos, prev_d, tight, is_started, n_total_digits):\\n        # Tuple for memoization key\\n        state = (pos, prev_d, tight, is_started)\\n        \\n        if pos == n_total_digits:\\n            # Successfully constructed a number of n_total_digits.\\n            # This counts one valid number. If is_started remained False, it means\\n            # all digits were zero, so this counts the number 0.\\n            return 1\\n        \\n        if state in self.memo:\\n            return self.memo[state]\\n\\n        ans = 0\\n        # Determine the upper limit for the current digit based on 'tight' constraint\\n        limit = s_digits_b[pos] if tight else (self.base_for_dp - 1)\\n\\n        for digit in range(limit + 1): # Iterate through possible values for the current digit\\n            # Update 'tight' for the next recursive call\\n            current_new_tight = tight and (digit == limit)\\n            \\n            if not is_started:\\n                # If we haven't placed any non-zero digit yet\\n                if digit == 0:\\n                    # If current digit is 0, we are still forming leading zeros (or the number 0)\\n                    # 'prev_d' for next step is 0 (or any value, it's ignored), 'is_started' remains False\\n                    ans = (ans + self._actual_solve(s_digits_b, pos + 1, 0, current_new_tight, False, n_total_digits)) % self.MOD\\n                else:\\n                    # This is the first non-zero digit\\n                    # 'prev_d' for next step is this 'digit', 'is_started' becomes True\\n                    ans = (ans + self._actual_solve(s_digits_b, pos + 1, digit, current_new_tight, True, n_total_digits)) % self.MOD\\n            else:\\n                # If we have already started (placed a non-zero digit)\\n                # The current digit must be greater than or equal to the previous digit\\n                if digit >= prev_d:\\n                    # 'prev_d' for next step is this 'digit', 'is_started' remains True\\n                    ans = (ans + self._actual_solve(s_digits_b, pos + 1, digit, current_new_tight, True, n_total_digits)) % self.MOD\\n        \\n        self.memo[state] = ans\\n        return ans\\n\\n    def _get_count_le_s(self, num_str_base10, base_val):\\n        num_val = int(num_str_base10)\\n        \\n        s_digits_b_repr = self._int_to_base_b_digits(num_val, base_val)\\n        n_digits_in_s = len(s_digits_b_repr)\\n        \\n        self.memo.clear()  # Clear memo for each new upper bound S\\n        self.base_for_dp = base_val # Make base available to _actual_solve via self\\n        \\n        # Initial call to the recursive DP solver:\\n        # pos = 0 (start from the most significant digit)\\n        # prev_d = 0 (placeholder, effectively ignored since is_started is False)\\n        # tight = True (digits are restricted by S's digits initially)\\n        # is_started = False (we haven't placed any non-zero digit yet)\\n        count = self._actual_solve(s_digits_b_repr, 0, 0, True, False, n_digits_in_s)\\n        return count\"",
  "1097_14631217_python-updated-time": "1746042171134",
  "2257_14631217_python": "\"class Solution:\\n    def earliestFullBloom(self, plantTime, growTime):\\n        seeds = sorted(zip(growTime, plantTime), reverse=True)\\n        curr_day = 0\\n        max_bloom = 0\\n        for g, p in seeds:\\n            curr_day += p\\n            max_bloom = max(max_bloom, curr_day + g)\\n        return max_bloom\\n\"",
  "689_14631217_python-updated-time": "1745785537840",
  "619_14631217_mysql": "\"SELECT \\n    MAX(num) AS num\\nFROM \\n    (SELECT num\\n     FROM MyNumbers\\n     GROUP BY num\\n     HAVING COUNT(*) = 1) AS singles;\\n\"",
  "482_14631217_python-updated-time": "1745441678239",
  "400_14631217_python": "\"class Solution:\\n    def findNthDigit(self, n):\\n        length = 1\\n        count = 9\\n        start = 1\\n        \\n        while n > length * count:\\n            n -= length * count\\n            length += 1\\n            count *= 10\\n            start *= 10\\n        \\n        start += (n - 1) // length\\n        s = str(start)\\n        return int(s[(n - 1) % length])\\n\"",
  "3711_14631217_mysql": "\"WITH RECURSIVE\\n-- 1) Unroll each string into rows (content_id, pos, len, full_text)\\npositions AS (\\n  SELECT\\n    content_id,\\n    content_text        AS full_text,\\n    1                    AS pos,\\n    CHAR_LENGTH(content_text) AS len\\n  FROM user_content\\n  UNION ALL\\n  SELECT\\n    content_id,\\n    full_text,\\n    pos + 1,\\n    len\\n  FROM positions\\n  WHERE pos < len\\n),\\n-- 2) Annotate each character with the previous character (or NULL if pos=1)\\nchars AS (\\n  SELECT\\n    content_id,\\n    pos,\\n    SUBSTRING(full_text, pos, 1)            AS ch,\\n    CASE WHEN pos = 1\\n         THEN NULL\\n         ELSE SUBSTRING(full_text, pos-1, 1)\\n    END                                        AS prev\\n  FROM positions\\n)\\n-- 3) Reassemble per content_id, applying our rule:\\nSELECT\\n  uc.content_id,\\n  uc.content_text     AS original_text,\\n  -- Use GROUP_CONCAT over pos, with empty SEPARATOR, to rebuild in order\\n  GROUP_CONCAT(\\n    CASE\\n      -- If at start or prev is non‐letter, and current is a letter → UPPER\\n      WHEN (pos = 1 OR prev NOT REGEXP '[A-Za-z]')\\n           AND ch  REGEXP '[A-Za-z]'\\n      THEN UPPER(ch)\\n      -- Otherwise → LOWER\\n      ELSE LOWER(ch)\\n    END\\n    ORDER BY pos\\n    SEPARATOR ''\\n  ) AS converted_text\\nFROM user_content AS uc\\nJOIN chars USING (content_id)\\nGROUP BY uc.content_id, uc.content_text\\nORDER BY uc.content_id;\\n\"",
  "15_14631217_python": "\"class Solution(object):\\n    def threeSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            left, right = i+1, n-1\\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                if total < 0:\\n                    left += 1\\n                elif total > 0:\\n                    right -= 1\\n                else:\\n                    res.append([nums[i], nums[left], nums[right]])\\n                    left += 1\\n                    right -= 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        return res\\n\"",
  "2870_14631217_python-updated-time": "1747222053151",
  "684_14631217_python-updated-time": "1745785109548",
  "3305_14631217_python-updated-time": "1747417769386",
  "733_14631217_python": "\"class Solution(object):\\n    def floodFill(self, image, sr, sc, color):\\n        m, n = len(image), len(image[0])\\n        orig = image[sr][sc]\\n        if orig == color:\\n            return image\\n        def dfs(r, c):\\n            if r < 0 or r >= m or c < 0 or c >= n or image[r][c] != orig:\\n                return\\n            image[r][c] = color\\n            dfs(r+1, c)\\n            dfs(r-1, c)\\n            dfs(r, c+1)\\n            dfs(r, c-1)\\n        dfs(sr, sc)\\n        return image\\n\"",
  "1362_14631217_python": "\"class Solution:\\n    def nthPersonGetsNthSeat(self, n):\\n        return 1.0 if n == 1 else 0.5\\n\"",
  "3069_14631217_pythondata-updated-time": "1747305804368",
  "1700_14631217_python-updated-time": "1746438411145",
  "3630_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nmod = 10**9 + 7\\n\\nclass Solution(object):\\n    def lengthAfterTransformations(self, s, t, nums):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Build transition matrix A: A[i][j] = 1 if char i transforms to char j\\n        A = [[0] * 26 for _ in range(26)]\\n        for i in range(26):\\n            for k in range(1, nums[i] + 1):\\n                j = (i + k) % 26\\n                A[i][j] = 1\\n\\n        # Matrix multiplication mod\\n        def mat_mult(X, Y):\\n            Z = [[0] * 26 for _ in range(26)]\\n            for i in range(26):\\n                Xi = X[i]\\n                Zi = Z[i]\\n                for k in range(26):\\n                    v = Xi[k]\\n                    if v:\\n                        Yk = Y[k]\\n                        for j in range(26):\\n                            Zi[j] = (Zi[j] + v * Yk[j]) % mod\\n            return Z\\n\\n        # Fast exponentiation of matrix\\n        def mat_pow(mat, power):\\n            # identity matrix\\n            res = [[0] * 26 for _ in range(26)]\\n            for i in range(26):\\n                res[i][i] = 1\\n            M = mat\\n            while power > 0:\\n                if power & 1:\\n                    res = mat_mult(res, M)\\n                M = mat_mult(M, M)\\n                power >>= 1\\n            return res\\n\\n        # Base: t=0 => each char contributes len 1\\n        if t == 0:\\n            return len(s) % mod\\n\\n        # Compute A^t\\n        At = mat_pow(A, t)\\n        # f_t[c] = total length contribution of starting char c\\n        f = [sum(At[c][j] for j in range(26)) % mod for c in range(26)]\\n\\n        # Sum over original string\\n        ans = 0\\n        for ch in s:\\n            ans = (ans + f[ord(ch) - ord('a')]) % mod\\n        return ans\\n\"",
  "2210_14631217_python": "\"class Solution:\\n    def targetIndices(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        result = []\\n        for i, v in enumerate(nums):\\n            if v == target:\\n                result.append(i)\\n        return result\\n\"",
  "50_14631217_python-updated-time": "1744999643815",
  "1939_14631217_python": "\"class Solution(object):\\n    def countPoints(self, points, queries):\\n        ans = []\\n        for x, y, r in queries:\\n            r2 = r * r\\n            cnt = 0\\n            for px, py in points:\\n                if (px - x) ** 2 + (py - y) ** 2 <= r2:\\n                    cnt += 1\\n            ans.append(cnt)\\n        return ans\\n\"",
  "2508_14631217_python": "\"class Solution:\\n    def maxSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        max_sum = 0\\n        for i in range(m - 2):\\n            for j in range(n - 2):\\n                # Sum the hourglass with top-left corner at (i,j)\\n                s = (\\n                    grid[i][j] + grid[i][j+1] + grid[i][j+2] +\\n                    grid[i+1][j+1] +\\n                    grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\\n                )\\n                if s > max_sum:\\n                    max_sum = s\\n        return max_sum\\n\"",
  "2174_14631217_python": "\"import itertools\\nimport bisect\\n\\nclass Solution(object):\\n    def nextBeautifulNumber(self, n):\\n        # Step 1: Build all balanced numbers of up to 7 digits\\n        balanced = set()\\n        # For each subset of digits 1..9, decide which digits to include\\n        # A digit d, if included, must appear exactly d times\\n        for mask in range(1, 1<<9):\\n            digits = []\\n            length = 0\\n            for d in range(1, 10):\\n                if (mask >> (d-1)) & 1:\\n                    length += d\\n                    digits += [str(d)] * d\\n            # we only need numbers up to 7 digits (since n ≤ 10^6)\\n            if 1 <= length <= 7:\\n                # generate all unique permutations of this multiset\\n                for perm in set(itertools.permutations(digits, length)):\\n                    # skip those starting with '0' (none will, since digits are '1'..'9')\\n                    num = int(\\\"\\\".join(perm))\\n                    balanced.add(num)\\n\\n        # Step 2: Sort the list\\n        sorted_balanced = sorted(balanced)\\n\\n        # Step 3: Binary-search for the smallest > n\\n        idx = bisect.bisect_right(sorted_balanced, n)\\n        return sorted_balanced[idx]\\n\"",
  "1993_14631217_python-updated-time": "1746625275734",
  "2614_14631217_python-updated-time": "1747060478281",
  "941_14631217_python-updated-time": "1746002775596",
  "1929_14631217_python": "\"class Solution(object):\\n    def maxValue(self, n, index, maxSum):\\n        def calc_sum(peak, length):\\n            if peak > length:\\n                total = (peak + peak - length + 1) * length // 2\\n            else:\\n                total = (peak + 1) * peak // 2 + (length - peak)\\n            return total\\n\\n        def is_valid(peak):\\n            left = calc_sum(peak - 1, index)\\n            right = calc_sum(peak - 1, n - index - 1)\\n            return left + right + peak <= maxSum\\n\\n        low, high = 1, maxSum\\n        while low < high:\\n            mid = (low + high + 1) // 2\\n            if is_valid(mid):\\n                low = mid\\n            else:\\n                high = mid - 1\\n        return low\\n\"",
  "646_14631217_python-updated-time": "1745782585785",
  "2018_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def minWastedSpace(self, packages, boxes):\\n        MOD = 10**9 + 7\\n        packages.sort()\\n        prefix = [0]\\n        for p in packages:\\n            prefix.append(prefix[-1] + p)\\n        \\n        res = float('inf')\\n        \\n        for supplier in boxes:\\n            supplier.sort()\\n            if supplier[-1] < packages[-1]:\\n                continue  # can't fit all packages\\n            i = 0\\n            total = 0\\n            for b in supplier:\\n                j = bisect.bisect_right(packages, b, i)\\n                count = j - i\\n                total += b * count - (prefix[j] - prefix[i])\\n                i = j\\n                if i == len(packages):\\n                    break\\n            res = min(res, total)\\n        \\n        return res % MOD if res < float('inf') else -1\\n\"",
  "3251_14631217_python-updated-time": "1747392723511",
  "2220_14631217_python-updated-time": "1746800192391",
  "2122_14631217_python-updated-time": "1746717305943",
  "2545_14631217_python": "\"class Solution(object):\\n    def treeQueries(self, root, queries):\\n        import sys\\n        sys.setrecursionlimit(10**7)\\n\\n        # 1) Build children map and count nodes\\n        nodes = {}\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            nodes[u.val] = u\\n            if u.left: stack.append(u.left)\\n            if u.right: stack.append(u.right)\\n        children = {v: [] for v in nodes}\\n        for v, u in nodes.items():\\n            if u.left:  children[v].append(u.left.val)\\n            if u.right: children[v].append(u.right.val)\\n        n = len(nodes)\\n\\n        # 2) Euler tour + depths\\n        tin = [0]*(n+1)\\n        tout = [0]*(n+1)\\n        depth = [0]*(n+1)\\n        order = []\\n        t = [0]  # use list to allow mutation\\n\\n        def dfs(u, d):\\n            tin[u] = t[0]\\n            order.append(u)\\n            depth[u] = d\\n            t[0] += 1\\n            for w in children[u]:\\n                dfs(w, d+1)\\n            tout[u] = t[0]-1\\n\\n        dfs(root.val, 0)\\n\\n        # 3) Segment tree for max depth over Euler positions\\n        size = 1\\n        while size < n:\\n            size <<= 1\\n        seg = [0] * (2*size)\\n        for i, u in enumerate(order):\\n            seg[size + i] = depth[u]\\n        for i in range(size-1, 0, -1):\\n            seg[i] = max(seg[2*i], seg[2*i+1])\\n\\n        def query(l, r):\\n            if l > r:\\n                return 0\\n            res = 0\\n            l += size; r += size\\n            while l <= r:\\n                if l & 1:\\n                    res = max(res, seg[l])\\n                    l += 1\\n                if not (r & 1):\\n                    res = max(res, seg[r])\\n                    r -= 1\\n                l //= 2; r //= 2\\n            return res\\n\\n        # 4) Answer queries by max outside the subtree interval\\n        ans = []\\n        for q in queries:\\n            L, R = tin[q], tout[q]\\n            m1 = query(0, L-1)\\n            m2 = query(R+1, n-1)\\n            ans.append(max(m1, m2))\\n        return ans\\n\"",
  "5_14631217_python": "\"class Solution(object):\\n    def longestPalindrome(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if len(s) < 2:\\n            return s\\n\\n        start = 0\\n        max_len = 1\\n\\n        for i in range(len(s)):\\n            l, r = i, i\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                if r - l + 1 > max_len:\\n                    start = l\\n                    max_len = r - l + 1\\n                l -= 1\\n                r += 1\\n\\n            l, r = i, i + 1\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                if r - l + 1 > max_len:\\n                    start = l\\n                    max_len = r - l + 1\\n                l -= 1\\n                r += 1\\n\\n        return s[start:start + max_len]\\n\"",
  "2128_14631217_python-updated-time": "1746717523767",
  "843_14631217_python": "\"class Solution(object):\\n    def numFactoredBinaryTrees(self, arr):\\n        MOD = 10**9 + 7\\n        arr.sort()\\n        dp = {}\\n        index = {x: i for i, x in enumerate(arr)}\\n        \\n        for i, x in enumerate(arr):\\n            dp[x] = 1\\n            for j in range(i):\\n                if x % arr[j] == 0 and (x // arr[j]) in dp:\\n                    dp[x] += dp[arr[j]] * dp[x // arr[j]]\\n        \\n        return sum(dp.values()) % MOD\\n\"",
  "3353_14631217_python-updated-time": "1747420986510",
  "1501_14631217_python": "\"class Solution(object):\\n    def checkOverlap(self, radius, xCenter, yCenter, x1, y1, x2, y2):\\n        # Clamp the circle center to the rectangle boundaries\\n        closest_x = max(x1, min(xCenter, x2))\\n        closest_y = max(y1, min(yCenter, y2))\\n        \\n        # Calculate squared distance from the circle center to the closest point\\n        dx = xCenter - closest_x\\n        dy = yCenter - closest_y\\n        \\n        return dx * dx + dy * dy <= radius * radius\\n\"",
  "1358_14631217_python-updated-time": "1746259318785",
  "1058_14631217_python-updated-time": "1746107717115",
  "1675_14631217_python-updated-time": "1746434487113",
  "3846_14631217_python-updated-time": "1747681780159",
  "1296_14631217_python": "\"class TreeAncestor(object):\\n    def __init__(self, n, parent):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type parent: List[int]\\n        \\\"\\\"\\\"\\n        LOG = 16  # since 2^16 > 5e4\\n        self.LOG = LOG\\n        self.up = [[-1] * LOG for _ in range(n)]\\n\\n        for i in range(n):\\n            self.up[i][0] = parent[i]\\n\\n        for j in range(1, LOG):\\n            for i in range(n):\\n                if self.up[i][j - 1] != -1:\\n                    self.up[i][j] = self.up[self.up[i][j - 1]][j - 1]\\n\\n    def getKthAncestor(self, node, k):\\n        \\\"\\\"\\\"\\n        :type node: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        for j in range(self.LOG):\\n            if k & (1 << j):\\n                node = self.up[node][j]\\n                if node == -1:\\n                    return -1\\n        return node\\n\"",
  "1725_14631217_python": "\"class Solution:\\n    def numberOfSets(self, n, k):\\n        MOD = 10**9 + 7\\n        \\n        # dp_prev[i] will hold dp[j-1][i], initialized for j=0: dp[0][i] = 1\\n        dp_prev = [1] * n\\n        \\n        # prefix_prev[i] = sum(dp_prev[0..i]) mod MOD\\n        prefix_prev = [0] * n\\n        prefix_prev[0] = dp_prev[0]\\n        for i in range(1, n):\\n            prefix_prev[i] = (prefix_prev[i-1] + dp_prev[i]) % MOD\\n        \\n        # Build up from j=1 to j=k\\n        for _ in range(1, k+1):\\n            dp_cur = [0] * n\\n            # dp_cur[0] stays 0 for j>=1\\n            for i in range(1, n):\\n                # dp[j][i] = dp[j][i-1] + sum(dp[j-1][0..i-1])\\n                dp_cur[i] = dp_cur[i-1] + prefix_prev[i-1]\\n                if dp_cur[i] >= MOD:\\n                    dp_cur[i] %= MOD\\n            \\n            # Move current row into dp_prev and rebuild prefix\\n            dp_prev = dp_cur\\n            prefix_prev[0] = dp_prev[0]\\n            for i in range(1, n):\\n                prefix_prev[i] = (prefix_prev[i-1] + dp_prev[i]) % MOD\\n        \\n        # Answer is dp[k][n-1]\\n        return dp_prev[n-1]\\n\"",
  "3463_14631217_python-updated-time": "1747486754154",
  "543_14631217_python": "\"class Solution:\\n    def diameterOfBinaryTree(self, root):\\n        self.max_diameter = 0\\n\\n        def depth(node):\\n            if not node:\\n                return 0\\n            left = depth(node.left)\\n            right = depth(node.right)\\n            self.max_diameter = max(self.max_diameter, left + right)\\n            return max(left, right) + 1\\n\\n        depth(root)\\n        return self.max_diameter\\n\"",
  "3731_14631217_python-updated-time": "1747659305036",
  "2116_14631217_python-updated-time": "1746717930958",
  "2482_14631217_python-updated-time": "1746965648715",
  "2808_14631217_python-updated-time": "1747221459982",
  "1064_14631217_python": "\"class Solution:\\n    def smallestRepunitDivByK(self, k):\\n        if k % 2 == 0 or k % 5 == 0:\\n            return -1\\n        \\n        num = 0\\n        for length in range(1, k + 1):\\n            num = (num * 10 + 1) % k\\n            if num == 0:\\n                return length\\n        return -1\\n\"",
  "3789_14631217_python-updated-time": "1747741026255",
  "978_14631217_python": "\"class Solution:\\n    def validMountainArray(self, arr):\\n        n = len(arr)\\n        if n < 3:\\n            return False\\n\\n        i = 0\\n\\n        # walk up\\n        while i + 1 < n and arr[i] < arr[i + 1]:\\n            i += 1\\n\\n        # peak can't be first or last\\n        if i == 0 or i == n - 1:\\n            return False\\n\\n        # walk down\\n        while i + 1 < n and arr[i] > arr[i + 1]:\\n            i += 1\\n\\n        return i == n - 1\\n\"",
  "1311_14631217_python": "\"class Solution:\\n    def largestMagicSquare(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Precompute prefix sums for rows and columns\\n        row_sum = [[0] * (n + 1) for _ in range(m)]\\n        col_sum = [[0] * n for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                row_sum[i][j + 1] = row_sum[i][j] + grid[i][j]\\n                col_sum[i + 1][j] = col_sum[i][j] + grid[i][j]\\n\\n        def is_magic(r, c, size):\\n            diag1 = diag2 = 0\\n            for i in range(size):\\n                diag1 += grid[r + i][c + i]\\n                diag2 += grid[r + i][c + size - 1 - i]\\n            if diag1 != diag2:\\n                return False\\n            target = diag1\\n            for i in range(size):\\n                rs = row_sum[r + i][c + size] - row_sum[r + i][c]\\n                cs = col_sum[r + size][c + i] - col_sum[r][c + i]\\n                if rs != target or cs != target:\\n                    return False\\n            return True\\n\\n        max_k = min(m, n)\\n        for k in range(max_k, 0, -1):\\n            for i in range(m - k + 1):\\n                for j in range(n - k + 1):\\n                    if is_magic(i, j, k):\\n                        return k\\n        return 1\\n\"",
  "384_14631217_python": "\"import random\\n\\nclass Solution:\\n    def __init__(self, nums):\\n        self.original = nums[:]\\n        self.nums = nums[:]\\n\\n    def reset(self):\\n        self.nums = self.original[:]\\n        return self.nums\\n\\n    def shuffle(self):\\n        for i in range(len(self.nums)):\\n            j = random.randint(i, len(self.nums) - 1)\\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\\n        return self.nums\\n\"",
  "1514_14631217_python": "\"class Solution(object):\\n    def minStartValue(self, nums):\\n        total = 0\\n        min_sum = 0\\n        for num in nums:\\n            total += num\\n            min_sum = min(min_sum, total)\\n        return 1 - min_sum\\n\"",
  "1616_14631217_python": "\"class Solution(object):\\n    def minDifference(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n <= 4:\\n            return 0  # Can change all to the same number\\n\\n        nums.sort()\\n        return min(\\n            nums[-1] - nums[3],   # remove 3 smallest\\n            nums[-2] - nums[2],   # remove 2 smallest + 1 largest\\n            nums[-3] - nums[1],   # remove 1 smallest + 2 largest\\n            nums[-4] - nums[0]    # remove 3 largest\\n        )\\n\"",
  "2144_14631217_python-updated-time": "1746719172619",
  "146_14631217_python": "\"class Node:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache(object):\\n    def __init__(self, capacity):\\n        \\\"\\\"\\\"\\n        :type capacity: int\\n        \\\"\\\"\\\"\\n        self.capacity = capacity\\n        self.cache = {}  # key -> Node\\n        # Dummy head and tail\\n        self.head = Node(0, 0)\\n        self.tail = Node(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def _remove(self, node):\\n        \\\"\\\"\\\"Remove a node from the linked list.\\\"\\\"\\\"\\n        prev = node.prev\\n        nxt = node.next\\n        prev.next = nxt\\n        nxt.prev = prev\\n\\n    def _add(self, node):\\n        \\\"\\\"\\\"Add a new node right before tail (most recently used).\\\"\\\"\\\"\\n        prev = self.tail.prev\\n        prev.next = node\\n        node.prev = prev\\n        node.next = self.tail\\n        self.tail.prev = node\\n\\n    def get(self, key):\\n        \\\"\\\"\\\"\\n        :type key: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._remove(node)\\n            self._add(node)  # move to the end (most recently used)\\n            return node.value\\n        return -1\\n\\n    def put(self, key, value):\\n        \\\"\\\"\\\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        if key in self.cache:\\n            self._remove(self.cache[key])\\n        \\n        node = Node(key, value)\\n        self.cache[key] = node\\n        self._add(node)\\n\\n        if len(self.cache) > self.capacity:\\n            # Remove least recently used node\\n            lru = self.head.next\\n            self._remove(lru)\\n            del self.cache[lru.key]\\n\"",
  "2639_14631217_python": "\"class Solution(object):\\n    def separateDigits(self, nums):\\n        res = []\\n        for num in nums:\\n            for digit in str(num):\\n                res.append(int(digit))\\n        return res\\n\"",
  "538_14631217_python": "\"class Solution:\\n    def convertBST(self, root):\\n        self.total = 0\\n\\n        def reverse_inorder(node):\\n            if not node:\\n                return\\n            reverse_inorder(node.right)\\n            self.total += node.val\\n            node.val = self.total\\n            reverse_inorder(node.left)\\n\\n        reverse_inorder(root)\\n        return root\\n\"",
  "3062_14631217_pythondata": "\"import pandas as pd\\n\\ndef createDataframe(student_data):\\n    \\\"\\\"\\\"\\n    Given a 2D list student_data where each sublist is [student_id, age],\\n    returns a pandas DataFrame with columns ['student_id', 'age'] in the same order.\\n    \\\"\\\"\\\"\\n    df = pd.DataFrame(student_data, columns=['student_id', 'age'])\\n    return df\\n\"",
  "68_14631217_python": "\"class Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        line = []\\n        line_len = 0\\n\\n        for word in words:\\n            if line_len + len(line) + len(word) > maxWidth:\\n                for i in range(maxWidth - line_len):\\n                    line[i % (len(line) - 1 or 1)] += ' '\\n                res.append(''.join(line))\\n                line = []\\n                line_len = 0\\n            line.append(word)\\n            line_len += len(word)\\n\\n        res.append(' '.join(line).ljust(maxWidth))\\n        return res\\n\"",
  "2831_14631217_python-updated-time": "1747221680230",
  "3080_14631217_python": "\"class Solution:\\n    def maxSubarrays(self, nums):\\n        n = len(nums)\\n        INF = 10**18\\n        # f[i]: min total score for first i elements\\n        # g[i]: max #subarrays achieving f[i]\\n        f = [INF] * (n + 1)\\n        g = [0] * (n + 1)\\n        f[0] = 0\\n        \\n        # prev maps AND-value -> (best_prefix_sum, best_prefix_segments)\\n        prev = {}\\n        \\n        for i, x in enumerate(nums):\\n            new = {}\\n            # Extend every subarray ending at i-1\\n            for v, (fj, gj) in prev.items():\\n                v_new = v & x\\n                old = new.get(v_new)\\n                if old is None or fj < old[0] or (fj == old[0] and gj > old[1]):\\n                    new[v_new] = (fj, gj)\\n            # Single-element subarray [i..i]\\n            old = new.get(x)\\n            if old is None or f[i] < old[0] or (f[i] == old[0] and g[i] > old[1]):\\n                new[x] = (f[i], g[i])\\n            # Choose the best split ending at i\\n            best_sum = INF\\n            best_segs = 0\\n            for v_new, (fj, gj) in new.items():\\n                total = fj + v_new\\n                segs = gj + 1\\n                if total < best_sum or (total == best_sum and segs > best_segs):\\n                    best_sum = total\\n                    best_segs = segs\\n            f[i + 1] = best_sum\\n            g[i + 1] = best_segs\\n            prev = new\\n        \\n        return g[n]\"",
  "1239_14631217_python-updated-time": "1746109365677",
  "1696_14631217_python-updated-time": "1746438796960",
  "334_14631217_python": "\"class Solution(object):\\n    def increasingTriplet(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        first = second = float('inf')\\n        for num in nums:\\n            if num <= first:\\n                first = num\\n            elif num <= second:\\n                second = num\\n            else:\\n                return True\\n        return False\\n\"",
  "964_14631217_python-updated-time": "1746003890206",
  "3700_14631217_python-updated-time": "1747651384349",
  "2053_14631217_python-updated-time": "1746638477089",
  "34_14631217_python": "\"class Solution(object):\\n    def searchRange(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def findLeft(nums, target):\\n            left, right = 0, len(nums) - 1\\n            res = -1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if nums[mid] == target:\\n                    res = mid\\n                    right = mid - 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return res\\n\\n        def findRight(nums, target):\\n            left, right = 0, len(nums) - 1\\n            res = -1\\n            while left <= right:\\n                mid = (left + right) // 2\\n                if nums[mid] == target:\\n                    res = mid\\n                    left = mid + 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return res\\n\\n        return [findLeft(nums, target), findRight(nums, target)]\\n\"",
  "3219_14631217_python": "\"class Solution:\\n    def lexicographicallySmallestArray(self, nums, limit):\\n        n = len(nums)\\n        \\n        # Union-Find setup\\n        parent = list(range(n))\\n\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px != py:\\n                parent[py] = px\\n\\n        # Step 1: Sort by value, then scan nearby values to union indices\\n        val_with_idx = sorted((v, i) for i, v in enumerate(nums))\\n        for i in range(n - 1):\\n            v1, i1 = val_with_idx[i]\\n            v2, i2 = val_with_idx[i + 1]\\n            if abs(v1 - v2) <= limit:\\n                union(i1, i2)\\n\\n        # Step 2: Group indices by root\\n        from collections import defaultdict\\n        groups = defaultdict(list)\\n        for i in range(n):\\n            groups[find(i)].append(i)\\n\\n        # Step 3: For each group, sort the values and reassign to original indices\\n        res = nums[:]\\n        for indices in groups.values():\\n            sorted_indices = sorted(indices)\\n            sorted_vals = sorted(nums[i] for i in sorted_indices)\\n            for i, val in zip(sorted_indices, sorted_vals):\\n                res[i] = val\\n\\n        return res\\n\"",
  "1381_14631217_python-updated-time": "1746259633613",
  "14_14631217_python-updated-time": "1744980657461",
  "420_14631217_python-updated-time": "1745356648999",
  "1977_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        intervals.sort(key=lambda x: x[0])\\n        sorted_q = sorted([(q, i) for i, q in enumerate(queries)])\\n        ans = [-1] * len(queries)\\n        heap = []\\n        idx = 0\\n        n = len(intervals)\\n        \\n        for q, qi in sorted_q:\\n            while idx < n and intervals[idx][0] <= q:\\n                l, r = intervals[idx]\\n                size = r - l + 1\\n                heapq.heappush(heap, (size, r))\\n                idx += 1\\n            while heap and heap[0][1] < q:\\n                heapq.heappop(heap)\\n            if heap:\\n                ans[qi] = heap[0][0]\\n        return ans\\n\"",
  "2032_14631217_python-updated-time": "1746627735193",
  "18_14631217_python": "\"class Solution(object):\\n    def fourSum(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n\\n        for i in range(n - 3):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            for j in range(i + 1, n - 2):\\n                if j > i + 1 and nums[j] == nums[j-1]:\\n                    continue\\n                left, right = j + 1, n - 1\\n                while left < right:\\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\\n                    if total < target:\\n                        left += 1\\n                    elif total > target:\\n                        right -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\\n                        left += 1\\n                        right -= 1\\n                        while left < right and nums[left] == nums[left-1]:\\n                            left += 1\\n                        while left < right and nums[right] == nums[right+1]:\\n                            right -= 1\\n\\n        return res\\n\"",
  "1184_14631217_python": "\"class Solution(object):\\n    def carPooling(self, trips, capacity):\\n        \\\"\\\"\\\"\\n        :type trips: List[List[int]]\\n        :type capacity: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        stops = [0] * 1001  # Since max location is 1000\\n\\n        for num_passengers, start, end in trips:\\n            stops[start] += num_passengers\\n            stops[end] -= num_passengers\\n\\n        current_passengers = 0\\n        for p in stops:\\n            current_passengers += p\\n            if current_passengers > capacity:\\n                return False\\n\\n        return True\\n\"",
  "2917_14631217_python": "\"class Solution(object):\\n    def countPairs(self, nums, target):\\n        n = len(nums)\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if nums[i] + nums[j] < target:\\n                    cnt += 1\\n        return cnt\\n\"",
  "2114_14631217_python": "\"class Solution:\\n    def minSessions(self, tasks, sessionTime):\\n        n = len(tasks)\\n        memo = {}\\n\\n        def dfs(mask, curr):\\n            key = (mask, curr)\\n            if key in memo:\\n                return memo[key]\\n\\n            if mask == (1 << n) - 1:\\n                return 0 if curr == 0 else 1\\n\\n            res = float('inf')\\n            for i in range(n):\\n                if not (mask & (1 << i)):\\n                    t = tasks[i]\\n                    if curr + t <= sessionTime:\\n                        res = min(res, dfs(mask | (1 << i), curr + t))\\n                    else:\\n                        res = min(res, 1 + dfs(mask | (1 << i), t))\\n\\n            memo[key] = res\\n            return res\\n\\n        return dfs(0, 0)\\n\"",
  "516_14631217_python": "\"class Solution:\\n    def longestPalindromeSubseq(self, s):\\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = 2 + dp[i+1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        \\n        return dp[0][n-1]\\n\"",
  "3816_14631217_mysql": "\"SELECT\\n  sample_id,\\n  dna_sequence,\\n  species,\\n  CASE \\n    WHEN dna_sequence LIKE 'ATG%' THEN 1 \\n    ELSE 0 \\n  END AS has_start,\\n  CASE \\n    WHEN dna_sequence LIKE '%TAA'\\n      OR dna_sequence LIKE '%TAG'\\n      OR dna_sequence LIKE '%TGA'\\n    THEN 1 \\n    ELSE 0 \\n  END AS has_stop,\\n  CASE \\n    WHEN dna_sequence LIKE '%ATAT%' THEN 1 \\n    ELSE 0 \\n  END AS has_atat,\\n  CASE \\n    WHEN dna_sequence LIKE '%GGG%' THEN 1 \\n    ELSE 0 \\n  END AS has_ggg\\nFROM Samples\\nORDER BY sample_id;\\n\"",
  "2012_14631217_python-updated-time": "1746626300652",
  "697_14631217_python": "\"class Solution(object):\\n    def findShortestSubArray(self, nums):\\n        left, right, count = {}, {}, {}\\n        for i, x in enumerate(nums):\\n            if x not in left:\\n                left[x] = i\\n            right[x] = i\\n            count[x] = count.get(x, 0) + 1\\n        \\n        degree = max(count.values())\\n        res = len(nums)\\n        for x in count:\\n            if count[x] == degree:\\n                res = min(res, right[x] - left[x] + 1)\\n        return res\\n\"",
  "1_0_python3-updated-time": "1740418264066",
  "2695_14631217_python-updated-time": "1747067253475",
  "1802_14631217_python-updated-time": "1746453332777",
  "1028_14631217_python-updated-time": "1746040432999",
  "1548_14631217_python-updated-time": "1746347246632",
  "2413_14631217_python": "\"import heapq\\n\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        # Min-heap of numbers that have been popped and then added back\\n        self.heap = []\\n        self.in_heap = set()\\n        # Next new number that has never been popped\\n        self.curr = 1\\n\\n    def popSmallest(self):\\n        # If we've previously added back some smaller numbers, use those first\\n        if self.heap:\\n            x = heapq.heappop(self.heap)\\n            self.in_heap.remove(x)\\n            return x\\n        # Otherwise return the next fresh number\\n        x = self.curr\\n        self.curr += 1\\n        return x\\n\\n    def addBack(self, num):\\n        # Only add back if it's strictly less than curr (i.e. was popped)\\n        # and not already in the heap\\n        if num < self.curr and num not in self.in_heap:\\n            heapq.heappush(self.heap, num)\\n            self.in_heap.add(num)\\n\"",
  "2157_14631217_python": "\"class Solution(object):\\n    def smallestSubsequence(self, s, k, letter, repetition):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :type letter: str\\n        :type repetition: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        total_letter = 0\\n        for ch in s:\\n            if ch == letter:\\n                total_letter += 1\\n\\n        stack = []\\n        count_letter_in_stack = 0\\n\\n        for i in range(n):\\n            ch = s[i]\\n            remaining = n - i - 1\\n\\n            while stack and ch < stack[-1] and \\\\\\n                  len(stack) + remaining >= k:\\n                # Only pop if:\\n                # - We don't violate repetition constraint\\n                top = stack[-1]\\n                if top == letter:\\n                    if count_letter_in_stack + total_letter - 1 < repetition:\\n                        break\\n                    count_letter_in_stack -= 1\\n                stack.pop()\\n\\n            if len(stack) < k:\\n                if ch == letter:\\n                    stack.append(ch)\\n                    count_letter_in_stack += 1\\n                else:\\n                    # Only push non-letter if we can still fit enough letters\\n                    if (k - len(stack)) > (repetition - count_letter_in_stack):\\n                        stack.append(ch)\\n\\n            if ch == letter:\\n                total_letter -= 1\\n\\n        return ''.join(stack)\\n\"",
  "2121_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def validPath(self, n, edges, source, destination):\\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # BFS from source\\n        seen = [False] * n\\n        q = deque([source])\\n        seen[source] = True\\n        \\n        while q:\\n            u = q.popleft()\\n            if u == destination:\\n                return True\\n            for v in adj[u]:\\n                if not seen[v]:\\n                    seen[v] = True\\n                    q.append(v)\\n        return False\\n\"",
  "3657_14631217_python-updated-time": "1747650479029",
  "862_14631217_python": "\"class Solution(object):\\n    def findReplaceString(self, s, indices, sources, targets):\\n        changes = sorted(zip(indices, sources, targets), reverse=True)\\n        for idx, src, tgt in changes:\\n            if s[idx:idx+len(src)] == src:\\n                s = s[:idx] + tgt + s[idx+len(src):]\\n        return s\\n\"",
  "2790_14631217_javascript-updated-time": "1747138834566",
  "2353_14631217_python-updated-time": "1746879719131",
  "2276_14631217_python-updated-time": "1746802870825",
  "3848_14631217_mysql-updated-time": "1747683069582",
  "73_14631217_python": "\"class Solution(object):\\n    def setZeroes(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \\\"\\\"\\\"\\n        m, n = len(matrix), len(matrix[0])\\n        first_row_zero = any(matrix[0][j] == 0 for j in range(n))\\n        first_col_zero = any(matrix[i][0] == 0 for i in range(m))\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n\\n        if first_row_zero:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n\\n        if first_col_zero:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n\"",
  "1482_14631217_python-updated-time": "1746345380595",
  "1669_14631217_python": "\"class Solution(object):\\n    def minCost(self, n, cuts):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type cuts: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        cuts = [0] + sorted(cuts) + [n]\\n        m = len(cuts)\\n        dp = [[0] * m for _ in range(m)]\\n\\n        for length in range(2, m):\\n            for i in range(m - length):\\n                j = i + length\\n                dp[i][j] = float('inf')\\n                for k in range(i + 1, j):\\n                    dp[i][j] = min(dp[i][j], cuts[j] - cuts[i] + dp[i][k] + dp[k][j])\\n\\n        return dp[0][m - 1]\\n\"",
  "2123_14631217_python-updated-time": "1746717342507",
  "3805_14631217_python-updated-time": "1747683164772",
  "1428_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def canReach(self, arr, start):\\n        n = len(arr)\\n        visited = set()\\n        queue = deque([start])\\n\\n        while queue:\\n            i = queue.popleft()\\n            if arr[i] == 0:\\n                return True\\n            if i in visited:\\n                continue\\n            visited.add(i)\\n\\n            for ni in [i + arr[i], i - arr[i]]:\\n                if 0 <= ni < n:\\n                    queue.append(ni)\\n\\n        return False\\n\"",
  "2592_14631217_python-updated-time": "1747058809851",
  "567_14631217_python-updated-time": "1745447815468",
  "1886_14631217_python": "\"class Solution(object):\\n    def minimumSize(self, nums, maxOperations):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type maxOperations: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def canDivide(maxSize):\\n            operations = 0\\n            for num in nums:\\n                operations += (num - 1) // maxSize\\n            return operations <= maxOperations\\n\\n        left, right = 1, max(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if canDivide(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "447_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def numberOfBoomerangs(self, points):\\n        res = 0\\n        for i in points:\\n            count = defaultdict(int)\\n            for j in points:\\n                dist = (i[0] - j[0]) ** 2 + (i[1] - j[1]) ** 2\\n                count[dist] += 1\\n            for c in count.values():\\n                res += c * (c - 1)\\n        return res\\n\"",
  "1580_14631217_python-updated-time": "1746432377695",
  "343_14631217_python": "\"class Solution(object):\\n    def integerBreak(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        product = 1\\n        while n > 4:\\n            product *= 3\\n            n -= 3\\n        return product * n\\n\"",
  "146_14631217_python-updated-time": "1745090530290",
  "1721_14631217_python": "\"class Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        waiting = 0\\n        total_boarded = 0\\n        best_profit = 0\\n        best_rotation = -1\\n        profit = 0\\n\\n        # 1) process the first n rotations with arrivals\\n        for i, arrive in enumerate(customers, start=1):\\n            waiting += arrive\\n            # board up to 4\\n            boarded = waiting if waiting < 4 else 4\\n            waiting -= boarded\\n            total_boarded += boarded\\n\\n            profit = total_boarded*boardingCost - i*runningCost\\n            if profit > best_profit:\\n                best_profit = profit\\n                best_rotation = i\\n\\n        # 2) any leftover waiting?\\n        #    If sending 4 every extra rotation is still profitable...\\n        delta = 4*boardingCost - runningCost\\n        if waiting > 0 and delta > 0:\\n            # how many full 4‑person rotations?\\n            full = waiting // 4\\n            rem  = waiting % 4\\n\\n            # profit after all full rotations\\n            profit_full_end = profit + full * delta\\n            rot_full_end   = len(customers) + full\\n            if profit_full_end > best_profit:\\n                best_profit = profit_full_end\\n                best_rotation = rot_full_end\\n\\n            # consider one final partial rotation (if any remain)\\n            if rem:\\n                profit_partial_end = profit_full_end + rem*boardingCost - runningCost\\n                rot_part = rot_full_end + 1\\n                if profit_partial_end > best_profit:\\n                    best_profit = profit_partial_end\\n                    best_rotation = rot_part\\n\\n        return best_rotation\\n\"",
  "2647_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def findValidSplit(self, nums):\\n        n = len(nums)\\n        if n < 2:\\n            return -1\\n\\n        # 1) Find primes up to sqrt(max(nums))\\n        M = max(nums)\\n        limit = int(math.sqrt(M)) + 1\\n        sieve = [True] * (limit + 1)\\n        sieve[0] = sieve[1] = False\\n        primes = []\\n        for i in range(2, limit + 1):\\n            if sieve[i]:\\n                primes.append(i)\\n                for j in range(i * i, limit + 1, i):\\n                    sieve[j] = False\\n\\n        # 2) Record first/last index for each prime factor\\n        first = {}\\n        last = {}\\n        for idx, v in enumerate(nums):\\n            x = v\\n            seen = set()\\n            for p in primes:\\n                if p * p > x:\\n                    break\\n                if x % p == 0:\\n                    seen.add(p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x > 1:\\n                seen.add(x)\\n            for p in seen:\\n                if p not in first:\\n                    first[p] = idx\\n                last[p] = idx\\n\\n        # 3) Mark forbidden split-intervals via a difference array\\n        diff = [0] * (n + 1)\\n        for p in first:\\n            a, b = first[p], last[p]\\n            if a < b:\\n                diff[a] += 1\\n                diff[b] -= 1\\n\\n        # 4) Prefix-sum and find smallest valid split i in [0..n-2]\\n        cover = 0\\n        for i in range(n - 1):\\n            cover += diff[i]\\n            if cover == 0:\\n                return i\\n\\n        return -1\\n\"",
  "1743_14631217_python-updated-time": "1746444956506",
  "2599_14631217_python": "\"class Solution:\\n    def takeCharacters(self, s, k):\\n        from collections import Counter\\n\\n        total = Counter(s)\\n        # If any character has fewer than k in total, impossible.\\n        if any(total[c] < k for c in 'abc'):\\n            return -1\\n\\n        n = len(s)\\n        # Limits on how many of each char we can remove in the middle window:\\n        limit = {c: total[c] - k for c in 'abc'}\\n\\n        count = {'a': 0, 'b': 0, 'c': 0}\\n        left = 0\\n        max_window = 0\\n\\n        # Slide right pointer\\n        for right, ch in enumerate(s):\\n            count[ch] += 1\\n            # If window [left..right] is invalid (removed too many of some char),\\n            # shrink from the left until valid again.\\n            while any(count[c] > limit[c] for c in 'abc'):\\n                count[s[left]] -= 1\\n                left += 1\\n            # Now [left..right] is a valid removable window\\n            max_window = max(max_window, right - left + 1)\\n\\n        # Minimum taken = total length - max removable window\\n        return n - max_window\\n\"",
  "1499_14631217_python-updated-time": "1746345924831",
  "1764_14631217_python": "\"class Solution:\\n    def maxRepeating(self, sequence, word):\\n        k = 0\\n        t = word\\n        # Keep appending `word` until it's no longer a substring\\n        while t in sequence:\\n            k += 1\\n            t += word\\n        return k\\n\"",
  "530_14631217_python": "\"class Solution:\\n    def getMinimumDifference(self, root):\\n        self.prev = None\\n        self.min_diff = float('inf')\\n        \\n        def inorder(node):\\n            if not node:\\n                return\\n            inorder(node.left)\\n            if self.prev is not None:\\n                self.min_diff = min(self.min_diff, node.val - self.prev)\\n            self.prev = node.val\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return self.min_diff\\n\"",
  "3713_14631217_python": "\"import itertools\\n\\nclass Solution(object):\\n    def supersequences(self, words):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # 1) Gather all letters that appear and build a small index map 0..M-1\\n        letters = set()\\n        for w in words:\\n            letters.add(w[0])\\n            letters.add(w[1])\\n        letters = sorted(letters)\\n        M = len(letters)\\n        idx = {ch:i for i,ch in enumerate(letters)}\\n        \\n        # 2) Build adjacency list and detect self-loops\\n        adj = [[] for _ in range(M)]\\n        self_loop = [False]*M\\n        for u_ch, v_ch in words:\\n            u = idx[u_ch]\\n            v = idx[v_ch]\\n            adj[u].append(v)\\n            if u==v:\\n                self_loop[u] = True\\n        \\n        # 3) Required removals R = all self-loop nodes\\n        R_mask = 0\\n        for u in range(M):\\n            if self_loop[u]:\\n                R_mask |= (1<<u)\\n        \\n        # 4) Build list of “optional” nodes V2 = those NOT already in R\\n        V2 = [u for u in range(M) if not (R_mask & (1<<u))]\\n        N2 = len(V2)\\n        \\n        # 5) A helper to test if G minus removed_mask is acyclic\\n        def is_acyclic(removed_mask):\\n            # compute indegree in the induced subgraph on V \\\\ removed\\n            indeg = [0]*M\\n            for u in range(M):\\n                if removed_mask & (1<<u): \\n                    continue\\n                for v in adj[u]:\\n                    if not (removed_mask & (1<<v)):\\n                        indeg[v] += 1\\n            # Kahn’s algorithm\\n            q = [u for u in range(M) \\n                 if not (removed_mask & (1<<u)) and indeg[u]==0]\\n            seen = 0\\n            while q:\\n                u = q.pop()\\n                seen += 1\\n                for v in adj[u]:\\n                    if removed_mask & (1<<v): \\n                        continue\\n                    indeg[v] -= 1\\n                    if indeg[v]==0:\\n                        q.append(v)\\n            # count of remaining nodes = M - popcount(removed_mask)\\n            return seen == (M - bin(removed_mask).count(\\\"1\\\"))\\n        \\n        # 6) Find minimal extra removals S' ⊆ V2 so that R∪S' breaks all cycles\\n        best_k = None\\n        minimal_S_masks = []\\n        for k in range(N2+1):\\n            found_any = False\\n            for comb in itertools.combinations(range(N2), k):\\n                # build mask of these removed\\n                mask = R_mask\\n                for j in comb:\\n                    mask |= (1<<V2[j])\\n                if is_acyclic(mask):\\n                    found_any = True\\n                    minimal_S_masks.append(mask)\\n                # but we still need to collect **all** of size k,\\n                # so do *not* break here\\n            if found_any:\\n                best_k = k\\n                break\\n        \\n        # 7) For each minimal removal-mask, build the frequency array\\n        out = []\\n        for mask in minimal_S_masks:\\n            freq = [0]*26\\n            for i,ch in enumerate(letters):\\n                # if i in mask → we “removed” it from U1, so we need c=2; \\n                # otherwise c=1\\n                freq[ord(ch)-97] = 2 if (mask & (1<<i)) else 1\\n            out.append(freq)\\n        \\n        return out\\n\"",
  "3760_14631217_python": "\"class Solution(object):\\n    def assignElements(self, groups, elements):\\n        \\\"\\\"\\\"\\n        :type groups: List[int]\\n        :type elements: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not groups or not elements:\\n            return [-1] * len(groups)\\n\\n        m = len(elements)\\n        maxg = max(groups)\\n        # Use m as \\\"infinity\\\" sentinel since valid indices are 0..m-1\\n        INF = m\\n\\n        # 1) For each element value e ≤ maxg, record the smallest index j where elements[j] == e\\n        minIdx = [INF] * (maxg + 1)\\n        for j, e in enumerate(elements):\\n            if e <= maxg and j < minIdx[e]:\\n                minIdx[e] = j\\n\\n        # 2) Build ansArr[g] = minimum j such that e divides g, or INF if none\\n        ansArr = [INF] * (maxg + 1)\\n        for e in range(1, maxg + 1):\\n            idx = minIdx[e]\\n            if idx < INF:\\n                # e is present in elements; it divides all multiples of e\\n                for multiple in range(e, maxg + 1, e):\\n                    if idx < ansArr[multiple]:\\n                        ansArr[multiple] = idx\\n\\n        # 3) Assign for each group\\n        result = []\\n        for g in groups:\\n            if ansArr[g] < INF:\\n                result.append(ansArr[g])\\n            else:\\n                result.append(-1)\\n\\n        return result\\n\"",
  "730_14631217_python-updated-time": "1745787044564",
  "657_14631217_python": "\"class Solution(object):\\n    def judgeCircle(self, moves):\\n        x = y = 0\\n        for move in moves:\\n            if move == 'U':\\n                y += 1\\n            elif move == 'D':\\n                y -= 1\\n            elif move == 'L':\\n                x -= 1\\n            elif move == 'R':\\n                x += 1\\n        return x == 0 and y == 0\\n\"",
  "1372_14631217_python-updated-time": "1746259507096",
  "2828_14631217_python": "\"class Solution:\\n    def smallestString(self, s):\\n        n = len(s)\\n        arr = list(s)\\n        \\n        # skip leading 'a's\\n        i = 0\\n        while i < n and arr[i] == 'a':\\n            i += 1\\n        \\n        # if all 'a's, change last 'a' to 'z'\\n        if i == n:\\n            arr[-1] = 'z'\\n        else:\\n            # decrement until hitting an 'a' or end\\n            while i < n and arr[i] != 'a':\\n                arr[i] = chr(ord(arr[i]) - 1)\\n                i += 1\\n        \\n        return ''.join(arr)\\n\"",
  "2283_14631217_python": "\"class Solution:\\n    def sortEvenOdd(self, nums):\\n        even = sorted(nums[::2])             # sort even indices in non-decreasing order\\n        odd = sorted(nums[1::2], reverse=True)  # sort odd indices in non-increasing order\\n\\n        result = []\\n        e = o = 0\\n        for i in range(len(nums)):\\n            if i % 2 == 0:\\n                result.append(even[e])\\n                e += 1\\n            else:\\n                result.append(odd[o])\\n                o += 1\\n        return result\\n\"",
  "1205_14631217_python": "\"class Solution(object):\\n    def defangIPaddr(self, address):\\n        \\\"\\\"\\\"\\n        :type address: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        return address.replace('.', '[.]')\\n\"",
  "2368_14631217_python-updated-time": "1746881515233",
  "174_14631217_python": "\"class Solution(object):\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\\n        dp[m][n-1] = dp[m-1][n] = 1\\n        \\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                need = min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]\\n                dp[i][j] = 1 if need <= 0 else need\\n        \\n        return dp[0][0]\\n\"",
  "2687_14631217_python": "\"class Solution(object):\\n    def smallestBeautifulString(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        Returns the lexicographically smallest beautiful string > s, or \\\"\\\" if none.\\n        Beautiful: no palindrome substring length >=2.\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        s_list = list(s)\\n        # helper to check valid at pos i for char c\\n        def valid_at(i, c):\\n            if i > 0 and s_list[i-1] == c:\\n                return False\\n            if i > 1 and s_list[i-2] == c:\\n                return False\\n            return True\\n\\n        # attempt position i from end\\n        for i in range(n-1, -1, -1):\\n            orig = s_list[i]\\n            # try next chars\\n            for code in range(ord(orig)+1, ord('a')+k):\\n                c = chr(code)\\n                if not valid_at(i, c):\\n                    continue\\n                # set prefix\\n                s_list[i] = c\\n                # fill suffix greedily\\n                for j in range(i+1, n):\\n                    for cc in range(ord('a'), ord('a')+k):\\n                        cj = chr(cc)\\n                        if valid_at(j, cj):\\n                            s_list[j] = cj\\n                            break\\n                # return joined\\n                return \\\"\\\".join(s_list)\\n            # restore and continue\\n            # s_list[i] = orig  # will be overwritten\\n        return \\\"\\\"\\n\"",
  "2713_14631217_python-updated-time": "1747066080594",
  "2493_14631217_python": "\"from collections import deque\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def reverseOddLevels(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        if not root:\\n            return None\\n        \\n        q = deque([root])\\n        level = 0\\n        \\n        while q:\\n            size = len(q)\\n            nodes = []\\n            for _ in range(size):\\n                node = q.popleft()\\n                nodes.append(node)\\n                if node.left:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            \\n            # Reverse values at odd levels\\n            if level % 2 == 1:\\n                vals = [node.val for node in nodes]\\n                for node, v in zip(nodes, reversed(vals)):\\n                    node.val = v\\n            \\n            level += 1\\n        \\n        return root\\n\"",
  "1907_14631217_python-updated-time": "1746543390591",
  "1223_14631217_python": "\"class Solution:\\n    def areConnected(self, n, threshold, queries):\\n        # Disjoint Set Union (Union-Find) with path compression & union by rank\\n        parent = list(range(n+1))\\n        rank = [0] * (n+1)\\n        \\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return\\n            if rank[rx] < rank[ry]:\\n                parent[rx] = ry\\n            elif rank[rx] > rank[ry]:\\n                parent[ry] = rx\\n            else:\\n                parent[ry] = rx\\n                rank[rx] += 1\\n        \\n        # Connect all cities that share a divisor > threshold\\n        for z in range(threshold + 1, n + 1):\\n            # Union z with all its multiples > z\\n            multiple = 2*z\\n            while multiple <= n:\\n                union(z, multiple)\\n                multiple += z\\n        \\n        # Answer each query by checking if two cities have the same root\\n        ans = []\\n        for a, b in queries:\\n            ans.append(find(a) == find(b))\\n        return ans\\n\"",
  "187_14631217_python": "\"class Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        seen = set()\\n        repeated = set()\\n        \\n        for i in range(len(s) - 9):\\n            sequence = s[i:i+10]\\n            if sequence in seen:\\n                repeated.add(sequence)\\n            else:\\n                seen.add(sequence)\\n                \\n        return list(repeated)\\n\"",
  "1948_14631217_mysql": "\"SELECT product_id, 'store1' AS store, store1 AS price\\nFROM Products\\nWHERE store1 IS NOT NULL\\n\\nUNION ALL\\n\\nSELECT product_id, 'store2', store2\\nFROM Products\\nWHERE store2 IS NOT NULL\\n\\nUNION ALL\\n\\nSELECT product_id, 'store3', store3\\nFROM Products\\nWHERE store3 IS NOT NULL;\\n\"",
  "1850_14631217_python": "\"class Solution(object):\\n    def minimumLength(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(s) - 1\\n\\n        while left < right and s[left] == s[right]:\\n            ch = s[left]\\n            while left <= right and s[left] == ch:\\n                left += 1\\n            while right >= left and s[right] == ch:\\n                right -= 1\\n\\n        return right - left + 1\\n\"",
  "1512_14631217_python": "\"class UndergroundSystem(object):\\n\\n    def __init__(self):\\n        self.check_in_data = {}  # id -> (stationName, time)\\n        self.trip_data = {}      # (startStation, endStation) -> [total_time, trip_count]\\n\\n    def checkIn(self, id, stationName, t):\\n        self.check_in_data[id] = (stationName, t)\\n\\n    def checkOut(self, id, stationName, t):\\n        start_station, start_time = self.check_in_data.pop(id)\\n        trip = (start_station, stationName)\\n        duration = t - start_time\\n        if trip not in self.trip_data:\\n            self.trip_data[trip] = [0, 0]\\n        self.trip_data[trip][0] += duration\\n        self.trip_data[trip][1] += 1\\n\\n    def getAverageTime(self, startStation, endStation):\\n        total_time, trip_count = self.trip_data[(startStation, endStation)]\\n        return float(total_time) / trip_count\\n\"",
  "329_14631217_python": "\"class Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        def dfs(i, j):\\n            if dp[i][j]:\\n                return dp[i][j]\\n            val = matrix[i][j]\\n            dp[i][j] = 1 + max(\\n                dfs(i-1, j) if i > 0 and matrix[i-1][j] > val else 0,\\n                dfs(i+1, j) if i < m-1 and matrix[i+1][j] > val else 0,\\n                dfs(i, j-1) if j > 0 and matrix[i][j-1] > val else 0,\\n                dfs(i, j+1) if j < n-1 and matrix[i][j+1] > val else 0\\n            )\\n            return dp[i][j]\\n        \\n        return max(dfs(i, j) for i in range(m) for j in range(n))\\n\"",
  "952_14631217_python-updated-time": "1746003442506",
  "1114_14631217_python": "\"class Solution:\\n    def bstToGst(self, root):\\n        self.total = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.right)\\n            self.total += node.val\\n            node.val = self.total\\n            dfs(node.left)\\n\\n        dfs(root)\\n        return root\\n\"",
  "1210_14631217_python": "\"class Solution:\\n    def trimMean(self, arr):\\n        arr.sort()\\n        n = len(arr)\\n        cut = n // 20                # 5% of n, and n is a multiple of 20\\n        middle_sum = sum(arr[cut: n - cut])\\n        # force floating‐point division\\n        return middle_sum * 1.0 / (n - 2 * cut)\\n\"",
  "2423_14631217_python": "\"class Solution:\\n    def minOperations(self, nums, numsDivide):\\n        # local gcd implementation to avoid relying on math.gcd\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n        \\n        # Compute gcd of all elements in numsDivide\\n        g = numsDivide[0]\\n        for x in numsDivide[1:]:\\n            g = gcd(g, x)\\n        \\n        # Sort nums so that the first valid divisor yields minimal deletions\\n        nums.sort()\\n        \\n        # Find the smallest nums[i] that divides g\\n        for i, x in enumerate(nums):\\n            if g % x == 0:\\n                return i\\n        \\n        return -1\\n\"",
  "385_14631217_python-updated-time": "1745355231311",
  "665_14631217_python-updated-time": "1745783158609",
  "2216_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def deleteMiddle(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        # If there's only one node, removing it leaves an empty list.\\n        if not head.next:\\n            return None\\n        \\n        prev = None\\n        slow = head\\n        fast = head\\n        \\n        # Move fast by 2 and slow by 1. When fast reaches end, slow is at middle.\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Remove the middle node (slow) by linking previous around it.\\n        prev.next = slow.next\\n        \\n        return head\\n\"",
  "1157_14631217_python": "\"class Solution(object):\\n    def sufficientSubset(self, root, limit):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type limit: int\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        def dfs(node, sum_so_far):\\n            if not node:\\n                return None\\n            sum_so_far += node.val\\n            if not node.left and not node.right:\\n                return node if sum_so_far >= limit else None\\n            node.left = dfs(node.left, sum_so_far)\\n            node.right = dfs(node.right, sum_so_far)\\n            return node if node.left or node.right else None\\n        \\n        return dfs(root, 0)\\n\"",
  "3411_14631217_python": "\"class Solution(object):\\n    def findProductsOfElements(self, queries):\\n        \\\"\\\"\\\"\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n\\n        # --------------------------------------------------------------------\\n        # 1) Helpers to compute, for a non-negative m, over all integers 1..m:\\n        #\\n        #    T(m) = sum_{i=1..m} popcount(i)\\n        #    B(m) = sum_{i=1..m} sum_{j: bit j in i} j\\n        #\\n        # We compute both by counting, for each bit position j separately,\\n        # how many numbers in [1..m] have that bit set.\\n        # --------------------------------------------------------------------\\n        def prefix_counts(m):\\n            \\\"\\\"\\\"\\n            Returns (T, B), where\\n              T = total number of set bits in 1..m,\\n              B = total of bit‐positions (i.e. sum of j for each set bit j).\\n            If m=0, returns (0,0).\\n            \\\"\\\"\\\"\\n            if m <= 0:\\n                return 0, 0\\n\\n            T = 0\\n            B = 0\\n            # We'll go up to bit 60 (since m ≤ 10^15 < 2^50)\\n            bit = 0\\n            while (1 << bit) <= m:\\n                cycle = 1 << (bit + 1)\\n                full_cycles = (m + 1) // cycle\\n                rem = (m + 1) % cycle\\n\\n                # In each full cycle, 2^bit ones in position `bit`.\\n                cnt = full_cycles * (1 << bit)\\n                # Plus the leftover in the partial cycle\\n                cnt += max(0, rem - (1 << bit))\\n\\n                T += cnt\\n                B += cnt * bit\\n                bit += 1\\n\\n            return T, B\\n\\n        # --------------------------------------------------------------------\\n        # 2) Given N = number of entries of big_nums, \\n        #    find sum of bit‐positions over big_nums[0..N-1].\\n        #\\n        # big_nums is formed by concatenating, for i=1,2,3,...,\\n        #    the list of powers-of-two (i.e. set bits) in i, in sorted order.\\n        #\\n        # Let T(m) = total count of bits in 1..m,\\n        #     B(m) = total of their bit‐positions.\\n        #\\n        # If we want the first N entries, we find the largest m so that\\n        #    T(m) ≤ N < T(m+1).\\n        # Those N entries consist of all bits from 1..m (contributing B(m)),\\n        # plus the first (N - T(m)) bits of (m+1), in ascending bit order.\\n        # --------------------------------------------------------------------\\n        def prefix_bitpos_sum(N):\\n            # sum of positions for big_nums[0..N-1]\\n            if N <= 0:\\n                return 0\\n\\n            # Binary search m in [0..N], T(m) is monotonic increasing\\n            lo, hi = 0, N\\n            while lo < hi:\\n                mid = (lo + hi + 1) // 2\\n                if prefix_counts(mid)[0] <= N:\\n                    lo = mid\\n                else:\\n                    hi = mid - 1\\n            m = lo\\n            Tm, Bm = prefix_counts(m)\\n            rem = N - Tm  # how many bits from (m+1)\\n\\n            # collect the bit‐positions of (m+1):\\n            bits_of_next = []\\n            x = m + 1\\n            bit = 0\\n            while x:\\n                if x & 1:\\n                    bits_of_next.append(bit)\\n                bit += 1\\n                x >>= 1\\n            # they're naturally in ascending order of bit\\n            # take the first `rem` of them\\n            return Bm + sum(bits_of_next[:rem])\\n\\n        # --------------------------------------------------------------------\\n        # 3) Now answer each query [L, R, mod]:\\n        #    product = ∏ big_nums[L..R] mod mod.\\n        # But each big_nums entry is 2^j, so the product is\\n        #    2^(sum of bit‐positions over [L..R]),\\n        # and we do that power mod `mod`.\\n        # --------------------------------------------------------------------\\n        ans = []\\n        for L, R, m in queries:\\n            # prefix up to R+1 minus prefix up to L\\n            exp = prefix_bitpos_sum(R+1) - prefix_bitpos_sum(L)\\n            ans.append(pow(2, exp, m))\\n        return ans\\n\"",
  "2414_14631217_python": "\"class Solution:\\n    def canChange(self, start, target):\\n        # collect non-blank pieces and their positions\\n        s_pos, t_pos = [], []\\n        for i, c in enumerate(start):\\n            if c != '_':\\n                s_pos.append((c, i))\\n        for i, c in enumerate(target):\\n            if c != '_':\\n                t_pos.append((c, i))\\n        \\n        # must have the same sequence of pieces\\n        if len(s_pos) != len(t_pos):\\n            return False\\n        \\n        # check each piece's movement feasibility\\n        for (c1, i1), (c2, i2) in zip(s_pos, t_pos):\\n            if c1 != c2:\\n                return False\\n            # 'L' can only move left: start index >= target index\\n            if c1 == 'L' and i1 < i2:\\n                return False\\n            # 'R' can only move right: start index <= target index\\n            if c1 == 'R' and i1 > i2:\\n                return False\\n        \\n        return True\\n\"",
  "3532_14631217_python-updated-time": "1747494747177",
  "645_14631217_python": "\"class Solution(object):\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        num_set = set()\\n        duplicate = -1\\n        total = 0\\n        \\n        for num in nums:\\n            if num in num_set:\\n                duplicate = num\\n            num_set.add(num)\\n            total += num\\n        \\n        missing = (n * (n + 1)) // 2 - (total - duplicate)\\n        return [duplicate, missing]\\n\"",
  "2244_14631217_python-updated-time": "1746801817849",
  "2582_14631217_python-updated-time": "1747057684379",
  "3299_14631217_python-updated-time": "1747411885186",
  "556_14631217_python-updated-time": "1745447509029",
  "2621_14631217_python-updated-time": "1747060236406",
  "2035_14631217_python": "\"class Solution:\\n    def countSubIslands(self, grid1, grid2):\\n        m, n = len(grid1), len(grid1[0])\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid2[i][j] == 0:\\n                return True\\n            grid2[i][j] = 0\\n            res = True\\n            if grid1[i][j] == 0:\\n                res = False\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                if not dfs(i + dx, j + dy):\\n                    res = False\\n            return res\\n\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    if dfs(i, j):\\n                        count += 1\\n        return count\\n\"",
  "2234_14631217_python": "\"from bisect import bisect_right\\n\\nclass Solution:\\n    def kIncreasing(self, arr, k):\\n        def lnds(seq):\\n            stack = []\\n            for num in seq:\\n                idx = bisect_right(stack, num)\\n                if idx == len(stack):\\n                    stack.append(num)\\n                else:\\n                    stack[idx] = num\\n            return len(stack)\\n\\n        n = len(arr)\\n        operations = 0\\n\\n        for start in range(k):\\n            seq = [arr[i] for i in range(start, n, k)]\\n            operations += len(seq) - lnds(seq)\\n\\n        return operations\\n\"",
  "1717_14631217_python": "\"class Solution(object):\\n    def connectTwoGroups(self, cost):\\n        \\\"\\\"\\\"\\n        :type cost: List[List[int]]   # cost[i][j]: cost of edge (i in G1, j in G2)\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m = len(cost)\\n        n = len(cost[0])\\n        full = (1 << n) - 1\\n        INF = 10**18\\n\\n        # 1) Precompute cost_i[sub] = sum of cost[i][j] for j in bitmask sub\\n        cost_i = [ [0]*(1<<n) for _ in range(m) ]\\n        for i in range(m):\\n            for sub in range(1, 1<<n):\\n                lsb = sub & -sub\\n                j = (lsb.bit_length() - 1)\\n                cost_i[i][sub] = cost_i[i][sub ^ lsb] + cost[i][j]\\n\\n        # 2) Precompute mincost_i[sub] = min(cost[i][j] for j in sub), ∞ if sub==0\\n        mincost_i = [ [INF]*(1<<n) for _ in range(m) ]\\n        for i in range(m):\\n            mincost_i[i][0] = INF\\n            for sub in range(1, 1<<n):\\n                lsb = sub & -sub\\n                j = (lsb.bit_length() - 1)\\n                rest = sub ^ lsb\\n                mincost_i[i][sub] = min(cost[i][j], mincost_i[i][rest])\\n\\n        # 3) DP over Group1 vertices\\n        dp_prev = [INF]*(1<<n)\\n        dp_prev[0] = 0\\n\\n        for i in range(m):\\n            dp_new = [INF]*(1<<n)\\n            for prev_mask in range(1<<n):\\n                base = dp_prev[prev_mask]\\n                if base >= INF:\\n                    continue\\n                free = (~prev_mask) & full\\n\\n                # (A) connect i to an already-covered j (if any),\\n                #     so mask stays prev_mask\\n                if prev_mask != 0:\\n                    dp_new[prev_mask] = min(\\n                        dp_new[prev_mask],\\n                        base + mincost_i[i][prev_mask]\\n                    )\\n\\n                # (B) connect i to some non-empty subset of new nodes sub ⊆ free\\n                sub = free\\n                while sub:\\n                    newmask = prev_mask | sub\\n                    dp_new[newmask] = min(\\n                        dp_new[newmask],\\n                        base + cost_i[i][sub]\\n                    )\\n                    sub = (sub - 1) & free\\n\\n            dp_prev = dp_new\\n\\n        ans = dp_prev[full]\\n        return ans if ans < INF else -1\\n\"",
  "1293_14631217_python-updated-time": "1746434440113",
  "1284_14631217_python": "\"class Solution(object):\\n    def sumFourDivisors(self, nums):\\n        def getDivisors(n):\\n            divs = set()\\n            for i in range(1, int(n**0.5) + 1):\\n                if n % i == 0:\\n                    divs.add(i)\\n                    divs.add(n // i)\\n                if len(divs) > 4:\\n                    return 0\\n            return sum(divs) if len(divs) == 4 else 0\\n\\n        return sum(getDivisors(num) for num in nums)\\n\"",
  "586_14631217_mysql-updated-time": "1745448108091",
  "2784_14631217_python": "\"class Solution:\\n    def sumOfPower(self, nums):\\n        MOD = 10**9 + 7\\n        nums.sort()\\n        res = 0\\n        prefix_sum = 0\\n\\n        for num in nums:\\n            # For each num as max, calculate power\\n            res = (res + num * num % MOD * (num + prefix_sum)) % MOD\\n            prefix_sum = (2 * prefix_sum + num) % MOD\\n\\n        return res\\n\"",
  "2211_14631217_python-updated-time": "1746729599820",
  "196_14631217_mysql": "\"# Write your MySQL query statement below\\nDELETE p1\\nFROM Person p1\\nJOIN Person p2\\nON p1.email = p2.email AND p1.id > p2.id;\\n\"",
  "1627_14631217_python": "\"class Solution(object):\\n    def getLastMoment(self, n, left, right):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type left: List[int]\\n        :type right: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_left = max(left) if left else 0\\n        max_right = max([n - r for r in right]) if right else 0\\n        return max(max_left, max_right)\\n\"",
  "871_14631217_python-updated-time": "1745879785343",
  "142_14631217_python-updated-time": "1745087020988",
  "733_14631217_python-updated-time": "1745787273009",
  "3382_14631217_python-updated-time": "1747423700560",
  "1963_14631217_python-updated-time": "1746544365110",
  "1496_14631217_python-updated-time": "1746345851600",
  "27_14631217_python-updated-time": "1744987835853",
  "319_14631217_python": "\"class Solution(object):\\n    def bulbSwitch(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return int(n ** 0.5)\\n\"",
  "79_14631217_python-updated-time": "1745015273309",
  "1975_14631217_python-updated-time": "1746624730829",
  "3753_14631217_python-updated-time": "1747675490468",
  "1738_14631217_python": "\"class Solution:\\n    def maximalNetworkRank(self, n, roads):\\n        # Count degrees and record direct connections\\n        degree = [0] * n\\n        connected = [[False]*n for _ in range(n)]\\n        \\n        for a, b in roads:\\n            degree[a] += 1\\n            degree[b] += 1\\n            connected[a][b] = True\\n            connected[b][a] = True\\n        \\n        # Compute the max network rank over all pairs\\n        max_rank = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # sum of degrees minus 1 if there's a direct road between them\\n                rank = degree[i] + degree[j] - (1 if connected[i][j] else 0)\\n                if rank > max_rank:\\n                    max_rank = rank\\n        \\n        return max_rank\\n\"",
  "1340_14631217_python-updated-time": "1746259178619",
  "1354_14631217_python-updated-time": "1746811204073",
  "2589_14631217_python": "\"class Solution(object):\\n    def maximumValue(self, strs):\\n        return max(int(s) if s.isdigit() else len(s) for s in strs)\\n\"",
  "2754_14631217_python": "\"import math\\n\\nclass Solution:\\n    def maxStrength(self, nums):\\n        positives = [x for x in nums if x > 0]\\n        negatives = sorted([x for x in nums if x < 0])\\n        zero_count = nums.count(0)\\n\\n        result = 1\\n        used = False\\n\\n        # Multiply all positive numbers\\n        for num in positives:\\n            result *= num\\n            used = True\\n\\n        # Multiply pairs of negative numbers\\n        for i in range(0, len(negatives) - 1, 2):\\n            result *= negatives[i] * negatives[i + 1]\\n            used = True\\n\\n        # Edge case: only one negative and no positives\\n        if not used:\\n            if zero_count > 0:\\n                return 0\\n            else:\\n                return max(nums)  # only one negative, no zero, return that\\n\\n        return result\\n\"",
  "1054_14631217_python": "\"class Solution:\\n    def bitwiseComplement(self, n):\\n        if n == 0:\\n            return 1\\n        mask = (1 << n.bit_length()) - 1\\n        return n ^ mask\\n\"",
  "3697_14631217_python-updated-time": "1747676353672",
  "609_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def findDuplicate(self, paths):\\n        \\\"\\\"\\\"\\n        :type paths: List[str]\\n        :rtype: List[List[str]]\\n        \\\"\\\"\\\"\\n        # Map file content to list of full file paths\\n        content_map = defaultdict(list)\\n        \\n        for entry in paths:\\n            parts = entry.split(' ')\\n            root = parts[0]\\n            # Each subsequent part is \\\"filename(content)\\\"\\n            for file_info in parts[1:]:\\n                name, rest = file_info.split('(')\\n                content = rest[:-1]  # strip the trailing ')'\\n                full_path = root + '/' + name\\n                content_map[content].append(full_path)\\n        \\n        # Only keep groups with more than one file (duplicates)\\n        return [group for group in content_map.values() if len(group) > 1]\\n\"",
  "404_14631217_python-updated-time": "1745355971992",
  "2812_14631217_python": "\"class Solution:\\n    def theMaximumAchievableX(self, num, t):\\n        return num + 2 * t\\n\"",
  "2211_14631217_python": "\"class Solution:\\n    def getAverages(self, nums, k):\\n        n = len(nums)\\n        w = 2 * k + 1\\n        res = [-1] * n\\n        \\n        # If window is larger than array, no valid averages\\n        if w > n:\\n            return res\\n        \\n        # Compute sum of the first window [0..w-1]\\n        window_sum = sum(nums[:w])\\n        # Center of that window is at index k\\n        res[k] = window_sum // w\\n        \\n        # Slide the window forward\\n        for i in range(k + 1, n - k):\\n            # Remove the element leaving the window, add the new entering one\\n            window_sum += nums[i + k] - nums[i - k - 1]\\n            res[i] = window_sum // w\\n        \\n        return res\\n\"",
  "3501_14631217_python": "\"class Solution(object):\\n    def modifiedList(self, nums, head):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        remove = set(nums)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev, curr = dummy, head\\n        \\n        while curr:\\n            if curr.val in remove:\\n                prev.next = curr.next\\n            else:\\n                prev = curr\\n            curr = curr.next\\n        \\n        return dummy.next\\n\"",
  "770_14631217_python": "\"class Solution(object):\\n    def minSwapsCouples(self, row):\\n        n = len(row) // 2\\n        pos = {person: i for i, person in enumerate(row)}\\n        swaps = 0\\n        \\n        for i in range(0, len(row), 2):\\n            first = row[i]\\n            partner = first ^ 1  # partner is first ^ 1 (0->1, 1->0, 2->3, 3->2, etc.)\\n            if row[i+1] != partner:\\n                swaps += 1\\n                partner_idx = pos[partner]\\n                \\n                # swap row[i+1] with row[partner_idx]\\n                row[i+1], row[partner_idx] = row[partner_idx], row[i+1]\\n                \\n                # update positions\\n                pos[row[partner_idx]] = partner_idx\\n                pos[row[i+1]] = i+1\\n        \\n        return swaps\\n\"",
  "933_14631217_python": "\"class Solution:\\n    def increasingBST(self, root):\\n        def inorder(node):\\n            if not node:\\n                return\\n            inorder(node.left)\\n            node.left = None\\n            self.curr.right = node\\n            self.curr = node\\n            inorder(node.right)\\n\\n        dummy = TreeNode(0)\\n        self.curr = dummy\\n        inorder(root)\\n        return dummy.right\\n\"",
  "292_14631217_python": "\"class Solution(object):\\n    def canWinNim(self, n):\\n        return n % 4 != 0\\n\"",
  "2479_14631217_python-updated-time": "1746965899617",
  "105_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \\\"\\\"\\\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: Optional[TreeNode]\\n        \\\"\\\"\\\"\\n        if not preorder or not inorder:\\n            return None\\n        \\n        root = TreeNode(preorder[0])\\n        mid = inorder.index(preorder[0])\\n        \\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n        \\n        return root\\n\"",
  "1477_14631217_python": "\"class ProductOfNumbers(object):\\n\\n    def __init__(self):\\n        self.prefix = [1]  # product prefix, starting with 1 as identity\\n        self.zero_index = -1  # last index where a zero was inserted\\n\\n    def add(self, num):\\n        if num == 0:\\n            self.prefix = [1]  # reset after zero\\n        else:\\n            self.prefix.append(self.prefix[-1] * num)\\n\\n    def getProduct(self, k):\\n        if k >= len(self.prefix):\\n            return 0  # there's a zero within the last k numbers\\n        return self.prefix[-1] // self.prefix[-k - 1]\\n\"",
  "1666_14631217_python-updated-time": "1746434355842",
  "933_14631217_python-updated-time": "1746002376892",
  "530_14631217_python-updated-time": "1745446760131",
  "820_14631217_python": "\"class Solution(object):\\n    def eventualSafeNodes(self, graph):\\n        n = len(graph)\\n        color = [0] * n  # 0 = unvisited, 1 = visiting, 2 = safe\\n        \\n        def dfs(u):\\n            if color[u] != 0:\\n                return color[u] == 2\\n            color[u] = 1\\n            for v in graph[u]:\\n                if not dfs(v):\\n                    return False\\n            color[u] = 2\\n            return True\\n        \\n        res = []\\n        for i in range(n):\\n            if dfs(i):\\n                res.append(i)\\n        return res\\n\"",
  "98_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def validate(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return validate(node.left, low, node.val) and validate(node.right, node.val, high)\\n        \\n        return validate(root, float('-inf'), float('inf'))\\n\"",
  "450_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def deleteNode(self, root, key):\\n        if not root:\\n            return None\\n        \\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            if not root.left:\\n                return root.right\\n            if not root.right:\\n                return root.left\\n            # Find the successor (smallest in the right subtree)\\n            min_larger_node = root.right\\n            while min_larger_node.left:\\n                min_larger_node = min_larger_node.left\\n            root.val = min_larger_node.val\\n            root.right = self.deleteNode(root.right, min_larger_node.val)\\n        \\n        return root\"",
  "826_14631217_python-updated-time": "1745878495452",
  "2798_14631217_javascript": "\"function chunk(arr, size) {\\n  const result = [];\\n  for (let i = 0; i < arr.length; i += size) {\\n    result.push(arr.slice(i, i + size));\\n  }\\n  return result;\\n}\\n\"",
  "1324_14631217_python-updated-time": "1746453826356",
  "699_14631217_python-updated-time": "1745786134263",
  "687_14631217_python": "\"class Solution(object):\\n    def longestUnivaluePath(self, root):\\n        self.res = 0\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            left_path = right_path = 0\\n            if node.left and node.left.val == node.val:\\n                left_path = left + 1\\n            if node.right and node.right.val == node.val:\\n                right_path = right + 1\\n            self.res = max(self.res, left_path + right_path)\\n            return max(left_path, right_path)\\n        \\n        dfs(root)\\n        return self.res\\n\"",
  "2650_14631217_python-updated-time": "1747066222227",
  "1160_14631217_python-updated-time": "1746108003411",
  "3398_14631217_python-updated-time": "1747424217125",
  "2496_14631217_python": "\"class Solution:\\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\\n        # Days per month in a non-leap year\\n        month_days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n        # Build prefix sum: days before the start of each month (1-indexed)\\n        prefix = [0]\\n        for d in month_days:\\n            prefix.append(prefix[-1] + d)\\n        \\n        def to_day_of_year(date):\\n            # date = \\\"MM-DD\\\"\\n            m = int(date[:2])\\n            d = int(date[3:])\\n            return prefix[m-1] + d\\n        \\n        a1 = to_day_of_year(arriveAlice)\\n        b1 = to_day_of_year(leaveAlice)\\n        a2 = to_day_of_year(arriveBob)\\n        b2 = to_day_of_year(leaveBob)\\n        \\n        start = max(a1, a2)\\n        end = min(b1, b2)\\n        return max(0, end - start + 1)\\n\"",
  "3190_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums1, nums2):\\n        n = len(nums1)\\n        best = float('inf')\\n\\n        # Try both possibilities for the last index: no swap (0) or swap (1)\\n        for swap_last in (0, 1):\\n            if swap_last == 0:\\n                a = nums1[-1]\\n                b = nums2[-1]\\n                cost = 0\\n            else:\\n                a = nums2[-1]\\n                b = nums1[-1]\\n                cost = 1\\n\\n            valid = True\\n            # For each other index, determine if we must swap or not\\n            for i in range(n - 1):\\n                u, v = nums1[i], nums2[i]\\n                ok0 = (u <= a and v <= b)   # leave as is\\n                ok1 = (v <= a and u <= b)   # swap at i\\n                if not ok0 and not ok1:\\n                    valid = False\\n                    break\\n                if not ok0 and ok1:\\n                    cost += 1\\n                # if ok0 is True (regardless of ok1), pick no swap to minimize cost\\n\\n            if valid:\\n                best = min(best, cost)\\n\\n        return best if best != float('inf') else -1\\n\"",
  "3478_14631217_python": "\"import math\\n\\nclass Solution:\\n    # ------------------------------------------------- helpers\\n    @staticmethod\\n    def circle_hits_rect(x, y, r, w, h):\\n        # does the open disk (x-c)²+(y-c)² < r² meet the open rectangle?\\n        dx = 0 if 0 < x < w else (0 - x if x <= 0 else x - w)\\n        dy = 0 if 0 < y < h else (0 - y if y <= 0 else y - h)\\n        return dx*dx + dy*dy < r*r\\n\\n    @staticmethod\\n    def circles_overlap_inside_rect(c1, c2, w, h):\\n        # does the intersection of two disks enter the rectangle’s interior?\\n        x1, y1, r1 = c1\\n        x2, y2, r2 = c2\\n        dx, dy     = x2 - x1, y2 - y1\\n        d2         = dx*dx + dy*dy\\n        rsum       = r1 + r2\\n        if d2 > rsum*rsum:               # no overlap at all\\n            return False\\n\\n        if d2 == 0:                      # concentric\\n            r_min = min(r1, r2)\\n            return Solution.circle_hits_rect(x1, y1, r_min, w, h)\\n\\n        rdiff = abs(r1 - r2)\\n        if d2 < rdiff*rdiff:             # one disk inside the other\\n            xc, yc, rc = (x1, y1, r1) if r1 < r2 else (x2, y2, r2)\\n            return Solution.circle_hits_rect(xc, yc, rc, w, h)\\n\\n        # proper intersection – compute the two intersection points\\n        d  = math.sqrt(d2)\\n        a  = (r1*r1 - r2*r2 + d2) / (2*d)\\n        h_ = math.sqrt(max(0.0, r1*r1 - a*a))\\n        xm = x1 + a * dx / d\\n        ym = y1 + a * dy / d\\n        rx = -dy * (h_ / d)\\n        ry =  dx * (h_ / d)\\n        ix1, iy1 = xm + rx, ym + ry\\n        ix2, iy2 = xm - rx, ym - ry\\n        return (0 < ix1 < w and 0 < iy1 < h) or (0 < ix2 < w and 0 < iy2 < h)\\n\\n    # ------------------------------------------------- main\\n    def canReachCorner(self, xCorner, yCorner, circles):\\n        w, h = xCorner, yCorner\\n\\n        # 0)  either corner covered (or tangent)  ⇒  impossible\\n        for cx, cy, r in circles:\\n            if cx*cx + cy*cy <= r*r:\\n                return False\\n            dx, dy = cx - w, cy - h\\n            if dx*dx + dy*dy <= r*r:\\n                return False\\n\\n        # 1) keep only disks that intrude the rectangle’s interior\\n        good = [(x, y, r) for x, y, r in circles\\n                if self.circle_hits_rect(x, y, r, w, h)]\\n\\n        n      = len(good)\\n        parent = list(range(n + 4))          # +4 virtual edge nodes\\n        LEFT, RIGHT, BOTTOM, TOP = n, n+1, n+2, n+3\\n\\n        def find(a):\\n            while parent[a] != a:\\n                parent[a] = parent[parent[a]]\\n                a = parent[a]\\n            return a\\n\\n        def union(a, b):\\n            pa, pb = find(a), find(b)\\n            if pa != pb:\\n                parent[pa] = pb\\n\\n        # 2) union disks with edges they touch (tangency counts)\\n        for i, (x, y, r) in enumerate(good):\\n            if x - r <= 0 and 0 < y < h:   union(i, LEFT)\\n            if x + r >= w and 0 < y < h:   union(i, RIGHT)\\n            if y - r <= 0 and 0 < x < w:   union(i, BOTTOM)\\n            if y + r >= h and 0 < x < w:   union(i, TOP)\\n\\n        # 3) union any two disks whose overlap enters the rectangle\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if self.circles_overlap_inside_rect(good[i], good[j], w, h):\\n                    union(i, j)\\n\\n        # 4) barrier checks\\n        if find(LEFT)  == find(RIGHT):  return False\\n        if find(TOP)   == find(BOTTOM): return False\\n        if find(LEFT)  == find(BOTTOM): return False   # start corner trapped\\n        if find(RIGHT) == find(TOP):    return False   # goal corner trapped\\n\\n        return True\\n\"",
  "3179_14631217_python": "\"class Solution:\\n    def maximumPoints(self, edges, coins, k):\\n        n = len(coins)\\n        # compute how many halvings are ever meaningful\\n        H = max(coins).bit_length() + 1\\n\\n        # build the rooted tree at 0\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        parent = [-1]*n\\n        parent[0] = 0\\n        order = [0]\\n        for u in order:                  # simple BFS/DFS to orient edges\\n            for v in adj[u]:\\n                if parent[v] < 0:\\n                    parent[v] = u\\n                    order.append(v)\\n\\n        # build children lists\\n        children = [[] for _ in range(n)]\\n        for u in range(1, n):\\n            children[parent[u]].append(u)\\n\\n        # dp[u][h] = best score in u's subtree if u has already been halved h times\\n        dp = [[0]*(H+1) for _ in range(n)]\\n\\n        # process in reverse‐order (leaf → root)\\n        for u in reversed(order):\\n            for h in range(H+1):\\n                # current coins at u after h halvings\\n                cur = coins[u] >> h\\n\\n                # sum of dp[v][h] or dp[v][h+1] over children\\n                sumA = sum(dp[v][h] for v in children[u])\\n                sumB = sum(dp[v][h+1] if h+1 <= H else dp[v][H]\\n                           for v in children[u])\\n\\n                # option1: take all current coins, pay k\\n                opt1 = (cur - k) + sumA\\n                # option2: take half, introduce an extra halving for descendants\\n                opt2 = (cur >> 1) + sumB\\n\\n                dp[u][h] = max(opt1, opt2)\\n\\n        return dp[0][0]\\n\"",
  "1440_14631217_python-updated-time": "1746261198801",
  "1121_14631217_python-updated-time": "1746042792694",
  "3782_14631217_mysql": "\"SELECT\\n  user_id,\\n  email\\nFROM\\n  Users\\nWHERE\\n  email RLIKE '^[[:alnum:]_]+@[[:alpha:]]+\\\\\\\\.com$'\\nORDER BY\\n  user_id;\\n\"",
  "1661_14631217_python": "\"class Solution(object):\\n    def findSmallestSetOfVertices(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Initialize an array to track the indegree of each vertex\\n        indegree = [0] * n\\n\\n        # Calculate indegree for each vertex\\n        for u, v in edges:\\n            indegree[v] += 1\\n\\n        # Collect all vertices with indegree 0 (source vertices)\\n        result = [i for i in range(n) if indegree[i] == 0]\\n\\n        return result\\n\"",
  "3045_14631217_python-updated-time": "1747227230626",
  "1220_14631217_python-updated-time": "1746109117312",
  "2465_14631217_python-updated-time": "1746965019097",
  "3057_14631217_python": "\"class Solution(object):\\n    def countKSubsequencesWithMaxBeauty(self, s, k):\\n        MOD = 10**9 + 7\\n        \\n        # 1) Compute frequencies of each letter\\n        from collections import Counter\\n        freq = list(Counter(s).values())   # up to 26 entries\\n        D = len(freq)\\n        if k > D:\\n            return 0\\n        \\n        # 2) Sort descending\\n        freq.sort(reverse=True)\\n        t = freq[k-1]                      # threshold frequency\\n        greater = sum(1 for x in freq if x > t)\\n        needed = k - greater\\n        totalT = sum(1 for x in freq if x == t)\\n        \\n        # 3) Product of all frequencies > t\\n        prod_higher = 1\\n        for x in freq:\\n            if x > t:\\n                prod_higher = prod_higher * x % MOD\\n        \\n        # 4) Precompute small factorials for combinations up to 26\\n        maxN = 26\\n        fact = [1] * (maxN + 1)\\n        inv = [1] * (maxN + 1)\\n        for i in range(1, maxN + 1):\\n            fact[i] = fact[i-1] * i % MOD\\n        inv[maxN] = pow(fact[maxN], MOD-2, MOD)\\n        for i in range(maxN, 0, -1):\\n            inv[i-1] = inv[i] * i % MOD\\n        \\n        # nCk function\\n        def comb(n, r):\\n            if r < 0 or r > n:\\n                return 0\\n            return fact[n] * inv[r] % MOD * inv[n-r] % MOD\\n        \\n        # 5) Compute the final answer\\n        #    Choose which of the \\\"t\\\"-frequency letters: C(totalT, needed)\\n        #    Multiply by t^needed, and by product of higher freqs.\\n        ways = comb(totalT, needed)\\n        ways = ways * pow(t, needed, MOD) % MOD\\n        ans = prod_higher * ways % MOD\\n        \\n        return ans\\n\"",
  "3559_14631217_python-updated-time": "1747571936054",
  "2684_14631217_python-updated-time": "1747136885171",
  "3354_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimizeStringValue(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # 1) Count initial letters and '?' count\\n        a = [0]*26\\n        q = 0\\n        for ch in s:\\n            if ch == '?':\\n                q += 1\\n            else:\\n                a[ord(ch) - 97] += 1\\n        \\n        # 2) Compute b[i]: how many '?' to assign to letter i\\n        heap = [(a[i], i) for i in range(26)]\\n        heapq.heapify(heap)\\n        b = [0]*26\\n        for _ in range(q):\\n            c, i = heapq.heappop(heap)\\n            b[i] += 1\\n            heapq.heappush(heap, (c+1, i))\\n        \\n        # 3) Reconstruct the answer lexicographically\\n        res = []\\n        for ch in s:\\n            if ch != '?':\\n                res.append(ch)\\n            else:\\n                # pick smallest i with b[i]>0\\n                for i in range(26):\\n                    if b[i] > 0:\\n                        b[i] -= 1\\n                        res.append(chr(97 + i))\\n                        break\\n        \\n        return \\\"\\\".join(res)\\n\"",
  "168_14631217_python": "\"class Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        result = \\\"\\\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            result = chr(ord('A') + columnNumber % 26) + result\\n            columnNumber //= 26\\n        return result\\n\"",
  "3644_14631217_python-updated-time": "1747595594829",
  "1952_14631217_python-updated-time": "1746544018948",
  "2979_14631217_python-updated-time": "1747225829506",
  "1493_14631217_python-updated-time": "1746345780686",
  "189_14631217_python": "\"class Solution(object):\\n    def rotate(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        k %= n\\n        \\n        def reverse(start, end):\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        \\n        reverse(0, n - 1)\\n        reverse(0, k - 1)\\n        reverse(k, n - 1)\\n\"",
  "2464_14631217_python": "\"class Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        zeros = 0\\n        max_time = 0\\n\\n        for c in s:\\n            if c == '0':\\n                zeros += 1\\n            elif zeros > 0:\\n                max_time = max(max_time + 1, zeros)\\n\\n        return max_time\\n\"",
  "1009_14631217_python": "\"class Solution:\\n    def pancakeSort(self, arr):\\n        res = []\\n        n = len(arr)\\n        \\n        for target in range(n, 1, -1):\\n            i = arr.index(target)\\n            if i == target - 1:\\n                continue\\n            if i != 0:\\n                res.append(i + 1)\\n                arr[:i + 1] = reversed(arr[:i + 1])\\n            res.append(target)\\n            arr[:target] = reversed(arr[:target])\\n        \\n        return res\\n\"",
  "1555_14631217_python-updated-time": "1746347506563",
  "585_14631217_mysql": "\"SELECT\\n    ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM Insurance i\\nJOIN (\\n    -- policies with a tiv_2015 value appearing more than once\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n) dup ON i.tiv_2015 = dup.tiv_2015\\nJOIN (\\n    -- policies whose (lat, lon) pair is unique\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n) loc ON i.lat = loc.lat AND i.lon = loc.lon;\\n\"",
  "2154_14631217_python-updated-time": "1746719494250",
  "343_14631217_python-updated-time": "1745257004116",
  "1452_14631217_mysql-updated-time": "1746261333784",
  "951_14631217_python-updated-time": "1746003388313",
  "1781_14631217_python-updated-time": "1746445659627",
  "2037_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def countTriples(self, n):\\n        count = 0\\n        for c in range(1, n+1):\\n            c2 = c*c\\n            for a in range(1, n+1):\\n                b2 = c2 - a*a\\n                if b2 <= 0:\\n                    continue\\n                b = int(math.sqrt(b2))\\n                if b*b == b2 and b <= n:\\n                    count += 1\\n        return count\\n\"",
  "3454_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        total = 0\\n        prev = 0  # think of diff[-1] = 0\\n        for i in range(n):\\n            cur = target[i] - nums[i]\\n            total += abs(cur - prev)\\n            prev = cur\\n        # account for returning to diff[n] = 0\\n        total += abs(prev - 0)\\n        # each operation changes two \\\"jumps\\\" by 1, so divide by 2\\n        return total // 2\\n\"",
  "1492_14631217_python-updated-time": "1746345754794",
  "2393_14631217_python": "\"class Solution:\\n    def matchReplacement(self, s, sub, mappings):\\n        # Build mapping: old_char -> set of new_chars\\n        mp = {}\\n        for old, new in mappings:\\n            if old not in mp:\\n                mp[old] = set()\\n            mp[old].add(new)\\n        \\n        n, m = len(s), len(sub)\\n        # Try every possible starting position\\n        for i in range(n - m + 1):\\n            for j in range(m):\\n                sc = s[i + j]\\n                tc = sub[j]\\n                if sc == tc:\\n                    continue\\n                # else see if we can map tc -> sc\\n                if tc in mp and sc in mp[tc]:\\n                    continue\\n                # cannot match at this position\\n                break\\n            else:\\n                # completed all j without break\\n                return True\\n        return False\\n\"",
  "1638_14631217_python-updated-time": "1746433584997",
  "3786_14631217_python-updated-time": "1747736984895",
  "414_14631217_python": "\"class Solution:\\n    def thirdMax(self, nums):\\n        first = second = third = float('-inf')\\n        \\n        for num in nums:\\n            if num in (first, second, third):\\n                continue\\n            if num > first:\\n                first, second, third = num, first, second\\n            elif num > second:\\n                second, third = num, second\\n            elif num > third:\\n                third = num\\n        \\n        return third if third != float('-inf') else first\\n\"",
  "3804_14631217_python": "\"class Solution(object):\\n    def maxActiveSectionsAfterTrade(self, s, queries):\\n        import math\\n\\n        n = len(s)\\n        # 1) Run‐length encode s into runs[]\\n        runs = []          # list of tuples (char, start, end, length)\\n        run_id = [0]*n     # run_id[i] = index in runs[] containing s[i]\\n        i = 0\\n        rid = 0\\n        while i < n:\\n            j = i\\n            while j+1 < n and s[j+1] == s[i]:\\n                j += 1\\n            runs.append((s[i], i, j, j - i + 1))\\n            for k in range(i, j+1):\\n                run_id[k] = rid\\n            rid += 1\\n            i = j + 1\\n        R = rid\\n\\n        # Unpack runs into parallel arrays\\n        run_char  = [runs[k][0] for k in range(R)]\\n        run_start = [runs[k][1] for k in range(R)]\\n        run_end   = [runs[k][2] for k in range(R)]\\n        run_len   = [runs[k][3] for k in range(R)]\\n\\n        INF = 10**15\\n        # 2a) Build array for min‐one‐run­length RMQ (INF on zero‐runs)\\n        arr_one_min = [INF]*R\\n        for k in range(1, R-1):\\n            if run_char[k] == '1':\\n                arr_one_min[k] = run_len[k]\\n\\n        # 2b) Build array for max‐zero‐run RMQ\\n        arr_zero_max = [0]*R\\n        for k in range(R):\\n            if run_char[k] == '0':\\n                arr_zero_max[k] = run_len[k]\\n\\n        # 2c) Build array for merging‐zeros RMQ:\\n        #    around each one‐run k: run_len[k-1] + run_len[k+1]\\n        arr_merge_max = [0]*R\\n        for k in range(1, R-1):\\n            if run_char[k] == '1':\\n                arr_merge_max[k] = run_len[k-1] + run_len[k+1]\\n\\n        # --- Sparse table boilerplate ---------------------\\n        # Precompute logs\\n        log = [0]*(R+1)\\n        for x in range(2, R+1):\\n            log[x] = log[x//2] + 1\\n        K = log[R] + 1\\n\\n        def build_rmq_max(arr):\\n            st = [arr[:]]\\n            j = 1\\n            while (1<<j) <= R:\\n                prev = st[j-1]\\n                cur = [max(prev[i], prev[i + (1<<(j-1))]) \\n                       for i in range(R - (1<<j) + 1)]\\n                st.append(cur)\\n                j += 1\\n            return st\\n\\n        def build_rmq_min(arr):\\n            st = [arr[:]]\\n            j = 1\\n            while (1<<j) <= R:\\n                prev = st[j-1]\\n                cur = [min(prev[i], prev[i + (1<<(j-1))]) \\n                       for i in range(R - (1<<j) + 1)]\\n                st.append(cur)\\n                j += 1\\n            return st\\n\\n        def rmq_max(st, L, R_):\\n            \\\"\\\"\\\"max over arr[L..R_]\\\"\\\"\\\"\\n            j = log[R_ - L + 1]\\n            row = st[j]\\n            return max(row[L], row[R_ - (1<<j) + 1])\\n\\n        def rmq_min(st, L, R_):\\n            \\\"\\\"\\\"min over arr[L..R_]\\\"\\\"\\\"\\n            j = log[R_ - L + 1]\\n            row = st[j]\\n            return min(row[L], row[R_ - (1<<j) + 1])\\n\\n        st_zero_max = build_rmq_max(arr_zero_max)\\n        st_one_min  = build_rmq_min(arr_one_min)\\n        st_merge_max= build_rmq_max(arr_merge_max)\\n\\n        total_ones = s.count('1')\\n        ans = []\\n\\n        # 3) Answer each query in O(1) RMQs + O(1) edge logic\\n        for l, r in queries:\\n            il = run_id[l]\\n            ir = run_id[r]\\n\\n            # 3a) longest zero‐block in [l,r]:\\n            left_z = 0\\n            if s[l] == '0':\\n                left_z = min(run_end[il], r) - l + 1\\n            right_z = 0\\n            if s[r] == '0':\\n                right_z = r - max(run_start[ir], l) + 1\\n\\n            mid_z = 0\\n            if il+1 <= ir-1:\\n                mid_z = rmq_max(st_zero_max, il+1, ir-1)\\n\\n            Z_max = max(left_z, right_z, mid_z)\\n\\n            # 3b) find all one‐runs fully inside (l,r):\\n            jl = max(il+1, 1)\\n            jr = min(ir-1, R-2)\\n            if jl > jr:\\n                # no one‐run we can flip\\n                ans.append(total_ones)\\n                continue\\n\\n            L1_min = rmq_min(st_one_min, jl, jr)\\n            if L1_min >= INF:\\n                # no valid one‐run strictly inside\\n                ans.append(total_ones)\\n                continue\\n\\n            gain1 = Z_max - L1_min  # using existing zero‐block\\n\\n            # 3c) best merge from flipping one‐run → zeros\\n            best_merge = 0\\n            # interior: j in [jl+1, jr-1]\\n            mL = jl+1\\n            mR = jr-1\\n            if mL <= mR:\\n                best_merge = rmq_max(st_merge_max, mL, mR)\\n\\n            # boundary j = jl\\n            j = jl\\n            if run_char[j] == '1':\\n                left_part  = max(0, run_end[j-1] - l + 1)\\n                right_part = max(0, min(run_end[j+1], r) - run_start[j+1] + 1)\\n                best_merge = max(best_merge, left_part + right_part)\\n\\n            # boundary j = jr (if distinct)\\n            if jr != jl:\\n                j = jr\\n                if run_char[j] == '1':\\n                    left_part  = max(0, min(run_end[j-1], r) - max(run_start[j-1], l) + 1)\\n                    right_part = max(0, r - run_start[j+1] + 1)\\n                    best_merge = max(best_merge, left_part + right_part)\\n\\n            gain2 = best_merge\\n            gain  = max(0, gain1, gain2)\\n            ans.append(total_ones + gain)\\n\\n        return ans\\n\"",
  "376_14631217_python": "\"class Solution:\\n    def wiggleMaxLength(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        up = down = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                up = down + 1\\n            elif nums[i] < nums[i-1]:\\n                down = up + 1\\n        \\n        return max(up, down)\\n\"",
  "668_14631217_python": "\"class Solution(object):\\n    def findKthNumber(self, m, n, k):\\n        def count(x):\\n            total = 0\\n            for i in range(1, m + 1):\\n                total += min(x // i, n)\\n            return total\\n        \\n        left, right = 1, m * n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if count(mid) < k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n\"",
  "152_14631217_python": "\"class Solution(object):\\n    def maxProduct(self, nums):\\n        if not nums:\\n            return 0\\n        \\n        max_prod = min_prod = result = nums[0]\\n        \\n        for num in nums[1:]:\\n            candidates = (num, num * max_prod, num * min_prod)\\n            max_prod = max(candidates)\\n            min_prod = min(candidates)\\n            result = max(result, max_prod)\\n        \\n        return result\\n\"",
  "2246_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite):\\n        n = len(favorite)\\n        indegree = [0] * n\\n        for f in favorite:\\n            indegree[f] += 1\\n\\n        # longest chain ending at each node\\n        longest = [0] * n\\n        queue = deque(i for i in range(n) if indegree[i] == 0)\\n\\n        while queue:\\n            u = queue.popleft()\\n            v = favorite[u]\\n            longest[v] = max(longest[v], longest[u] + 1)\\n            indegree[v] -= 1\\n            if indegree[v] == 0:\\n                queue.append(v)\\n\\n        visited = [False] * n\\n        max_cycle = 0\\n        mutual_sum = 0\\n\\n        for i in range(n):\\n            if visited[i] or indegree[i] == 0:\\n                continue\\n\\n            # detect cycle\\n            curr = i\\n            cycle = []\\n            while not visited[curr]:\\n                visited[curr] = True\\n                cycle.append(curr)\\n                curr = favorite[curr]\\n\\n            # check if it's a mutual pair\\n            if len(cycle) == 2 and favorite[cycle[1]] == cycle[0]:\\n                mutual_sum += 2 + longest[cycle[0]] + longest[cycle[1]]\\n            else:\\n                max_cycle = max(max_cycle, len(cycle))\\n\\n        return max(max_cycle, mutual_sum)\\n\"",
  "1021_14631217_python": "\"class Solution:\\n    def distributeCoins(self, root):\\n        self.moves = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            self.moves += abs(left) + abs(right)\\n            return node.val + left + right - 1  # coins to pass up: excess or need\\n\\n        dfs(root)\\n        return self.moves\\n\"",
  "2206_14631217_python-updated-time": "1746729832719",
  "920_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def uncommonFromSentences(self, s1, s2):\\n        count = Counter(s1.split()) + Counter(s2.split())\\n        return [word for word in count if count[word] == 1]\\n\"",
  "3200_14631217_python-updated-time": "1747310608945",
  "290_14631217_python": "\"class Solution(object):\\n    def wordPattern(self, pattern, s):\\n        \\\"\\\"\\\"\\n        :type pattern: str\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        words = s.split()\\n        if len(pattern) != len(words):\\n            return False\\n\\n        char_to_word = {}\\n        word_to_char = {}\\n\\n        for c, w in zip(pattern, words):\\n            if c in char_to_word and char_to_word[c] != w:\\n                return False\\n            if w in word_to_char and word_to_char[w] != c:\\n                return False\\n            char_to_word[c] = w\\n            word_to_char[w] = c\\n        \\n        return True\\n\"",
  "2700_14631217_python": "\"class Solution(object):\\n    def substringXorQueries(self, s, queries):\\n        n = len(s)\\n        best = {}\\n        MAX_LEN = 32  # enough to cover up to 2^31 values\\n        \\n        # Precompute the best (shortest, then leftmost) substring for every value\\n        for i in xrange(n):\\n            val = 0\\n            for l in xrange(1, MAX_LEN + 1):\\n                j = i + l - 1\\n                if j >= n:\\n                    break\\n                # build the integer value of s[i..j]\\n                val = (val << 1) + (ord(s[j]) - ord('0'))\\n                # record if this is the first time we see val, or it's a shorter\\n                # substring, or same length but more leftmost\\n                if val not in best or l < best[val][0] or (l == best[val][0] and i < best[val][1]):\\n                    best[val] = (l, i, j)\\n        \\n        # Answer the queries\\n        ans = []\\n        for first, second in queries:\\n            target = first ^ second\\n            if target in best:\\n                _, left, right = best[target]\\n                ans.append([left, right])\\n            else:\\n                ans.append([-1, -1])\\n        return ans\\n\"",
  "3034_14631217_python": "\"class Solution(object):\\n    def numberOfPoints(self, nums):\\n        # Since 1 <= starti <= endi <= 100, we can mark each integer point.\\n        covered = [0] * 101\\n        for a, b in nums:\\n            for x in range(a, b + 1):\\n                covered[x] = 1\\n        return sum(covered)\\n\"",
  "1290_14631217_python-updated-time": "1746126669518",
  "1880_14631217_python": "\"class Solution(object):\\n    def largestMerge(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        merge = []\\n        i, j = 0, 0\\n        while i < len(word1) and j < len(word2):\\n            if word1[i:] > word2[j:]:\\n                merge.append(word1[i])\\n                i += 1\\n            else:\\n                merge.append(word2[j])\\n                j += 1\\n\\n        merge.extend(word1[i:])\\n        merge.extend(word2[j:])\\n        return ''.join(merge)\\n\"",
  "3555_14631217_python-updated-time": "1747502380268",
  "445_14631217_python-updated-time": "1745359064406",
  "2038_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def nearestExit(self, maze, entrance):\\n        m, n = len(maze), len(maze[0])\\n        sr, sc = entrance\\n        visited = [[False]*n for _ in range(m)]\\n        visited[sr][sc] = True\\n        q = deque([(sr, sc, 0)])\\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        while q:\\n            r, c, d = q.popleft()\\n            for dr, dc in dirs:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and maze[nr][nc] == '.':\\n                    if nr == 0 or nr == m-1 or nc == 0 or nc == n-1:\\n                        return d + 1\\n                    visited[nr][nc] = True\\n                    q.append((nr, nc, d+1))\\n        return -1\\n\"",
  "522_14631217_python": "\"class Solution:\\n    def findLUSlength(self, strs):\\n        def is_subsequence(s, t):\\n            it = iter(t)\\n            return all(c in it for c in s)\\n        \\n        strs.sort(key=len, reverse=True)\\n        \\n        for i, s in enumerate(strs):\\n            if all(not is_subsequence(s, t) for j, t in enumerate(strs) if i != j):\\n                return len(s)\\n        \\n        return -1\\n\"",
  "608_14631217_mysql-updated-time": "1745448732055",
  "2058_14631217_python-updated-time": "1746637926332",
  "2694_14631217_python-updated-time": "1747136042413",
  "728_14631217_python-updated-time": "1745786972718",
  "1576_14631217_python": "\"class Solution(object):\\n    def minReorder(self, n, connections):\\n        from collections import deque\\n        # Build adjacency: (neighbor, needs_reorder)\\n        adj = [[] for _ in range(n)]\\n        for u, v in connections:\\n            adj[u].append((v, 1))  # edge u->v needs reorder when going from u to v\\n            adj[v].append((u, 0))  # edge v->u is originally u->v, so no reorder\\n        \\n        count = 0\\n        visited = [False] * n\\n        dq = deque([0])\\n        visited[0] = True\\n        \\n        while dq:\\n            u = dq.popleft()\\n            for v, need in adj[u]:\\n                if not visited[v]:\\n                    visited[v] = True\\n                    count += need\\n                    dq.append(v)\\n        \\n        return count\\n\"",
  "2891_14631217_python-updated-time": "1747222366912",
  "392_14631217_python": "\"class Solution:\\n    def isSubsequence(self, s, t):\\n        i, j = 0, 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n            j += 1\\n        return i == len(s)\\n\"",
  "2202_14631217_python-updated-time": "1746729406869",
  "1430_14631217_python": "\"class Solution:\\n    def divisorSubstrings(self, num, k):\\n        s = str(num)\\n        count = 0\\n        for i in range(len(s) - k + 1):\\n            sub = s[i:i+k]\\n            val = int(sub)\\n            if val != 0 and num % val == 0:\\n                count += 1\\n        return count\\n\"",
  "508_14631217_python-updated-time": "1745446262537",
  "742_14631217_python-updated-time": "1745786463527",
  "2411_14631217_python-updated-time": "1746906625783",
  "3019_14631217_python-updated-time": "1747225913793",
  "1262_14631217_python": "\"import random\\nimport bisect\\nfrom collections import defaultdict\\n\\nclass MajorityChecker(object):\\n    def __init__(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        \\\"\\\"\\\"\\n        self.arr = arr\\n        self.indices = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            self.indices[val].append(i)\\n\\n    def query(self, left, right, threshold):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        for _ in range(20):  # Try 20 random samples for high probability\\n            rand_index = random.randint(left, right)\\n            candidate = self.arr[rand_index]\\n            idx_list = self.indices[candidate]\\n            l = bisect.bisect_left(idx_list, left)\\n            r = bisect.bisect_right(idx_list, right)\\n            if r - l >= threshold:\\n                return candidate\\n        return -1\\n\"",
  "2690_14631217_python": "\"class Solution(object):\\n    def minCapability(self, nums, k):\\n        def can_rob(cap):\\n            count = i = 0\\n            while i < len(nums):\\n                if nums[i] <= cap:\\n                    count += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            return count >= k\\n\\n        left, right = min(nums), max(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_rob(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "3643_14631217_python-updated-time": "1747587919815",
  "967_14631217_python-updated-time": "1746003976049",
  "1344_14631217_python-updated-time": "1746259142917",
  "514_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n        char_pos = defaultdict(list)\\n        for i, ch in enumerate(ring):\\n            char_pos[ch].append(i)\\n\\n        memo = {}\\n\\n        def dp(i, pos):\\n            if i == len(key):\\n                return 0\\n            if (i, pos) in memo:\\n                return memo[(i, pos)]\\n            res = float('inf')\\n            for j in char_pos[key[i]]:\\n                steps = min(abs(j - pos), n - abs(j - pos)) + 1\\n                res = min(res, steps + dp(i + 1, j))\\n            memo[(i, pos)] = res\\n            return res\\n\\n        return dp(0, 0)\\n\"",
  "3606_14631217_python-updated-time": "1747572892423",
  "1557_14631217_python": "\"class Solution(object):\\n    def hasAllCodes(self, s, k):\\n        n = len(s)\\n        # If there are fewer than k bits, can't have any k-length code\\n        if n < k:\\n            return False\\n        total = 1 << k\\n        # To contain all k-length binary codes, s must have at least total substrings of length k\\n        # i.e., n - k + 1 >= total  =>  n >= total + k - 1\\n        if n < total + k - 1:\\n            return False\\n\\n        mask = total - 1\\n        seen = bytearray(total)\\n        count = 0\\n        val = 0\\n        # build initial value for first k bits\\n        for i in range(k):\\n            val = ((val << 1) & mask) | (ord(s[i]) - ord('0'))\\n        seen[val] = 1\\n        count = 1\\n\\n        # slide the window\\n        for i in range(k, n):\\n            # add new bit, drop oldest by masking\\n            val = ((val << 1) & mask) | (ord(s[i]) - ord('0'))\\n            if not seen[val]:\\n                seen[val] = 1\\n                count += 1\\n                if count == total:\\n                    return True\\n\\n        return count == total\\n\"",
  "3711_14631217_mysql-updated-time": "1747596088912",
  "900_14631217_python": "\"class Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        from collections import Counter\\n        target = Counter(str(n))\\n        for i in range(31):\\n            if Counter(str(1 << i)) == target:\\n                return True\\n        return False\\n\"",
  "3838_14631217_python-updated-time": "1747683957562",
  "1275_14631217_python": "\"class Solution(object):\\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\\n        parent = [0] * n\\n\\n        # Step 1: Check for multiple parents\\n        for i in range(n):\\n            for child in (leftChild[i], rightChild[i]):\\n                if child != -1:\\n                    if parent[child] == 1:\\n                        return False\\n                    parent[child] = 1\\n\\n        # Step 2: Find root (node with no parent)\\n        roots = [i for i in range(n) if parent[i] == 0]\\n        if len(roots) != 1:\\n            return False\\n        root = roots[0]\\n\\n        # Step 3: DFS to check for cycles and connectivity\\n        visited = set()\\n\\n        def dfs(node):\\n            if node == -1:\\n                return True\\n            if node in visited:\\n                return False\\n            visited.add(node)\\n            return dfs(leftChild[node]) and dfs(rightChild[node])\\n\\n        return dfs(root) and len(visited) == n\\n\"",
  "172_14631217_python": "\"class Solution(object):\\n    def trailingZeroes(self, n):\\n        count = 0\\n        while n > 0:\\n            n //= 5\\n            count += n\\n        return count\\n\"",
  "986_14631217_python-updated-time": "1746004834830",
  "2820_14631217_lang-updated-time": "1720874875892",
  "235_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        while root:\\n            if p.val < root.val and q.val < root.val:\\n                root = root.left\\n            elif p.val > root.val and q.val > root.val:\\n                root = root.right\\n            else:\\n                return root\\n\"",
  "886_14631217_python": "\"class Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = [0]\\n        for c in s:\\n            if c == '(':\\n                stack.append(0)\\n            else:\\n                val = stack.pop()\\n                stack[-1] += max(2 * val, 1)\\n        return stack[0]\\n\"",
  "2676_14631217_python-updated-time": "1747135840821",
  "3321_14631217_python-updated-time": "1747413011268",
  "2_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def addTwoNumbers(self, l1, l2):\\n        \\\"\\\"\\\"\\n        :type l1: Optional[ListNode]\\n        :type l2: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0)\\n        current = dummy\\n        carry = 0\\n\\n        while l1 or l2 or carry:\\n            val1 = l1.val if l1 else 0\\n            val2 = l2.val if l2 else 0\\n\\n            total = val1 + val2 + carry\\n            carry = total // 10\\n            current.next = ListNode(total % 10)\\n            current = current.next\\n\\n            if l1:\\n                l1 = l1.next\\n            if l2:\\n                l2 = l2.next\\n\\n        return dummy.next\\n\"",
  "3582_14631217_python-updated-time": "1747571493455",
  "1789_14631217_python-updated-time": "1746453039611",
  "1851_14631217_python-updated-time": "1746531457802",
  "1242_14631217_python": "\"class Solution:\\n    def matrixBlockSum(self, mat, k):\\n        m, n = len(mat), len(mat[0])\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        # Compute prefix sum\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i + 1][j + 1] = mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j]\\n        \\n        res = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                r1, c1 = max(0, i - k), max(0, j - k)\\n                r2, c2 = min(m, i + k + 1), min(n, j + k + 1)\\n                res[i][j] = prefix[r2][c2] - prefix[r1][c2] - prefix[r2][c1] + prefix[r1][c1]\\n        \\n        return res\\n\"",
  "1761_14631217_python": "\"class Solution:\\n    def countVowelStrings(self, n):\\n        # The answer is C(n+4, 4): number of multisets of size n from 5 vowels.\\n        res = 1\\n        for i in range(1, 5):\\n            res = res * (n + i) // i\\n        return res\\n\"",
  "2022_14631217_python-updated-time": "1746637165481",
  "2954_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def maxSum(self, nums, m, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type m: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        freq = defaultdict(int)\\n        distinct = 0\\n        window_sum = 0\\n        max_sum = 0\\n\\n        # initialize first window [0..k-1]\\n        for i in range(k):\\n            x = nums[i]\\n            window_sum += x\\n            if freq[x] == 0:\\n                distinct += 1\\n            freq[x] += 1\\n\\n        if distinct >= m:\\n            max_sum = window_sum\\n\\n        # slide window\\n        for i in range(k, n):\\n            # remove nums[i-k]\\n            y = nums[i - k]\\n            freq[y] -= 1\\n            if freq[y] == 0:\\n                distinct -= 1\\n                del freq[y]\\n            window_sum -= y\\n\\n            # add nums[i]\\n            x = nums[i]\\n            if freq[x] == 0:\\n                distinct += 1\\n            freq[x] += 1\\n            window_sum += x\\n\\n            # check\\n            if distinct >= m and window_sum > max_sum:\\n                max_sum = window_sum\\n\\n        return max_sum\\n\"",
  "1820_14631217_python-updated-time": "1746454349188",
  "1219_14631217_python": "\"class Solution(object):\\n    def longestWPI(self, hours):\\n        \\\"\\\"\\\"\\n        :type hours: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        score = 0\\n        seen = {}\\n        max_len = 0\\n\\n        for i, h in enumerate(hours):\\n            score += 1 if h > 8 else -1\\n\\n            if score > 0:\\n                max_len = i + 1\\n            elif (score - 1) in seen:\\n                max_len = max(max_len, i - seen[score - 1])\\n\\n            if score not in seen:\\n                seen[score] = i\\n\\n        return max_len\\n\"",
  "1371_14631217_python-updated-time": "1746259471429",
  "96_14631217_python": "\"class Solution(object):\\n    def numTrees(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [0] * (n + 1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n + 1):\\n            for j in range(i):\\n                dp[i] += dp[j] * dp[i - 1 - j]\\n        \\n        return dp[n]\\n\"",
  "1942_14631217_mysql-updated-time": "1746542629985",
  "1413_14631217_python-updated-time": "1746260401946",
  "2714_14631217_python": "\"class Solution(object):\\n    def leftRightDifference(self, nums):\\n        n = len(nums)\\n        leftSum = [0] * n\\n        rightSum = [0] * n\\n        answer = [0] * n\\n\\n        # Build leftSum\\n        for i in range(1, n):\\n            leftSum[i] = leftSum[i - 1] + nums[i - 1]\\n\\n        # Build rightSum\\n        for i in range(n - 2, -1, -1):\\n            rightSum[i] = rightSum[i + 1] + nums[i + 1]\\n\\n        # Compute answer\\n        for i in range(n):\\n            answer[i] = abs(leftSum[i] - rightSum[i])\\n\\n        return answer\\n\"",
  "78_14631217_python": "\"class Solution(object):\\n    def subsets(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(start, path):\\n            res.append(list(path))\\n            for i in range(start, len(nums)):\\n                path.append(nums[i])\\n                backtrack(i + 1, path)\\n                path.pop()\\n\\n        backtrack(0, [])\\n        return res\\n\"",
  "812_14631217_python": "\"class Solution(object):\\n    def rotateString(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        return goal in (s + s)\\n\"",
  "1216_14631217_java-updated-time": "1746108947805",
  "209_14631217_python": "\"class Solution(object):\\n    def minSubArrayLen(self, target, nums):\\n        \\\"\\\"\\\"\\n        :type target: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left = 0\\n        total = 0\\n        res = float('inf')\\n        \\n        for right in range(len(nums)):\\n            total += nums[right]\\n            while total >= target:\\n                res = min(res, right - left + 1)\\n                total -= nums[left]\\n                left += 1\\n                \\n        return res if res != float('inf') else 0\\n\"",
  "3858_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def subtreeInversionSum(self, edges, nums, k):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # build tree\\n        g = [[] for _ in range(n)]\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        m = (k+1)*2  # number of DP states per node: d=0..k, p=0/1\\n        NEG_INF = -10**18\\n        \\n        def dfs(u, parent):\\n            # Initialize accumulators S0, S1 for children contributions:\\n            # S0[idx] = sum of best child contributions if we do NOT invert at u,\\n            # S1[idx] = sum if we DO invert at u.\\n            S0 = [0]*m\\n            S1 = [0]*m\\n            \\n            # process children\\n            for v in g[u]:\\n                if v == parent:\\n                    continue\\n                dp_child = dfs(v, u)  # length-m list\\n                # compute this child's contribution for every parent state (d,p)\\n                # we will add into S0 and S1\\n                f0 = [0]*m\\n                f1 = [0]*m\\n                for d in range(k+1):\\n                    for p in (0,1):\\n                        idx_par = d*2 + p\\n                        # if we do NOT invert at u: d_child = min(d+1, k), p_child = p\\n                        d0 = d+1 if d < k else k\\n                        idx0 = d0*2 + p\\n                        f0[idx_par] = dp_child[idx0]\\n                        # if we DO invert at u: allowed later; \\n                        # for now compute d_child = 1, p_child = p^1\\n                        idx1 = 1*2 + (p^1)\\n                        f1[idx_par] = dp_child[idx1]\\n                # accumulate\\n                for i in range(m):\\n                    S0[i] += f0[i]\\n                    S1[i] += f1[i]\\n            \\n            # now build dp for u\\n            dp_u = [NEG_INF]*m\\n            for d in range(k+1):\\n                for p in (0,1):\\n                    idx = d*2 + p\\n                    # value at u itself under sel=0 or 1\\n                    val0 = nums[u]* (1 if p==0 else -1)\\n                    val1 = nums[u]* ( -1 if p==0 else 1)  # flip once\\n                    # sel = 0 (no inversion at u)\\n                    best = S0[idx] + val0\\n                    # sel = 1 (invert at u) only if d >= k\\n                    if d >= k:\\n                        best = max(best, S1[idx] + val1)\\n                    dp_u[idx] = best\\n            return dp_u\\n        \\n        # compute dp at root, starting with no inversion above => d=k, p=0\\n        dp0 = dfs(0, -1)\\n        return dp0[k*2 + 0]\\n\"",
  "26_14631217_python": "\"class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return 0\\n        \\n        i = 0\\n        for j in range(1, len(nums)):\\n            if nums[j] != nums[i]:\\n                i += 1\\n                nums[i] = nums[j]\\n        \\n        return i + 1\\n\"",
  "2360_14631217_python-updated-time": "1746881266662",
  "2054_14631217_python-updated-time": "1746638505189",
  "3091_14631217_python": "\"class Solution(object):\\n    def countSubMultisets(self, nums, l, r):\\n        MOD = 10**9 + 7\\n        from collections import Counter\\n\\n        # Count zeros separately\\n        freq = Counter(nums)\\n        z = freq.pop(0, 0)\\n\\n        total_sum = sum(val * cnt for val, cnt in freq.items())\\n        max_s = min(r, total_sum)\\n\\n        # dp[s] = number of ways to get sum s using non-zero values\\n        dp = [0] * (max_s + 1)\\n        dp[0] = 1\\n\\n        # Bounded knapsack via sliding-window per residue\\n        for v, c in freq.items():\\n            for rem in range(v):\\n                window = 0\\n                queue = []\\n                for s in range(rem, max_s + 1, v):\\n                    window = (window + dp[s]) % MOD\\n                    queue.append(dp[s])\\n                    if len(queue) > c + 1:\\n                        window = (window - queue.pop(0)) % MOD\\n                    dp[s] = window\\n\\n        # Multiply each dp[s] by ways to choose zeros: (z+1)\\n        mult = z + 1\\n        ans = 0\\n        # sum over s in [l..r], but s=0 case uses dp[0]*(z+1)\\n        for s in range(l, max_s + 1):\\n            ans = (ans + dp[s] * mult) % MOD\\n\\n        return ans\\n\"",
  "368_14631217_python-updated-time": "1745354493640",
  "3516_14631217_python-updated-time": "1747494809233",
  "313_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ugly = [1]\\n        heap = []\\n        for prime in primes:\\n            heapq.heappush(heap, (prime, prime, 0))\\n        \\n        while len(ugly) < n:\\n            val, prime, idx = heapq.heappop(heap)\\n            if val != ugly[-1]:\\n                ugly.append(val)\\n            heapq.heappush(heap, (prime * ugly[idx + 1], prime, idx + 1))\\n        \\n        return ugly[-1]\\n\"",
  "3334_14631217_python": "\"class Solution(object):\\n    def minimumBoxes(self, apple, capacity):\\n        \\\"\\\"\\\"\\n        :type apple: List[int]\\n        :type capacity: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total_apples = sum(apple)\\n        # Sort box capacities in descending order\\n        capacity.sort(reverse=True)\\n        \\n        used = 0\\n        acc = 0\\n        # Pick largest boxes until we can fit all apples\\n        for cap in capacity:\\n            acc += cap\\n            used += 1\\n            if acc >= total_apples:\\n                return used\\n        \\n        # The problem guarantees it's always possible\\n        return used\\n\"",
  "388_14631217_python-updated-time": "1745355315353",
  "2832_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def longestEqualSubarray(self, nums, k):\\n        positions = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            positions[num].append(i)\\n\\n        res = 0\\n        for pos in positions.values():\\n            left = 0\\n            for right in range(len(pos)):\\n                # elements to delete = total elements in range - equal elements\\n                while pos[right] - pos[left] - (right - left) > k:\\n                    left += 1\\n                res = max(res, right - left + 1)\\n        return res\\n\"",
  "3017_14631217_python": "\"class Solution(object):\\n    def numberOfBeautifulIntegers(self, low, high, k):\\n        # count how many beautiful numbers in [1..n]\\n        def count(n):\\n            if n <= 0:\\n                return 0\\n            digs = map(int, list(str(n)))\\n            L = len(digs)\\n            memo = {}\\n\\n            def dp(pos, tight, mod, diff, started):\\n                # diff = (#even digits) - (#odd digits)\\n                key = (pos, tight, mod, diff, started)\\n                if key in memo:\\n                    return memo[key]\\n                if pos == L:\\n                    # at end: must have started, divisible by k, and diff == 0\\n                    res = 1 if started and mod == 0 and diff == 0 else 0\\n                else:\\n                    res = 0\\n                    up = digs[pos] if tight else 9\\n                    for d in range(up + 1):\\n                        nt = tight and (d == up)\\n                        ns = started or (d != 0)\\n                        nm = (mod * 10 + d) % k if ns else 0\\n                        nd = diff\\n                        if ns:\\n                            if d % 2 == 0:\\n                                nd += 1\\n                            else:\\n                                nd -= 1\\n                        res += dp(pos + 1, nt, nm, nd, ns)\\n                memo[key] = res\\n                return res\\n\\n            return dp(0, True, 0, 0, False)\\n\\n        # beautifuls in [low..high] = count(high) - count(low-1)\\n        return count(high) - count(low - 1)\\n\"",
  "notification-status:lastFetched": "1747738765178",
  "1575_14631217_python-updated-time": "1746348193348",
  "1924_14631217_python-updated-time": "1746543710560",
  "3579_14631217_python": "\"class Solution(object):\\n    def kthCharacter(self, k, operations):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type operations: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Number of operations\\n        m = len(operations)\\n        # Precompute the length of the string after each operation: length[i] = 2^i\\n        lengths = [1] * (m + 1)\\n        for i in range(m):\\n            lengths[i + 1] = lengths[i] << 1\\n        # Current position we want, and the total shift count\\n        cur_k = k\\n        shift_count = 0\\n        # Walk operations in reverse to map cur_k back to the original 'a'\\n        for i in range(m - 1, -1, -1):\\n            if cur_k > lengths[i]:\\n                # We're in the second half of the string after operation i\\n                cur_k -= lengths[i]\\n                # If this operation was a shift-append, accumulate one shift\\n                if operations[i] == 1:\\n                    shift_count = (shift_count + 1) % 26\\n        # After reversing all operations, we land at position cur_k in the initial string \\\"a\\\"\\n        # Since the initial word is \\\"a\\\" of length 1, cur_k must be 1\\n        # Apply the accumulated shifts to 'a'\\n        return chr((ord('a') - ord('a') + shift_count) % 26 + ord('a'))\\n\\n    def maxGoodNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import itertools\\n        max_val = 0\\n        # Try all permutations of the three numbers\\n        for perm in itertools.permutations(nums):\\n            # Concatenate binary representations without leading zeros\\n            s = ''.join(bin(x)[2:] for x in perm)\\n            # Convert concatenated binary string to integer\\n            val = int(s, 2)\\n            if val > max_val:\\n                max_val = val\\n        return max_val\"",
  "749_14631217_python-updated-time": "1745875506221",
  "498_14631217_python-updated-time": "1745446049378",
  "4_14631217_python-updated-time": "1744978907463",
  "371_14631217_python-updated-time": "1745354531352",
  "2356_14631217_python": "\"class Solution:\\n    def largestCombination(self, candidates):\\n        # Count how many numbers have each bit set\\n        bit_counts = [0] * 24  # since candidates[i] <= 10^7 < 2^24\\n        for x in candidates:\\n            b = 0\\n            while x:\\n                if x & 1:\\n                    bit_counts[b] += 1\\n                x >>= 1\\n                b += 1\\n        # The largest subset whose AND > 0 must all share at least one common '1' bit\\n        return max(bit_counts)\\n\"",
  "3706_14631217_python-updated-time": "1747652692191",
  "446_14631217_python-updated-time": "1745359093690",
  "982_14631217_python-updated-time": "1746004679043",
  "123_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, prices):\\n        # initialize\\n        first_buy   = float('-inf')\\n        first_sell  = 0\\n        second_buy  = float('-inf')\\n        second_sell = 0\\n\\n        for p in prices:\\n            # Maximize each state in turn\\n            first_buy   = max(first_buy,   -p)            # buy first share\\n            first_sell  = max(first_sell,  first_buy + p) # sell first share\\n            second_buy  = max(second_buy,  first_sell - p) # buy second share\\n            second_sell = max(second_sell, second_buy + p) # sell second share\\n\\n        return second_sell\\n\"",
  "1014_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def kClosest(self, points, k):\\n        return heapq.nsmallest(k, points, key=lambda p: p[0]**2 + p[1]**2)\\n\"",
  "2576_14631217_python": "\"class Solution(object):\\n    def bestClosingTime(self, customers):\\n        penalN = 0\\n        penalY = customers.count('Y')\\n        minPen = float('inf')\\n        ans = 0\\n        n = len(customers)\\n        for j in range(n + 1):\\n            cur = penalN + penalY\\n            if cur < minPen:\\n                minPen = cur\\n                ans = j\\n            if j < n:\\n                if customers[j] == 'N':\\n                    penalN += 1\\n                else:\\n                    penalY -= 1\\n        return ans\\n\"",
  "661_14631217_python": "\"class Solution(object):\\n    def imageSmoother(self, img):\\n        m, n = len(img), len(img[0])\\n        res = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                total = 0\\n                count = 0\\n                for r in range(i-1, i+2):\\n                    for c in range(j-1, j+2):\\n                        if 0 <= r < m and 0 <= c < n:\\n                            total += img[r][c]\\n                            count += 1\\n                res[i][j] = total // count\\n        \\n        return res\\n\"",
  "2697_14631217_python": "\"from collections import deque\\nimport bisect\\n\\nclass Solution:\\n    def minimumVisitedCells(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        # Available unvisited columns per row and rows per column\\n        row_avail = [list(range(n)) for _ in range(m)]\\n        col_avail = [list(range(m)) for _ in range(n)]\\n\\n        visited = [[False]*n for _ in range(m)]\\n        dq = deque()\\n        # Start at (0,0) with distance = 1\\n        visited[0][0] = True\\n        dq.append((0, 0, 1))\\n        # Remove (0,0) from availability\\n        row_avail[0].pop(0)\\n        col_avail[0].pop(0)\\n\\n        while dq:\\n            r, c, d = dq.popleft()\\n            if r == m-1 and c == n-1:\\n                return d\\n            steps = grid[r][c]\\n            # Right moves\\n            low_c = c+1\\n            high_c = min(n-1, c+steps)\\n            row_list = row_avail[r]\\n            L = bisect.bisect_left(row_list, low_c)\\n            R = L\\n            # collect candidates\\n            while R < len(row_list) and row_list[R] <= high_c:\\n                nc = row_list[R]\\n                if not visited[r][nc]:\\n                    visited[r][nc] = True\\n                    dq.append((r, nc, d+1))\\n                    # remove r from column availability\\n                    col_list = col_avail[nc]\\n                    idx = bisect.bisect_left(col_list, r)\\n                    if idx < len(col_list) and col_list[idx] == r:\\n                        col_list.pop(idx)\\n                R += 1\\n            # remove processed columns from this row\\n            del row_list[L:R]\\n\\n            # Down moves\\n            low_r = r+1\\n            high_r = min(m-1, r+steps)\\n            col_list = col_avail[c]\\n            L = bisect.bisect_left(col_list, low_r)\\n            R = L\\n            while R < len(col_list) and col_list[R] <= high_r:\\n                nr = col_list[R]\\n                if not visited[nr][c]:\\n                    visited[nr][c] = True\\n                    dq.append((nr, c, d+1))\\n                    # remove c from row availability\\n                    row_list2 = row_avail[nr]\\n                    idx = bisect.bisect_left(row_list2, c)\\n                    if idx < len(row_list2) and row_list2[idx] == c:\\n                        row_list2.pop(idx)\\n                R += 1\\n            del col_list[L:R]\\n\\n        return -1\"",
  "19_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :type n: int\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0, head)\\n        first = second = dummy\\n\\n        for _ in range(n + 1):\\n            first = first.next\\n\\n        while first:\\n            first = first.next\\n            second = second.next\\n\\n        second.next = second.next.next\\n        return dummy.next\\n\"",
  "1826_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maximizeXor(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        # queries_with_idx = [(mi, xi, original_index), ...] sorted by mi\\n        queries_with_idx = sorted(\\n            [(mi, xi, i) for i, (xi, mi) in enumerate(queries)]\\n        )\\n        \\n        # We'll build a bitwise trie; each node has children[0] and children[1].\\n        children = [[-1, -1]]\\n        node_count = [1]   # store as list so inner functions can update\\n        \\n        def trie_insert(x):\\n            node = 0\\n            # from bit 30 down to bit 0\\n            for b in range(30, -1, -1):\\n                bit = (x >> b) & 1\\n                nxt = children[node][bit]\\n                if nxt == -1:\\n                    nxt = node_count[0]\\n                    children[node][bit] = nxt\\n                    children.append([-1, -1])\\n                    node_count[0] += 1\\n                node = nxt\\n        \\n        def trie_max_xor(x):\\n            node = 0\\n            res = 0\\n            for b in range(30, -1, -1):\\n                bit = (x >> b) & 1\\n                want = 1 - bit\\n                if children[node][want] != -1:\\n                    res |= (1 << b)\\n                    node = children[node][want]\\n                else:\\n                    node = children[node][bit]\\n            return res\\n        \\n        res = [-1] * len(queries)\\n        p = 0  # pointer into nums\\n        \\n        for mi, xi, qi in queries_with_idx:\\n            # insert all nums[p] <= mi into the trie\\n            while p < len(nums) and nums[p] <= mi:\\n                trie_insert(nums[p])\\n                p += 1\\n            # if we inserted nothing yet, answer is -1\\n            if p == 0:\\n                res[qi] = -1\\n            else:\\n                res[qi] = trie_max_xor(xi)\\n        \\n        return res\\n\"",
  "2758_14631217_javascript-updated-time": "1747135091030",
  "835_14631217_python-updated-time": "1745878769555",
  "1975_14631217_python": "\"class Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        return min(abs(i - start) for i, v in enumerate(nums) if v == target)\\n\"",
  "633_14631217_python": "\"class Solution(object):\\n    def judgeSquareSum(self, c):\\n        left, right = 0, int(c**0.5)\\n        while left <= right:\\n            curr = left * left + right * right\\n            if curr == c:\\n                return True\\n            elif curr < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n\"",
  "816_14631217_python": "\"class MyHashSet(object):\\n\\n    def __init__(self):\\n        # Keys are in [0, 10^6], so we can use a fixed-size bytearray\\n        self.data = bytearray(10**6 + 1)\\n\\n    def add(self, key):\\n        # Mark presence by setting to 1\\n        self.data[key] = 1\\n\\n    def remove(self, key):\\n        # Mark absence by setting back to 0\\n        self.data[key] = 0\\n\\n    def contains(self, key):\\n        # Return True if marked present\\n        return self.data[key] == 1\\n\"",
  "2368_14631217_python": "\"class Solution:\\n    def totalStrength(self, strength):\\n        MOD = 10**9 + 7\\n        n = len(strength)\\n        \\n        # Compute previous less element (strictly less)\\n        L = [-1] * n\\n        stack = []\\n        for i, val in enumerate(strength):\\n            while stack and strength[stack[-1]] >= val:\\n                stack.pop()\\n            L[i] = stack[-1] if stack else -1\\n            stack.append(i)\\n        \\n        # Compute next less element (strictly less)\\n        R = [n] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            val = strength[i]\\n            while stack and strength[stack[-1]] > val:\\n                stack.pop()\\n            R[i] = stack[-1] if stack else n\\n            stack.append(i)\\n        \\n        # Prefix sums P and prefix-of-prefix PP\\n        P = [0] * (n+1)\\n        for i in range(n):\\n            P[i+1] = (P[i] + strength[i]) % MOD\\n        PP = [0] * (n+2)\\n        for i in range(n+1):\\n            PP[i+1] = (PP[i] + P[i]) % MOD\\n        \\n        ans = 0\\n        for i in range(n):\\n            left_count  = i - L[i]       # number of choices for start\\n            right_count = R[i] - i       # number of choices for end\\n            \\n            # Sum over ends: sum_{r=i..R[i]-1} P[r+1] = PP[R[i]+1] - PP[i+1]\\n            sumR = (PP[R[i]+1] - PP[i+1]) % MOD\\n            # Sum over starts: sum_{l=L[i]+1..i} P[l] = PP[i+1] - PP[L[i]+1]\\n            sumL = (PP[i+1] - PP[L[i]+1]) % MOD\\n            \\n            total_subarray_sum = (left_count * sumR - right_count * sumL) % MOD\\n            ans = (ans + strength[i] * total_subarray_sum) % MOD\\n        \\n        return ans\\n\"",
  "3560_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxMoves(self, kx, ky, positions):\\n        n = len(positions)\\n        # include the knight's start as point n\\n        pts = positions + [(kx, ky)]\\n        N = n + 1\\n\\n        # Precompute knight distances between all pts[i] -> pts[j]\\n        dist = [[0]*N for _ in range(N)]\\n        dirs = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]\\n        for i, (sx, sy) in enumerate(pts):\\n            D = [[-1]*50 for _ in range(50)]\\n            dq = deque([(sx, sy)])\\n            D[sx][sy] = 0\\n            while dq:\\n                x, y = dq.popleft()\\n                d0 = D[x][y]\\n                for dx, dy in dirs:\\n                    nx, ny = x+dx, y+dy\\n                    if 0 <= nx < 50 and 0 <= ny < 50 and D[nx][ny] < 0:\\n                        D[nx][ny] = d0 + 1\\n                        dq.append((nx, ny))\\n            for j, (tx, ty) in enumerate(pts):\\n                dist[i][j] = D[tx][ty]\\n\\n        full = (1<<n) - 1\\n        # dp[mask][cur]: optimal total from state\\n        dp = [[0]*N for _ in range(1<<n)]\\n        # base dp[0][*] = 0\\n\\n        for mask in range(1, full+1):\\n            # number removed so far = n - popcount(mask)\\n            removed = n - bin(mask).count('1')\\n            alice = (removed % 2 == 0)\\n            for cur in range(N):\\n                if alice:\\n                    best = -10**18\\n                else:\\n                    best =  10**18\\n                m = mask\\n                while m:\\n                    lb = m & -m\\n                    i = (lb.bit_length() - 1)\\n                    m ^= lb\\n                    nxt = mask ^ lb\\n                    cost = dist[cur][i] + dp[nxt][i]\\n                    if alice:\\n                        if cost > best: best = cost\\n                    else:\\n                        if cost < best: best = cost\\n                dp[mask][cur] = best\\n\\n        return dp[full][n]\\n\"",
  "1186_14631217_java-updated-time": "1746108984096",
  "1850_14631217_python-updated-time": "1746531408625",
  "1747_14631217_python-updated-time": "1746444676187",
  "874_14631217_python-updated-time": "1745880101723",
  "3063_14631217_pythondata-updated-time": "1747306106967",
  "309_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, prices):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not prices:\\n            return 0\\n        \\n        n = len(prices)\\n        hold = [0] * n\\n        sold = [0] * n\\n        rest = [0] * n\\n        \\n        hold[0] = -prices[0]\\n        sold[0] = 0\\n        rest[0] = 0\\n        \\n        for i in range(1, n):\\n            hold[i] = max(hold[i-1], rest[i-1] - prices[i])\\n            sold[i] = hold[i-1] + prices[i]\\n            rest[i] = max(rest[i-1], sold[i-1])\\n        \\n        return max(sold[-1], rest[-1])\\n\"",
  "2180_14631217_python-updated-time": "1746729091331",
  "993_14631217_python-updated-time": "1746038764256",
  "3743_14631217_python-updated-time": "1747674274590",
  "82_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0, head)\\n        prev = dummy\\n\\n        while head:\\n            if head.next and head.val == head.next.val:\\n                while head.next and head.val == head.next.val:\\n                    head = head.next\\n                prev.next = head.next\\n            else:\\n                prev = prev.next\\n            head = head.next\\n\\n        return dummy.next\\n\"",
  "74_14631217_python-updated-time": "1745015121758",
  "1908_14631217_mysql-updated-time": "1746531614294",
  "3613_14631217_python-updated-time": "1747596748131",
  "3515_14631217_python": "\"class Solution(object):\\n    def canAliceWin(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        sum_single = 0\\n        sum_double = 0\\n        for x in nums:\\n            if x < 10:\\n                sum_single += x\\n            else:\\n                sum_double += x\\n        # Alice can choose single-digit or double-digit numbers\\n        return sum_single > sum_double or sum_double > sum_single\\n\"",
  "538_14631217_python-updated-time": "1745446914331",
  "1503_14631217_python": "\"class Solution(object):\\n    def maxSatisfaction(self, satisfaction):\\n        satisfaction.sort(reverse=True)\\n        total = 0\\n        curr = 0\\n        for s in satisfaction:\\n            if curr + s > 0:\\n                curr += s\\n                total += curr\\n            else:\\n                break\\n        return total\\n\"",
  "1748_14631217_python-updated-time": "1746444702946",
  "326_14631217_python": "\"class Solution(object):\\n    def isPowerOfThree(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return n > 0 and 1162261467 % n == 0\\n\"",
  "1497_14631217_python-updated-time": "1746345874288",
  "3517_14631217_python-updated-time": "1747494878605",
  "2594_14631217_python-updated-time": "1747059053564",
  "3068_14631217_pythondata-updated-time": "1747313081928",
  "119_14631217_python-updated-time": "1745081515861",
  "3849_14631217_python": "\"class Solution(object):\\n    def canPartitionGrid(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # 1) Total sum\\n        total = 0\\n        for row in grid:\\n            total += sum(row)\\n        # If odd, can't split equally\\n        if total & 1:\\n            return False\\n        half = total // 2\\n        \\n        # 2) Try horizontal cuts\\n        racc = 0\\n        for i in range(m):\\n            racc += sum(grid[i])\\n            # cut after row i ⇒ upper block is rows [0..i], lower [i+1..m-1]\\n            if racc == half and i < m - 1:\\n                return True\\n        \\n        # 3) Try vertical cuts\\n        # build column sums\\n        col_sums = [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                col_sums[c] += grid[r][c]\\n        \\n        cacc = 0\\n        for j in range(n):\\n            cacc += col_sums[j]\\n            # cut after col j ⇒ left block cols [0..j], right [j+1..n-1]\\n            if cacc == half and j < n - 1:\\n                return True\\n        \\n        return False\\n\"",
  "2777_14631217_python-updated-time": "1747137182797",
  "2168_14631217_python": "\"class Solution(object):\\n    def areNumbersAscending(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        tokens = s.split()\\n        prev = -1\\n        for token in tokens:\\n            if token.isdigit():\\n                num = int(token)\\n                if num <= prev:\\n                    return False\\n                prev = num\\n        return True\\n\"",
  "1238_14631217_python-updated-time": "1746109317386",
  "493_14631217_python": "\"class Solution:\\n    def reversePairs(self, nums):\\n        def merge_sort(start, end):\\n            if start >= end:\\n                return 0\\n            mid = (start + end) // 2\\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\\n\\n            j = mid + 1\\n            for i in range(start, mid + 1):\\n                while j <= end and nums[i] > 2 * nums[j]:\\n                    j += 1\\n                count += j - (mid + 1)\\n\\n            # Merge step\\n            temp = []\\n            left, right = start, mid + 1\\n            while left <= mid and right <= end:\\n                if nums[left] <= nums[right]:\\n                    temp.append(nums[left])\\n                    left += 1\\n                else:\\n                    temp.append(nums[right])\\n                    right += 1\\n            while left <= mid:\\n                temp.append(nums[left])\\n                left += 1\\n            while right <= end:\\n                temp.append(nums[right])\\n                right += 1\\n            for i in range(len(temp)):\\n                nums[start + i] = temp[i]\\n\\n            return count\\n\\n        return merge_sort(0, len(nums) - 1)\\n\"",
  "1387_14631217_python": "\"class FindElements:\\n\\n    def __init__(self, root):\\n        self.values = set()\\n\\n        def recover(node, val):\\n            if not node:\\n                return\\n            node.val = val\\n            self.values.add(val)\\n            recover(node.left, 2 * val + 1)\\n            recover(node.right, 2 * val + 2)\\n\\n        recover(root, 0)\\n\\n    def find(self, target):\\n        return target in self.values\\n\"",
  "1941_14631217_python-updated-time": "1746544247355",
  "873_14631217_python": "\"class Solution(object):\\n    def findSecretWord(self, words, master):\\n        def match(a, b):\\n            return sum(x == y for x, y in zip(a, b))\\n\\n        # Up to 30 guesses\\n        for _ in range(30):\\n            # Minimax selection\\n            best = None\\n            bestscore = float('inf')\\n            for w in words:\\n                cnt = [0] * 7\\n                for w2 in words:\\n                    if w2 != w:\\n                        cnt[match(w, w2)] += 1\\n                worst = max(cnt)\\n                if worst < bestscore:\\n                    bestscore = worst\\n                    best = w\\n\\n            x = master.guess(best)\\n            if x == 6:\\n                return\\n            words = [w2 for w2 in words if match(best, w2) == x]\\n\"",
  "1229_14631217_python-updated-time": "1746109184677",
  "1696_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \\\"\\\"\\\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        # find all colors\\n        colors = set()\\n        for row in targetGrid:\\n            for c in row:\\n                colors.add(c)\\n        \\n        # bounding box for each color: minr, maxr, minc, maxc\\n        INF = 10**9\\n        minr = {c: INF for c in colors}\\n        maxr = {c: -INF for c in colors}\\n        minc = {c: INF for c in colors}\\n        maxc = {c: -INF for c in colors}\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                if i < minr[c]: minr[c] = i\\n                if i > maxr[c]: maxr[c] = i\\n                if j < minc[c]: minc[c] = j\\n                if j > maxc[c]: maxc[c] = j\\n        \\n        # build graph: edge c -> d if c's rectangle covers a cell of color d!=c\\n        adj = defaultdict(set)\\n        indegree = {c: 0 for c in colors}\\n        \\n        for c in colors:\\n            for i in range(minr[c], maxr[c] + 1):\\n                for j in range(minc[c], maxc[c] + 1):\\n                    d = targetGrid[i][j]\\n                    if d != c and d not in adj[c]:\\n                        adj[c].add(d)\\n                        indegree[d] += 1\\n        \\n        # topological sort (Kahn's algorithm)\\n        q = deque([c for c in colors if indegree[c] == 0])\\n        processed = 0\\n        \\n        while q:\\n            u = q.popleft()\\n            processed += 1\\n            for v in adj[u]:\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    q.append(v)\\n        \\n        # if all colors processed, no cycle\\n        return processed == len(colors)\\n\"",
  "1289_14631217_python": "\"import datetime\\n\\nclass Solution(object):\\n    def dayOfTheWeek(self, day, month, year):\\n        \\\"\\\"\\\"\\n        :type day: int\\n        :type month: int\\n        :type year: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        days = [\\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\", \\\"Sunday\\\"]\\n        date = datetime.date(year, month, day)\\n        return days[date.weekday()]\\n\"",
  "2462_14631217_python-updated-time": "1746965339035",
  "3296_14631217_python-updated-time": "1747413617614",
  "3197_14631217_python-updated-time": "1747311593301",
  "3332_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        heapq.heapify(nums)\\n        ops = 0\\n        while nums[0] < k:\\n            x = heapq.heappop(nums)\\n            y = heapq.heappop(nums)\\n            new_val = 2 * x + y\\n            heapq.heappush(nums, new_val)\\n            ops += 1\\n        return ops\\n\"",
  "855_14631217_python": "\"class Solution(object):\\n    def uniqueLetterString(self, s):\\n        index = {}\\n        for i, c in enumerate(s):\\n            if c not in index:\\n                index[c] = []\\n            index[c].append(i)\\n        \\n        res = 0\\n        n = len(s)\\n        for idxs in index.values():\\n            for i, j in enumerate(idxs):\\n                prev = idxs[i-1] if i > 0 else -1\\n                nex = idxs[i+1] if i+1 < len(idxs) else n\\n                res += (j - prev) * (nex - j)\\n        return res\\n\"",
  "3360_14631217_python-updated-time": "1747421057102",
  "1002_14631217_python-updated-time": "1746038975368",
  "3153_14631217_python-updated-time": "1747307206089",
  "173_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        self.stack = []\\n        self._leftmost_inorder(root)\\n\\n    def _leftmost_inorder(self, root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self):\\n        node = self.stack.pop()\\n        if node.right:\\n            self._leftmost_inorder(node.right)\\n        return node.val\\n\\n    def hasNext(self):\\n        return len(self.stack) > 0\\n\"",
  "2449_14631217_python-updated-time": "1746965691254",
  "1724_14631217_mysql": "\"SELECT\\n  v.customer_id,\\n  COUNT(*) AS count_no_trans\\nFROM Visits v\\nLEFT JOIN Transactions t\\n  ON v.visit_id = t.visit_id\\nWHERE t.visit_id IS NULL\\nGROUP BY\\n  v.customer_id;\\n\"",
  "1879_14631217_python-updated-time": "1746531544069",
  "2171_14631217_python-updated-time": "1746720126893",
  "1891_14631217_python-updated-time": "1746532370801",
  "2681_14631217_python": "\"class Solution:\\n    def putMarbles(self, weights, k):\\n        n = len(weights)\\n        if k == 1:\\n            return 0\\n        \\n        # Compute boundary sums for possible cut positions\\n        boundary_sums = [weights[i-1] + weights[i] for i in range(1, n)]\\n        boundary_sums.sort()\\n        \\n        # Sum of smallest (k-1) and largest (k-1)\\n        small_sum = sum(boundary_sums[:k-1])\\n        large_sum = sum(boundary_sums[-(k-1):])\\n        \\n        return large_sum - small_sum\\n\"",
  "2744_14631217_javascript": "\"function memoize(fn) {\\n  // A unique symbol to store results at a leaf\\n  const RESULT = Symbol('result');\\n  // Nested Maps: each level maps an argument → next Map (or finally a stored result)\\n  const cache = new Map();\\n  let callCount = 0;\\n\\n  function memoized(...args) {\\n    let node = cache;\\n    // Traverse/extend the nested Map structure for each argument\\n    for (const arg of args) {\\n      if (!node.has(arg)) {\\n        node.set(arg, new Map());\\n      }\\n      node = node.get(arg);\\n    }\\n    // Now `node` is the leaf-map for this exact args tuple\\n    if (node.has(RESULT)) {\\n      // cache-hit\\n      return node.get(RESULT);\\n    }\\n    // cache-miss → call original, store result\\n    const value = fn(...args);\\n    callCount++;\\n    node.set(RESULT, value);\\n    return value;\\n  }\\n\\n  // Expose a method to read how many real calls were made\\n  memoized.getCallCount = () => callCount;\\n  return memoized;\\n}\\n\"",
  "16_14631217_python-updated-time": "1744980734260",
  "1111_14631217_python": "\"class Solution:\\n    def minScoreTriangulation(self, values):\\n        n = len(values)\\n        # dp[i][j] = min score to triangulate polygon from i to j\\n        dp = [[0]*n for _ in range(n)]\\n        \\n        # length = j - i + 1, start from length 3 (one triangle)\\n        for length in range(3, n+1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                dp[i][j] = float('inf')\\n                # pick k between i and j to form triangle (i,k,j)\\n                for k in range(i+1, j):\\n                    cost = dp[i][k] + dp[k][j] + values[i]*values[k]*values[j]\\n                    if cost < dp[i][j]:\\n                        dp[i][j] = cost\\n        \\n        return dp[0][n-1]\\n\"",
  "2084_14631217_python-updated-time": "1746638781163",
  "1554_14631217_python": "\"class Solution(object):\\n    def minTime(self, n, edges, hasApple):\\n        g = [[] for _ in range(n)]\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        def dfs(u, p):\\n            t = 0\\n            for v in g[u]:\\n                if v != p:\\n                    sub = dfs(v, u)\\n                    if sub > 0 or hasApple[v]:\\n                        t += sub + 2\\n            return t\\n        return dfs(0, -1)\\n\"",
  "1783_14631217_python": "\"class Solution:\\n    def waysToMakeFair(self, nums):\\n        n = len(nums)\\n        # prefix sums of even-/odd-indexed elements\\n        pe = [0] * (n + 1)\\n        po = [0] * (n + 1)\\n        for i, v in enumerate(nums):\\n            pe[i+1] = pe[i]\\n            po[i+1] = po[i]\\n            if i & 1:\\n                po[i+1] += v\\n            else:\\n                pe[i+1] += v\\n\\n        total_even = pe[n]\\n        total_odd  = po[n]\\n        ans = 0\\n\\n        for i, v in enumerate(nums):\\n            left_even = pe[i]\\n            left_odd  = po[i]\\n            right_even = total_even - pe[i+1]\\n            right_odd  = total_odd  - po[i+1]\\n\\n            new_even = left_even + right_odd\\n            new_odd  = left_odd  + right_even\\n\\n            if new_even == new_odd:\\n                ans += 1\\n\\n        return ans\\n\"",
  "1798_14631217_python-updated-time": "1746452743907",
  "750_14631217_python-updated-time": "1745875555599",
  "2916_14631217_python-updated-time": "1747225190129",
  "757_14631217_python-updated-time": "1745875853525",
  "643_14631217_python": "\"class Solution(object):\\n    def findMaxAverage(self, nums, k):\\n        curr_sum = sum(nums[:k])\\n        max_sum = curr_sum\\n        \\n        for i in range(k, len(nums)):\\n            curr_sum += nums[i] - nums[i - k]\\n            max_sum = max(max_sum, curr_sum)\\n        \\n        return max_sum * 1.0 / k\\n\"",
  "1808_14631217_python": "\"class Solution(object):\\n    def stoneGameVII(self, stones):\\n        \\\"\\\"\\\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(stones)\\n        # prefix sums: presum[i] = sum of stones[0..i-1]\\n        presum = [0] * (n + 1)\\n        for i in range(n):\\n            presum[i+1] = presum[i] + stones[i]\\n\\n        # helper to get sum of stones[i..j], inclusive\\n        def range_sum(i, j):\\n            return presum[j+1] - presum[i]\\n\\n        # dp[i][j]: max score difference current player can achieve on stones[i..j]\\n        dp = [[0] * n for _ in range(n)]\\n\\n        # length = 2 to n\\n        for length in range(2, n+1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                # if remove stones[i], gain = sum(i+1..j), then opponent plays (i+1,j)\\n                score_remove_i = range_sum(i+1, j) - dp[i+1][j]\\n                # if remove stones[j], gain = sum(i..j-1), then opponent plays (i,j-1)\\n                score_remove_j = range_sum(i, j-1) - dp[i][j-1]\\n                dp[i][j] = max(score_remove_i, score_remove_j)\\n\\n        return dp[0][n-1]\\n\"",
  "72_14631217_python-updated-time": "1745015065189",
  "2642_14631217_python-updated-time": "1747060836544",
  "2630_14631217_python-updated-time": "1747061702777",
  "61_14631217_python-updated-time": "1745014713896",
  "3188_14631217_python": "\"class Solution(object):\\n    def findChampion(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        # A team a is champion iff no other team b is stronger:\\n        # i.e. there is no b with grid[b][a] == 1.\\n        for a in range(n):\\n            for b in range(n):\\n                if grid[b][a] == 1:\\n                    break\\n            else:\\n                # no break => no b stronger than a\\n                return a\\n        # problem guarantees a unique champion, so we never reach here\\n        return -1\"",
  "2762_14631217_javascript-updated-time": "1747135210450",
  "535_14631217_python-updated-time": "1745446849425",
  "3768_14631217_python-updated-time": "1747681051163",
  "3837_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def minMoves(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # 1) Gather portal positions by letter\\n        portals = defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                ch = matrix[i][j]\\n                if 'A' <= ch <= 'Z':\\n                    portals[ch].append((i, j))\\n        \\n        # 2) Distances, -1 = unvisited\\n        dist = [[-1]*n for _ in range(m)]\\n        dist[0][0] = 0\\n        \\n        # 3) Track used portals\\n        used = {ch: False for ch in portals}\\n        \\n        # 4) 0-1 BFS\\n        dq = deque()\\n        dq.append((0,0))\\n        while dq:\\n            x,y = dq.popleft()\\n            d = dist[x][y]\\n            # If reached target\\n            if x==m-1 and y==n-1:\\n                return d\\n            \\n            # 4a) Teleport if letter and not yet used\\n            ch = matrix[x][y]\\n            if 'A' <= ch <= 'Z' and not used[ch]:\\n                for nx, ny in portals[ch]:\\n                    # teleport cost = 0\\n                    if dist[nx][ny] == -1 or dist[nx][ny] > d:\\n                        dist[nx][ny] = d\\n                        dq.appendleft((nx, ny))\\n                used[ch] = True  # only once\\n            \\n            # 4b) Regular moves\\n            for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):\\n                nx, ny = x+dx, y+dy\\n                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] != '#':\\n                    if dist[nx][ny] == -1 or dist[nx][ny] > d+1:\\n                        dist[nx][ny] = d+1\\n                        dq.append((nx, ny))\\n        \\n        # Unreachable\\n        return -1\\n\"",
  "3494_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, m, n, horizontalCut, verticalCut):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :type horizontalCut: List[int]\\n        :type verticalCut: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # sort descending\\n        horizontalCut.sort(reverse=True)\\n        verticalCut.sort(reverse=True)\\n        \\n        h_idx = 0\\n        v_idx = 0\\n        h_segments = 1\\n        v_segments = 1\\n        total = 0\\n        \\n        # Greedily do the largest remaining cut\\n        while h_idx < len(horizontalCut) and v_idx < len(verticalCut):\\n            if horizontalCut[h_idx] > verticalCut[v_idx]:\\n                total += horizontalCut[h_idx] * v_segments\\n                h_segments += 1\\n                h_idx += 1\\n            else:\\n                total += verticalCut[v_idx] * h_segments\\n                v_segments += 1\\n                v_idx += 1\\n        \\n        # Remaining horizontal cuts\\n        while h_idx < len(horizontalCut):\\n            total += horizontalCut[h_idx] * v_segments\\n            h_segments += 1\\n            h_idx += 1\\n        \\n        # Remaining vertical cuts\\n        while v_idx < len(verticalCut):\\n            total += verticalCut[v_idx] * h_segments\\n            v_segments += 1\\n            v_idx += 1\\n        \\n        return total\\n\"",
  "116_14631217_python": "\"# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=0, left=None, right=None, next=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Node\\n        :rtype: Node\\n        \\\"\\\"\\\"\\n        if not root:\\n            return None\\n\\n        leftmost = root\\n\\n        while leftmost.left:\\n            head = leftmost\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                head = head.next\\n            leftmost = leftmost.left\\n\\n        return root\\n\"",
  "1207_14631217_python": "\"class Solution(object):\\n    def delNodes(self, root, to_delete):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type to_delete: List[int]\\n        :rtype: List[TreeNode]\\n        \\\"\\\"\\\"\\n        to_delete_set = set(to_delete)\\n        result = []\\n\\n        def dfs(node, is_root):\\n            if not node:\\n                return None\\n            deleted = node.val in to_delete_set\\n            if is_root and not deleted:\\n                result.append(node)\\n            node.left = dfs(node.left, deleted)\\n            node.right = dfs(node.right, deleted)\\n            return None if deleted else node\\n\\n        dfs(root, True)\\n        return result\\n\"",
  "654_14631217_python": "\"class Solution(object):\\n    def constructMaximumBinaryTree(self, nums):\\n        if not nums:\\n            return None\\n        max_idx = nums.index(max(nums))\\n        root = TreeNode(nums[max_idx])\\n        root.left = self.constructMaximumBinaryTree(nums[:max_idx])\\n        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])\\n        return root\\n\"",
  "2538_14631217_python": "\"class Solution(object):\\n    def minCost(self, nums, cost):\\n        # Pair and sort by nums\\n        pairs = sorted(zip(nums, cost))\\n        total_cost = sum(cost for _, cost in pairs)\\n        # Find weighted median target value x\\n        cum = 0\\n        half = (total_cost + 1) // 2\\n        for val, c in pairs:\\n            cum += c\\n            if cum >= half:\\n                x = val\\n                break\\n        \\n        # Compute total cost at x\\n        ans = 0\\n        for v, c in pairs:\\n            ans += abs(v - x) * c\\n        return ans\\n\"",
  "714_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, prices, fee):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :type fee: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # cash: max profit if we do not hold a stock\\n        # hold: max profit if we hold a stock\\n        cash, hold = 0, -prices[0]\\n        \\n        for price in prices[1:]:\\n            # either keep cash, or sell the stock today and pay fee\\n            cash = max(cash, hold + price - fee)\\n            # either keep holding, or buy today with current cash\\n            hold = max(hold, cash - price)\\n        \\n        return cash\\n\"",
  "1552_14631217_python-updated-time": "1746347317606",
  "1858_14631217_python-updated-time": "1746530481044",
  "1273_14631217_python-updated-time": "1746126283371",
  "2041_14631217_mysql": "\"SELECT user_id, MAX(time_stamp) AS last_stamp\\nFROM Logins\\nWHERE YEAR(time_stamp) = 2020\\nGROUP BY user_id;\\n\"",
  "2066_14631217_python": "\"class Solution(object):\\n    def addRungs(self, rungs, dist):\\n        prev = 0\\n        added = 0\\n        for h in rungs:\\n            gap = h - prev\\n            if gap > dist:\\n                added += (gap + dist - 1) // dist - 1\\n            prev = h\\n        return added\\n\"",
  "1216_14631217_java": "\"import java.util.concurrent.Semaphore;\\n\\nclass ZeroEvenOdd {\\n    private int n;\\n    private Semaphore zeroSem = new Semaphore(1);\\n    private Semaphore oddSem = new Semaphore(0);\\n    private Semaphore evenSem = new Semaphore(0);\\n\\n    public ZeroEvenOdd(int n) {\\n        this.n = n;\\n    }\\n\\n    public void zero(IntConsumer printNumber) throws InterruptedException {\\n        for (int i = 1; i <= n; i++) {\\n            zeroSem.acquire();\\n            printNumber.accept(0);\\n            if (i % 2 == 1) {\\n                oddSem.release();\\n            } else {\\n                evenSem.release();\\n            }\\n        }\\n    }\\n\\n    public void even(IntConsumer printNumber) throws InterruptedException {\\n        for (int i = 2; i <= n; i += 2) {\\n            evenSem.acquire();\\n            printNumber.accept(i);\\n            zeroSem.release();\\n        }\\n    }\\n\\n    public void odd(IntConsumer printNumber) throws InterruptedException {\\n        for (int i = 1; i <= n; i += 2) {\\n            oddSem.acquire();\\n            printNumber.accept(i);\\n            zeroSem.release();\\n        }\\n    }\\n}\\n\"",
  "1112_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def countCharacters(self, words, chars):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type chars: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        chars_count = Counter(chars)\\n        total = 0\\n        \\n        for word in words:\\n            word_count = Counter(word)\\n            if all(word_count[c] <= chars_count[c] for c in word_count):\\n                total += len(word)\\n        \\n        return total\\n\"",
  "3348_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        # comp_and[x] is valid only when x is a root\\n        self.comp_and = [~0] * n  # all‐ones initial mask\\n\\n    def find(self, x):\\n        while self.p[x] != x:\\n            self.p[x] = self.p[self.p[x]]\\n            x = self.p[x]\\n        return x\\n\\n    def union(self, a, b, w):\\n        ra, rb = self.find(a), self.find(b)\\n        if ra == rb:\\n            # even if already unioned, we still AND this edge into the component\\n            self.comp_and[ra] &= w\\n        else:\\n            # merge rb into ra\\n            self.p[rb] = ra\\n            # the combined component's AND is the AND of both plus this edge\\n            self.comp_and[ra] = self.comp_and[ra] & self.comp_and[rb] & w\\n\\nclass Solution(object):\\n    def minimumCost(self, n, edges, query):\\n        dsu = DSU(n)\\n        for u, v, w in edges:\\n            dsu.union(u, v, w)\\n\\n        ans = []\\n        for s, t in query:\\n            rs, rt = dsu.find(s), dsu.find(t)\\n            if rs != rt:\\n                ans.append(-1)\\n            else:\\n                ans.append(dsu.comp_and[rs])\\n        return ans\\n\"",
  "1709_14631217_python-updated-time": "1746443890600",
  "938_14631217_python-updated-time": "1746002499711",
  "2020_14631217_python": "\"class Solution:\\n    def canBeIncreasing(self, nums):\\n        def is_strictly_increasing(arr):\\n            for i in range(1, len(arr)):\\n                if arr[i - 1] >= arr[i]:\\n                    return False\\n            return True\\n\\n        for i in range(len(nums)):\\n            if is_strictly_increasing(nums[:i] + nums[i+1:]):\\n                return True\\n        return False\\n\"",
  "3212_14631217_python-updated-time": "1747317937873",
  "1556_14631217_python": "\"class Solution(object):\\n    def canBeEqual(self, target, arr):\\n        return sorted(target) == sorted(arr)\\n\"",
  "2486_14631217_python": "\"class Solution:\\n    def mostFrequentEven(self, nums):\\n        freq = {}\\n        for x in nums:\\n            if x % 2 == 0:\\n                freq[x] = freq.get(x, 0) + 1\\n        if not freq:\\n            return -1\\n        # pick the even number with highest frequency; ties → smaller number\\n        return max(freq.keys(), key=lambda x: (freq[x], -x))\\n\"",
  "671_14631217_python": "\"class Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        if not root or (not root.left and not root.right):\\n            return -1\\n        \\n        left = root.left.val\\n        right = root.right.val\\n        \\n        if left == root.val:\\n            left = self.findSecondMinimumValue(root.left)\\n        if right == root.val:\\n            right = self.findSecondMinimumValue(root.right)\\n        \\n        if left != -1 and right != -1:\\n            return min(left, right)\\n        if left != -1:\\n            return left\\n        return right\\n\"",
  "72_14631217_python": "\"class Solution(object):\\n    def minDistance(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            dp[i][0] = i\\n        for j in range(n + 1):\\n            dp[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                        dp[i-1][j],    # delete\\n                        dp[i][j-1],    # insert\\n                        dp[i-1][j-1]   # replace\\n                    )\\n\\n        return dp[m][n]\\n\"",
  "1778_14631217_python-updated-time": "1746445577733",
  "2914_14631217_python-updated-time": "1747225228441",
  "691_14631217_python-updated-time": "1745785597267",
  "3183_14631217_python-updated-time": "1747309361522",
  "1337_14631217_python": "\"import random\\n\\nclass Node(object):\\n    def __init__(self, val, level):\\n        self.val = val\\n        self.forward = [None] * level\\n\\nclass Skiplist(object):\\n    def __init__(self):\\n        self.MAX_LEVEL = 16\\n        self.P = 0.5\\n        self.head = Node(-1, self.MAX_LEVEL)\\n\\n    def randomLevel(self):\\n        level = 1\\n        while random.random() < self.P and level < self.MAX_LEVEL:\\n            level += 1\\n        return level\\n\\n    def search(self, target):\\n        curr = self.head\\n        for i in reversed(range(self.MAX_LEVEL)):\\n            while curr.forward[i] and curr.forward[i].val < target:\\n                curr = curr.forward[i]\\n        curr = curr.forward[0]\\n        return curr is not None and curr.val == target\\n\\n    def add(self, num):\\n        update = [None] * self.MAX_LEVEL\\n        curr = self.head\\n        for i in reversed(range(self.MAX_LEVEL)):\\n            while curr.forward[i] and curr.forward[i].val < num:\\n                curr = curr.forward[i]\\n            update[i] = curr\\n\\n        level = self.randomLevel()\\n        newNode = Node(num, level)\\n        for i in range(level):\\n            newNode.forward[i] = update[i].forward[i]\\n            update[i].forward[i] = newNode\\n\\n    def erase(self, num):\\n        update = [None] * self.MAX_LEVEL\\n        curr = self.head\\n        found = False\\n        for i in reversed(range(self.MAX_LEVEL)):\\n            while curr.forward[i] and curr.forward[i].val < num:\\n                curr = curr.forward[i]\\n            update[i] = curr\\n\\n        curr = curr.forward[0]\\n        if curr and curr.val == num:\\n            found = True\\n            for i in range(self.MAX_LEVEL):\\n                if update[i].forward[i] != curr:\\n                    continue\\n                update[i].forward[i] = curr.forward[i]\\n        return found\\n\"",
  "2746_14631217_javascript-updated-time": "1747135665777",
  "2008_14631217_python-updated-time": "1746627027389",
  "238_14631217_python-updated-time": "1745247499485",
  "2539_14631217_python-updated-time": "1746968283608",
  "508_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def findFrequentTreeSum(self, root):\\n        count = defaultdict(int)\\n        max_freq = [0]\\n\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            total = node.val + dfs(node.left) + dfs(node.right)\\n            count[total] += 1\\n            max_freq[0] = max(max_freq[0], count[total])\\n            return total\\n\\n        dfs(root)\\n        return [s for s in count if count[s] == max_freq[0]]\\n\"",
  "128_14631217_python": "\"class Solution(object):\\n    def longestConsecutive(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return 0\\n        \\n        # Create a set from nums for O(1) lookups\\n        num_set = set(nums)\\n        max_length = 0\\n        \\n        # Check each number as a potential start of a sequence\\n        for num in num_set:\\n            # Only check sequences from their starting points\\n            # If num-1 exists, then num is not the start of a sequence\\n            if num - 1 not in num_set:\\n                current_num = num\\n                current_length = 1\\n                \\n                # Count consecutive numbers\\n                while current_num + 1 in num_set:\\n                    current_num += 1\\n                    current_length += 1\\n                \\n                # Update max length if current sequence is longer\\n                max_length = max(max_length, current_length)\\n        \\n        return max_length\"",
  "2345_14631217_python": "\"class Solution(object):\\n    def convertTime(self, current, correct):\\n        ch, cm = map(int, current.split(':'))\\n        uh, um = map(int, correct.split(':'))\\n        diff = (uh * 60 + um) - (ch * 60 + cm)\\n        ops = 0\\n        for step in (60, 15, 5, 1):\\n            ops += diff // step\\n            diff %= step\\n        return ops\\n\"",
  "565_14631217_python": "\"class Solution(object):\\n    def arrayNesting(self, nums):\\n        visited = [False] * len(nums)\\n        max_len = 0\\n        for i in range(len(nums)):\\n            if not visited[i]:\\n                count = 0\\n                x = i\\n                while not visited[x]:\\n                    visited[x] = True\\n                    x = nums[x]\\n                    count += 1\\n                if count > max_len:\\n                    max_len = count\\n        return max_len\\n\"",
  "1137_14631217_python-updated-time": "1746107560836",
  "1693_14631217_python-updated-time": "1746438716169",
  "1815_14631217_python-updated-time": "1746453297731",
  "1232_14631217_python": "\"class Solution:\\n    def findBestValue(self, arr, target):\\n        arr.sort()\\n        left, right = 0, max(arr)\\n        result = right\\n        min_diff = float('inf')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            curr_sum = sum(min(num, mid) for num in arr)\\n            diff = abs(curr_sum - target)\\n            \\n            if diff < min_diff or (diff == min_diff and mid < result):\\n                min_diff = diff\\n                result = mid\\n\\n            if curr_sum < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\"",
  "454_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def fourSumCount(self, nums1, nums2, nums3, nums4):\\n        count = Counter()\\n        for a in nums1:\\n            for b in nums2:\\n                count[a + b] += 1\\n        \\n        res = 0\\n        for c in nums3:\\n            for d in nums4:\\n                res += count[-(c + d)]\\n        \\n        return res\\n\"",
  "1983_14631217_python": "\"class Solution(object):\\n    def maximumPopulation(self, logs):\\n        arr = [0] * 101\\n        for b, d in logs:\\n            arr[b - 1950] += 1\\n            arr[d - 1950] -= 1\\n        curr = 0\\n        max_pop = 0\\n        year = 1950\\n        for i in range(101):\\n            curr += arr[i]\\n            if curr > max_pop:\\n                max_pop = curr\\n                year = 1950 + i\\n        return year\\n\"",
  "3262_14631217_python-updated-time": "1747318442133",
  "2519_14631217_python-updated-time": "1746967315760",
  "523_14631217_python": "\"class Solution:\\n    def checkSubarraySum(self, nums, k):\\n        rem_map = {0: -1}\\n        total = 0\\n        \\n        for i, num in enumerate(nums):\\n            total += num\\n            rem = total % k\\n            if rem in rem_map:\\n                if i - rem_map[rem] >= 2:\\n                    return True\\n            else:\\n                rem_map[rem] = i\\n        \\n        return False\\n\"",
  "notification-status:lastModified-updated-time": "1747320168888",
  "1953_14631217_python-updated-time": "1746544120400",
  "2821_14631217_javascript": "\"function cancellable(fn, args, t) {\\n  const timeoutId = setTimeout(() => {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = () => {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n}\\n\"",
  "503_14631217_python-updated-time": "1745446158299",
  "2279_14631217_python": "\"class Solution:\\n    def maximumEvenSplit(self, finalSum):\\n        if finalSum % 2 != 0:\\n            return []\\n        \\n        res = []\\n        curr = 2\\n        while finalSum >= curr:\\n            res.append(curr)\\n            finalSum -= curr\\n            curr += 2\\n        \\n        res[-1] += finalSum\\n        return res\\n\"",
  "1525_14631217_python-updated-time": "1746346624000",
  "3239_14631217_python-updated-time": "1747319811898",
  "3592_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def findXSum(self, nums, k, x):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type x: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        cnt = defaultdict(int)\\n        top = []       # min-heap of (freq, num)\\n        rest = []      # max-heap of (-freq, -num)\\n        in_top = set()\\n        sum_top = [0]  # we’ll do sum_top[0] += … / -= … inside closures\\n\\n        def clean_top():\\n            while top:\\n                f, num = top[0]\\n                if cnt.get(num, 0) != f or num not in in_top:\\n                    heapq.heappop(top)\\n                else:\\n                    break\\n\\n        def clean_rest():\\n            while rest:\\n                nf, nnum = rest[0]\\n                f, num = -nf, -nnum\\n                if cnt.get(num, 0) != f or num in in_top:\\n                    heapq.heappop(rest)\\n                else:\\n                    break\\n\\n        def promote():\\n            clean_rest()\\n            if not rest: return\\n            nf, nnum = heapq.heappop(rest)\\n            f, num = -nf, -nnum\\n            in_top.add(num)\\n            heapq.heappush(top, (f, num))\\n            sum_top[0] += f * num\\n\\n        def demote():\\n            clean_top()\\n            f, num = heapq.heappop(top)\\n            in_top.remove(num)\\n            sum_top[0] -= f * num\\n            heapq.heappush(rest, (-f, -num))\\n\\n        def rebalance():\\n            distinct = len(cnt)\\n            target = min(x, distinct)\\n            # shrink top if too large\\n            while len(in_top) > target:\\n                demote()\\n            # grow top if too small\\n            while len(in_top) < target:\\n                promote()\\n            # ensure every item in top ≥ every item in rest\\n            while top and rest:\\n                clean_top(); clean_rest()\\n                if not top or not rest:\\n                    break\\n                f_t, num_t = top[0]\\n                f_r, num_r = -rest[0][0], -rest[0][1]\\n                if (f_t < f_r) or (f_t == f_r and num_t < num_r):\\n                    # swap them\\n                    heapq.heappop(top)\\n                    in_top.remove(num_t)\\n                    sum_top[0] -= f_t * num_t\\n                    heapq.heappop(rest)\\n                    in_top.add(num_r)\\n                    sum_top[0] += f_r * num_r\\n                    heapq.heappush(top, (f_r, num_r))\\n                    heapq.heappush(rest, (-f_t, -num_t))\\n                else:\\n                    break\\n\\n        # Initialize counts for the first window\\n        for i in range(k):\\n            cnt[nums[i]] += 1\\n        # Put everything into rest, then rebalance to fill top\\n        for num, f in cnt.items():\\n            heapq.heappush(rest, (-f, -num))\\n        rebalance()\\n\\n        ans = [sum_top[0]]\\n\\n        # Slide window\\n        for i in range(k, n):\\n            old = nums[i - k]\\n            # remove old\\n            cnt[old] -= 1\\n            if old in in_top:\\n                sum_top[0] -= old\\n            if cnt[old] == 0:\\n                del cnt[old]\\n                in_top.discard(old)\\n            else:\\n                if old in in_top:\\n                    heapq.heappush(top, (cnt[old], old))\\n                else:\\n                    heapq.heappush(rest, (-cnt[old], -old))\\n\\n            # add new\\n            new = nums[i]\\n            cnt[new] += 1\\n            if new in in_top:\\n                sum_top[0] += new\\n                heapq.heappush(top, (cnt[new], new))\\n            else:\\n                heapq.heappush(rest, (-cnt[new], -new))\\n\\n            rebalance()\\n            ans.append(sum_top[0])\\n\\n        return ans\\n\"",
  "2088_14631217_python": "\"class Solution(object):\\n    def minTimeToType(self, word):\\n        pos = ord('a')\\n        time = 0\\n        for ch in word:\\n            target = ord(ch)\\n            diff = abs(pos - target)\\n            time += min(diff, 26 - diff) + 1\\n            pos = target\\n        return time\\n\"",
  "747_14631217_python": "\"class Solution(object):\\n    def minCostClimbingStairs(self, cost):\\n        n = len(cost)\\n        dp = [0] * (n + 1)\\n        for i in range(2, n + 1):\\n            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])\\n        return dp[n]\\n\"",
  "3430_14631217_python": "\"class Solution(object):\\n    def countDays(self, days, meetings):\\n        \\\"\\\"\\\"\\n        :type days: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not meetings:\\n            return days\\n\\n        # Sort meetings by start time\\n        meetings.sort()\\n        \\n        merged = []\\n        for start, end in meetings:\\n            if not merged or merged[-1][1] < start - 1:\\n                merged.append([start, end])\\n            else:\\n                merged[-1][1] = max(merged[-1][1], end)\\n        \\n        # Total days covered by meetings\\n        meeting_days = sum(end - start + 1 for start, end in merged)\\n        \\n        return days - meeting_days\\n\"",
  "860_14631217_python": "\"class MyCircularQueue(object):\\n    def __init__(self, k):\\n        self.queue = [0] * k\\n        self.head = 0\\n        self.count = 0\\n        self.size = k\\n\\n    def enQueue(self, value):\\n        if self.isFull():\\n            return False\\n        tail = (self.head + self.count) % self.size\\n        self.queue[tail] = value\\n        self.count += 1\\n        return True\\n\\n    def deQueue(self):\\n        if self.isEmpty():\\n            return False\\n        self.head = (self.head + 1) % self.size\\n        self.count -= 1\\n        return True\\n\\n    def Front(self):\\n        if self.isEmpty():\\n            return -1\\n        return self.queue[self.head]\\n\\n    def Rear(self):\\n        if self.isEmpty():\\n            return -1\\n        tail = (self.head + self.count - 1) % self.size\\n        return self.queue[tail]\\n\\n    def isEmpty(self):\\n        return self.count == 0\\n\\n    def isFull(self):\\n        return self.count == self.size\\n\"",
  "140_14631217_python-updated-time": "1745086946199",
  "413_14631217_python": "\"class Solution:\\n    def numberOfArithmeticSlices(self, nums):\\n        if len(nums) < 3:\\n            return 0\\n        \\n        count = 0\\n        current = 0\\n        \\n        for i in range(2, len(nums)):\\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\\n                current += 1\\n                count += current\\n            else:\\n                current = 0\\n        \\n        return count\\n\"",
  "3797_14631217_python-updated-time": "1747682642654",
  "2021_14631217_python": "\"class Solution:\\n    def removeOccurrences(self, s, part):\\n        while part in s:\\n            s = s.replace(part, \\\"\\\", 1)\\n        return s\\n\"",
  "809_14631217_python-updated-time": "1745877852665",
  "770_14631217_python-updated-time": "1745876112002",
  "1839_14631217_python-updated-time": "1746454373796",
  "486_14631217_python": "\"class Solution(object):\\n    def predictTheWinner(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def dp(i, j):\\n            if i == j:\\n                return nums[i]\\n            pick_start = nums[i] - dp(i + 1, j)\\n            pick_end = nums[j] - dp(i, j - 1)\\n            return max(pick_start, pick_end)\\n\\n        return dp(0, len(nums) - 1) >= 0\\n\"",
  "973_14631217_python": "\"class Solution:\\n    def movesToStamp(self, stamp, target):\\n        stamp_len, target_len = len(stamp), len(target)\\n        s = list(target)\\n        res = []\\n        visited = [False] * (target_len - stamp_len + 1)\\n        total_replaced = [0]  # use list to make it mutable in nested function\\n\\n        def can_stamp(pos):\\n            changed = False\\n            for i in range(stamp_len):\\n                if s[pos + i] == '?':\\n                    continue\\n                if s[pos + i] != stamp[i]:\\n                    return False\\n                changed = True\\n            return changed\\n\\n        def do_stamp(pos):\\n            for i in range(stamp_len):\\n                if s[pos + i] != '?':\\n                    s[pos + i] = '?'\\n                    total_replaced[0] += 1\\n\\n        while total_replaced[0] < target_len:\\n            stamped_this_round = False\\n            for i in range(target_len - stamp_len + 1):\\n                if not visited[i] and can_stamp(i):\\n                    do_stamp(i)\\n                    visited[i] = True\\n                    res.append(i)\\n                    stamped_this_round = True\\n            if not stamped_this_round:\\n                return []\\n\\n        return res[::-1]\\n\"",
  "131_14631217_python": "\"class Solution(object):\\n    def partition(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: List[List[str]]\\n        \\\"\\\"\\\"\\n        result = []\\n        \\n        def is_palindrome(start, end):\\n            while start < end:\\n                if s[start] != s[end]:\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n        \\n        def backtrack(start, path):\\n            # If we've reached the end of the string, we've found a valid partition\\n            if start == len(s):\\n                result.append(path[:])\\n                return\\n            \\n            # Try all possible substrings starting from 'start'\\n            for end in range(start, len(s)):\\n                # If substring s[start:end+1] is a palindrome, add it to our path\\n                if is_palindrome(start, end):\\n                    path.append(s[start:end+1])\\n                    # Recursively find all palindrome partitions for the rest of the string\\n                    backtrack(end + 1, path)\\n                    # Backtrack to try other possibilities\\n                    path.pop()\\n        \\n        backtrack(0, [])\\n        return result\"",
  "1004_14631217_python-updated-time": "1746039618628",
  "214_14631217_python": "\"class Solution(object):\\n    def shortestPalindrome(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        rev_s = s[::-1]\\n        l = s + \\\"#\\\" + rev_s\\n        table = [0] * len(l)\\n\\n        for i in range(1, len(l)):\\n            j = table[i - 1]\\n            while j > 0 and l[i] != l[j]:\\n                j = table[j - 1]\\n            if l[i] == l[j]:\\n                j += 1\\n            table[i] = j\\n\\n        return rev_s[:len(s) - table[-1]] + s\\n\"",
  "3391_14631217_python-updated-time": "1747481877730",
  "3606_14631217_python": "\"class Solution(object):\\n    def minElement(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def digit_sum(n):\\n            return sum(int(d) for d in str(n))\\n        \\n        return min(digit_sum(num) for num in nums)\\n\"",
  "2377_14631217_python": "\"class Solution:\\n    def digitCount(self, num):\\n        freq = {}\\n        for ch in num:\\n            freq[ch] = freq.get(ch, 0) + 1\\n        \\n        for i, ch in enumerate(num):\\n            if freq.get(str(i), 0) != int(ch):\\n                return False\\n        return True\\n\"",
  "17_14631217_python-updated-time": "1744980770142",
  "2108_14631217_python": "\"class Solution:\\n    def minimizeTheDifference(self, mat, target):\\n        # Compute the maximum possible sum to size our bitmask\\n        max_sum = sum(max(row) for row in mat)\\n        # dp is a bitmask where bit s is 1 if sum s is reachable\\n        dp = 1  # only sum=0 is reachable initially\\n        \\n        for row in mat:\\n            next_dp = 0\\n            seen = set()\\n            for v in row:\\n                if v in seen:  # skip duplicates in the same row\\n                    continue\\n                seen.add(v)\\n                # shift all current sums by v, and OR into next_dp\\n                next_dp |= dp << v\\n            dp = next_dp\\n        \\n        # Search outward from target for the smallest difference\\n        limit = max(target, max_sum)\\n        for d in range(limit + 1):\\n            lo = target - d\\n            if lo >= 0 and ((dp >> lo) & 1):\\n                return d\\n            hi = target + d\\n            if hi <= max_sum and ((dp >> hi) & 1):\\n                return d\\n        # Should never get here because some sum must be reachable\\n        return None\\n\"",
  "1704_14631217_python": "\"class Solution(object):\\n    def numSpecial(self, mat):\\n        \\\"\\\"\\\"\\n        :type mat: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m = len(mat)\\n        n = len(mat[0]) if m else 0\\n        \\n        # count 1s in each row and column\\n        row_counts = [sum(row) for row in mat]\\n        col_counts = [sum(mat[i][j] for i in range(m)) for j in range(n)]\\n        \\n        # a position is special if it's 1 and its row and column sums are both 1\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] == 1 and row_counts[i] == 1 and col_counts[j] == 1:\\n                    ans += 1\\n        return ans\\n\"",
  "3018_14631217_python-updated-time": "1747225578356",
  "489_14631217_python": "\"class Solution:\\n    def kthSmallestPath(self, destination, k):\\n        row, col = destination\\n        # Precompute nCk up to n = row+col (max 30)\\n        n = row + col\\n        C = [[0]*(n+1) for _ in range(n+1)]\\n        for i in range(n+1):\\n            C[i][0] = 1\\n            for j in range(1, i+1):\\n                C[i][j] = C[i-1][j-1] + C[i-1][j]\\n        \\n        path = []\\n        # Build the path character by character\\n        for _ in range(n):\\n            if col == 0:\\n                # No H left, must put V\\n                path.append('V')\\n                row -= 1\\n            elif row == 0:\\n                # No V left, must put H\\n                path.append('H')\\n                col -= 1\\n            else:\\n                # Count of strings if we put 'H' next:\\n                # we then need to arrange (col-1) H's and row V's over (row+col-1) positions\\n                cnt = C[row+col-1][row]\\n                if k <= cnt:\\n                    path.append('H')\\n                    col -= 1\\n                else:\\n                    path.append('V')\\n                    k -= cnt\\n                    row -= 1\\n        \\n        return ''.join(path)\\n\"",
  "978_14631217_python-updated-time": "1746004569665",
  "2089_14631217_python": "\"class Solution(object):\\n    def maxMatrixSum(self, matrix):\\n        total = 0\\n        min_abs = float('inf')\\n        neg_count = 0\\n        \\n        for row in matrix:\\n            for val in row:\\n                total += abs(val)\\n                min_abs = min(min_abs, abs(val))\\n                if val < 0:\\n                    neg_count += 1\\n                    \\n        if neg_count % 2 == 0:\\n            return total\\n        else:\\n            return total - 2 * min_abs\\n\"",
  "3213_14631217_python": "\"from bisect import bisect_left\\n\\nclass Solution(object):\\n    def countSubarrays(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        M = max(nums)\\n        # Positions where the global maximum M occurs\\n        P = [i for i, v in enumerate(nums) if v == M]\\n        t = len(P)\\n        if t < k:\\n            return 0\\n        \\n        ans = 0\\n        # For each starting index L, find the earliest occurrence of M at or after L\\n        # that will serve as the k-th occurrence in the subarray.\\n        for L in range(n):\\n            j = bisect_left(P, L)\\n            # If there are at least k occurrences from j onward:\\n            if j + k - 1 < t:\\n                # the subarray must end at R >= P[j+k-1]\\n                # so we get (n - P[j+k-1]) choices for R\\n                ans += n - P[j + k - 1]\\n        return ans\\n\"",
  "380_14631217_python": "\"import random\\n\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.val_to_index = {}\\n        self.nums = []\\n\\n    def insert(self, val):\\n        if val in self.val_to_index:\\n            return False\\n        self.val_to_index[val] = len(self.nums)\\n        self.nums.append(val)\\n        return True\\n\\n    def remove(self, val):\\n        if val not in self.val_to_index:\\n            return False\\n        idx = self.val_to_index[val]\\n        last_val = self.nums[-1]\\n        self.nums[idx] = last_val\\n        self.val_to_index[last_val] = idx\\n        self.nums.pop()\\n        del self.val_to_index[val]\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.nums)\\n\"",
  "2839_14631217_python-updated-time": "1747221194665",
  "720_14631217_python": "\"class Solution(object):\\n    def longestWord(self, words):\\n        # Put all words into a set for O(1) lookups\\n        word_set = set(words)\\n        # Sort by descending length, then lexicographically ascending\\n        words.sort(key=lambda w: (-len(w), w))\\n        \\n        for w in words:\\n            # Check if every prefix of w exists\\n            valid = True\\n            for i in range(1, len(w)):\\n                if w[:i] not in word_set:\\n                    valid = False\\n                    break\\n            if valid:\\n                return w\\n        \\n        return \\\"\\\"\\n\"",
  "891_14631217_python-updated-time": "1745953994940",
  "984_14631217_python-updated-time": "1746004764122",
  "1355_14631217_python": "\"class Solution(object):\\n    def minDeletion(self, nums):\\n        n = len(nums)\\n        deletions = 0\\n        B_len = 0\\n        prev = None\\n        for x in nums:\\n            if B_len % 2 == 0:\\n                prev = x\\n                B_len += 1\\n            else:\\n                if x != prev:\\n                    prev = x\\n                    B_len += 1\\n                else:\\n                    deletions += 1\\n        if B_len % 2 == 1:\\n            deletions += 1\\n        return deletions\\n\"",
  "1967_14631217_python-updated-time": "1746544457311",
  "2321_14631217_python-updated-time": "1746810390696",
  "1575_14631217_python": "\"class Solution(object):\\n    def maxArea(self, h, w, horizontalCuts, verticalCuts):\\n        MOD = 10**9 + 7\\n        \\n        # Sort the cut positions\\n        horizontalCuts.sort()\\n        verticalCuts.sort()\\n        \\n        # Find maximum height between horizontal cuts (including edges)\\n        max_h = horizontalCuts[0]\\n        for i in range(1, len(horizontalCuts)):\\n            max_h = max(max_h, horizontalCuts[i] - horizontalCuts[i-1])\\n        max_h = max(max_h, h - horizontalCuts[-1])\\n        \\n        # Find maximum width between vertical cuts (including edges)\\n        max_w = verticalCuts[0]\\n        for j in range(1, len(verticalCuts)):\\n            max_w = max(max_w, verticalCuts[j] - verticalCuts[j-1])\\n        max_w = max(max_w, w - verticalCuts[-1])\\n        \\n        # The largest piece area modulo 10^9+7\\n        return (max_h * max_w) % MOD\\n\"",
  "2722_14631217_python-updated-time": "1747134769242",
  "1168_14631217_python": "\"class Solution(object):\\n    def duplicateZeros(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: None (modifies arr in-place)\\n        \\\"\\\"\\\"\\n        n = len(arr)\\n        zeros = arr.count(0)\\n        i = n - 1\\n        j = n + zeros - 1  # virtual extended array index\\n\\n        while i < j:\\n            if j < n:\\n                arr[j] = arr[i]\\n            if arr[i] == 0:\\n                j -= 1\\n                if j < n:\\n                    arr[j] = 0\\n            i -= 1\\n            j -= 1\\n\"",
  "2428_14631217_python": "\"class Solution:\\n    def equalPairs(self, grid):\\n        from collections import Counter\\n        \\n        n = len(grid)\\n        # Count each row as a tuple\\n        row_counts = Counter(tuple(row) for row in grid)\\n        \\n        ans = 0\\n        # For each column, form its tuple and add how many matching rows there are\\n        for j in range(n):\\n            col = tuple(grid[i][j] for i in range(n))\\n            ans += row_counts[col]\\n        \\n        return ans\\n\"",
  "3720_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def minMaxWeight(self, n, edges, threshold):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type threshold: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Collect unique weights\\n        weights = sorted({w for _, _, w in edges})\\n        # Build reversed adjacency lists grouped by weight threshold\\n        # For binary search, filter edges with w <= mid\\n        def can(W):\\n            # Build reversed graph with edges weight <= W\\n            adj = [[] for _ in range(n)]\\n            for u, v, w in edges:\\n                if w <= W:\\n                    # reversed edge v -> u\\n                    adj[v].append(u)\\n            # BFS from 0 over reversed graph\\n            seen = [False]*n\\n            dq = collections.deque([0])\\n            seen[0] = True\\n            cnt = 1\\n            while dq:\\n                x = dq.popleft()\\n                for y in adj[x]:\\n                    if not seen[y]:\\n                        seen[y] = True\\n                        cnt += 1\\n                        dq.append(y)\\n            return cnt == n\\n        # Binary search weights\\n        lo, hi = 0, len(weights)-1\\n        ans = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if can(weights[mid]):\\n                ans = weights[mid]\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        return ans if ans is not None else -1\"",
  "2675_14631217_python-updated-time": "1747135813074",
  "2597_14631217_python": "\"class Solution:\\n    def cycleLengthQueries(self, n, queries):\\n        res = []\\n        for u, v in queries:\\n            du = u.bit_length() - 1\\n            dv = v.bit_length() - 1\\n            cnt_u = cnt_v = 0\\n\\n            # bring u and v to same depth\\n            while du > dv:\\n                u //= 2\\n                du -= 1\\n                cnt_u += 1\\n            while dv > du:\\n                v //= 2\\n                dv -= 1\\n                cnt_v += 1\\n\\n            # climb until they meet at LCA\\n            while u != v:\\n                u //= 2\\n                v //= 2\\n                cnt_u += 1\\n                cnt_v += 1\\n\\n            # cycle length = path_u + path_v + the added edge\\n            res.append(cnt_u + cnt_v + 1)\\n        return res\\n\"",
  "3350_14631217_python-updated-time": "1747420393711",
  "1457_14631217_python-updated-time": "1746261680000",
  "3347_14631217_python-updated-time": "1747420204077",
  "2220_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def findAllRecipes(self, recipes, ingredients, supplies):\\n        graph = defaultdict(list)\\n        indegree = {}\\n        can_make = set(supplies)\\n\\n        for rcp, ing in zip(recipes, ingredients):\\n            indegree[rcp] = len(ing)\\n            for ing_item in ing:\\n                graph[ing_item].append(rcp)\\n\\n        queue = deque(supplies)\\n        result = []\\n\\n        while queue:\\n            item = queue.popleft()\\n            for recipe in graph[item]:\\n                indegree[recipe] -= 1\\n                if indegree[recipe] == 0:\\n                    queue.append(recipe)\\n                    result.append(recipe)\\n\\n        return result\\n\"",
  "3654_14631217_python": "\"class Solution(object):\\n    def minArraySum(self, nums, k, op1, op2):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type op1: int\\n        :type op2: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Precompute gains at each index\\n        items = []\\n        for v in nums:\\n            # gain of op1 alone\\n            s1 = v - ((v + 1) // 2)        # = floor(v/2)\\n            # gain of op2 alone, only if v>=k\\n            s2 = k if v >= k else None\\n\\n            # gain of doing both: try both orders\\n            best_both = None\\n\\n            # op1 then op2\\n            v1 = (v + 1)//2\\n            if v1 >= k:\\n                gA = v - (v1 - k)\\n                best_both = gA\\n\\n            # op2 then op1\\n            if v >= k:\\n                v2 = v - k\\n                gB = v - ((v2+1)//2)\\n                best_both = max(best_both, gB) if best_both is not None else gB\\n\\n            items.append((s1, s2, best_both))\\n\\n        # dp[c1][c2] = max gain using <=c1 of op1 and <=c2 of op2\\n        NEG = -10**18\\n        dp = [[NEG]*(op2+1) for _ in range(op1+1)]\\n        dp[0][0] = 0\\n\\n        for (s1, s2, sb) in items:\\n            new_dp = [row[:] for row in dp]\\n            for c1 in range(op1+1):\\n                for c2 in range(op2+1):\\n                    base = dp[c1][c2]\\n                    if base < 0:\\n                        continue\\n                    # op1 only\\n                    if s1 > 0 and c1+1 <= op1:\\n                        new_dp[c1+1][c2] = max(new_dp[c1+1][c2], base + s1)\\n                    # op2 only\\n                    if s2 is not None and s2 > 0 and c2+1 <= op2:\\n                        new_dp[c1][c2+1] = max(new_dp[c1][c2+1], base + s2)\\n                    # both\\n                    if sb is not None and sb > 0 and c1+1 <= op1 and c2+1 <= op2:\\n                        new_dp[c1+1][c2+1] = max(new_dp[c1+1][c2+1], base + sb)\\n            dp = new_dp\\n\\n        # maximum gain is the best over all (i,j) within limits\\n        max_gain = max(dp[c1][c2] \\n                       for c1 in range(op1+1) \\n                       for c2 in range(op2+1))\\n        return sum(nums) - max_gain\\n\"",
  "212_14631217_python-updated-time": "1745246126534",
  "55_14631217_python-updated-time": "1745014308866",
  "1031_14631217_python": "\"class Solution:\\n    def addToArrayForm(self, num, k):\\n        res = []\\n        i = len(num) - 1\\n        carry = k\\n\\n        while i >= 0 or carry > 0:\\n            if i >= 0:\\n                carry += num[i]\\n            res.append(carry % 10)\\n            carry //= 10\\n            i -= 1\\n\\n        return res[::-1]\\n\"",
  "1690_14631217_python-updated-time": "1746438030136",
  "1071_14631217_python": "\"class Solution:\\n    def prefixesDivBy5(self, nums):\\n        ans = []\\n        cur = 0\\n        for b in nums:\\n            cur = ((cur << 1) | b) % 5\\n            ans.append(cur == 0)\\n        return ans\\n\"",
  "900_14631217_python-updated-time": "1746001398668",
  "386_14631217_python": "\"class Solution:\\n    def lexicalOrder(self, n):\\n        result = []\\n        curr = 1\\n        for _ in range(n):\\n            result.append(curr)\\n            if curr * 10 <= n:\\n                curr *= 10\\n            else:\\n                while curr % 10 == 9 or curr + 1 > n:\\n                    curr //= 10\\n                curr += 1\\n        return result\\n\"",
  "2727_14631217_python-updated-time": "1747137866861",
  "769_14631217_python": "\"class Solution(object):\\n    def orderOfLargestPlusSign(self, n, mines):\\n        grid = [[n] * n for _ in range(n)]\\n        banned = set(tuple(mine) for mine in mines)\\n        \\n        for i in range(n):\\n            count = 0\\n            for j in range(n):\\n                count = 0 if (i, j) in banned else count + 1\\n                grid[i][j] = min(grid[i][j], count)\\n            count = 0\\n            for j in range(n-1, -1, -1):\\n                count = 0 if (i, j) in banned else count + 1\\n                grid[i][j] = min(grid[i][j], count)\\n        \\n        for j in range(n):\\n            count = 0\\n            for i in range(n):\\n                count = 0 if (i, j) in banned else count + 1\\n                grid[i][j] = min(grid[i][j], count)\\n            count = 0\\n            for i in range(n-1, -1, -1):\\n                count = 0 if (i, j) in banned else count + 1\\n                grid[i][j] = min(grid[i][j], count)\\n        \\n        return max(max(row) for row in grid)\\n\"",
  "1900_14631217_python": "\"class Solution:\\n    def closestCost(self, baseCosts, toppingCosts, target):\\n        possible = set()\\n\\n        def dfs(i, total):\\n            if i == len(toppingCosts):\\n                possible.add(total)\\n                return\\n            for count in range(3):\\n                dfs(i + 1, total + count * toppingCosts[i])\\n\\n        for base in baseCosts:\\n            dfs(0, base)\\n\\n        return min(possible, key=lambda x: (abs(x - target), x))\\n\"",
  "71_14631217_python": "\"class Solution(object):\\n    def simplifyPath(self, path):\\n        \\\"\\\"\\\"\\n        :type path: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        stack = []\\n        parts = path.split('/')\\n\\n        for part in parts:\\n            if part == '' or part == '.':\\n                continue\\n            elif part == '..':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(part)\\n\\n        return '/' + '/'.join(stack)\\n\"",
  "930_14631217_python": "\"class Solution(object):\\n    def allPossibleFBT(self, n):\\n        memo = {}\\n\\n        def build(t):\\n            if t in memo:\\n                return memo[t]\\n            if t == 1:\\n                return [TreeNode(0)]\\n            res = []\\n            for i in range(1, t, 2):\\n                for left in build(i):\\n                    for right in build(t - 1 - i):\\n                        res.append(TreeNode(0, left, right))\\n            memo[t] = res\\n            return res\\n\\n        return build(n) if n % 2 == 1 else []\"",
  "2186_14631217_python-updated-time": "1746720811589",
  "1268_14631217_mysql": "\"SELECT \\n    u.user_id AS buyer_id,\\n    u.join_date,\\n    COUNT(o.order_id) AS orders_in_2019\\nFROM Users u\\nLEFT JOIN Orders o\\n    ON u.user_id = o.buyer_id AND YEAR(o.order_date) = 2019\\nGROUP BY u.user_id, u.join_date;\\n\"",
  "3164_14631217_python-updated-time": "1747307242840",
  "1104_14631217_python": "\"class Solution:\\n    def colorBorder(self, grid, row, col, color):\\n        m, n = len(grid), len(grid[0])\\n        orig = grid[row][col]\\n        visited = set()\\n        stack = [(row, col)]\\n        \\n        # DFS to find the connected component\\n        while stack:\\n            i, j = stack.pop()\\n            if (i, j) in visited:\\n                continue\\n            visited.add((i, j))\\n            for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == orig:\\n                    stack.append((ni, nj))\\n        \\n        # Identify border cells\\n        border = set()\\n        for i, j in visited:\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                border.add((i, j))\\n            else:\\n                for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\\n                    ni, nj = i + di, j + dj\\n                    if (ni, nj) not in visited:\\n                        border.add((i, j))\\n                        break\\n        \\n        # Color the border\\n        for i, j in border:\\n            grid[i][j] = color\\n        \\n        return grid\\n\"",
  "2678_14631217_python": "\"import heapq\\n\\nclass Graph(object):\\n    def __init__(self, n, edges):\\n        \\\"\\\"\\\"\\n        :param n: int, number of nodes 0..n-1\\n        :param edges: List[List[int]] initial edges [u,v,cost]\\n        \\\"\\\"\\\"\\n        self.n = n\\n        self.adj = [[] for _ in range(n)]\\n        for u, v, cost in edges:\\n            self.adj[u].append((v, cost))\\n\\n    def addEdge(self, edge):\\n        \\\"\\\"\\\"\\n        :param edge: List[int] [u, v, cost]\\n        \\\"\\\"\\\"\\n        u, v, cost = edge\\n        self.adj[u].append((v, cost))\\n\\n    def shortestPath(self, node1, node2):\\n        \\\"\\\"\\\"\\n        :param node1: int\\n        :param node2: int\\n        :return: int shortest path cost or -1 if unreachable\\n        \\\"\\\"\\\"\\n        n = self.n\\n        dist = [float('inf')] * n\\n        dist[node1] = 0\\n        heap = [(0, node1)]  # (cost, node)\\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if d > dist[u]:\\n                continue\\n            if u == node2:\\n                return d\\n            for v, w in self.adj[u]:\\n                nd = d + w\\n                if nd < dist[v]:\\n                    dist[v] = nd\\n                    heapq.heappush(heap, (nd, v))\\n        return -1\"",
  "1356_14631217_python-updated-time": "1746804181945",
  "2587_14631217_python-updated-time": "1747058949485",
  "1447_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution:\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Map each value to the list of its indices\\n        pos = defaultdict(list)\\n        for i, v in enumerate(arr):\\n            pos[v].append(i)\\n        \\n        visited = [False] * n\\n        visited[0] = True\\n        queue = deque([0])\\n        steps = 0\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                i = queue.popleft()\\n                if i == n - 1:\\n                    return steps\\n                \\n                # Jump to i-1\\n                if i - 1 >= 0 and not visited[i - 1]:\\n                    visited[i - 1] = True\\n                    queue.append(i - 1)\\n                # Jump to i+1\\n                if i + 1 < n and not visited[i + 1]:\\n                    visited[i + 1] = True\\n                    queue.append(i + 1)\\n                # Jump to all other indices with same value\\n                for j in pos[arr[i]]:\\n                    if not visited[j]:\\n                        visited[j] = True\\n                        queue.append(j)\\n                # Clear the list to prevent redundant future visits\\n                pos[arr[i]] = []\\n            \\n            steps += 1\\n        \\n        return -1\\n\"",
  "3345_14631217_python": "\"class Solution(object):\\n    def sumOfPower(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        # 1) DP[s][l] = #ways to pick subset of size l summing to s\\n        dp = [[0]*(k+1) for _ in range(k+1)]\\n        dp[0][0] = 1\\n        \\n        for x in nums:\\n            if x > k:\\n                continue\\n            # reverse to avoid reuse within same iteration\\n            for s in range(k, x-1, -1):\\n                for l in range(1, k+1):\\n                    dp[s][l] = (dp[s][l] + dp[s-x][l-1]) % MOD\\n        \\n        # 2) precompute powers of 2\\n        pow2 = [1]*(n+1)\\n        for i in range(1, n+1):\\n            pow2[i] = (pow2[i-1]*2) % MOD\\n        \\n        # 3) sum over all subset‐sizes l\\n        ans = 0\\n        for l in range(k+1):\\n            cnt = dp[k][l]\\n            if cnt:\\n                # each such subset T contributes 2^(n-l)\\n                ans = (ans + cnt * pow2[n-l]) % MOD\\n        \\n        return ans\\n\"",
  "3794_14631217_python": "\"class Solution(object):\\n    def minTime(self, skill, mana):\\n        \\\"\\\"\\\"\\n        :type skill: List[int]\\n        :type mana: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(skill), len(mana)\\n        # M[i] = the time at which wizard i finishes the last brewed potion\\n        M = [0]*n\\n\\n        # iterate over potions 0..m-1 in order\\n        for j in range(m):\\n            # compute prefix sums of processing times for potion j\\n            # prefix[i] = sum of skill[0]*mana[j] + ... + skill[i-1]*mana[j]\\n            # prefix[0] = 0\\n            prefix = 0\\n            best_t = 0\\n\\n            # First pass: find the earliest start t so that\\n            # for all i: t + prefix >= M[i]  ⇒  t >= M[i] - prefix\\n            for i in range(n):\\n                # processing time of wizard i on potion j\\n                p = skill[i]*mana[j]\\n                # we compare M[i] - prefix\\n                diff = M[i] - prefix\\n                if diff > best_t:\\n                    best_t = diff\\n                # advance prefix by p for next i\\n                prefix += p\\n\\n            # Now best_t is the start time on wizard 0.\\n            # Second pass: update M[i] = completion time on wizard i\\n            # which is best_t + sum of p[0..i]\\n            running = best_t\\n            for i in range(n):\\n                running += skill[i]*mana[j]\\n                M[i] = running\\n\\n        # when the last wizard finishes the last potion:\\n        return M[-1]\\n\"",
  "950_14631217_python-updated-time": "1746003360066",
  "1008_14631217_python": "\"class Solution:\\n    def minCameraCover(self, root):\\n        NOT_MONITORED = 0\\n        HAS_CAMERA = 1\\n        MONITORED = 2\\n\\n        self.cameras = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return MONITORED\\n\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n\\n            if left == NOT_MONITORED or right == NOT_MONITORED:\\n                self.cameras += 1\\n                return HAS_CAMERA\\n            elif left == HAS_CAMERA or right == HAS_CAMERA:\\n                return MONITORED\\n            else:\\n                return NOT_MONITORED\\n\\n        if dfs(root) == NOT_MONITORED:\\n            self.cameras += 1\\n\\n        return self.cameras\\n\"",
  "855_14631217_python-updated-time": "1745879254979",
  "3834_14631217_python-updated-time": "1747684059189",
  "11_14631217_python-updated-time": "1744980081168",
  "2000_14631217_python": "\"class Solution:\\n    def minSpeedOnTime(self, dist, hour):\\n        # parse hour (float with <=2 decimals) into numerator/denominator\\n        h = str(hour)\\n        if '.' in h:\\n            a, b = h.split('.')\\n            denom = 10 ** len(b)\\n            numer = int(a) * denom + int(b)\\n        else:\\n            numer = int(h)\\n            denom = 1\\n\\n        n = len(dist)\\n        # if even the (n-1) mandatory integer-hour waits exceed hour, impossible\\n        if numer < denom * (n - 1):\\n            return -1\\n\\n        # check feasibility at speed v using integer arithmetic only\\n        def ok(v):\\n            # S1 = sum of ceil(dist[i]/v) for i in [0..n-2]\\n            S1 = 0\\n            for d in dist[:-1]:\\n                S1 += (d + v - 1) // v\\n                # early exit if already too many whole hours\\n                if S1 * denom > numer:\\n                    return False\\n            # total_time * denom <= hour * denom\\n            # total_time = S1 + dist[-1]/v\\n            # ⇒ (S1 * v + dist[-1]) * denom <= numer * v\\n            left = (S1 * v + dist[-1]) * denom\\n            right = numer * v\\n            return left <= right\\n\\n        # if max speed still fails, impossible\\n        MAX = 10**7\\n        if not ok(MAX):\\n            return -1\\n\\n        lo, hi, ans = 1, MAX, MAX\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if ok(mid):\\n                ans = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return ans\\n\"",
  "3196_14631217_python": "\"class Solution(object):\\n    def maxFrequencyScore(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        # prefix sums: S[i] = sum(nums[0..i])\\n        S = [0] * n\\n        S[0] = nums[0]\\n        for i in range(1, n):\\n            S[i] = S[i-1] + nums[i]\\n        \\n        def range_sum(i, j):\\n            \\\"\\\"\\\"Sum of nums[i..j], inclusive.\\\"\\\"\\\"\\n            return S[j] - (S[i-1] if i > 0 else 0)\\n        \\n        l = 0\\n        ans = 1\\n        for r in range(n):\\n            # Expand window to [l..r], then shrink l until cost <= k\\n            while l < r:\\n                m = (l + r) // 2\\n                # cost to make all in [l..r] equal to nums[m]\\n                left_cnt = m - l + 1\\n                left_sum = range_sum(l, m)\\n                left_cost = nums[m] * left_cnt - left_sum\\n                \\n                right_cnt = r - m\\n                right_sum = range_sum(m+1, r) if m+1 <= r else 0\\n                right_cost = right_sum - nums[m] * right_cnt\\n                \\n                if left_cost + right_cost <= k:\\n                    break\\n                l += 1\\n            \\n            # update answer\\n            curr_len = r - l + 1\\n            if curr_len > ans:\\n                ans = curr_len\\n        \\n        return ans\\n\"",
  "349_14631217_python": "\"class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        return list(set(nums1) & set(nums2))\\n\"",
  "1353_14631217_python-updated-time": "1746881295165",
  "263_14631217_python": "\"class Solution(object):\\n    def isUgly(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if n <= 0:\\n            return False\\n        for p in [2, 3, 5]:\\n            while n % p == 0:\\n                n //= p\\n        return n == 1\\n\"",
  "3820_14631217_python-updated-time": "1747737126800",
  "1742_14631217_python": "\"class Solution:\\n    def maxWidthOfVerticalArea(self, points):\\n        # Extract all x-coordinates\\n        xs = [x for x, _ in points]\\n        xs.sort()\\n        \\n        # Compute the maximum gap between consecutive x's\\n        max_gap = 0\\n        for i in range(1, len(xs)):\\n            gap = xs[i] - xs[i-1]\\n            if gap > max_gap:\\n                max_gap = gap\\n        \\n        return max_gap\\n\"",
  "2113_14631217_python": "\"class Solution:\\n    def kthLargestNumber(self, nums, k):\\n        nums.sort(key=lambda x: (len(x), x))\\n        return nums[-k]\\n\"",
  "233_14631217_python-updated-time": "1745247276235",
  "1646_14631217_python-updated-time": "1746434258816",
  "2846_14631217_python-updated-time": "1747221793905",
  "629_14631217_python": "\"class Solution(object):\\n    def kInversePairs(self, n, k):\\n        MOD = 10**9 + 7\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, n + 1):\\n            dp[i][0] = 1\\n            for j in range(1, k + 1):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD\\n                if j >= i:\\n                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD\\n                    \\n        return dp[n][k]\\n\"",
  "987_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def deckRevealedIncreasing(self, deck):\\n        # Sort the deck in ascending order\\n        deck.sort()\\n        \\n        dq = deque()\\n        # Build the initial deck order in reverse\\n        for card in reversed(deck):\\n            if dq:\\n                # Reverse the \\\"reveal then move top to bottom\\\" step:\\n                # take the last element and move it to the front\\n                dq.appendleft(dq.pop())\\n            # Place the next largest card at the front\\n            dq.appendleft(card)\\n        \\n        return list(dq)\\n\"",
  "798_14631217_python": "\"class Solution(object):\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        \\n        # Check if the board can be transformed\\n        for i in range(n):\\n            for j in range(n):\\n                if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\\n                    return -1\\n        \\n        row_sum = sum(board[0])\\n        col_sum = sum(board[i][0] for i in range(n))\\n        row_swap = sum(board[0][i] == i % 2 for i in range(n))\\n        col_swap = sum(board[i][0] == i % 2 for i in range(n))\\n        \\n        if not (n // 2 <= row_sum <= (n + 1) // 2):\\n            return -1\\n        if not (n // 2 <= col_sum <= (n + 1) // 2):\\n            return -1\\n        \\n        if n % 2:\\n            if row_swap % 2:\\n                row_swap = n - row_swap\\n            if col_swap % 2:\\n                col_swap = n - col_swap\\n        else:\\n            row_swap = min(row_swap, n - row_swap)\\n            col_swap = min(col_swap, n - col_swap)\\n        \\n        return (row_swap + col_swap) // 2\\n\"",
  "2655_14631217_python": "\"class Solution(object):\\n    def maxScore(self, nums):\\n        nums.sort(reverse=True)\\n        score = 0\\n        prefix_sum = 0\\n        for num in nums:\\n            prefix_sum += num\\n            if prefix_sum > 0:\\n                score += 1\\n            else:\\n                break\\n        return score\\n\"",
  "3531_14631217_python-updated-time": "1747570338191",
  "3805_14631217_python": "\"class Solution(object):\\n    def maxActiveSectionsAfterTrade(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Count initial active sections\\n        total_ones = s.count('1')\\n        \\n        # Build segments of t = '1' + s + '1'\\n        segments = []\\n        curr_char = '1'\\n        curr_len = 1\\n        # Process s\\n        for c in s:\\n            if c == curr_char:\\n                curr_len += 1\\n            else:\\n                segments.append((curr_char, curr_len))\\n                curr_char = c\\n                curr_len = 1\\n        # Process trailing '1'\\n        if curr_char == '1':\\n            curr_len += 1\\n        else:\\n            segments.append((curr_char, curr_len))\\n            curr_char = '1'\\n            curr_len = 1\\n        segments.append((curr_char, curr_len))\\n        \\n        # Compute max gain = z_left + z_right for each removable '1'-segment\\n        max_gain = 0\\n        m = len(segments)\\n        # We can pick any '1'-segment at index i with zeros on both sides => i in [1..m-2]\\n        for i in range(1, m-1):\\n            typ, length = segments[i]\\n            if typ == '1':\\n                # neighbors must be zeros by construction of t\\n                z_left = segments[i-1][1]\\n                z_right = segments[i+1][1]\\n                gain = z_left + z_right\\n                if gain > max_gain:\\n                    max_gain = gain\\n        \\n        # Best we can do\\n        return total_ones + max_gain\\n\"",
  "3026_14631217_python": "\"class Solution(object):\\n    def minimumPossibleSum(self, n, target):\\n        mod = 10**9 + 7\\n\\n        # Number of disjoint “conflict‐pairs” below target:\\n        # pairs (i, target−i) for i=1..floor((target−1)/2)\\n        L = (target - 1) // 2\\n\\n        # Sum of the “safe” smaller side of each pair: 1 + 2 + … + L\\n        sumA = L * (L + 1) // 2\\n\\n        # If target is even, the middle value target/2 stands alone (no conflict).\\n        hasMid = 1 if target % 2 == 0 else 0\\n        mid = target // 2 if hasMid else 0\\n\\n        if n <= L:\\n            # We only need the first n integers 1..n\\n            return (n * (n + 1) // 2) % mod\\n\\n        if n <= L + hasMid:\\n            # We take all L “small” picks plus the single middle\\n            return (sumA + mid) % mod\\n\\n        # Otherwise we take:\\n        #  • All L “small” picks,\\n        #  • The middle (if any),\\n        #  • Plus r more integers starting from target upwards.\\n        r = n - L - hasMid\\n        # Sum of r consecutive numbers target, target+1, …, target+r−1:\\n        sumB = r * (2*target + (r - 1)) // 2\\n\\n        return (sumA + mid + sumB) % mod\\n\"",
  "1228_14631217_python-updated-time": "1746109206487",
  "130_14631217_python-updated-time": "1745085199341",
  "903_14631217_python-updated-time": "1745359911886",
  "1613_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        self.parent[yr] = xr\\n        return True\\n\\n\\nclass Solution(object):\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # Add original indices to edges\\n        for i in range(len(edges)):\\n            edges[i].append(i)\\n        \\n        # Sort by weight\\n        edges.sort(key=lambda x: x[2])\\n\\n        # Kruskal's MST total weight\\n        def kruskal(n, edges, skip=-1, force=None):\\n            dsu = DSU(n)\\n            weight = 0\\n            if force:\\n                a, b, w, _ = force\\n                if dsu.union(a, b):\\n                    weight += w\\n            for i, (a, b, w, idx) in enumerate(edges):\\n                if i == skip:\\n                    continue\\n                if dsu.union(a, b):\\n                    weight += w\\n            # Check if all nodes are connected\\n            parent_set = set(dsu.find(x) for x in range(n))\\n            return weight if len(parent_set) == 1 else float('inf')\\n\\n        base_weight = kruskal(n, edges)\\n\\n        critical = []\\n        pseudo_critical = []\\n\\n        for i, edge in enumerate(edges):\\n            # Check if it's critical (skip it → MST cost increases)\\n            if kruskal(n, edges, skip=i) > base_weight:\\n                critical.append(edge[3])\\n            # Check if it's pseudo-critical (force include → same MST)\\n            elif kruskal(n, edges, force=edge) == base_weight:\\n                pseudo_critical.append(edge[3])\\n\\n        return [critical, pseudo_critical]\\n\"",
  "403_14631217_python": "\"class Solution:\\n    def canCross(self, stones):\\n        stone_set = set(stones)\\n        last_stone = stones[-1]\\n        dp = {0: {0}}\\n        \\n        for stone in stones:\\n            for jump in dp.get(stone, set()):\\n                for next_jump in (jump - 1, jump, jump + 1):\\n                    if next_jump > 0 and stone + next_jump in stone_set:\\n                        if stone + next_jump not in dp:\\n                            dp[stone + next_jump] = set()\\n                        dp[stone + next_jump].add(next_jump)\\n        \\n        return last_stone in dp\\n\"",
  "1966_14631217_python-updated-time": "1746544428178",
  "1534_14631217_python": "\"class Solution(object):\\n    def minNumberOfFrogs(self, croakOfFrogs):\\n        from collections import defaultdict\\n\\n        counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0}\\n        max_frogs = 0\\n        current_frogs = 0\\n\\n        for ch in croakOfFrogs:\\n            if ch == 'c':\\n                counts['c'] += 1\\n                current_frogs += 1\\n                max_frogs = max(max_frogs, current_frogs)\\n            elif ch == 'r':\\n                if counts['c'] == 0:\\n                    return -1\\n                counts['c'] -= 1\\n                counts['r'] += 1\\n            elif ch == 'o':\\n                if counts['r'] == 0:\\n                    return -1\\n                counts['r'] -= 1\\n                counts['o'] += 1\\n            elif ch == 'a':\\n                if counts['o'] == 0:\\n                    return -1\\n                counts['o'] -= 1\\n                counts['a'] += 1\\n            elif ch == 'k':\\n                if counts['a'] == 0:\\n                    return -1\\n                counts['a'] -= 1\\n                current_frogs -= 1\\n            else:\\n                return -1  # invalid character\\n\\n        # If any frogs are still mid-croak, it's invalid\\n        if any(counts[ch] > 0 for ch in 'croa'):\\n            return -1\\n\\n        return max_frogs\\n\"",
  "217_14631217_python": "\"class Solution(object):\\n    def containsDuplicate(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return len(nums) != len(set(nums))\\n\"",
  "836_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def racecar(self, target):\\n        queue = collections.deque([(0, 1, 0)])  # (position, speed, steps)\\n        visited = set((0, 1))\\n        \\n        while queue:\\n            pos, speed, steps = queue.popleft()\\n            if pos == target:\\n                return steps\\n            \\n            # Accelerate\\n            next_pos, next_speed = pos + speed, speed * 2\\n            if (next_pos, next_speed) not in visited and 0 <= next_pos <= 2 * target:\\n                visited.add((next_pos, next_speed))\\n                queue.append((next_pos, next_speed, steps + 1))\\n            \\n            # Reverse\\n            next_speed = -1 if speed > 0 else 1\\n            if (pos, next_speed) not in visited:\\n                visited.add((pos, next_speed))\\n                queue.append((pos, next_speed, steps + 1))\\n\"",
  "1549_14631217_python-updated-time": "1746347268746",
  "2146_14631217_python": "\"class Solution(object):\\n    def placeWordInCrossword(self, board, word):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def can_place(segment, word):\\n            if len(segment) != len(word):\\n                return False\\n            for s, w in zip(segment, word):\\n                if s != ' ' and s != w:\\n                    return False\\n            return True\\n\\n        def check_lines(lines):\\n            for line in lines:\\n                i = 0\\n                while i < len(line):\\n                    if line[i] == '#':\\n                        i += 1\\n                        continue\\n                    j = i\\n                    while j < len(line) and line[j] != '#':\\n                        j += 1\\n                    segment = line[i:j]\\n                    if can_place(segment, word) or can_place(segment, word[::-1]):\\n                        return True\\n                    i = j\\n            return False\\n\\n        # Rows as-is and reversed\\n        rows = board\\n        cols = list(zip(*board))  # transpose for columns\\n\\n        return check_lines(rows) or check_lines(cols)\\n\"",
  "1714_14631217_python": "\"class Solution(object):\\n    def reorderSpaces(self, text):\\n        spaces = text.count(' ')\\n        words = text.split()\\n        if len(words) == 1:\\n            return words[0] + ' ' * spaces\\n        gaps = spaces // (len(words) - 1)\\n        extra = spaces % (len(words) - 1)\\n        return (' ' * gaps).join(words) + ' ' * extra\\n\"",
  "2213_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        # Initially, only person 0 and firstPerson know the secret\\n        known = {0, firstPerson}\\n        \\n        # Group meetings by time\\n        meetings.sort(key=lambda x: x[2])\\n        i = 0\\n        m = len(meetings)\\n        \\n        while i < m:\\n            t = meetings[i][2]\\n            # Build adjacency for this time t\\n            adj = defaultdict(list)\\n            j = i\\n            while j < m and meetings[j][2] == t:\\n                x, y, _ = meetings[j]\\n                adj[x].append(y)\\n                adj[y].append(x)\\n                j += 1\\n            \\n            # Find all participants at this time\\n            participants = set(adj.keys())\\n            # BFS from those who already know among participants\\n            queue = deque([p for p in participants if p in known])\\n            visited = set(queue)\\n            \\n            while queue:\\n                u = queue.popleft()\\n                for v in adj[u]:\\n                    if v not in visited:\\n                        visited.add(v)\\n                        queue.append(v)\\n            \\n            # Anyone visited now learns the secret\\n            known |= visited\\n            \\n            # Move to next time block\\n            i = j\\n        \\n        return list(known)\\n\"",
  "3073_14631217_pythondata": "\"import pandas as pd\\n\\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Reshapes the DataFrame from wide to long format so each row represents\\n    sales for a product in a specific quarter.\\n    \\\"\\\"\\\"\\n    return pd.melt(report, id_vars=['product'], \\n                   value_vars=['quarter_1', 'quarter_2', 'quarter_3', 'quarter_4'],\\n                   var_name='quarter', value_name='sales')\\n\"",
  "110_14631217_python-updated-time": "1745081242021",
  "2642_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        waitL = []  # (-efficiency, -index)\\n        waitR = []  # (-efficiency, -index)\\n        workL = []  # (available_time, index)\\n        workR = []  # (available_time, index)\\n\\n        for i in range(k):\\n            eff = time[i][0] + time[i][2]\\n            heapq.heappush(waitL, (-eff, -i))\\n\\n        curr_time = 0\\n        boxes_remaining = n\\n        latest_arrival = 0\\n\\n        while boxes_remaining > 0 or workR or waitR or workL:\\n            # Release workers who are done putting or picking\\n            while workL and workL[0][0] <= curr_time:\\n                _, i = heapq.heappop(workL)\\n                eff = time[i][0] + time[i][2]\\n                heapq.heappush(waitL, (-eff, -i))\\n            while workR and workR[0][0] <= curr_time:\\n                _, i = heapq.heappop(workR)\\n                eff = time[i][0] + time[i][2]\\n                heapq.heappush(waitR, (-eff, -i))\\n\\n            if waitR:\\n                _, i = heapq.heappop(waitR)\\n                i = -i\\n                curr_time += time[i][2]  # lefti\\n                latest_arrival = curr_time  # box has reached left\\n                heapq.heappush(workL, (curr_time + time[i][3], i))  # putting box\\n            elif boxes_remaining > 0 and waitL:\\n                _, i = heapq.heappop(waitL)\\n                i = -i\\n                curr_time += time[i][0]  # righti\\n                heapq.heappush(workR, (curr_time + time[i][1], i))  # picking box\\n                boxes_remaining -= 1\\n            else:\\n                # Jump to the next event time\\n                next_times = []\\n                if workL:\\n                    next_times.append(workL[0][0])\\n                if workR:\\n                    next_times.append(workR[0][0])\\n                if next_times:\\n                    curr_time = max(curr_time, min(next_times))\\n\\n        return latest_arrival\\n\"",
  "3435_14631217_python": "\"class Solution(object):\\n    def getResults(self, queries):\\n        # Find the maximum x in any query\\n        N = max(q[1] for q in queries)\\n        \\n        INF = 10**18\\n        size = 4*(N+1)\\n        left_obs  = [INF] * size\\n        right_obs = [-INF] * size\\n        max_gap   = [0]   * size\\n        \\n        def _combine(node, lnode, rnode):\\n            # combine child rnode into lnode, store in node\\n            left_obs[node]  = min(left_obs[lnode],  left_obs[rnode])\\n            right_obs[node] = max(right_obs[lnode], right_obs[rnode])\\n            # gap between the boundary obstacles of the two children\\n            bridge = 0\\n            if right_obs[lnode] != -INF and left_obs[rnode] != INF:\\n                bridge = left_obs[rnode] - right_obs[lnode]\\n            max_gap[node] = max(max_gap[lnode],\\n                               max_gap[rnode],\\n                               bridge)\\n        \\n        # Point-update: insert obstacle at position pos\\n        def update(node, l, r, pos):\\n            if l == r:\\n                left_obs[node] = right_obs[node] = pos\\n                max_gap[node] = 0\\n                return\\n            mid = (l + r) // 2\\n            if pos <= mid:\\n                update(node*2,   l,    mid, pos)\\n            else:\\n                update(node*2+1, mid+1, r,   pos)\\n            _combine(node, node*2, node*2+1)\\n        \\n        # Range-query on [L..R], returning (left_obs, right_obs, max_gap)\\n        def query(node, l, r, L, R):\\n            if R < l or r < L:\\n                # no overlap\\n                return (INF, -INF, 0)\\n            if L <= l and r <= R:\\n                return (left_obs[node],\\n                        right_obs[node],\\n                        max_gap[node])\\n            mid = (l + r) // 2\\n            lo1, ro1, g1 = query(node*2,   l,    mid, L, R)\\n            lo2, ro2, g2 = query(node*2+1, mid+1, r,   L, R)\\n            # combine the two halves\\n            lo = min(lo1, lo2)\\n            ro = max(ro1, ro2)\\n            bridge = 0\\n            if ro1 != -INF and lo2 != INF:\\n                bridge = lo2 - ro1\\n            return (lo, ro, max(g1, g2, bridge))\\n        \\n        result = []\\n        for q in queries:\\n            if q[0] == 1:\\n                # place an obstacle\\n                x = q[1]\\n                update(1, 1, N, x)\\n            else:\\n                # can we fit a block of size sz in [0..x]?\\n                x, sz = q[1], q[2]\\n                lo, ro, g = query(1, 1, N, 1, x)\\n                # gap from 0 to first obstacle\\n                left_gap  = lo if lo != INF else x\\n                # gap from last obstacle to x\\n                right_gap = (x - ro) if ro != -INF else x\\n                max_free  = max(left_gap, right_gap, g)\\n                result.append(max_free >= sz)\\n        \\n        return result\\n\"",
  "1194_14631217_python-updated-time": "1746108491267",
  "2406_14631217_python-updated-time": "1746883714931",
  "902_14631217_python-updated-time": "1746001456796",
  "1705_14631217_python-updated-time": "1746438523270",
  "117_14631217_python-updated-time": "1745081452688",
  "2737_14631217_python-updated-time": "1747136012028",
  "3318_14631217_python-updated-time": "1747415793966",
  "2448_14631217_python": "\"class Solution(object):\\n    def countBadPairs(self, nums):\\n        from collections import defaultdict\\n\\n        n = len(nums)\\n        good = 0\\n        freq = defaultdict(int)\\n\\n        for i in range(n):\\n            key = nums[i] - i\\n            good += freq[key]\\n            freq[key] += 1\\n\\n        total = n * (n - 1) // 2\\n        return total - good\\n\"",
  "2325_14631217_python-updated-time": "1746811107042",
  "1229_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def shortestAlternatingPaths(self, n, redEdges, blueEdges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type redEdges: List[List[int]]\\n        :type blueEdges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        RED, BLUE = 0, 1\\n        graph = [defaultdict(list), defaultdict(list)]  # 0: red, 1: blue\\n        \\n        for u, v in redEdges:\\n            graph[RED][u].append(v)\\n        for u, v in blueEdges:\\n            graph[BLUE][u].append(v)\\n        \\n        # dist[node][color] = shortest distance to node ending with given color edge\\n        dist = [[-1, -1] for _ in range(n)]\\n        dist[0] = [0, 0]  # distance to node 0 is 0 for both colors\\n\\n        queue = deque()\\n        queue.append((0, RED))\\n        queue.append((0, BLUE))\\n\\n        while queue:\\n            node, color = queue.popleft()\\n            next_color = 1 - color\\n            for nei in graph[next_color][node]:\\n                if dist[nei][next_color] == -1:\\n                    dist[nei][next_color] = dist[node][color] + 1\\n                    queue.append((nei, next_color))\\n\\n        res = []\\n        for red_d, blue_d in dist:\\n            if red_d == -1 or blue_d == -1:\\n                res.append(max(red_d, blue_d))\\n            else:\\n                res.append(min(red_d, blue_d))\\n        return res\\n\"",
  "210_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \\\"\\\"\\\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        indegree = [0] * numCourses\\n        graph = defaultdict(list)\\n        \\n        for a, b in prerequisites:\\n            graph[b].append(a)\\n            indegree[a] += 1\\n        \\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\\n        res = []\\n        \\n        while queue:\\n            node = queue.popleft()\\n            res.append(node)\\n            for neighbor in graph[node]:\\n                indegree[neighbor] -= 1\\n                if indegree[neighbor] == 0:\\n                    queue.append(neighbor)\\n                    \\n        return res if len(res) == numCourses else []\\n\"",
  "7_14631217_python-updated-time": "1744979063784",
  "1732_14631217_python": "\"class Solution:\\n    def minimumOneBitOperations(self, n):\\n        memo = {}\\n\\n        def f(x):\\n            # base cases\\n            if x < 2:\\n                return x\\n            if x in memo:\\n                return memo[x]\\n\\n            m = x.bit_length() - 1\\n            high = 1 << m\\n            # use the recurrence: f(x) = (2^(m+1)-1) - f(x - 2^m)\\n            res = (high << 1) - 1 - f(x - high)\\n\\n            memo[x] = res\\n            return res\\n\\n        return f(n)\\n\"",
  "3230_14631217_python-updated-time": "1747317086328",
  "2869_14631217_python": "\"class Solution:\\n    def maxNonDecreasingLength(self, nums1, nums2):\\n        n = len(nums1)\\n        dp1 = dp2 = 1\\n        res = 1\\n\\n        for i in range(1, n):\\n            ndp1 = ndp2 = 1\\n\\n            if nums1[i] >= nums1[i-1]:\\n                ndp1 = max(ndp1, dp1 + 1)\\n            if nums1[i] >= nums2[i-1]:\\n                ndp1 = max(ndp1, dp2 + 1)\\n            if nums2[i] >= nums1[i-1]:\\n                ndp2 = max(ndp2, dp1 + 1)\\n            if nums2[i] >= nums2[i-1]:\\n                ndp2 = max(ndp2, dp2 + 1)\\n\\n            dp1, dp2 = ndp1, ndp2\\n            res = max(res, dp1, dp2)\\n\\n        return res\\n\"",
  "894_14631217_python": "\"import random\\n\\nclass Solution(object):\\n    def __init__(self, n, blacklist):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type blacklist: List[int]\\n        \\\"\\\"\\\"\\n        self.N = n\\n        self.black = set(blacklist)\\n        self.M = n - len(blacklist)\\n        \\n        # Map for blacklisted numbers in [0, M) to valid numbers >= M\\n        self.mapping = {}\\n        # Start from the end of the range\\n        w = n - 1\\n        \\n        # For every blacklisted b < M, find a w >= M that's not blacklisted\\n        for b in blacklist:\\n            if b < self.M:\\n                # Move w down until it's not in black set\\n                while w in self.black:\\n                    w -= 1\\n                self.mapping[b] = w\\n                w -= 1\\n\\n    def pick(self):\\n        \\\"\\\"\\\"\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Pick uniformly from [0, M)\\n        x = random.randrange(self.M)\\n        # If x is remapped, return its mapping, else x itself\\n        return self.mapping.get(x, x)\\n\"",
  "3557_14631217_python-updated-time": "1747572537357",
  "177_14631217_mysql-updated-time": "1745092359258",
  "3327_14631217_python-updated-time": "1747422493371",
  "3582_14631217_python": "\"class Solution(object):\\n    def stableMountains(self, height, threshold):\\n        return [i for i in range(1, len(height)) if height[i - 1] > threshold]\\n\"",
  "1351_14631217_python-updated-time": "1746259277724",
  "2894_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def findMaximumElegance(self, items, k):\\n        items.sort(reverse=True)  # sort by profit descending\\n        used = set()\\n        dup_heap = []\\n        total = 0\\n        res = 0\\n\\n        for i in range(k):\\n            profit, cat = items[i]\\n            total += profit\\n            if cat in used:\\n                heapq.heappush(dup_heap, profit)\\n            else:\\n                used.add(cat)\\n\\n        res = total + len(used) * len(used)\\n\\n        j = k\\n        while j < len(items) and dup_heap:\\n            profit, cat = items[j]\\n            if cat in used:\\n                j += 1\\n                continue\\n            removed = heapq.heappop(dup_heap)\\n            total += profit - removed\\n            used.add(cat)\\n            res = max(res, total + len(used) * len(used))\\n            j += 1\\n\\n        return res\\n\"",
  "3065_14631217_pythondata-updated-time": "1720875221860",
  "46_14631217_python": "\"class Solution(object):\\n    def permute(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(path, remaining):\\n            if not remaining:\\n                res.append(path)\\n                return\\n            for i in range(len(remaining)):\\n                backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:])\\n\\n        backtrack([], nums)\\n        return res\\n\"",
  "1775_14631217_python": "\"class OrderedStream:\\n    def __init__(self, n):\\n        # 1-indexed storage for values; positions start empty\\n        self.stream = [''] * (n + 2)\\n        # ptr is the next ID we're waiting to output\\n        self.ptr = 1\\n\\n    def insert(self, idKey, value):\\n        # Store the incoming value\\n        self.stream[idKey] = value\\n        # If this fills the next-expected slot, collect all consecutive\\n        res = []\\n        while self.stream[self.ptr]:\\n            res.append(self.stream[self.ptr])\\n            self.ptr += 1\\n        return res\\n\"",
  "2317_14631217_python": "\"class Solution(object):\\n    def countCollisions(self, directions):\\n        # Remove leading L and trailing R as they won't cause any collisions\\n        directions = directions.lstrip('L').rstrip('R')\\n        return sum(1 for c in directions if c != 'S')\\n\"",
  "3636_14631217_python-updated-time": "1747585896267",
  "1662_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums):\\n        sum_bits = 0\\n        max_num = 0\\n        for num in nums:\\n            sum_bits += bin(num).count('1')\\n            if num > max_num:\\n                max_num = num\\n        doubling = max_num.bit_length() - 1 if max_num > 0 else 0\\n        return sum_bits + doubling\\n\"",
  "2778_14631217_python": "\"class FrequencyTracker(object):\\n    def __init__(self):\\n        # count[number] = current frequency of number\\n        self.count = {}\\n        # freq_map[f] = number of elements that appear exactly f times\\n        self.freq_map = {}\\n\\n    def add(self, number):\\n        # old frequency\\n        old = self.count.get(number, 0)\\n        # decrement old freq count\\n        if old > 0:\\n            self.freq_map[old] -= 1\\n        # new frequency\\n        new = old + 1\\n        self.count[number] = new\\n        # increment new freq count\\n        self.freq_map[new] = self.freq_map.get(new, 0) + 1\\n\\n    def deleteOne(self, number):\\n        old = self.count.get(number, 0)\\n        if old == 0:\\n            return  # nothing to delete\\n        # decrement old freq count\\n        self.freq_map[old] -= 1\\n        # new frequency\\n        new = old - 1\\n        if new > 0:\\n            self.count[number] = new\\n            # increment the new frequency count\\n            self.freq_map[new] = self.freq_map.get(new, 0) + 1\\n        else:\\n            # remove the number entirely\\n            del self.count[number]\\n\\n    def hasFrequency(self, frequency):\\n        # return True if any number has exactly `frequency` occurrences\\n        return self.freq_map.get(frequency, 0) > 0\\n\"",
  "2155_14631217_python-updated-time": "1746719519589",
  "502_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def findMaximizedCapital(self, k, w, profits, capital):\\n        projects = sorted(zip(capital, profits))\\n        max_heap = []\\n        i = 0\\n        n = len(projects)\\n\\n        for _ in range(k):\\n            while i < n and projects[i][0] <= w:\\n                heapq.heappush(max_heap, -projects[i][1])\\n                i += 1\\n            if not max_heap:\\n                break\\n            w += -heapq.heappop(max_heap)\\n        \\n        return w\\n\"",
  "1408_14631217_python": "\"class Solution:\\n    def smallestDivisor(self, nums, threshold):\\n        left, right = 1, max(nums)\\n\\n        def compute_sum(divisor):\\n            return sum((num + divisor - 1) // divisor for num in nums)\\n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if compute_sum(mid) > threshold:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        return left\\n\"",
  "3634_14631217_python-updated-time": "1747654824983",
  "20_14631217_python-updated-time": "1744980875826",
  "2077_14631217_python": "\"class Solution(object):\\n    def maximumNumber(self, num, change):\\n        s = list(num)\\n        n = len(s)\\n        i = 0\\n        # 1) Find start of mutation: first position where change[d] > original\\n        while i < n and change[ord(s[i]) - ord('0')] <= ord(s[i]) - ord('0'):\\n            i += 1\\n        # If no such position, no mutation helps\\n        if i == n:\\n            return num\\n        # 2) Mutate substring while it doesn't decrease digits\\n        while i < n and change[ord(s[i]) - ord('0')] >= ord(s[i]) - ord('0'):\\n            s[i] = str(change[ord(s[i]) - ord('0')])\\n            i += 1\\n        return \\\"\\\".join(s)\\n\"",
  "2691_14631217_python": "\"class Solution(object):\\n    def vowelStrings(self, words, queries):\\n        vowels = set('aeiou')\\n        n = len(words)\\n        prefix = [0] * (n + 1)\\n\\n        for i in range(n):\\n            w = words[i]\\n            if w[0] in vowels and w[-1] in vowels:\\n                prefix[i + 1] = prefix[i] + 1\\n            else:\\n                prefix[i + 1] = prefix[i]\\n\\n        res = []\\n        for l, r in queries:\\n            res.append(prefix[r + 1] - prefix[l])\\n        return res\\n\"",
  "1935_14631217_python-updated-time": "1746543479640",
  "2539_14631217_python": "\"class Solution(object):\\n    def makeSimilar(self, nums, target):\\n        ev_n, od_n = [], []\\n        ev_t, od_t = [], []\\n        for x in nums:\\n            (ev_n if x%2==0 else od_n).append(x)\\n        for x in target:\\n            (ev_t if x%2==0 else od_t).append(x)\\n\\n        # They must have the same counts per parity (guaranteed possible)\\n        ev_n.sort()\\n        od_n.sort()\\n        ev_t.sort()\\n        od_t.sort()\\n\\n        ops = 0\\n        # Sum positive shifts in the even list\\n        for a, b in zip(ev_n, ev_t):\\n            if b > a:\\n                ops += (b - a) // 2\\n        # Sum positive shifts in the odd list\\n        for a, b in zip(od_n, od_t):\\n            if b > a:\\n                ops += (b - a) // 2\\n\\n        return ops\\n\"",
  "1707_14631217_python-updated-time": "1746438655103",
  "698_14631217_python": "\"class Solution(object):\\n    def canPartitionKSubsets(self, nums, k):\\n        total = sum(nums)\\n        if total % k != 0:\\n            return False\\n        target = total // k\\n        n = len(nums)\\n        nums.sort(reverse=True)\\n        memo = {}\\n        \\n        def dfs(used, curr_sum):\\n            if used in memo:\\n                return memo[used]\\n            if used == (1 << n) - 1:\\n                return True\\n            for i in range(n):\\n                if not (used >> i) & 1:\\n                    if curr_sum + nums[i] > target:\\n                        continue\\n                    if dfs(used | (1 << i), (curr_sum + nums[i]) % target):\\n                        memo[used] = True\\n                        return True\\n            memo[used] = False\\n            return False\\n        \\n        return dfs(0, 0)\\n\"",
  "2742_14631217_javascript": "\"Array.prototype.groupBy = function(fn) {\\n  const result = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (!result.hasOwnProperty(key)) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n  }\\n  return result;\\n};\\n\\n// Example Usage:\\n// const array = [{ id: '1' }, { id: '1' }, { id: '2' }];\\n// const grouped = array.groupBy(item => item.id);\\n// console.log(grouped);\\n// // { '1': [{ id: '1' }, { id: '1' }], '2': [{ id: '2' }] }\\n\"",
  "1840_14631217_python": "\"class Solution:\\n    def minimumHammingDistance(self, source, target, allowedSwaps):\\n        from collections import defaultdict, Counter\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent[find(x)] = find(y)\\n\\n        n = len(source)\\n        parent = list(range(n))\\n\\n        for a, b in allowedSwaps:\\n            union(a, b)\\n\\n        groups = defaultdict(list)\\n        for i in range(n):\\n            groups[find(i)].append(i)\\n\\n        res = 0\\n        for indices in groups.values():\\n            src_counter = Counter(source[i] for i in indices)\\n            tgt_counter = Counter(target[i] for i in indices)\\n            for val in tgt_counter:\\n                src_counter[val] -= tgt_counter[val]\\n            res += sum(max(0, v) for v in src_counter.values())\\n\\n        return res\\n\"",
  "2920_14631217_python-updated-time": "1747224053487",
  "2094_14631217_python-updated-time": "1746639263779",
  "3442_14631217_python-updated-time": "1747484986632",
  "648_14631217_python-updated-time": "1745782645670",
  "1041_14631217_python-updated-time": "1746040848576",
  "1332_14631217_python": "\"class Solution(object):\\n    def countVowelPermutation(self, n):\\n        MOD = 10**9 + 7\\n\\n        a = e = i = o = u = 1\\n\\n        for _ in range(1, n):\\n            a_new = (e + i + u) % MOD\\n            e_new = (a + i) % MOD\\n            i_new = (e + o) % MOD\\n            o_new = i % MOD\\n            u_new = (i + o) % MOD\\n\\n            a, e, i, o, u = a_new, e_new, i_new, o_new, u_new\\n\\n        return (a + e + i + o + u) % MOD\\n\"",
  "2954_14631217_python-updated-time": "1747226653470",
  "881_14631217_python": "\"class Solution(object):\\n    def loudAndRich(self, richer, quiet):\\n        n = len(quiet)\\n        graph = [[] for _ in range(n)]\\n        for a, b in richer:\\n            graph[b].append(a)\\n        \\n        ans = [-1] * n\\n\\n        def dfs(x):\\n            if ans[x] != -1:\\n                return ans[x]\\n            ans[x] = x\\n            for y in graph[x]:\\n                cand = dfs(y)\\n                if quiet[cand] < quiet[ans[x]]:\\n                    ans[x] = cand\\n            return ans[x]\\n        \\n        for i in range(n):\\n            dfs(i)\\n        \\n        return ans\\n\"",
  "472_14631217_python": "\"class Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        word_set = set(words)\\n        res = []\\n\\n        def canForm(word):\\n            if not word: return False\\n            dp = [False] * (len(word) + 1)\\n            dp[0] = True\\n            for i in range(1, len(word) + 1):\\n                for j in range(i):\\n                    if dp[j] and word[j:i] in word_set:\\n                        if j == 0 and i == len(word):\\n                            continue  # skip if the whole word matches\\n                        dp[i] = True\\n                        break\\n            return dp[len(word)]\\n\\n        for word in words:\\n            word_set.remove(word)\\n            if canForm(word):\\n                res.append(word)\\n            word_set.add(word)\\n\\n        return res\\n\"",
  "3290_14631217_python": "\"class Solution(object):\\n    def countMatchingSubarrays(self, nums, pattern):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type pattern: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        m = len(pattern)\\n        if m == 0:\\n            # pattern of length 0: every adjacent pair counts, so n-1 subarrays\\n            return n - 1\\n        \\n        # Build the diff array of length n-1, where\\n        # diff[i] = sign(nums[i+1] - nums[i]) in {-1,0,1}\\n        diff = [0] * (n - 1)\\n        for i in range(n - 1):\\n            d = nums[i+1] - nums[i]\\n            if d > 0:\\n                diff[i] = 1\\n            elif d < 0:\\n                diff[i] = -1\\n            else:\\n                diff[i] = 0\\n        \\n        # KMP prefix-function on the pattern\\n        pi = [0] * m\\n        j = 0\\n        for i in range(1, m):\\n            while j > 0 and pattern[i] != pattern[j]:\\n                j = pi[j-1]\\n            if pattern[i] == pattern[j]:\\n                j += 1\\n            pi[i] = j\\n        \\n        # KMP search for pattern in diff\\n        count = 0\\n        j = 0\\n        for x in diff:\\n            while j > 0 and x != pattern[j]:\\n                j = pi[j-1]\\n            if x == pattern[j]:\\n                j += 1\\n                if j == m:\\n                    count += 1\\n                    j = pi[j-1]\\n        \\n        return count\\n\"",
  "327_14631217_python": "\"class Solution(object):\\n    def countRangeSum(self, nums, lower, upper):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type lower: int\\n        :type upper: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        prefix = [0]\\n        for num in nums:\\n            prefix.append(prefix[-1] + num)\\n        \\n        def sort(lo, hi):\\n            if hi - lo <= 1:\\n                return 0\\n            mid = (lo + hi) // 2\\n            count = sort(lo, mid) + sort(mid, hi)\\n            j = k = mid\\n            for left in prefix[lo:mid]:\\n                while k < hi and prefix[k] - left < lower:\\n                    k += 1\\n                while j < hi and prefix[j] - left <= upper:\\n                    j += 1\\n                count += j - k\\n            prefix[lo:hi] = sorted(prefix[lo:hi])\\n            return count\\n        \\n        return sort(0, len(prefix))\\n\"",
  "2471_14631217_python": "\"class Solution(object):\\n    def garbageCollection(self, garbage, travel):\\n        \\\"\\\"\\\"\\n        :type garbage: List[str]\\n        :type travel: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(garbage)\\n        # prefix[i] = time to travel from house 0 to house i\\n        prefix = [0] * n\\n        for i in range(1, n):\\n            prefix[i] = prefix[i - 1] + travel[i - 1]\\n\\n        # Track the last house index where each type appears\\n        last = {'M': -1, 'P': -1, 'G': -1}\\n        total_pickup = 0\\n\\n        for i, s in enumerate(garbage):\\n            total_pickup += len(s)\\n            for ch in ('M', 'P', 'G'):\\n                if ch in s:\\n                    last[ch] = i\\n\\n        # Sum up travel time for each truck to its last needed house\\n        total_time = total_pickup\\n        for ch in ('M', 'P', 'G'):\\n            idx = last[ch]\\n            if idx != -1:\\n                total_time += prefix[idx]\\n\\n        return total_time\\n\"",
  "3483_14631217_python-updated-time": "1747486945942",
  "447_14631217_python-updated-time": "1745359130201",
  "220_14631217_python-updated-time": "1745246550282",
  "1079_14631217_python": "\"class Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, val):\\n            if not node:\\n                return 0\\n            val = (val << 1) | node.val\\n            if not node.left and not node.right:\\n                return val\\n            return dfs(node.left, val) + dfs(node.right, val)\\n\\n        return dfs(root, 0)\\n\"",
  "1781_14631217_python": "\"class Solution:\\n    def arrayStringsAreEqual(self, word1, word2):\\n        return \\\"\\\".join(word1) == \\\"\\\".join(word2)\\n\"",
  "1329_14631217_python": "\"class Solution(object):\\n    def minCostToMoveChips(self, position):\\n        \\\"\\\"\\\"\\n        :type position: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        even = sum(1 for p in position if p % 2 == 0)\\n        odd = len(position) - even\\n        return min(even, odd)\\n\"",
  "1437_14631217_python": "\"class Solution:\\n    def minInsertions(self, s):\\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                if s[i] == s[j]:\\n                    dp[i][j] = dp[i + 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\\n        return dp[0][n - 1]\\n\"",
  "2278_14631217_python": "\"class Solution:\\n    def sumOfThree(self, num):\\n        if num % 3 != 0:\\n            return []\\n        x = num // 3\\n        return [x - 1, x, x + 1]\\n\"",
  "1644_14631217_python": "\"class Solution(object):\\n    def maxNumOfSubstrings(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        first = [n] * 26\\n        last = [-1] * 26\\n\\n        # Step 1: record first and last index of each char\\n        for i, ch in enumerate(s):\\n            idx = ord(ch) - ord('a')\\n            first[idx] = min(first[idx], i)\\n            last[idx] = max(last[idx], i)\\n\\n        intervals = []\\n\\n        # Step 2: Expand each character's range to include all its dependent characters\\n        for i in range(26):\\n            if first[i] > last[i]:\\n                continue\\n            l, r = first[i], last[i]\\n            j = l\\n            valid = True\\n            while j <= r:\\n                ch_idx = ord(s[j]) - ord('a')\\n                if first[ch_idx] < l:\\n                    l = first[ch_idx]\\n                    j = l  # restart\\n                if last[ch_idx] > r:\\n                    r = last[ch_idx]\\n                j += 1\\n            # After expansion, re-check\\n            j = l\\n            while j <= r:\\n                ch_idx = ord(s[j]) - ord('a')\\n                if first[ch_idx] < l or last[ch_idx] > r:\\n                    valid = False\\n                    break\\n                j += 1\\n            if valid:\\n                intervals.append((l, r))\\n\\n        # Step 3: Greedily choose non-overlapping intervals with min total length\\n        intervals.sort(key=lambda x: x[1])  # sort by end\\n        res = []\\n        end = -1\\n        for l, r in intervals:\\n            if l > end:\\n                res.append(s[l:r+1])\\n                end = r\\n\\n        return res\\n\"",
  "2716_14631217_python-updated-time": "1747133779187",
  "796_14631217_python-updated-time": "1745877348999",
  "1633_14631217_python": "\"class Solution(object):\\n    def minNumberOperations(self, target):\\n        \\\"\\\"\\\"\\n        :type target: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ops = target[0]\\n        for i in range(1, len(target)):\\n            if target[i] > target[i - 1]:\\n                ops += target[i] - target[i - 1]\\n        return ops\\n\"",
  "3290_14631217_python-updated-time": "1747413768098",
  "815_14631217_python-updated-time": "1745878099655",
  "2384_14631217_python-updated-time": "1746879534713",
  "3057_14631217_python-updated-time": "1747226722623",
  "282_14631217_python-updated-time": "1745248469383",
  "3575_14631217_python-updated-time": "1747571686174",
  "1331_14631217_python": "\"class Solution(object):\\n    def getMaximumGold(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        max_gold = 0\\n\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]:\\n                return 0\\n\\n            visited[i][j] = True\\n            gold = grid[i][j]\\n            max_val = 0\\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                max_val = max(max_val, dfs(i+dx, j+dy, visited))\\n            visited[i][j] = False\\n            return gold + max_val\\n\\n        visited = [[False]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    max_gold = max(max_gold, dfs(i, j, visited))\\n\\n        return max_gold\\n\"",
  "3713_14631217_python-updated-time": "1747671583618",
  "3105_14631217_python-updated-time": "1747227420107",
  "2221_14631217_python": "\"class Solution:\\n    def canBeValid(self, s, locked):\\n        n = len(s)\\n        if n % 2 != 0:\\n            return False\\n\\n        # Left to right check\\n        balance = 0  # represents net open brackets\\n        flex = 0     # number of unlocked positions\\n        for i in range(n):\\n            if locked[i] == '1':\\n                balance += 1 if s[i] == '(' else -1\\n            else:\\n                flex += 1\\n\\n            if balance + flex < 0:\\n                return False\\n\\n        # Right to left check\\n        balance = 0\\n        flex = 0\\n        for i in reversed(range(n)):\\n            if locked[i] == '1':\\n                balance += 1 if s[i] == ')' else -1\\n            else:\\n                flex += 1\\n\\n            if balance + flex < 0:\\n                return False\\n\\n        return True\\n\"",
  "402_14631217_python-updated-time": "1745355897183",
  "908_14631217_python": "\"class Solution(object):\\n    def middleNode(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        return slow\\n\"",
  "2140_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def longestSubsequenceRepeatedK(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        cnt = collections.Counter(s)\\n        chars = [c for c in cnt if cnt[c] >= k]\\n        chars.sort(reverse=True)\\n        maxlen = len(s) // k\\n\\n        def ok(seq):\\n            i = times = 0\\n            m = len(seq)\\n            for ch in s:\\n                if ch == seq[i]:\\n                    i += 1\\n                    if i == m:\\n                        times += 1\\n                        if times == k:\\n                            return True\\n                        i = 0\\n            return False\\n\\n        res = ''\\n        cur = ['']\\n        for _ in xrange(maxlen):\\n            nxt = []\\n            for seq in cur:\\n                for ch in chars:\\n                    cand = seq + ch\\n                    if ok(cand):\\n                        nxt.append(cand)\\n            if not nxt:\\n                break\\n            res = nxt[0]\\n            cur = nxt\\n        return res\\n\"",
  "2298_14631217_python-updated-time": "1746803531421",
  "2796_14631217_javascript-updated-time": "1747137091310",
  "3236_14631217_python-updated-time": "1747319706245",
  "532_14631217_python-updated-time": "1745446791369",
  "2765_14631217_python": "\"class Solution(object):\\n    def countOperationsToEmptyArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # BIT for alive counts\\n        size = n\\n        bit = [0] * (size + 1)\\n        def bit_add(i, v):\\n            # i: 0-based index\\n            x = i + 1\\n            while x <= size:\\n                bit[x] += v\\n                x += x & -x\\n        def bit_sum(i):\\n            # sum [0..i]\\n            s = 0\\n            x = i + 1\\n            while x > 0:\\n                s += bit[x]\\n                x -= x & -x\\n            return s\\n        def range_sum(l, r):\\n            if l > r: return 0\\n            return bit_sum(r) - (bit_sum(l-1) if l>0 else 0)\\n\\n        # initialize all alive\\n        for i in range(n): bit_add(i, 1)\\n        # sort values with original indices\\n        arr = sorted((v, i) for i, v in enumerate(nums))\\n        ops = 0\\n        cur = 0  # current front pointer in original indices\\n        for _, idx in arr:\\n            if idx >= cur:\\n                steps = range_sum(cur, idx-1)\\n            else:\\n                steps = range_sum(cur, n-1) + range_sum(0, idx-1)\\n            ops += steps + 1  # rotations + removal\\n            # remove idx\\n            bit_add(idx, -1)\\n            cur = idx\\n            # advance cur to next alive\\n            # but removal makes next front at same idx position\\n        return ops\\n\"",
  "577_14631217_mysql": "\"SELECT\\n    e.name,\\n    b.bonus\\nFROM Employee e\\nLEFT JOIN Bonus b\\n    ON e.empId = b.empId\\nWHERE b.bonus < 1000\\n   OR b.bonus IS NULL;\\n\"",
  "1336_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxProduct(self, s):\\n        n = len(s)\\n        # Manacher's odd-length radii\\n        d1 = [0]*n\\n        l = r = -1\\n        for i in range(n):\\n            k = 1 if i > r else min(d1[l+r-i], r - i + 1)\\n            while i-k >= 0 and i+k < n and s[i-k] == s[i+k]:\\n                k += 1\\n            d1[i] = k\\n            if i + k - 1 > r:\\n                l, r = i - k + 1, i + k - 1\\n\\n        # Compute best_left[i]: max odd-pal length ending at or before i\\n        best_left = [0]*n\\n        heap = []  # min-heap of (center, right_end)\\n        for i in range(n):\\n            # Add center i\\n            c = i\\n            end = c + d1[c] - 1\\n            if d1[c] > 0:\\n                heapq.heappush(heap, (c, end))\\n            # Remove expired centers\\n            while heap and heap[0][1] < i:\\n                heapq.heappop(heap)\\n            # Choose minimal center among active\\n            curr = 0\\n            if heap:\\n                c0, _ = heap[0]\\n                curr = 2*(i - c0 + 1) - 1\\n            best_left[i] = curr if i == 0 else max(best_left[i-1], curr)\\n\\n        # Compute best_right[i]: max odd-pal length starting at or after i\\n        best_right = [0]*n\\n        heap = []\\n        for i in range(n-1, -1, -1):\\n            c = i\\n            # for right side, center c covers start = c - (d1[c]-1)\\n            start = c - (d1[c] - 1)\\n            if d1[c] > 0:\\n                heapq.heappush(heap, (-c, start))\\n            # Remove expired (start > i) => intervals not covering i\\n            while heap and heap[0][1] > i:\\n                heapq.heappop(heap)\\n            curr = 0\\n            if heap:\\n                # maximal palindrome uses maximal center => minimal -c\\n                c0 = -heap[0][0]\\n                curr = 2*(c0 - i + 1) - 1\\n            best_right[i] = curr if i == n-1 else max(best_right[i+1], curr)\\n\\n        # Maximize product over split\\n        ans = 0\\n        for i in range(n-1):\\n            ans = max(ans, best_left[i] * best_right[i+1])\\n        return ans\\n\"",
  "2090_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def countPaths(self, n, roads):\\n        mod = 10**9 + 7\\n        graph = [[] for _ in range(n)]\\n        for u, v, t in roads:\\n            graph[u].append((v, t))\\n            graph[v].append((u, t))\\n        \\n        dist = [float('inf')] * n\\n        ways = [0] * n\\n        dist[0] = 0\\n        ways[0] = 1\\n        \\n        heap = [(0, 0)]  # (time, node)\\n        \\n        while heap:\\n            time, node = heapq.heappop(heap)\\n            if time > dist[node]:\\n                continue\\n            for nei, t in graph[node]:\\n                new_time = time + t\\n                if new_time < dist[nei]:\\n                    dist[nei] = new_time\\n                    ways[nei] = ways[node]\\n                    heapq.heappush(heap, (new_time, nei))\\n                elif new_time == dist[nei]:\\n                    ways[nei] = (ways[nei] + ways[node]) % mod\\n        \\n        return ways[n - 1]\\n\"",
  "918_14631217_python-updated-time": "1746001763182",
  "1530_14631217_python": "\"class Solution:\\n    def checkIfCanBreak(self, s1, s2):\\n        s1_sorted = sorted(s1)\\n        s2_sorted = sorted(s2)\\n\\n        def can_break(a, b):\\n            return all(x >= y for x, y in zip(a, b))\\n\\n        return can_break(s1_sorted, s2_sorted) or can_break(s2_sorted, s1_sorted)\\n\"",
  "2184_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def possiblyEquals(self, s1, s2):\\n        \\\"\\\"\\\"\\n        Returns True if there exists an original string that can be encoded\\n        as both s1 and s2 according to the described rules.\\n        \\\"\\\"\\\"\\n        N1, N2 = len(s1), len(s2)\\n        # BFS state: (i, j, diff)\\n        seen = set()\\n        dq = deque([(0, 0, 0)])\\n        seen.add((0, 0, 0))\\n        \\n        while dq:\\n            i, j, diff = dq.popleft()\\n            # If both strings consumed and balanced, success\\n            if i == N1 and j == N2 and diff == 0:\\n                return True\\n            \\n            # diff == 0: align new letters or introduce skips\\n            if diff == 0:\\n                # match letters\\n                if i < N1 and j < N2 and s1[i].isalpha() and s2[j].isalpha():\\n                    if s1[i] == s2[j]:\\n                        state = (i+1, j+1, 0)\\n                        if state not in seen:\\n                            seen.add(state)\\n                            dq.append(state)\\n                # skip via number in s1\\n                if i < N1 and s1[i].isdigit():\\n                    num = 0\\n                    for k in range(i, min(N1, i+3)):\\n                        if s1[k].isdigit():\\n                            num = num*10 + int(s1[k])\\n                            state = (k+1, j, diff + num)\\n                            if state not in seen:\\n                                seen.add(state)\\n                                dq.append(state)\\n                        else:\\n                            break\\n                # skip via number in s2\\n                if j < N2 and s2[j].isdigit():\\n                    num = 0\\n                    for k in range(j, min(N2, j+3)):\\n                        if s2[k].isdigit():\\n                            num = num*10 + int(s2[k])\\n                            state = (i, k+1, diff - num)\\n                            if state not in seen:\\n                                seen.add(state)\\n                                dq.append(state)\\n                        else:\\n                            break\\n            \\n            # diff > 0: s1 is ahead, consume from s2\\n            elif diff > 0:\\n                # consume a letter from s2\\n                if j < N2 and s2[j].isalpha():\\n                    state = (i, j+1, diff-1)\\n                    if state not in seen:\\n                        seen.add(state)\\n                        dq.append(state)\\n                # consume via number in s2\\n                if j < N2 and s2[j].isdigit():\\n                    num = 0\\n                    for k in range(j, min(N2, j+3)):\\n                        if s2[k].isdigit():\\n                            num = num*10 + int(s2[k])\\n                            state = (i, k+1, diff - num)\\n                            if state not in seen:\\n                                seen.add(state)\\n                                dq.append(state)\\n                        else:\\n                            break\\n            \\n            # diff < 0: s2 is ahead, consume from s1\\n            else:\\n                # consume a letter from s1\\n                if i < N1 and s1[i].isalpha():\\n                    state = (i+1, j, diff+1)\\n                    if state not in seen:\\n                        seen.add(state)\\n                        dq.append(state)\\n                # consume via number in s1\\n                if i < N1 and s1[i].isdigit():\\n                    num = 0\\n                    for k in range(i, min(N1, i+3)):\\n                        if s1[k].isdigit():\\n                            num = num*10 + int(s1[k])\\n                            state = (k+1, j, diff + num)\\n                            if state not in seen:\\n                                seen.add(state)\\n                                dq.append(state)\\n                        else:\\n                            break\\n        \\n        return False\\n\"",
  "1044_14631217_python-updated-time": "1746040952783",
  "2067_14631217_python": "\"class Solution(object):\\n    def maxPoints(self, points):\\n        m = len(points)\\n        n = len(points[0])\\n        dp = points[0][:]\\n        for r in range(1, m):\\n            newDp = [0]*n\\n            best = float(\\\"-inf\\\")\\n            # left-to-right pass\\n            for c in range(n):\\n                best = max(best, dp[c] + c)\\n                newDp[c] = best - c + points[r][c]\\n            # right-to-left pass\\n            best = float(\\\"-inf\\\")\\n            for c in range(n-1, -1, -1):\\n                best = max(best, dp[c] - c)\\n                newDp[c] = max(newDp[c], best + c + points[r][c])\\n            dp = newDp\\n        return max(dp)\\n\"",
  "196_14631217_mysql-updated-time": "1745092949369",
  "2127_14631217_mysql": "\"SELECT \\n    e.employee_id\\nFROM \\n    Employees e\\nLEFT JOIN \\n    Employees m \\n    ON e.manager_id = m.employee_id\\nWHERE \\n    e.salary < 30000\\n    AND e.manager_id IS NOT NULL\\n    AND m.employee_id IS NULL\\nORDER BY \\n    e.employee_id;\\n\"",
  "1073_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def numEnclaves(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        q = deque()\\n        # enqueue all boundary land cells\\n        for i in range(m):\\n            for j in (0, n - 1):\\n                if grid[i][j] == 1:\\n                    q.append((i, j))\\n                    grid[i][j] = 0\\n        for j in range(n):\\n            for i in (0, m - 1):\\n                if grid[i][j] == 1:\\n                    q.append((i, j))\\n                    grid[i][j] = 0\\n        # BFS to erase all land reachable from boundary\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\\n                    grid[nx][ny] = 0\\n                    q.append((nx, ny))\\n        # count remaining land\\n        cnt = 0\\n        for row in grid:\\n            cnt += sum(row)\\n        return cnt\\n\"",
  "1839_14631217_python": "\"class Solution(object):\\n    def decode(self, encoded, first):\\n        \\\"\\\"\\\"\\n        :type encoded: List[int]\\n        :type first: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(encoded) + 1\\n        arr = [0] * n\\n        arr[0] = first\\n        for i in range(n - 1):\\n            arr[i + 1] = arr[i] ^ encoded[i]\\n        return arr\\n\"",
  "868_14631217_python": "\"class Solution(object):\\n    def pushDominoes(self, dominoes):\\n        n = len(dominoes)\\n        forces = [0] * n\\n        \\n        force = 0\\n        for i in range(n):\\n            if dominoes[i] == 'R':\\n                force = n\\n            elif dominoes[i] == 'L':\\n                force = 0\\n            else:\\n                force = max(force - 1, 0)\\n            forces[i] += force\\n        \\n        force = 0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == 'L':\\n                force = n\\n            elif dominoes[i] == 'R':\\n                force = 0\\n            else:\\n                force = max(force - 1, 0)\\n            forces[i] -= force\\n        \\n        res = []\\n        for f in forces:\\n            if f > 0:\\n                res.append('R')\\n            elif f < 0:\\n                res.append('L')\\n            else:\\n                res.append('.')\\n        \\n        return ''.join(res)\\n\"",
  "1436_14631217_python": "\"from collections import deque, Counter\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        n = len(friends)\\n        seen = set([id])\\n        queue = deque([id])\\n        for _ in range(level):\\n            for _ in range(len(queue)):\\n                curr = queue.popleft()\\n                for f in friends[curr]:\\n                    if f not in seen:\\n                        seen.add(f)\\n                        queue.append(f)\\n\\n        freq = Counter()\\n        for friend in queue:\\n            freq.update(watchedVideos[friend])\\n        \\n        return sorted(freq.keys(), key=lambda x: (freq[x], x))\\n\"",
  "2207_14631217_python-updated-time": "1746799833078",
  "2079_14631217_python-updated-time": "1746638711354",
  "2398_14631217_python": "\"class Solution:\\n    def checkXMatrix(self, grid):\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                val = grid[i][j]\\n                # On a diagonal?\\n                if i == j or i + j == n - 1:\\n                    if val == 0:\\n                        return False\\n                else:\\n                    if val != 0:\\n                        return False\\n        return True\\n\"",
  "3310_14631217_python": "\"class Solution(object):\\n    def countOfPairs(self, n, x, y):\\n        # same-house shortcut ⇒ simple line\\n        if x == y:\\n            return [(n - k) * 2 for k in xrange(1, n + 1)]\\n\\n        # keep  x < y\\n        if x > y:\\n            x, y = y, x\\n\\n        # unordered baseline: pure line\\n        cnt = [n - d for d in xrange(1, n)] + [0]\\n\\n        a, b       = x, y          # chord endpoints (a < b)\\n        mid_limit  = (a + b - 2) // 2      # max i we need to look at\\n\\n        add = [0] * (n + 2)        # range-adds for new   distances\\n        sub = [0] * (n + 2)        # range-subs for old   distances\\n\\n        for i in xrange(1, mid_limit + 1):\\n            A = abs(i - a) + 1     # fixed prefix length to reach the chord\\n\\n            # ---- j  ≥  b  ----------------------------------------------\\n            k1, k2 = A, A + (n - b)        # new-distance range\\n            d1, d2 = b - i, n - i          # old-distance range\\n            add[k1]           += 1\\n            add[min(k2 + 1, n + 1)] -= 1\\n            sub[d1]           += 1\\n            sub[d2 + 1]       -= 1\\n\\n            # ---- i+1 ≤ j < b  (but large enough to make the shortcut best)\\n            thresh  = (i + b + A) // 2 + 1\\n            j_low   = max(i + 1, thresh)\\n            if j_low < b:\\n                k_low, k_high = A + 1, A + b - j_low\\n                d_low, d_high = j_low - i, (b - 1) - i\\n                add[k_low]                += 1\\n                add[min(k_high + 1, n + 1)] -= 1\\n                sub[d_low]                += 1\\n                sub[d_high + 1]           -= 1\\n\\n        # apply the difference arrays\\n        cur = 0\\n        for k in xrange(1, n + 1):\\n            cur += add[k]\\n            cnt[k - 1] += cur\\n        cur = 0\\n        for k in xrange(1, n + 1):\\n            cur += sub[k]\\n            cnt[k - 1] -= cur\\n\\n        # convert unordered → ordered\\n        return [v * 2 for v in cnt]\\n\"",
  "3528_14631217_python-updated-time": "1747571235916",
  "2764_14631217_python": "\"class Solution(object):\\n    def findMaxFish(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False]*n for _ in range(m)]\\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        def dfs(r, c):\\n            stack = [(r, c)]\\n            visited[r][c] = True\\n            total = 0\\n            while stack:\\n                x, y = stack.pop()\\n                total += grid[x][y]\\n                for dx, dy in dirs:\\n                    nx, ny = x+dx, y+dy\\n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] > 0:\\n                        visited[nx][ny] = True\\n                        stack.append((nx, ny))\\n            return total\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0 and not visited[i][j]:\\n                    max_fish = max(max_fish, dfs(i, j))\\n        return max_fish\"",
  "774_14631217_python-updated-time": "1745447598594",
  "628_14631217_python-updated-time": "1745782160515",
  "2222_14631217_python-updated-time": "1746801648391",
  "2625_14631217_python": "\"class Solution:\\n    def rangeAddQueries(self, n, queries):\\n        # Initialize difference matrix with 0s\\n        diff = [[0] * (n + 1) for _ in range(n + 1)]\\n\\n        # Step 1: Apply difference array updates\\n        for r1, c1, r2, c2 in queries:\\n            diff[r1][c1] += 1\\n            if c2 + 1 < n:\\n                diff[r1][c2 + 1] -= 1\\n            if r2 + 1 < n:\\n                diff[r2 + 1][c1] -= 1\\n            if r2 + 1 < n and c2 + 1 < n:\\n                diff[r2 + 1][c2 + 1] += 1\\n\\n        # Step 2: Convert to prefix sums across rows\\n        for i in range(n):\\n            for j in range(1, n):\\n                diff[i][j] += diff[i][j - 1]\\n\\n        # Step 3: Convert to prefix sums down columns\\n        for j in range(n):\\n            for i in range(1, n):\\n                diff[i][j] += diff[i - 1][j]\\n\\n        # Step 4: Trim to n x n result\\n        return [diff[i][:n] for i in range(n)]\\n\"",
  "3271_14631217_python-updated-time": "1747400421263",
  "275_14631217_python": "\"class Solution(object):\\n    def hIndex(self, citations):\\n        \\\"\\\"\\\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return citations[mid]\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return n - left\\n\"",
  "2598_14631217_python-updated-time": "1747059465633",
  "1304_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def longestDiverseString(self, a, b, c):\\n        max_heap = []\\n        for count, char in [(-a, 'a'), (-b, 'b'), (-c, 'c')]:\\n            if count != 0:\\n                heapq.heappush(max_heap, (count, char))\\n\\n        result = []\\n\\n        while max_heap:\\n            count1, char1 = heapq.heappop(max_heap)\\n\\n            if len(result) >= 2 and result[-1] == result[-2] == char1:\\n                if not max_heap:\\n                    break\\n                count2, char2 = heapq.heappop(max_heap)\\n                result.append(char2)\\n                count2 += 1\\n                if count2 != 0:\\n                    heapq.heappush(max_heap, (count2, char2))\\n                heapq.heappush(max_heap, (count1, char1))\\n            else:\\n                result.append(char1)\\n                count1 += 1\\n                if count1 != 0:\\n                    heapq.heappush(max_heap, (count1, char1))\\n\\n        return ''.join(result)\\n\"",
  "3475_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        ops = 0\\n        \\n        # Walk from i=0 up to i=n-3.\\n        # Whenever nums[i] is 0, we flip [i, i+1, i+2].\\n        for i in range(n-2):\\n            if nums[i] == 0:\\n                # perform the flip\\n                nums[i]   ^= 1\\n                nums[i+1] ^= 1\\n                nums[i+2] ^= 1\\n                ops += 1\\n        \\n        # After that, positions n-2 and n-1 cannot be changed again.\\n        # If either is 0, it's impossible.\\n        if nums[-2] == 0 or nums[-1] == 0:\\n            return -1\\n        return ops\\n\"",
  "2096_14631217_python": "\"from bisect import bisect_right\\n\\nclass Solution(object):\\n    def longestObstacleCourseAtEachPosition(self, obstacles):\\n        dp = []\\n        ans = []\\n        for x in obstacles:\\n            # find length of longest non-decreasing subsequence ending here\\n            pos = bisect_right(dp, x)\\n            if pos == len(dp):\\n                dp.append(x)\\n            else:\\n                dp[pos] = x\\n            ans.append(pos + 1)\\n        return ans\\n\"",
  "1114_14631217_python-updated-time": "1746042462926",
  "258_14631217_python-updated-time": "1745247833844",
  "1689_14631217_python": "\"class Solution(object):\\n    def containsPattern(self, arr, m, k):\\n        n = len(arr)\\n        for i in range(n - m * k + 1):\\n            pattern = arr[i:i+m]\\n            count = 1\\n            for j in range(i + m, n, m):\\n                if arr[j:j+m] == pattern:\\n                    count += 1\\n                    if count >= k:\\n                        return True\\n                else:\\n                    break\\n        return False\\n\"",
  "3858_14631217_python-updated-time": "1747744315358",
  "763_14631217_python-updated-time": "1745875954310",
  "831_14631217_python-updated-time": "1745878637363",
  "640_14631217_python-updated-time": "1745782439230",
  "2270_14631217_python-updated-time": "1746802675076",
  "2733_14631217_javascript": "\"async function sleep(millis) {\\n  return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\"",
  "2088_14631217_python-updated-time": "1746715245339",
  "1289_14631217_python-updated-time": "1746126548961",
  "3588_14631217_python-updated-time": "1747578435035",
  "842_14631217_python-updated-time": "1745879057273",
  "921_14631217_python-updated-time": "1746001872589",
  "3277_14631217_python-updated-time": "1747413283249",
  "3581_14631217_python": "\"class Solution(object):\\n    def getSneakyNumbers(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        count = [0] * 100  # since 0 <= nums[i] < n <= 100\\n        res = []\\n        for num in nums:\\n            count[num] += 1\\n            if count[num] == 2:\\n                res.append(num)\\n                if len(res) == 2:\\n                    break\\n        return res\\n\"",
  "2707_14631217_python": "\"class Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        i, j = 0, 0\\n        res = []\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i][0] == nums2[j][0]:\\n                res.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\\n                i += 1\\n                j += 1\\n            elif nums1[i][0] < nums2[j][0]:\\n                res.append(nums1[i])\\n                i += 1\\n            else:\\n                res.append(nums2[j])\\n                j += 1\\n        while i < len(nums1):\\n            res.append(nums1[i])\\n            i += 1\\n        while j < len(nums2):\\n            res.append(nums2[j])\\n            j += 1\\n        return res\\n\"",
  "2340_14631217_python-updated-time": "1746880597915",
  "2175_14631217_python-updated-time": "1746720248688",
  "3193_14631217_python": "\"class Solution(object):\\n    def maximumStrongPairXor(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        max_xor = 0\\n        \\n        for i in range(n):\\n            x = nums[i]\\n            for j in range(n):\\n                y = nums[j]\\n                # check strong pair: |x - y| <= min(x, y)\\n                if abs(x - y) <= min(x, y):\\n                    max_xor = max(max_xor, x ^ y)\\n        \\n        return max_xor\"",
  "1986_14631217_python-updated-time": "1746624999038",
  "389_14631217_python": "\"class Solution:\\n    def findTheDifference(self, s, t):\\n        res = 0\\n        for c in s + t:\\n            res ^= ord(c)\\n        return chr(res)\\n\"",
  "3452_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # If k is large enough, we can take the whole array.\\n        if k >= n - 1:\\n            return n\\n\\n        # 1) Compress values to 0..d-1\\n        uniq = {}\\n        comp = []\\n        for x in nums:\\n            if x not in uniq:\\n                uniq[x] = len(uniq)\\n            comp.append(uniq[x])\\n        d = len(uniq)\\n\\n        # 2) dp[t][v] = best subseq length ending with value v using <= t transitions\\n        # Initialize all 0.\\n        dp = [[0] * d for _ in range(k + 1)]\\n\\n        # For each t, track the best and second-best dp[t][*] and which value achieves them.\\n        best1_dp = [0] * (k + 1)\\n        best1_val = [-1] * (k + 1)\\n        best2_dp = [0] * (k + 1)\\n        best2_val = [-1] * (k + 1)\\n\\n        # 3) Sweep through the array\\n        for v in comp:\\n            # process transitions in descending order\\n            for t in range(k, -1, -1):\\n                old = dp[t][v]\\n                # (a) extend same-value chain (no new transition)\\n                cand = old + 1\\n\\n                # (b) or extend best different-value chain from dp[t-1] (one new transition)\\n                if t > 0:\\n                    # pick the top dp[t-1] unless it came from v, in which case pick the runner-up\\n                    if best1_val[t-1] != v:\\n                        other_best = best1_dp[t-1]\\n                    else:\\n                        other_best = best2_dp[t-1]\\n                    cand = max(cand, other_best + 1)\\n\\n                # update dp[t][v]\\n                dp[t][v] = cand\\n\\n                # 4) update the best1/2 trackers for level t\\n                if best1_val[t] == v:\\n                    # we just improved the existing champion\\n                    best1_dp[t] = cand\\n                else:\\n                    if cand > best1_dp[t]:\\n                        # new champ pushes the old champ to runner-up\\n                        best2_dp[t] = best1_dp[t]\\n                        best2_val[t] = best1_val[t]\\n                        best1_dp[t] = cand\\n                        best1_val[t] = v\\n                    elif cand > best2_dp[t]:\\n                        # new runner-up\\n                        best2_dp[t] = cand\\n                        best2_val[t] = v\\n\\n        # The best you can do with <= k transitions is the top dp[k][*].\\n        return best1_dp[k]\\n\"",
  "623_14631217_python-updated-time": "1745780742572",
  "1727_14631217_python": "\"class Solution:\\n    def canMouseWin(self, grid, catJump, mouseJump):\\n        from collections import deque, defaultdict\\n\\n        rows, cols = len(grid), len(grid[0])\\n        MOUSE_TURN, CAT_TURN = 0, 1\\n        MOUSE_WIN, CAT_WIN, UNKNOWN = 1, 2, 0\\n\\n        # 1) Collect all free cells and map to indices 0..P-1\\n        idx = {}\\n        cells = []\\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] != '#':\\n                    idx[(r, c)] = len(cells)\\n                    cells.append((r, c))\\n\\n        P = len(cells)\\n\\n        # 2) Find starts and food\\n        for (r, c), i in idx.items():\\n            if grid[r][c] == 'M':\\n                mouse_start = i\\n            elif grid[r][c] == 'C':\\n                cat_start = i\\n            elif grid[r][c] == 'F':\\n                food = i\\n\\n        # 3) Precompute moves for mouse and cat from each cell\\n        DIRS = [(-1,0),(1,0),(0,-1),(0,1)]\\n        def build_moves(jump):\\n            nxt = [[] for _ in range(P)]\\n            prev = [[] for _ in range(P)]\\n            for i, (r0, c0) in enumerate(cells):\\n                # staying in place is allowed\\n                nxt[i].append(i)\\n                for dr, dc in DIRS:\\n                    for step in range(1, jump+1):\\n                        r, c = r0+dr*step, c0+dc*step\\n                        if 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#':\\n                            j = idx[(r,c)]\\n                            nxt[i].append(j)\\n                        else:\\n                            break\\n                # we'll fill prev later\\n            for i in range(P):\\n                for j in nxt[i]:\\n                    prev[j].append(i)\\n            return nxt, prev\\n\\n        mouse_nxt, mouse_prev = build_moves(mouseJump)\\n        cat_nxt,   cat_prev   = build_moves(catJump)\\n\\n        # 4) degree[m][c][turn] = number of moves possible from that state\\n        degree = [[[0,0] for _ in range(P)] for __ in range(P)]\\n        for m in range(P):\\n            for c in range(P):\\n                degree[m][c][MOUSE_TURN] = len(mouse_nxt[m])\\n                degree[m][c][CAT_TURN]   = len(cat_nxt[c])\\n\\n        # 5) result[m][c][turn] = UNKNOWN/MOUSE_WIN/CAT_WIN\\n        result = [[[UNKNOWN, UNKNOWN] for _ in range(P)] for __ in range(P)]\\n        q = deque()\\n\\n        # 6) Initialize terminal states\\n        for m in range(P):\\n            for c in range(P):\\n                for t in (MOUSE_TURN, CAT_TURN):\\n                    if m == c:\\n                        result[m][c][t] = CAT_WIN\\n                        q.append((m, c, t, CAT_WIN))\\n                    elif c == food:\\n                        result[m][c][t] = CAT_WIN\\n                        q.append((m, c, t, CAT_WIN))\\n                    elif m == food:\\n                        result[m][c][t] = MOUSE_WIN\\n                        q.append((m, c, t, MOUSE_WIN))\\n\\n        # 7) BFS retrograde propagation\\n        while q:\\n            m, c, turn, winner = q.popleft()\\n            # whose turn it was to move to get to (m,c,turn)?\\n            prev_turn = CAT_TURN if turn == MOUSE_TURN else MOUSE_TURN\\n\\n            if prev_turn == MOUSE_TURN:\\n                # we came from a mouse move → cat_pos same, mouse_pos was one of mouse_prev[m]\\n                for pm in mouse_prev[m]:\\n                    if result[pm][c][prev_turn] != UNKNOWN:\\n                        continue\\n                    # If mouse just moved to a state that is MOUSE_WIN, mouse would choose it\\n                    if winner == MOUSE_WIN:\\n                        result[pm][c][prev_turn] = MOUSE_WIN\\n                        q.append((pm, c, prev_turn, MOUSE_WIN))\\n                    else:\\n                        # Every mouse move leads to CAT_WIN?\\n                        degree[pm][c][prev_turn] -= 1\\n                        if degree[pm][c][prev_turn] == 0:\\n                            result[pm][c][prev_turn] = CAT_WIN\\n                            q.append((pm, c, prev_turn, CAT_WIN))\\n            else:\\n                # prev_turn == CAT_TURN\\n                # we came from a cat move → mouse_pos same, cat_pos was one of cat_prev[c]\\n                for pc in cat_prev[c]:\\n                    if result[m][pc][prev_turn] != UNKNOWN:\\n                        continue\\n                    # If cat just moved to a state that is CAT_WIN, cat would choose it\\n                    if winner == CAT_WIN:\\n                        result[m][pc][prev_turn] = CAT_WIN\\n                        q.append((m, pc, prev_turn, CAT_WIN))\\n                    else:\\n                        # Every cat move leads to MOUSE_WIN?\\n                        degree[m][pc][prev_turn] -= 1\\n                        if degree[m][pc][prev_turn] == 0:\\n                            result[m][pc][prev_turn] = MOUSE_WIN\\n                            q.append((m, pc, prev_turn, MOUSE_WIN))\\n\\n        # 8) Finally, starting from Mouse’s turn at the initial positions:\\n        return result[mouse_start][cat_start][MOUSE_TURN] == MOUSE_WIN\\n\"",
  "3426_14631217_python-updated-time": "1747483949309",
  "47_14631217_python": "\"class Solution(object):\\n    def permuteUnique(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n        nums.sort()\\n        used = [False] * len(nums)\\n\\n        def backtrack(path):\\n            if len(path) == len(nums):\\n                res.append(list(path))\\n                return\\n            for i in range(len(nums)):\\n                if used[i]:\\n                    continue\\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\\n                    continue\\n                used[i] = True\\n                backtrack(path + [nums[i]])\\n                used[i] = False\\n\\n        backtrack([])\\n        return res\\n\"",
  "2765_14631217_python-updated-time": "1747136835171",
  "3375_14631217_python": "\"class Solution(object):\\n    def findKthSmallest(self, coins, k):\\n        \\\"\\\"\\\"\\n        :type coins: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # simple gcd\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        m = len(coins)\\n        N = 1 << m\\n\\n        # Precompute LCM for each nonempty subset\\n        lcm_mask = [1] * N\\n        for mask in range(1, N):\\n            lb = mask & -mask\\n            j = lb.bit_length() - 1\\n            prev = mask ^ lb\\n            l = lcm_mask[prev]\\n            c = coins[j]\\n            # lcm(l, c) = l // gcd(l,c) * c\\n            lcm_mask[mask] = l // gcd(l, c) * c\\n\\n        # Count how many distinct multiples ≤ X via inclusion-exclusion\\n        def count_upto(X):\\n            total = 0\\n            for mask in range(1, N):\\n                l = lcm_mask[mask]\\n                if l <= X:\\n                    cnt = X // l\\n                    if bin(mask).count(\\\"1\\\") & 1:\\n                        total += cnt\\n                    else:\\n                        total -= cnt\\n            return total\\n\\n        # Binary search for the minimal X with count_upto(X) ≥ k\\n        lo, hi = 1, k * min(coins)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if count_upto(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n\"",
  "1526_14631217_python-updated-time": "1746346669104",
  "global_lang-updated-time": "1746109018450",
  "691_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def minStickers(self, stickers, target):\\n        m = len(stickers)\\n        sticker_count = [Counter(sticker) for sticker in stickers]\\n        memo = {}\\n        \\n        def dfs(remain):\\n            if remain == \\\"\\\":\\n                return 0\\n            if remain in memo:\\n                return memo[remain]\\n            \\n            remain_count = Counter(remain)\\n            res = float('inf')\\n            for sc in sticker_count:\\n                if remain[0] not in sc:\\n                    continue\\n                new_remain = \\\"\\\"\\n                for c in remain_count:\\n                    if remain_count[c] > sc[c]:\\n                        new_remain += (c * (remain_count[c] - sc[c]))\\n                tmp = dfs(new_remain)\\n                if tmp != -1:\\n                    res = min(res, 1 + tmp)\\n            \\n            memo[remain] = -1 if res == float('inf') else res\\n            return memo[remain]\\n        \\n        return dfs(target)\\n\"",
  "606_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def tree2str(self, t):\\n        \\\"\\\"\\\"\\n        :type t: TreeNode\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if not t:\\n            return \\\"\\\"\\n        \\n        s = str(t.val)\\n        \\n        # If there is a right child but no left child, we need \\\"()\\\"\\n        if not t.left and t.right:\\n            s += \\\"()\\\"\\n        \\n        # Recurse on left child if exists\\n        if t.left:\\n            s += \\\"(\\\" + self.tree2str(t.left) + \\\")\\\"\\n        \\n        # Recurse on right child if exists\\n        if t.right:\\n            s += \\\"(\\\" + self.tree2str(t.right) + \\\")\\\"\\n        \\n        return s\\n\"",
  "108_14631217_python-updated-time": "1745081186570",
  "3675_14631217_python": "\"class Solution(object):\\n    def maximizeSumOfWeights(self, edges, k):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import sys\\n        sys.setrecursionlimit(10**7)\\n\\n        n = len(edges) + 1\\n        # build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n\\n        # dp[u] will be a pair (f0, f1):\\n        #   f0 = max total in subtree u if we DO NOT keep the edge up to u's parent\\n        #        ⇒ u may keep up to k edges to its children\\n        #   f1 = max total if we DO keep the edge up to its parent\\n        #        ⇒ u may keep up to (k-1) edges to its children\\n        def dfs(u, parent):\\n            base = 0\\n            gains = []\\n            # process children\\n            for v, w in adj[u]:\\n                if v == parent:\\n                    continue\\n                f0_v, f1_v = dfs(v, u)\\n                # if we cut u–v, we get f0_v\\n                base += f0_v\\n                # if we keep u–v, we get (f1_v + w) instead\\n                gains.append((f1_v + w) - f0_v)\\n\\n            # sort descending by marginal gain of keeping that child‐edge\\n            gains.sort(reverse=True)\\n\\n            # helper to sum top t positive gains\\n            def top_sum(t):\\n                s = 0\\n                for i in range(min(t, len(gains))):\\n                    if gains[i] > 0:\\n                        s += gains[i]\\n                    else:\\n                        break\\n                return s\\n\\n            # f0: no parent‐edge kept ⇒ can keep up to k children\\n            f0 = base + top_sum(k)\\n            # f1: parent‐edge is kept ⇒ can only keep up to k-1 children\\n            f1 = base + top_sum(k-1)\\n\\n            return f0, f1\\n\\n        # pick node 0 as root; we have no parent‐edge, so the answer is f0(0)\\n        answer, _ = dfs(0, -1)\\n        return answer\\n\"",
  "2106_14631217_python": "\"class Solution:\\n    def findGCD(self, nums):\\n        a = min(nums)\\n        b = max(nums)\\n        while b:\\n            a, b = b, a % b\\n        return a\\n\"",
  "1913_14631217_python-updated-time": "1746542601504",
  "2134_14631217_python-updated-time": "1746719440002",
  "3581_14631217_python-updated-time": "1747571793836",
  "494_14631217_python-updated-time": "1745445934794",
  "2788_14631217_javascript": "\"function cancellable(gen) {\\n  let cancelReject;\\n  let finished = false;\\n\\n  // A promise that rejects when cancel() is called\\n  const cancelPromise = new Promise((_, rej) => {\\n    cancelReject = () => {\\n      if (!finished) rej(\\\"Cancelled\\\");\\n    };\\n  });\\n\\n  // Drive the generator, wiring each yielded promise through Promise.race\\n  const driver = new Promise((resolve, reject) => {\\n    function step(nextF, arg) {\\n      let result;\\n      try {\\n        result = nextF.call(gen, arg); // either gen.next(arg) or gen.throw(arg)\\n      } catch (err) {\\n        finished = true;\\n        return reject(err);\\n      }\\n      handleResult(result);\\n    }\\n\\n    function handleResult({ value, done }) {\\n      if (done) {\\n        finished = true;\\n        return resolve(value);\\n      }\\n      // value is assumed to be a Promise\\n      Promise.race([value, cancelPromise])\\n        .then(\\n          v => step(gen.next, v),\\n          err => {\\n            if (err === \\\"Cancelled\\\") {\\n              // inject cancellation into the generator\\n              try {\\n                step(gen.throw, \\\"Cancelled\\\");\\n              } catch (e) {\\n                finished = true;\\n                reject(e);\\n              }\\n            } else {\\n              // inject actual error into the generator\\n              try {\\n                step(gen.throw, err);\\n              } catch (e) {\\n                finished = true;\\n                reject(e);\\n              }\\n            }\\n          }\\n        );\\n    }\\n\\n    // kick off\\n    step(gen.next);\\n  });\\n\\n  return [\\n    () => cancelReject(), // the cancel function\\n    driver               // the promise that resolves/rejects per spec\\n  ];\\n}\\n\\n// -- Example Usage --\\n\\n// Example 3 from the prompt:\\nfunction* tasks() {\\n  const val = yield new Promise(res => res(2 + 2));\\n  yield new Promise(res => setTimeout(res, 100));\\n  return val + 1; // shouldn't execute if cancelled early\\n}\\n\\nconst [cancel, p] = cancellable(tasks());\\nsetTimeout(cancel, 50);\\n\\np.catch(console.log); // logs \\\"Cancelled\\\" at ~50ms\\n\"",
  "3344_14631217_python": "\"class Solution(object):\\n    def minimumDistance(self, points):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(points)\\n        # Precompute transformed coords\\n        u = [x + y for x, y in points]\\n        v = [x - y for x, y in points]\\n        \\n        # Find max_u, second_max_u, count_max_u\\n        max_u = -10**30\\n        second_max_u = -10**30\\n        count_max_u = 0\\n        \\n        # Find min_u, second_min_u, count_min_u\\n        min_u = 10**30\\n        second_min_u = 10**30\\n        count_min_u = 0\\n        \\n        for val in u:\\n            # max\\n            if val > max_u:\\n                second_max_u = max_u\\n                max_u = val\\n                count_max_u = 1\\n            elif val == max_u:\\n                count_max_u += 1\\n            elif val > second_max_u:\\n                second_max_u = val\\n            \\n            # min\\n            if val < min_u:\\n                second_min_u = min_u\\n                min_u = val\\n                count_min_u = 1\\n            elif val == min_u:\\n                count_min_u += 1\\n            elif val < second_min_u:\\n                second_min_u = val\\n        \\n        # Same for v\\n        max_v = -10**30\\n        second_max_v = -10**30\\n        count_max_v = 0\\n        \\n        min_v = 10**30\\n        second_min_v = 10**30\\n        count_min_v = 0\\n        \\n        for val in v:\\n            if val > max_v:\\n                second_max_v = max_v\\n                max_v = val\\n                count_max_v = 1\\n            elif val == max_v:\\n                count_max_v += 1\\n            elif val > second_max_v:\\n                second_max_v = val\\n            \\n            if val < min_v:\\n                second_min_v = min_v\\n                min_v = val\\n                count_min_v = 1\\n            elif val == min_v:\\n                count_min_v += 1\\n            elif val < second_min_v:\\n                second_min_v = val\\n        \\n        # Now try removing each point\\n        ans = float('inf')\\n        for i in range(n):\\n            # Compute new u-range\\n            ui = u[i]\\n            if ui == max_u and count_max_u == 1:\\n                new_max_u = second_max_u\\n            else:\\n                new_max_u = max_u\\n            \\n            if ui == min_u and count_min_u == 1:\\n                new_min_u = second_min_u\\n            else:\\n                new_min_u = min_u\\n            \\n            A_i = new_max_u - new_min_u\\n            \\n            # Compute new v-range\\n            vi = v[i]\\n            if vi == max_v and count_max_v == 1:\\n                new_max_v = second_max_v\\n            else:\\n                new_max_v = max_v\\n            \\n            if vi == min_v and count_min_v == 1:\\n                new_min_v = second_min_v\\n            else:\\n                new_min_v = min_v\\n            \\n            B_i = new_max_v - new_min_v\\n            \\n            D_i = max(A_i, B_i)\\n            if D_i < ans:\\n                ans = D_i\\n        \\n        return ans\\n\"",
  "3684_14631217_python": "\"class Solution(object):\\n    def hasMatch(self, s, p):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # Split p = A * B\\n        star = p.index('*')\\n        A = p[:star]\\n        B = p[star+1:]\\n        n, m = len(s), len(B)\\n        \\n        # Special‐cases: if A and B are both empty then \\\"*\\\" matches the empty substring\\n        if not A and not B:\\n            return True\\n        \\n        # Gather all positions where B occurs in s\\n        # (if B is empty, every position i in [0..n] is a valid \\\"end of suffix\\\")\\n        posB = []\\n        if B:\\n            for j in range(n - len(B) + 1):\\n                if s[j:j+len(B)] == B:\\n                    posB.append(j)\\n        else:\\n            # Treat suffix‐match (empty B) as valid at every j from 0..n\\n            posB = list(range(n+1))\\n        \\n        # Now look for A somewhere before one of those B‐matches:\\n        #   find an index i where s[i:i+len(A)] == A\\n        #   and there exists j in posB with j >= i+len(A)\\n        if A:\\n            for i in range(n - len(A) + 1):\\n                if s[i:i+len(A)] == A:\\n                    # We need some j ≥ i + len(A)\\n                    # Since posB is small (≤ 50), just linear‐scan:\\n                    for j in posB:\\n                        if j >= i + len(A):\\n                            return True\\n            return False\\n        else:\\n            # A is empty, so we only need B to occur somewhere (we already found posB)\\n            return bool(posB)\\n\"",
  "725_14631217_python-updated-time": "1745786906163",
  "3781_14631217_python-updated-time": "1747759335862",
  "1953_14631217_python": "\"import math\\nimport bisect\\nfrom collections import deque\\n\\nclass SortedListWithSum:\\n    def __init__(self):\\n        self.size = 0\\n        self.buckets = []\\n        self.bucket_sums = []\\n\\n    def _build(self, a=None):\\n        if a is None:\\n            a = list(self)\\n        a.sort()\\n        self.size = len(a)\\n        if self.size == 0:\\n            self.buckets = []\\n            self.bucket_sums = []\\n            return\\n        b = int(math.ceil(math.sqrt(self.size)))\\n        self.buckets = [a[i:i+b] for i in range(0, self.size, b)]\\n        self.bucket_sums = [sum(bucket) for bucket in self.buckets]\\n\\n    def _find_bucket(self, x):\\n        for i, bucket in enumerate(self.buckets):\\n            if x <= bucket[-1]:\\n                return i, bucket\\n        return len(self.buckets) - 1, self.buckets[-1]\\n\\n    def add(self, x):\\n        if self.size == 0:\\n            self.buckets = [[x]]\\n            self.bucket_sums = [x]\\n            self.size = 1\\n            return\\n        i, bucket = self._find_bucket(x)\\n        pos = bisect.bisect_left(bucket, x)\\n        bucket.insert(pos, x)\\n        self.bucket_sums[i] += x\\n        self.size += 1\\n        if len(bucket) > len(self.buckets) * 50:\\n            self._build()\\n\\n    def discard(self, x):\\n        if self.size == 0:\\n            return False\\n        i, bucket = self._find_bucket(x)\\n        pos = bisect.bisect_left(bucket, x)\\n        if pos < len(bucket) and bucket[pos] == x:\\n            bucket.pop(pos)\\n            self.bucket_sums[i] -= x\\n            self.size -= 1\\n            if not bucket:\\n                self._build()\\n            return True\\n        return False\\n\\n    def __iter__(self):\\n        for bucket in self.buckets:\\n            for x in bucket:\\n                yield x\\n\\n    def prefix_sum(self, k):\\n        res = 0\\n        cnt = k\\n        for bucket, s in zip(self.buckets, self.bucket_sums):\\n            if cnt <= 0:\\n                break\\n            if len(bucket) <= cnt:\\n                res += s\\n                cnt -= len(bucket)\\n            else:\\n                for i in range(cnt):\\n                    res += bucket[i]\\n                break\\n        return res\\n\\nclass MKAverage(object):\\n    def __init__(self, m, k):\\n        self.m = m\\n        self.k = k\\n        self.queue = deque()\\n        self.sl = SortedListWithSum()\\n        self.total = 0\\n\\n    def addElement(self, num):\\n        self.queue.append(num)\\n        self.sl.add(num)\\n        self.total += num\\n        if len(self.queue) > self.m:\\n            old = self.queue.popleft()\\n            self.sl.discard(old)\\n            self.total -= old\\n\\n    def calculateMKAverage(self):\\n        if len(self.queue) < self.m:\\n            return -1\\n        sum_small = self.sl.prefix_sum(self.k)\\n        sum_mid = self.sl.prefix_sum(self.m - self.k) - sum_small\\n        cnt = self.m - 2*self.k\\n        return sum_mid // cnt\\n\"",
  "3788_14631217_python": "\"class Solution(object):\\n    def maxSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sum each positive value exactly once:\\n        total = sum({x for x in nums if x > 0})\\n        if total > 0:\\n            return total\\n        # Otherwise no positives – pick the single largest element\\n        return max(nums)\\n\"",
  "2791_14631217_python-updated-time": "1747138507955",
  "2648_14631217_python": "\"class Solution(object):\\n    def waysToReachTarget(self, target, types):\\n        MOD = 10**9 + 7\\n        # dp[s] = #ways to reach sum s using processed types\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n\\n        for count, val in types:\\n            new_dp = [0] * (target + 1)\\n            # for each achievable sum s so far...\\n            for s in xrange(target + 1):\\n                ways = dp[s]\\n                if ways:\\n                    # try taking k questions of this type, 0 <= k <= count\\n                    for k in xrange(count + 1):\\n                        t = s + k * val\\n                        if t > target:\\n                            break\\n                        new_dp[t] = (new_dp[t] + ways) % MOD\\n            dp = new_dp\\n\\n        return dp[target]\\n\"",
  "1253_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def diagonalSort(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        diagonals = defaultdict(list)\\n        \\n        # Collect values of each diagonal keyed by (i - j)\\n        for i in range(m):\\n            for j in range(n):\\n                diagonals[i - j].append(mat[i][j])\\n        \\n        # Sort each diagonal's list in reverse to pop smallest efficiently\\n        for key in diagonals:\\n            diagonals[key].sort(reverse=True)\\n        \\n        # Write back the sorted values\\n        for i in range(m):\\n            for j in range(n):\\n                mat[i][j] = diagonals[i - j].pop()\\n        \\n        return mat\\n\"",
  "2696_14631217_python-updated-time": "1747133644887",
  "2250_14631217_python-updated-time": "1746802343541",
  "3563_14631217_python-updated-time": "1747570634841",
  "1401_14631217_python-updated-time": "1746260077621",
  "3186_14631217_python-updated-time": "1747307888560",
  "621_14631217_python": "\"class Solution(object):\\n    def leastInterval(self, tasks, n):\\n        from collections import Counter\\n        counts = Counter(tasks)\\n        max_count = max(counts.values())\\n        max_freq = list(counts.values()).count(max_count)\\n        return max(len(tasks), (max_count - 1) * (n + 1) + max_freq)\\n\"",
  "3170_14631217_python-updated-time": "1747307716367",
  "412_14631217_python-updated-time": "1745356164809",
  "3321_14631217_python": "\"class Solution(object):\\n    def triangleType(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        a, b, c = sorted(nums)\\n        if a + b <= c:\\n            return \\\"none\\\"\\n        if a == b == c:\\n            return \\\"equilateral\\\"\\n        if a == b or b == c or a == c:\\n            return \\\"isosceles\\\"\\n        return \\\"scalene\\\"\\n\"",
  "notification-status:numUnread": "0",
  "2137_14631217_python-updated-time": "1746718104054",
  "2397_14631217_python-updated-time": "1746883154447",
  "2748_14631217_python-updated-time": "1747136317782",
  "3353_14631217_python": "\"class Solution(object):\\n    def isSubstringPresent(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        if n < 2:\\n            return False\\n        \\n        rev = s[::-1]\\n        seen = set(rev[i:i+2] for i in range(n-1))\\n        \\n        for i in range(n-1):\\n            if s[i:i+2] in seen:\\n                return True\\n        \\n        return False\\n\"",
  "1264_14631217_python": "\"class Solution(object):\\n    def canBeTypedWords(self, text, brokenLetters):\\n        broken = set(brokenLetters)\\n        count = 0\\n        for word in text.split():\\n            if not broken.intersection(word):\\n                count += 1\\n        return count\\n\"",
  "1533_14631217_python": "\"class Solution(object):\\n    def displayTable(self, orders):\\n        from collections import defaultdict\\n\\n        table_orders = defaultdict(lambda: defaultdict(int))\\n        food_items = set()\\n\\n        # Collect orders\\n        for customer, table, food in orders:\\n            table_orders[int(table)][food] += 1\\n            food_items.add(food)\\n\\n        # Sort food items alphabetically\\n        sorted_food = sorted(food_items)\\n        result = [[\\\"Table\\\"] + sorted_food]\\n\\n        # Sort table numbers numerically\\n        for table in sorted(table_orders):\\n            row = [str(table)]\\n            for food in sorted_food:\\n                row.append(str(table_orders[table][food]))\\n            result.append(row)\\n\\n        return result\\n\"",
  "564_14631217_python": "\"class Solution(object):\\n    def nearestPalindromic(self, n):\\n        k = len(n)\\n        orig = int(n)\\n        candidates = set([\\n            str(10**(k-1) - 1),\\n            str(10**k + 1)\\n        ])\\n        prefix_len = (k + 1) // 2\\n        prefix = int(n[:prefix_len])\\n        for x in (prefix - 1, prefix, prefix + 1):\\n            if x < 0:\\n                continue\\n            s = str(x)\\n            # pad with leading zeros if needed\\n            if len(s) < prefix_len:\\n                s = s.zfill(prefix_len)\\n            # build palindrome\\n            if k % 2 == 0:\\n                pal = s + s[::-1]\\n            else:\\n                pal = s + s[:-1][::-1]\\n            candidates.add(pal)\\n        # remove original\\n        candidates.discard(n)\\n\\n        ans = None\\n        min_diff = None\\n        for cand in candidates:\\n            # skip empty\\n            if not cand:\\n                continue\\n            val = int(cand)\\n            diff = abs(val - orig)\\n            if val == orig:\\n                continue\\n            if ans is None or diff < min_diff or (diff == min_diff and val < int(ans)):\\n                ans = cand\\n                min_diff = diff\\n        return ans\\n\"",
  "2057_14631217_mysql-updated-time": "1746627861754",
  "1465_14631217_python-updated-time": "1746261780517",
  "3691_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        total_ops = 0\\n\\n        for col in range(n):\\n            prev = grid[0][col]\\n            for row in range(1, m):\\n                if grid[row][col] <= prev:\\n                    ops = prev + 1 - grid[row][col]\\n                    total_ops += ops\\n                    grid[row][col] += ops\\n                prev = grid[row][col]\\n\\n        return total_ops\\n\"",
  "1525_14631217_python": "\"class Solution(object):\\n    def processQueries(self, queries, m):\\n        P = list(range(1, m + 1))\\n        result = []\\n\\n        for q in queries:\\n            idx = P.index(q)\\n            result.append(idx)\\n            P.pop(idx)\\n            P.insert(0, q)\\n\\n        return result\\n\"",
  "2676_14631217_python": "\"class Solution(object):\\n    def findPrefixScore(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        ans = []\\n        max_val = float('-inf')\\n        total = 0\\n\\n        for num in nums:\\n            max_val = max(max_val, num)\\n            converted = num + max_val\\n            total += converted\\n            ans.append(total)\\n\\n        return ans\\n\"",
  "1392_14631217_python-updated-time": "1746810916994",
  "1843_14631217_python-updated-time": "1746529882349",
  "2418_14631217_python-updated-time": "1746907164055",
  "26_14631217_python-updated-time": "1744987803098",
  "764_14631217_python-updated-time": "1745358593689",
  "1454_14631217_python-updated-time": "1746261599010",
  "2571_14631217_python-updated-time": "1747057368449",
  "290_14631217_python-updated-time": "1745254994663",
  "1129_14631217_python-updated-time": "1746042999945",
  "1664_14631217_lang-updated-time": "1744902462625",
  "2210_14631217_python-updated-time": "1746729577276",
  "2552_14631217_python-updated-time": "1746968891514",
  "344_14631217_python-updated-time": "1745257039293",
  "2031_14631217_python-updated-time": "1746626386890",
  "2341_14631217_python": "\"class Solution:\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for w in words:\\n            if s.startswith(w):\\n                count += 1\\n        return count\\n\"",
  "688_14631217_python": "\"class Solution(object):\\n    def knightProbability(self, n, k, row, column):\\n        directions = [(-2, -1), (-2, 1), (2, -1), (2, 1),\\n                      (-1, -2), (-1, 2), (1, -2), (1, 2)]\\n        \\n        memo = {}\\n        \\n        def dfs(r, c, moves):\\n            if r < 0 or r >= n or c < 0 or c >= n:\\n                return 0\\n            if moves == 0:\\n                return 1\\n            if (r, c, moves) in memo:\\n                return memo[(r, c, moves)]\\n            \\n            prob = 0\\n            for dr, dc in directions:\\n                prob += dfs(r + dr, c + dc, moves - 1) / 8.0\\n            memo[(r, c, moves)] = prob\\n            return prob\\n        \\n        return dfs(row, column, k)\\n\"",
  "1652_14631217_python": "\"class Solution(object):\\n    def minFlips(self, target):\\n        \\\"\\\"\\\"\\n        :type target: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        flips = 0\\n        current = '0'\\n        \\n        for bit in target:\\n            if bit != current:\\n                flips += 1\\n                current = bit  # flip toggles the current state\\n        \\n        return flips\\n\"",
  "3684_14631217_python-updated-time": "1747653282669",
  "1939_14631217_python-updated-time": "1746544186614",
  "1902_14631217_python": "\"class Solution:\\n    def getCollisionTimes(self, cars):\\n        n = len(cars)\\n        res = [-1.0] * n\\n        stack = []  # stack of (index)\\n\\n        for i in range(n - 1, -1, -1):\\n            pos, speed = cars[i]\\n            while stack:\\n                j = stack[-1]\\n                pos_j, speed_j = cars[j]\\n                \\n                if speed <= speed_j:\\n                    stack.pop()\\n                else:\\n                    time = float(pos_j - pos) / (speed - speed_j)\\n                    # If j collides later than time or never collides\\n                    if res[j] == -1 or time <= res[j]:\\n                        res[i] = time\\n                        break\\n                    else:\\n                        stack.pop()\\n            stack.append(i)\\n        return res\\n\"",
  "2326_14631217_python-updated-time": "1746811155935",
  "241_14631217_python-updated-time": "1745247618443",
  "3502_14631217_python-updated-time": "1747580398782",
  "1363_14631217_python": "\"class Solution:\\n    def greatestLetter(self, s):\\n        lowers = set()\\n        uppers = set()\\n        for ch in s:\\n            if 'a' <= ch <= 'z':\\n                lowers.add(ch)\\n            else:\\n                uppers.add(ch)\\n        \\n        # Check from 'Z' down to 'A'\\n        for code in range(ord('Z'), ord('A') - 1, -1):\\n            ch = chr(code)\\n            if ch in uppers and ch.lower() in lowers:\\n                return ch\\n        return \\\"\\\"\\n\"",
  "2378_14631217_python": "\"class Solution:\\n    def largestWordCount(self, messages, senders):\\n        counts = {}\\n        for msg, sender in zip(messages, senders):\\n            # Count words by counting spaces + 1\\n            wc = msg.count(' ') + 1\\n            counts[sender] = counts.get(sender, 0) + wc\\n        \\n        # Find the sender with max count, breaking ties by lex order\\n        best_sender = None\\n        best_count = -1\\n        for sender, cnt in counts.items():\\n            if cnt > best_count or (cnt == best_count and sender > best_sender):\\n                best_count = cnt\\n                best_sender = sender\\n        \\n        return best_sender\\n\"",
  "313_14631217_python-updated-time": "1745255957485",
  "3610_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def findXSum(self, nums, k, x):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type x: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        res = []\\n        \\n        for i in range(n - k + 1):\\n            window = nums[i:i+k]\\n            count = Counter(window)\\n            \\n            # Sort by (-frequency, -value) to prioritize:\\n            # - higher frequency first\\n            # - for ties, higher value first\\n            top = sorted(count.items(), key=lambda t: (-t[1], -t[0]))[:x]\\n            \\n            # Include all occurrences of top x elements\\n            total = 0\\n            top_set = set(val for val, _ in top)\\n            for num in window:\\n                if num in top_set:\\n                    total += num\\n            \\n            res.append(total)\\n        \\n        return res\\n\"",
  "197_14631217_mysql-updated-time": "1745093021588",
  "1619_14631217_python": "\"class Solution(object):\\n    def isPathCrossing(self, path):\\n        \\\"\\\"\\\"\\n        :type path: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        visited = set()\\n        x = y = 0\\n        visited.add((x, y))\\n\\n        for direction in path:\\n            if direction == 'N':\\n                y += 1\\n            elif direction == 'S':\\n                y -= 1\\n            elif direction == 'E':\\n                x += 1\\n            elif direction == 'W':\\n                x -= 1\\n\\n            if (x, y) in visited:\\n                return True\\n            visited.add((x, y))\\n\\n        return False\\n\"",
  "175_14631217_mysql": "\"SELECT \\n    p.firstName, \\n    p.lastName, \\n    a.city, \\n    a.state\\nFROM \\n    Person p\\nLEFT JOIN \\n    Address a\\nON \\n    p.personId = a.personId;\\n\"",
  "1338_14631217_mysql": "\"SELECT\\n  query_name,\\n  ROUND(AVG(rating * 1.0 / position), 2) AS quality,\\n  ROUND(100.0 * SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) / COUNT(*), 2) AS poor_query_percentage\\nFROM Queries\\nGROUP BY query_name;\\n\"",
  "2084_14631217_python": "\"class Solution(object):\\n    def numberOfWeeks(self, milestones):\\n        total = sum(milestones)\\n        m = max(milestones)\\n        rest = total - m\\n        # If the largest project can be interleaved with the rest, do all weeks\\n        if m <= rest + 1:\\n            return total\\n        # Otherwise, we can only alternate until others run out\\n        return rest * 2 + 1\\n\"",
  "1527_14631217_python-updated-time": "1746346718796",
  "3777_14631217_python": "\"class Solution(object):\\n    def maxProduct(self, nums, k, limit):\\n        # dp_pos[(sum,parity)] = set of all positive products ≤limit reaching that state WITHOUT any zero\\n        dp_pos = {}\\n        best_pos = -1\\n\\n        # dp_sums = set of all (sum,parity) reachable ignoring product entirely\\n        # dp_zero = set of all (sum,parity) reachable with at least one zero (product=0)\\n        dp_sums = set()\\n        dp_zero = set()\\n        zero_ok = False\\n\\n        for v in nums:\\n            new_sums = set()\\n            new_pos  = {}\\n            new_zero = set()\\n\\n            # 1) Handle positive v\\n            if v != 0:\\n                # start a new subsequence [v]\\n                new_sums.add((v, 1))\\n                if v <= limit:\\n                    new_pos.setdefault((v, 1), set()).add(v)\\n                    if v == k:\\n                        best_pos = max(best_pos, v)\\n\\n                # extend every old sum state (for future zero-collapses and dp_sums)\\n                for (s, p) in dp_sums:\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    new_sums.add((s2, p2))\\n\\n                # extend every positive path\\n                for (s, p), prods in dp_pos.items():\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    cap = limit // v\\n                    for prod in prods:\\n                        if prod <= cap:\\n                            p2val = prod * v\\n                            if p2val <= limit:\\n                                new_pos.setdefault((s2, p2), set()).add(p2val)\\n                                if s2 == k:\\n                                    best_pos = max(best_pos, p2val)\\n\\n                # extend zero-layer forward (still product=0)\\n                for (s, p) in dp_zero:\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    new_zero.add((s2, p2))\\n                    if s2 == k:\\n                        zero_ok = True\\n\\n            # 2) Handle v == 0\\n            else:\\n                # start [0]\\n                new_sums.add((0, 1))\\n                new_zero.add((0, 1))\\n                if k == 0:\\n                    zero_ok = True\\n\\n                # *collapse* every previously reachable sum into the zero-layer\\n                for (s, p) in dp_sums:\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    new_sums.add((s2, p2))\\n                    new_zero.add((s2, p2))\\n                    if s2 == k:\\n                        zero_ok = True\\n\\n                # also any positive path you had collapses\\n                for (s, p) in dp_pos:\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    new_zero.add((s2, p2))\\n                    if s2 == k:\\n                        zero_ok = True\\n\\n                # and any prior zero-layer carries on too\\n                for (s, p) in dp_zero:\\n                    s2 = s + v if p == 0 else s - v\\n                    p2 = 1 - p\\n                    new_zero.add((s2, p2))\\n                    if s2 == k:\\n                        zero_ok = True\\n\\n            # 3) Merge updates back in\\n            dp_sums |= new_sums\\n            for key, sset in new_pos.items():\\n                if key in dp_pos:\\n                    dp_pos[key] |= sset\\n                else:\\n                    dp_pos[key] = set(sset)\\n            dp_zero |= new_zero\\n\\n        # 4) Final answer\\n        if best_pos < 0 and not zero_ok:\\n            return -1\\n        return max(best_pos, 0)\\n\"",
  "219_14631217_python": "\"class Solution(object):\\n    def containsNearbyDuplicate(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        seen = {}\\n        for i, num in enumerate(nums):\\n            if num in seen and i - seen[num] <= k:\\n                return True\\n            seen[num] = i\\n        return False\\n\"",
  "1730_14631217_python": "\"class Solution:\\n    def specialArray(self, nums):\\n        n = len(nums)\\n        # Try every possible x from 0 up to n\\n        for x in range(n + 1):\\n            # Count how many numbers are >= x\\n            cnt = 0\\n            for v in nums:\\n                if v >= x:\\n                    cnt += 1\\n            # If exactly x numbers are >= x, we've found our answer\\n            if cnt == x:\\n                return x\\n        return -1\\n\"",
  "695_14631217_python": "\"class Solution(object):\\n    def maxAreaOfIsland(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        max_area = 0\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\\n                return 0\\n            grid[i][j] = 0\\n            area = 1\\n            area += dfs(i+1, j)\\n            area += dfs(i-1, j)\\n            area += dfs(i, j+1)\\n            area += dfs(i, j-1)\\n            return area\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    max_area = max(max_area, dfs(i, j))\\n        \\n        return max_area\\n\"",
  "1807_14631217_python": "\"class Solution(object):\\n    def minPartitions(self, n):\\n        return max(int(c) for c in n)\\n\"",
  "1140_14631217_python-updated-time": "1746107673732",
  "3739_14631217_python-updated-time": "1747659274176",
  "3519_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def winningPlayerCount(self, n, pick):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type pick: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # counts[i][color] = how many balls of 'color' player i picked\\n        counts = [defaultdict(int) for _ in range(n)]\\n        for player, color in pick:\\n            counts[player][color] += 1\\n\\n        winners = 0\\n        for i in range(n):\\n            # player i needs at least i+1 balls of the same color\\n            requirement = i + 1\\n            # check if any color meets that requirement\\n            if any(cnt >= requirement for cnt in counts[i].values()):\\n                winners += 1\\n\\n        return winners\\n\"",
  "3801_14631217_python-updated-time": "1747760309233",
  "755_14631217_python-updated-time": "1745875700951",
  "2805_14631217_javascript": "\"/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, val) => sum + val, 0);\\n};\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(',')}]`;\\n};\\n\"",
  "453_14631217_python-updated-time": "1745359317601",
  "833_14631217_python-updated-time": "1745878697507",
  "3228_14631217_python": "\"class Solution(object):\\n    def maximumSetSize(self, nums1, nums2):\\n        n = len(nums1)\\n        half = n // 2\\n\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        common = set1 & set2\\n\\n        # max we can pick is half from each list\\n        # but we must avoid duplicate selections\\n        unique1 = len(set1)\\n        unique2 = len(set2)\\n        overlap = len(common)\\n\\n        # pick at most half from each\\n        from1 = min(half, unique1)\\n        from2 = min(half, unique2)\\n\\n        # if overlap is too big, set size gets reduced\\n        if from1 + from2 <= len(set1 | set2):\\n            return from1 + from2\\n        return len(set1 | set2)\\n\"",
  "2140_14631217_python-updated-time": "1746719137250",
  "22_14631217_python": "\"class Solution(object):\\n    def generateParenthesis(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(s, left, right):\\n            if len(s) == 2 * n:\\n                res.append(s)\\n                return\\n            if left < n:\\n                backtrack(s + '(', left + 1, right)\\n            if right < left:\\n                backtrack(s + ')', left, right + 1)\\n\\n        backtrack(\\\"\\\", 0, 0)\\n        return res\\n\"",
  "3031_14631217_python-updated-time": "1747307775270",
  "1567_14631217_python": "\"class Solution(object):\\n    def maxVowels(self, s, k):\\n        vowels = set('aeiou')\\n        count = sum(1 for c in s[:k] if c in vowels)\\n        max_count = count\\n        for i in range(k, len(s)):\\n            if s[i] in vowels:\\n                count += 1\\n            if s[i-k] in vowels:\\n                count -= 1\\n            if count > max_count:\\n                max_count = count\\n        return max_count\\n\"",
  "1860_14631217_python": "\"class Solution:\\n    def kthLargestValue(self, matrix, k):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        # prev[j] will hold the prefix-xor for column j from the previous row\\n        prev = [0] * n\\n        vals = []\\n\\n        for i in range(m):\\n            curr = [0] * n\\n            for j in range(n):\\n                v = matrix[i][j]\\n                # xor with above\\n                if i:\\n                    v ^= prev[j]\\n                # xor with left\\n                if j:\\n                    v ^= curr[j-1]\\n                # we've xored above and left twice, so xor the overlap back\\n                if i and j:\\n                    v ^= prev[j-1]\\n                curr[j] = v\\n                vals.append(v)\\n            prev = curr\\n\\n        # sort descending and pick the k‑th\\n        vals.sort(reverse=True)\\n        return vals[k-1]\\n\"",
  "1372_14631217_python": "\"class Solution:\\n    def isGoodArray(self, nums):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        g = nums[0]\\n        for num in nums[1:]:\\n            g = gcd(g, num)\\n        return g == 1\\n\"",
  "3651_14631217_python": "\"class Solution(object):\\n    def constructTransformedArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        result = [0]*n\\n        for i, v in enumerate(nums):\\n            # (i + v) % n handles both positive and negative steps\\n            j = (i + v) % n\\n            result[i] = nums[j]\\n        return result\\n\"",
  "2802_14631217_python": "\"class Solution:\\n    def punishmentNumber(self, n):\\n        def can_partition(s, target):\\n            def dfs(i, total):\\n                if i == len(s):\\n                    return total == target\\n                for j in range(i + 1, len(s) + 1):\\n                    if dfs(j, total + int(s[i:j])):\\n                        return True\\n                return False\\n            return dfs(0, 0)\\n\\n        res = 0\\n        for i in range(1, n + 1):\\n            sq = str(i * i)\\n            if can_partition(sq, i):\\n                res += i * i\\n        return res\\n\"",
  "1072_14631217_python": "\"class Solution:\\n    def nextLargerNodes(self, head):\\n        vals = []\\n        while head:\\n            vals.append(head.val)\\n            head = head.next\\n        res = [0] * len(vals)\\n        stack = []\\n        for i, v in enumerate(vals):\\n            while stack and vals[stack[-1]] < v:\\n                res[stack.pop()] = v\\n            stack.append(i)\\n        return res\\n\"",
  "112_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def hasPathSum(self, root, targetSum):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :type targetSum: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not root:\\n            return False\\n        if not root.left and not root.right:\\n            return root.val == targetSum\\n        targetSum -= root.val\\n        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)\\n\"",
  "2717_14631217_python": "\"import collections\\n\\nclass Solution:\\n    def collectTheCoins(self, coins, edges):\\n        \\\"\\\"\\\"Return minimum number of edge-traversals needed to collect every coin\\n        (distance ≤ 2 collection) and come back to start.\\n        Greedy pruning described in LC 2603 editorial.\\n        Complexity O(n).\\\"\\\"\\\"\\n        n = len(coins)\\n        if sum(coins) == 0:\\n            return 0\\n\\n        # Build adjacency list and degree array\\n        g = [[] for _ in range(n)]\\n        degree = [0] * n\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n            degree[u] += 1\\n            degree[v] += 1\\n\\n        removed = [False] * n\\n        q = collections.deque()\\n        # 1) Prune all leaves having no coin (repeat until none left)\\n        for i in range(n):\\n            if degree[i] == 1 and coins[i] == 0:\\n                removed[i] = True\\n                q.append(i)\\n        while q:\\n            u = q.popleft()\\n            for v in g[u]:\\n                if removed[v]:\\n                    continue\\n                degree[v] -= 1\\n                if degree[v] == 1 and coins[v] == 0:\\n                    removed[v] = True\\n                    q.append(v)\\n\\n        # 2) Remove leaves twice (regardless of coin)\\n        for _ in range(2):\\n            leaves = [i for i in range(n) if not removed[i] and degree[i] == 1]\\n            for u in leaves:\\n                removed[u] = True\\n                for v in g[u]:\\n                    if not removed[v]:\\n                        degree[v] -= 1\\n\\n        # 3) Count remaining edges; each traversed twice (out & back)\\n        remaining_edges = 0\\n        for u, v in edges:\\n            if not removed[u] and not removed[v]:\\n                remaining_edges += 1\\n\\n        return remaining_edges * 2\"",
  "2708_14631217_python": "\"class Solution(object):\\n    def findTheString(self, lcp):\\n        n = len(lcp)\\n        # 1) Basic validation\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\\"\\\"\\n            for j in range(n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\\"\\\"\\n                if lcp[i][j] > n - max(i, j):\\n                    return \\\"\\\"\\n        \\n        # 2) Greedily build the lexicographically smallest string\\n        res = []\\n        for i in range(n):\\n            # start with all lowercase letters\\n            possible = set(chr(ord('a') + k) for k in range(26))\\n            for j in range(i):\\n                if lcp[i][j] > 0:\\n                    # must match res[j]\\n                    possible &= {res[j]}\\n                else:\\n                    # must differ from res[j]\\n                    possible.discard(res[j])\\n                if not possible:\\n                    return \\\"\\\"\\n            # pick smallest letter\\n            c = min(possible)\\n            res.append(c)\\n        word = \\\"\\\".join(res)\\n        \\n        # 3) Recompute LCP to verify\\n        lcp2 = [[0]*n for _ in range(n)]\\n        # fill from bottom-right up for easy DP\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if word[i] == word[j]:\\n                    if i+1 < n and j+1 < n:\\n                        lcp2[i][j] = 1 + lcp2[i+1][j+1]\\n                    else:\\n                        lcp2[i][j] = 1\\n                else:\\n                    lcp2[i][j] = 0\\n        \\n        if lcp2 == lcp:\\n            return word\\n        else:\\n            return \\\"\\\"\\n\"",
  "665_14631217_python": "\"class Solution(object):\\n    def checkPossibility(self, nums):\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] < nums[i-1]:\\n                count += 1\\n                if count > 1:\\n                    return False\\n                if i >= 2 and nums[i] < nums[i-2]:\\n                    nums[i] = nums[i-1]\\n                else:\\n                    nums[i-1] = nums[i]\\n        return True\\n\"",
  "3336_14631217_python": "\"class Solution(object):\\n    def maxBottlesDrunk(self, numBottles, numExchange):\\n        \\\"\\\"\\\"\\n        :type numBottles: int\\n        :type numExchange: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # total drunk starts with the initial full bottles\\n        total = numBottles\\n        # empty bottles after drinking them all\\n        empty = numBottles\\n        k = numExchange\\n        \\n        # as long as we have enough empties to do one exchange at the current rate\\n        while empty >= k:\\n            # perform exactly one exchange at this rate\\n            empty -= k\\n            # we get one new full bottle\\n            total += 1\\n            # after drinking it, we get one more empty\\n            empty += 1\\n            # rate increases by 1\\n            k += 1\\n        \\n        return total\\n\"",
  "1524_14631217_python-updated-time": "1746346599552",
  "1207_14631217_python-updated-time": "1746108798810",
  "3067_14631217_pythondata-updated-time": "1747305762527",
  "100_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \\\"\\\"\\\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\"",
  "2061_14631217_python": "\"class Solution(object):\\n    def colorTheGrid(self, m, n):\\n        MOD = 10**9+7\\n        total = 3**m\\n        valid = []\\n        cols = []\\n        for p in range(total):\\n            x = p\\n            prev = -1\\n            ok = True\\n            col = []\\n            for _ in range(m):\\n                d = x % 3\\n                x //= 3\\n                if d == prev:\\n                    ok = False\\n                    break\\n                prev = d\\n                col.append(d)\\n            if ok:\\n                valid.append(p)\\n                cols.append(col)\\n        k = len(valid)\\n        comp = [[False]*k for _ in range(k)]\\n        for i in range(k):\\n            for j in range(k):\\n                ok = True\\n                for r in range(m):\\n                    if cols[i][r] == cols[j][r]:\\n                        ok = False\\n                        break\\n                comp[i][j] = ok\\n        dp = [1]*k\\n        for _ in range(1, n):\\n            ndp = [0]*k\\n            for j in range(k):\\n                s = 0\\n                for i in range(k):\\n                    if comp[i][j]:\\n                        s += dp[i]\\n                ndp[j] = s % MOD\\n            dp = ndp\\n        return sum(dp) % MOD\\n\"",
  "2757_14631217_python-updated-time": "1747140756498",
  "2715_14631217_python": "\"class Solution:\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        # 1’s first\\n        take1 = min(k, numOnes)\\n        k -= take1\\n        total = take1  # each 1 contributes +1\\n\\n        # then 0’s\\n        take0 = min(k, numZeros)\\n        k -= take0\\n        # total += take0 * 0  // no change\\n\\n        # finally -1’s\\n        # whatever remains of k must be from neg-ones\\n        total -= k   # each contributes -1\\n\\n        return total\\n\"",
  "1455_14631217_python": "\"class Solution:\\n    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):\\n        filtered = []\\n        for r in restaurants:\\n            id_, rating, vegan, price, dist = r\\n            if veganFriendly and not vegan:\\n                continue\\n            if price > maxPrice or dist > maxDistance:\\n                continue\\n            filtered.append((rating, id_))\\n        # Sort by rating desc, id desc\\n        filtered.sort(key=lambda x: (-x[0], -x[1]))\\n        return [id_ for _, id_ in filtered]\\n\"",
  "1708_14631217_python": "\"class ParkingSystem:\\n    def __init__(self, big, medium, small):\\n        # capacities for each car type\\n        self.cap = [0, big, medium, small]\\n        # current parked counts\\n        self.count = [0, 0, 0, 0]\\n\\n    def addCar(self, carType):\\n        if self.count[carType] < self.cap[carType]:\\n            self.count[carType] += 1\\n            return True\\n        return False\\n\"",
  "2513_14631217_python": "\"class Fenwick:\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0]*(n+1)\\n    def update(self, i, v):\\n        # add v at index i (1-based)\\n        while i <= self.n:\\n            self.fw[i] += v\\n            i += i & -i\\n    def query(self, i):\\n        # sum of fw[1..i]\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n\\nclass Solution:\\n    def numberOfPairs(self, nums1, nums2, diff):\\n        n = len(nums1)\\n        A = [nums1[i] - nums2[i] for i in range(n)]\\n        # Gather all values we will need to rank:\\n        vals = set(A)\\n        vals.update(a + diff for a in A)\\n        # Coordinate-compress\\n        sorted_vals = sorted(vals)\\n        rank = {v: i+1 for i,v in enumerate(sorted_vals)}  # 1-based\\n\\n        fenw = Fenwick(len(sorted_vals))\\n        ans = 0\\n\\n        for a in A:\\n            # count how many prior A[i] <= a + diff\\n            idx = rank[a + diff]\\n            ans += fenw.query(idx)\\n            # now include this A[j] in Fenwick\\n            fenw.update(rank[a], 1)\\n\\n        return ans\\n\"",
  "3680_14631217_python-updated-time": "1747596300798",
  "2789_14631217_javascript-updated-time": "1747137051149",
  "836_14631217_python-updated-time": "1745878796794",
  "2366_14631217_python-updated-time": "1746881441795",
  "1321_14631217_python-updated-time": "1746127571275",
  "2436_14631217_python-updated-time": "1746907962184",
  "373_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        if not nums1 or not nums2:\\n            return []\\n        \\n        heap = []\\n        for i in range(min(k, len(nums1))):\\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\\n        \\n        res = []\\n        while heap and len(res) < k:\\n            _, i, j = heapq.heappop(heap)\\n            res.append([nums1[i], nums2[j]])\\n            if j + 1 < len(nums2):\\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\\n        \\n        return res\\n\"",
  "3058_14631217_python": "\"class Solution(object):\\n    def maxKDivisibleComponents(self, n, edges, values, k):\\n        import sys\\n        sys.setrecursionlimit(10**7)\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        self.count = 0\\n        def dfs(u, p):\\n            total = values[u]\\n            for v in adj[u]:\\n                if v == p:\\n                    continue\\n                subtotal = dfs(v, u)\\n                if subtotal % k == 0:\\n                    self.count += 1\\n                else:\\n                    total += subtotal\\n            return total\\n        dfs(0, -1)\\n        return self.count + 1\"",
  "3838_14631217_python": "\"class Solution(object):\\n    def pathExistenceQueries(self, n, nums, maxDiff, queries):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type nums: List[int]\\n        :type maxDiff: int\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        # Build component ids: consecutive nums with gap <= maxDiff are connected.\\n        comp = [0] * n\\n        for i in range(1, n):\\n            # if this node links to the previous one, share component;\\n            # otherwise start a new component.\\n            if nums[i] - nums[i - 1] <= maxDiff:\\n                comp[i] = comp[i - 1]\\n            else:\\n                comp[i] = comp[i - 1] + 1\\n        \\n        # For each query, they're connected iff in the same component.\\n        ans = []\\n        for u, v in queries:\\n            ans.append(comp[u] == comp[v])\\n        return ans\\n\"",
  "3697_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumIncrements(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) gcd helper\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        m = len(target)\\n        full_mask = (1 << m) - 1\\n\\n        # 2) precompute LCM for each non-empty subset of target (bitmask)\\n        lcm_of = {}\\n        for mask in range(1, full_mask + 1):\\n            L = 1\\n            for j in range(m):\\n                if (mask >> j) & 1:\\n                    t = target[j]\\n                    L = (L // gcd(L, t)) * t\\n            lcm_of[mask] = L\\n\\n        # 3) for each subset‐mask, collect up to m cheapest (inc, index) pairs\\n        candidate_costs = {}\\n        for mask, L in lcm_of.items():\\n            costs = []\\n            for i, v in enumerate(nums):\\n                rem = v % L\\n                inc = (L - rem) % L\\n                costs.append((inc, i))\\n            # keep the m smallest by inc\\n            candidate_costs[mask] = heapq.nsmallest(m, costs)\\n\\n        # 4) generate all set‐partitions of {0,…,m−1} as lists of masks\\n        partitions = []\\n        def backtrack(remaining, parts):\\n            if remaining == 0:\\n                partitions.append(parts[:])\\n                return\\n            lowb = remaining & -remaining\\n            sub = remaining\\n            while sub:\\n                if sub & lowb:\\n                    parts.append(sub)\\n                    backtrack(remaining ^ sub, parts)\\n                    parts.pop()\\n                sub = (sub - 1) & remaining\\n\\n        backtrack(full_mask, [])\\n\\n        # 5) for each partition, do a small DFS to pick distinct nums‐indices\\n        ans = float('inf')\\n        for parts in partitions:\\n            k = len(parts)\\n            best_for_part = [float('inf')]  # use list to capture “by reference”\\n\\n            def dfs(idx, used, total):\\n                # prune\\n                if total >= best_for_part[0]:\\n                    return\\n                if idx == k:\\n                    best_for_part[0] = total\\n                    return\\n                mask = parts[idx]\\n                for cost, i in candidate_costs[mask]:\\n                    if i not in used:\\n                        dfs(idx + 1, used | {i}, total + cost)\\n\\n            dfs(0, set(), 0)\\n            if best_for_part[0] < ans:\\n                ans = best_for_part[0]\\n\\n        return ans\\n\"",
  "2478_14631217_python-updated-time": "1746965833989",
  "1240_14631217_python-updated-time": "1746109424893",
  "2176_14631217_python": "\"class Solution(object):\\n    def minimumTime(self, n, relations, time):\\n        \\\"\\\"\\\"\\n        Computes the minimum number of months needed to complete all courses given prerequisite relations\\n        and individual course durations. Multiple courses may be taken in parallel as long as prerequisites\\n        are met.\\n\\n        :param n: int, number of courses labeled from 1 to n\\n        :param relations: List[List[int]], each pair [u, v] means u must be completed before v\\n        :param time: List[int], time[i] is the duration to complete course i+1\\n        :return: int, minimum months to finish all courses\\n        \\\"\\\"\\\"\\n        from collections import deque, defaultdict\\n\\n        # Build adjacency list and in-degree counts\\n        graph = defaultdict(list)\\n        indegree = [0] * (n + 1)\\n        for u, v in relations:\\n            graph[u].append(v)\\n            indegree[v] += 1\\n\\n        # dp[i] tracks earliest completion time of course i\\n        dp = [0] * (n + 1)\\n\\n        # Initialize queue with courses without prerequisites\\n        q = deque()\\n        for course in range(1, n + 1):\\n            if indegree[course] == 0:\\n                dp[course] = time[course - 1]\\n                q.append(course)\\n\\n        # Process courses in topological order\\n        while q:\\n            u = q.popleft()\\n            for v in graph[u]:\\n                # v can only start after u is completed\\n                dp[v] = max(dp[v], dp[u] + time[v - 1])\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    q.append(v)\\n\\n        # The answer is the maximum completion time among all courses\\n        return max(dp[1:])\"",
  "1966_14631217_python": "\"class Solution(object):\\n    def maxFrequency(self, nums, k):\\n        nums.sort()\\n        left = 0\\n        total = 0\\n        res = 1\\n        for right, x in enumerate(nums):\\n            total += x\\n            # cost to make all in window [left..right] equal to x\\n            cost = x * (right - left + 1) - total\\n            while cost > k:\\n                total -= nums[left]\\n                left += 1\\n                cost = x * (right - left + 1) - total\\n            res = max(res, right - left + 1)\\n        return res\\n\"",
  "3751_14631217_python": "\"class Solution(object):\\n    def maxFrequency(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Count how many k’s we already have\\n        orig_k = sum(1 for a in nums if a == k)\\n        \\n        best_gain = 0\\n        # Try aligning every other value v -> k by choosing x = k - v\\n        # The net change in #k’s when you shift a segment by x\\n        # is: (# of v’s in segment) - (# of k’s in segment).\\n        # We want the segment where that difference is maximized.\\n        for v in set(nums):\\n            if v == k:\\n                continue\\n            \\n            # Kadane’s maximum‐subarray on weights w[i]:\\n            # w[i] = +1 if nums[i]==v, -1 if nums[i]==k, else 0\\n            curr = float('-inf')\\n            best_for_v = float('-inf')\\n            for a in nums:\\n                w = 1 if a == v else (-1 if a == k else 0)\\n                # either start new at w, or extend\\n                if curr < 0:\\n                    curr = w\\n                else:\\n                    curr += w\\n                best_for_v = max(best_for_v, curr)\\n            \\n            # only positive gain helps\\n            if best_for_v > 0:\\n                best_gain = max(best_gain, best_for_v)\\n        \\n        return orig_k + best_gain\\n\"",
  "403_14631217_python-updated-time": "1745355940636",
  "1486_14631217_python-updated-time": "1746345944713",
  "2104_14631217_python": "\"class LockingTree:\\n    def __init__(self, parent):\\n        self.parent = parent\\n        self.n = len(parent)\\n        self.children = [[] for _ in range(self.n)]\\n        for i in range(1, self.n):\\n            self.children[parent[i]].append(i)\\n        self.locked_by = [-1] * self.n  # -1 means unlocked\\n\\n    def lock(self, num, user):\\n        if self.locked_by[num] != -1:\\n            return False\\n        self.locked_by[num] = user\\n        return True\\n\\n    def unlock(self, num, user):\\n        if self.locked_by[num] != user:\\n            return False\\n        self.locked_by[num] = -1\\n        return True\\n\\n    def upgrade(self, num, user):\\n        # Check condition 1: node must be unlocked\\n        if self.locked_by[num] != -1:\\n            return False\\n\\n        # Check condition 2: has at least one locked descendant\\n        if not self._has_locked_descendant(num):\\n            return False\\n\\n        # Check condition 3: no locked ancestor\\n        if self._has_locked_ancestor(num):\\n            return False\\n\\n        # Unlock all descendants\\n        self._unlock_all_descendants(num)\\n\\n        # Lock the current node\\n        self.locked_by[num] = user\\n        return True\\n\\n    def _has_locked_descendant(self, node):\\n        stack = [node]\\n        while stack:\\n            curr = stack.pop()\\n            for child in self.children[curr]:\\n                if self.locked_by[child] != -1:\\n                    return True\\n                stack.append(child)\\n        return False\\n\\n    def _has_locked_ancestor(self, node):\\n        while node != -1:\\n            if self.locked_by[node] != -1:\\n                return True\\n            node = self.parent[node]\\n        return False\\n\\n    def _unlock_all_descendants(self, node):\\n        stack = [node]\\n        while stack:\\n            curr = stack.pop()\\n            for child in self.children[curr]:\\n                self.locked_by[child] = -1\\n                stack.append(child)\\n\"",
  "24_14631217_python-updated-time": "1744987724089",
  "795_14631217_python": "\"class Solution(object):\\n    def kthGrammar(self, n, k):\\n        if n == 1:\\n            return 0\\n        if k <= (1 << (n-2)):\\n            return self.kthGrammar(n-1, k)\\n        else:\\n            return 1 - self.kthGrammar(n-1, k - (1 << (n-2)))\\n\"",
  "3579_14631217_python-updated-time": "1747575558366",
  "895_14631217_python-updated-time": "1746001222177",
  "1928_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def getNumberOfBacklogOrders(self, orders):\\n        MOD = 10**9 + 7\\n        buy_heap = []   # Max-heap for buy orders: (-price, amount)\\n        sell_heap = []  # Min-heap for sell orders: (price, amount)\\n\\n        for price, amount, order_type in orders:\\n            if order_type == 0:  # Buy order\\n                while amount > 0 and sell_heap and sell_heap[0][0] <= price:\\n                    sell_price, sell_amount = heapq.heappop(sell_heap)\\n                    matched = min(amount, sell_amount)\\n                    amount -= matched\\n                    sell_amount -= matched\\n                    if sell_amount > 0:\\n                        heapq.heappush(sell_heap, (sell_price, sell_amount))\\n                if amount > 0:\\n                    heapq.heappush(buy_heap, (-price, amount))\\n\\n            else:  # Sell order\\n                while amount > 0 and buy_heap and -buy_heap[0][0] >= price:\\n                    buy_price, buy_amount = heapq.heappop(buy_heap)\\n                    matched = min(amount, buy_amount)\\n                    amount -= matched\\n                    buy_amount -= matched\\n                    if buy_amount > 0:\\n                        heapq.heappush(buy_heap, (buy_price, buy_amount))\\n                if amount > 0:\\n                    heapq.heappush(sell_heap, (price, amount))\\n\\n        # Sum up remaining amounts in both heaps\\n        total = sum(amount for _, amount in buy_heap + sell_heap)\\n        return total % MOD\\n\"",
  "969_14631217_python": "\"from collections import deque\\n\\nclass RecentCounter:\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def ping(self, t):\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n\"",
  "2130_14631217_python": "\"class Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n        palins = {}\\n\\n        # Step 1: collect all palindromic subsequences with their bitmask\\n        for mask in range(1, 1 << n):\\n            subseq = []\\n            for i in range(n):\\n                if (mask >> i) & 1:\\n                    subseq.append(s[i])\\n            if subseq == subseq[::-1]:\\n                palins[mask] = len(subseq)\\n\\n        # Step 2: try all disjoint pairs\\n        max_product = 0\\n        keys = list(palins.keys())\\n        for i in range(len(keys)):\\n            for j in range(i + 1, len(keys)):\\n                if keys[i] & keys[j] == 0:\\n                    max_product = max(max_product, palins[keys[i]] * palins[keys[j]])\\n\\n        return max_product\\n\"",
  "2289_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums):\\n        even = Counter(nums[::2])\\n        odd = Counter(nums[1::2])\\n\\n        even_items = even.most_common(2) + [(0, 0)]\\n        odd_items = odd.most_common(2) + [(0, 0)]\\n\\n        if even_items[0][0] != odd_items[0][0]:\\n            return len(nums) - even_items[0][1] - odd_items[0][1]\\n        return min(\\n            len(nums) - even_items[0][1] - odd_items[1][1],\\n            len(nums) - even_items[1][1] - odd_items[0][1]\\n        )\\n\"",
  "1422_14631217_python": "\"from collections import Counter\\nimport heapq\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums, k):\\n        if len(nums) % k != 0:\\n            return False\\n\\n        count = Counter(nums)\\n        keys = sorted(count)\\n\\n        for num in keys:\\n            if count[num] > 0:\\n                freq = count[num]\\n                for i in range(num, num + k):\\n                    if count[i] < freq:\\n                        return False\\n                    count[i] -= freq\\n\\n        return True\\n\"",
  "181_14631217_mysql": "\"SELECT e.name AS Employee\\nFROM Employee e\\nJOIN Employee m ON e.managerId = m.id\\nWHERE e.salary > m.salary;\\n\"",
  "215_14631217_python-updated-time": "1745246277074",
  "540_14631217_python": "\"class Solution:\\n    def singleNonDuplicate(self, nums):\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if mid % 2 == 1:\\n                mid -= 1\\n            if nums[mid] == nums[mid + 1]:\\n                left = mid + 2\\n            else:\\n                right = mid\\n        return nums[left]\\n\"",
  "676_14631217_python": "\"class MagicDictionary(object):\\n    def __init__(self):\\n        self.words = set()\\n\\n    def buildDict(self, dictionary):\\n        self.words = set(dictionary)\\n\\n    def search(self, searchWord):\\n        for word in self.words:\\n            if len(word) != len(searchWord):\\n                continue\\n            diff = 0\\n            for a, b in zip(word, searchWord):\\n                if a != b:\\n                    diff += 1\\n                    if diff > 1:\\n                        break\\n            if diff == 1:\\n                return True\\n        return False\\n\"",
  "3625_14631217_python-updated-time": "1747592613480",
  "2473_14631217_python-updated-time": "1746907510696",
  "1322_14631217_python-updated-time": "1746258958021",
  "827_14631217_python": "\"class Solution(object):\\n    def expressiveWords(self, s, words):\\n        def RLE(S):\\n            rle = []\\n            prev = S[0]\\n            count = 1\\n            for c in S[1:]:\\n                if c == prev:\\n                    count += 1\\n                else:\\n                    rle.append((prev, count))\\n                    prev = c\\n                    count = 1\\n            rle.append((prev, count))\\n            return rle\\n        \\n        s_rle = RLE(s)\\n        res = 0\\n        \\n        for word in words:\\n            w_rle = RLE(word)\\n            if len(w_rle) != len(s_rle):\\n                continue\\n            ok = True\\n            for (sc, scount), (wc, wcount) in zip(s_rle, w_rle):\\n                if sc != wc:\\n                    ok = False\\n                    break\\n                if scount < 3 and scount != wcount:\\n                    ok = False\\n                    break\\n                if scount >= 3 and wcount > scount:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        return res\\n\"",
  "2090_14631217_python-updated-time": "1746715294937",
  "102_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        result = []\\n        queue = deque([root])\\n        \\n        while queue:\\n            level = []\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            result.append(level)\\n        \\n        return result\\n\"",
  "2544_14631217_python-updated-time": "1746968538346",
  "2476_14631217_python-updated-time": "1746965714496",
  "1605_14631217_python-updated-time": "1746432717558",
  "1800_14631217_python-updated-time": "1746452786964",
  "2572_14631217_python": "\"class Solution(object):\\n    def appendCharacters(self, s, t):\\n        i = j = 0\\n        while i < len(s) and j < len(t):\\n            if s[i] == t[j]:\\n                j += 1\\n            i += 1\\n        return len(t) - j\\n\"",
  "458_14631217_python-updated-time": "1745359488168",
  "2359_14631217_python": "\"class Solution:\\n    def maximumWhiteTiles(self, tiles, carpetLen):\\n        # 1) Sort and unpack\\n        tiles.sort()\\n        l = [x for x,_ in tiles]\\n        r = [y for _,y in tiles]\\n        n = len(tiles)\\n\\n        # 2) prefix_len[k] = total white tiles in intervals[0..k-1]\\n        prefix_len = [0] * (n+1)\\n        for i in range(n):\\n            prefix_len[i+1] = prefix_len[i] + (r[i] - l[i] + 1)\\n\\n        ans = 0\\n        f = 0\\n\\n        # 3) Sweep i and advance f\\n        for i in range(n):\\n            start = l[i]\\n            end_cover = start + carpetLen - 1\\n\\n            # Ensure f >= i\\n            if f < i:\\n                f = i\\n\\n            # Move f to first interval not fully covered\\n            while f < n and r[f] <= end_cover:\\n                f += 1\\n\\n            # Fully covered total = prefix_len[f] - prefix_len[i]\\n            covered = prefix_len[f] - prefix_len[i]\\n\\n            # Partial cover of interval f, if it overlaps\\n            if f < n and l[f] <= end_cover:\\n                covered += end_cover - l[f] + 1\\n\\n            ans = max(ans, covered)\\n\\n        return ans\\n\"",
  "3404_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        # Step 1: for each column, compute cost_j[v] = #cells to change to make column=j all = v\\n        # and include a wildcard None at cost = m (change all cells to some other value)\\n        costs = []\\n        for j in range(n):\\n            freq = {}\\n            for i in range(m):\\n                x = grid[i][j]\\n                freq[x] = freq.get(x, 0) + 1\\n            cost_j = {v: m - cnt for v, cnt in freq.items()}\\n            cost_j[None] = m  # change all to some fresh value\\n            costs.append(cost_j)\\n\\n        # Step 2: DP over columns: dp_prev[v] = best cost up to previous column ending with value v\\n        dp_prev = costs[0].copy()\\n\\n        for j in range(1, n):\\n            # find the two best (cost, value) pairs in dp_prev\\n            best1 = (float('inf'), None)\\n            best2 = (float('inf'), None)\\n            for v, c in dp_prev.items():\\n                if c < best1[0]:\\n                    best2 = best1\\n                    best1 = (c, v)\\n                elif c < best2[0]:\\n                    best2 = (c, v)\\n\\n            dp_curr = {}\\n            for v, add_cost in costs[j].items():\\n                # choose best from previous that isn’t the same v\\n                prev_best_cost = best1[0] if best1[1] != v else best2[0]\\n                dp_curr[v] = add_cost + prev_best_cost\\n            dp_prev = dp_curr\\n\\n        # The answer is the minimum over all ending values\\n        return min(dp_prev.values())\\n\"",
  "96_14631217_python-updated-time": "1745080764671",
  "3104_14631217_python-updated-time": "1747227519073",
  "125_14631217_python": "\"class Solution(object):\\n    def isPalindrome(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        left, right = 0, len(s) - 1\\n        \\n        while left < right:\\n            # Move left pointer if not alphanumeric\\n            while left < right and not s[left].isalnum():\\n                left += 1\\n            # Move right pointer if not alphanumeric\\n            while left < right and not s[right].isalnum():\\n                right -= 1\\n            # Compare characters after converting to lowercase\\n            if s[left].lower() != s[right].lower():\\n                return False\\n            left += 1\\n            right -= 1\\n        \\n        return True\\n\"",
  "2461_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def amountOfTime(self, root, start):\\n        graph = defaultdict(list)\\n\\n        def build_graph(node, parent):\\n            if not node:\\n                return\\n            if parent:\\n                graph[node.val].append(parent.val)\\n                graph[parent.val].append(node.val)\\n            build_graph(node.left, node)\\n            build_graph(node.right, node)\\n\\n        build_graph(root, None)\\n\\n        visited = set()\\n        queue = deque([(start, 0)])\\n        visited.add(start)\\n        max_time = 0\\n\\n        while queue:\\n            node, time = queue.popleft()\\n            max_time = max(max_time, time)\\n            for nei in graph[node]:\\n                if nei not in visited:\\n                    visited.add(nei)\\n                    queue.append((nei, time + 1))\\n\\n        return max_time\\n\"",
  "39_14631217_python-updated-time": "1744988782109",
  "238_14631217_python": "\"class Solution(object):\\n    def productExceptSelf(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        answer = [1] * n\\n        \\n        prefix = 1\\n        for i in range(n):\\n            answer[i] = prefix\\n            prefix *= nums[i]\\n        \\n        suffix = 1\\n        for i in range(n-1, -1, -1):\\n            answer[i] *= suffix\\n            suffix *= nums[i]\\n        \\n        return answer\\n\"",
  "1380_14631217_python-updated-time": "1746259613516",
  "1194_14631217_python": "\"class Solution(object):\\n    def pathInZigZagTree(self, label):\\n        \\\"\\\"\\\"\\n        :type label: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        level = 0\\n        while (1 << level) <= label:\\n            level += 1\\n\\n        while label >= 1:\\n            res.append(label)\\n            level -= 1\\n            # Find the range of the current level\\n            start = 1 << level\\n            end = (1 << (level + 1)) - 1\\n            # Move to the parent in normal binary tree,\\n            # then reverse it if needed\\n            label = (start + end - label) // 2\\n\\n        return res[::-1]\\n\"",
  "456_14631217_python-updated-time": "1745359392024",
  "165_14631217_python-updated-time": "1745091401665",
  "154_14631217_python": "\"class Solution(object):\\n    def findMin(self, nums):\\n        left, right = 0, len(nums) - 1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < nums[right]:\\n                right = mid\\n            elif nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right -= 1\\n                \\n        return nums[left]\\n\"",
  "2888_14631217_python": "\"class Solution:\\n    def minimumIndex(self, nums):\\n        from collections import Counter\\n\\n        # Step 1: Find the global dominant element\\n        count = Counter(nums)\\n        n = len(nums)\\n        dominant = max(count, key=lambda x: count[x])\\n        total = count[dominant]\\n\\n        # Step 2: Try all splits from left to right\\n        left_count = 0\\n        for i in range(len(nums) - 1):\\n            if nums[i] == dominant:\\n                left_count += 1\\n            left_len = i + 1\\n            right_len = n - left_len\\n            if (left_count * 2 > left_len) and ((total - left_count) * 2 > right_len):\\n                return i\\n\\n        return -1\\n\"",
  "3811_14631217_python": "\"class Solution(object):\\n    def reverseDegree(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = 0\\n        for i, c in enumerate(s, 1):\\n            rev_idx = 26 - (ord(c) - ord('a'))\\n            total += rev_idx * i\\n        return total\\n\"",
  "1000_14631217_python-updated-time": "1746038922011",
  "262_14631217_mysql-updated-time": "1745247947992",
  "1519_14631217_python": "\"class Solution(object):\\n    def minSubsequence(self, nums):\\n        nums.sort(reverse=True)\\n        total = sum(nums)\\n        curr_sum = 0\\n        result = []\\n        for num in nums:\\n            curr_sum += num\\n            result.append(num)\\n            if curr_sum > total - curr_sum:\\n                break\\n        return result\\n\"",
  "334_14631217_python-updated-time": "1745256702181",
  "2554_14631217_python-updated-time": "1746969017743",
  "2669_14631217_python-updated-time": "1747134337196",
  "2487_14631217_python": "\"class Solution:\\n    def partitionString(self, s):\\n        seen = set()\\n        ans = 0\\n        for c in s:\\n            if c in seen:\\n                ans += 1\\n                seen.clear()\\n            seen.add(c)\\n        return ans + 1\\n\"",
  "1050_14631217_python-updated-time": "1746041277169",
  "2624_14631217_python": "\"class Solution:\\n    def differenceOfSum(self, nums):\\n        element_sum = sum(nums)\\n        digit_sum = sum(int(d) for num in nums for d in str(num))\\n        return abs(element_sum - digit_sum)\\n\"",
  "304_14631217_python": "\"class NumMatrix(object):\\n    def __init__(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        \\\"\\\"\\\"\\n        m, n = len(matrix), len(matrix[0])\\n        self.prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                self.prefix[i+1][j+1] = matrix[i][j] + self.prefix[i][j+1] + self.prefix[i+1][j] - self.prefix[i][j]\\n\\n    def sumRegion(self, row1, col1, row2, col2):\\n        \\\"\\\"\\\"\\n        :type row1: int\\n        :type col1: int\\n        :type row2: int\\n        :type col2: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self.prefix[row2+1][col2+1] - self.prefix[row1][col2+1] - self.prefix[row2+1][col1] + self.prefix[row1][col1]\\n\"",
  "564_14631217_python-updated-time": "1745447732016",
  "583_14631217_python-updated-time": "1745448030119",
  "2469_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def answerQueries(self, nums, queries):\\n        nums.sort()\\n        prefix = [0]\\n        for x in nums:\\n            prefix.append(prefix[-1] + x)\\n        res = []\\n        for q in queries:\\n            k = bisect.bisect_right(prefix, q) - 1\\n            res.append(k)\\n        return res\\n\"",
  "466_14631217_python-updated-time": "1745359806473",
  "507_14631217_python": "\"class Solution:\\n    def checkPerfectNumber(self, num):\\n        if num <= 1:\\n            return False\\n        total = 1\\n        for i in range(2, int(num ** 0.5) + 1):\\n            if num % i == 0:\\n                total += i\\n                if i != num // i:\\n                    total += num // i\\n        return total == num\\n\"",
  "989_14631217_python": "\"from collections import defaultdict\\nimport math\\n\\nclass Solution:\\n    def largestComponentSize(self, nums):\\n        parent = {}\\n\\n        def find(x):\\n            if x != parent.setdefault(x, x):\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent.setdefault(x, x)\\n            parent.setdefault(y, y)\\n            px, py = find(x), find(y)\\n            if px != py:\\n                parent[px] = py\\n\\n        def get_factors(n):\\n            factors = set()\\n            i = 2\\n            while i * i <= n:\\n                if n % i == 0:\\n                    factors.add(i)\\n                    while n % i == 0:\\n                        n //= i\\n                i += 1\\n            if n > 1:\\n                factors.add(n)\\n            return factors\\n\\n        for num in nums:\\n            factors = get_factors(num)\\n            for f in factors:\\n                union(num, f)\\n\\n        count = defaultdict(int)\\n        for num in nums:\\n            root = find(num)\\n            count[root] += 1\\n\\n        return max(count.values())\\n\"",
  "2017_14631217_python-updated-time": "1746626480577",
  "1378_14631217_python": "\"class Solution:\\n    def oddCells(self, m, n, indices):\\n        row = [0] * m\\n        col = [0] * n\\n\\n        for r, c in indices:\\n            row[r] += 1\\n            col[c] += 1\\n\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (row[i] + col[j]) % 2 == 1:\\n                    count += 1\\n\\n        return count\\n\"",
  "2802_14631217_python-updated-time": "1747139256877",
  "2505_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1]*n\\n\\n    def find(self, x):\\n        while self.parent[x] != x:\\n            self.parent[x] = self.parent[self.parent[x]]\\n            x = self.parent[x]\\n        return x\\n\\n    def union(self, a, b):\\n        ra = self.find(a)\\n        rb = self.find(b)\\n        if ra == rb:\\n            return False\\n        # union by size\\n        if self.size[ra] < self.size[rb]:\\n            ra, rb = rb, ra\\n        self.parent[rb] = ra\\n        self.size[ra] += self.size[rb]\\n        return True\\n\\nclass Solution:\\n    def numberOfGoodPaths(self, vals, edges):\\n        n = len(vals)\\n        # Group nodes by value\\n        val_nodes = {}\\n        for i, v in enumerate(vals):\\n            val_nodes.setdefault(v, []).append(i)\\n        # Sort unique values\\n        unique_vals = sorted(val_nodes.keys())\\n        # Prepare edges with weight = max(vals[u], vals[v])\\n        edges2 = []\\n        for u, v in edges:\\n            w = max(vals[u], vals[v])\\n            edges2.append((w, u, v))\\n        edges2.sort(key=lambda x: x[0])\\n\\n        dsu = DSU(n)\\n        res = n  # each node itself is a good path\\n        ei = 0\\n        m = len(edges2)\\n\\n        # Process values in ascending order\\n        for v in unique_vals:\\n            # Union all edges whose max-value <= current v\\n            while ei < m and edges2[ei][0] <= v:\\n                _, u, w = edges2[ei]\\n                dsu.union(u, w)\\n                ei += 1\\n            # Count nodes with value v in each component\\n            count = {}\\n            for node in val_nodes[v]:\\n                root = dsu.find(node)\\n                count[root] = count.get(root, 0) + 1\\n            # For each component, add combinations C(cnt, 2)\\n            for cnt in count.values():\\n                res += cnt * (cnt - 1) // 2\\n\\n        return res\\n\"",
  "2291_14631217_python-updated-time": "1746803363236",
  "337_14631217_python-updated-time": "1745256831654",
  "2867_14631217_python": "\"class Solution:\\n    def numberOfGoodSubarraySplits(self, nums):\\n        MOD = 10**9 + 7\\n        ones = [i for i, num in enumerate(nums) if num == 1]\\n\\n        if not ones:\\n            return 0\\n\\n        ans = 1\\n        for i in range(1, len(ones)):\\n            gap = ones[i] - ones[i - 1] - 1\\n            ans = (ans * (gap + 1)) % MOD\\n\\n        return ans\\n\"",
  "367_14631217_python": "\"class Solution:\\n    def isPerfectSquare(self, num):\\n        left, right = 1, num\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if mid * mid == num:\\n                return True\\n            elif mid * mid < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return False\\n\"",
  "488_14631217_python": "\"from collections import Counter, deque\\n\\nclass Solution:\\n    # fixed order of colours\\n    COLORS = ['R', 'Y', 'B', 'G', 'W']\\n    CID    = {c: i for i, c in enumerate(COLORS)}\\n\\n    # --------------------------- RLE helpers ---------------------------\\n    @staticmethod\\n    def to_rle(s):\\n        \\\"\\\"\\\"'RRBB' -> ((R,2),(B,2)) with colours as ints 0..4\\\"\\\"\\\"\\n        i, n, out = 0, len(s), []\\n        while i < n:\\n            j = i + 1\\n            while j < n and s[j] == s[i]:\\n                j += 1\\n            out.append((Solution.CID[s[i]], j - i))\\n            i = j\\n        return tuple(out)\\n\\n    @staticmethod\\n    def shrink(rle):\\n        \\\"\\\"\\\"drop runs ≥3, merge neighbours, repeat until stable\\\"\\\"\\\"\\n        changed = True\\n        while changed:\\n            changed, tmp = False, []\\n            # phase-1: drop long runs\\n            for c, k in rle:\\n                if k >= 3:\\n                    changed = True\\n                else:\\n                    tmp.append((c, k))\\n            # phase-2: merge neighbours (and drop newly ≥3)\\n            new = []\\n            for c, k in tmp:\\n                if new and new[-1][0] == c:\\n                    k += new.pop()[1]            # merged length\\n                if k >= 3:\\n                    changed = True\\n                else:\\n                    new.append((c, k))\\n            rle = tuple(new)\\n        return rle\\n\\n    @staticmethod\\n    def solvable(rle, hand_t):\\n        \\\"\\\"\\\"True if each colour on board can still reach 3 with remaining hand\\\"\\\"\\\"\\n        need = [0] * 5\\n        for c, k in rle:\\n            need[c] += k\\n        return all(need[c] == 0 or need[c] + hand_t[c] >= 3 for c in range(5))\\n\\n    # ----------------------------- BFS --------------------------------\\n    def findMinStep(self, board, hand):\\n        start_rle  = self.shrink(self.to_rle(board))\\n        start_hand = tuple(Counter(hand)[c] for c in self.COLORS)\\n\\n        dq   = deque([(start_rle, start_hand, 0)])     # (board, hand, steps)\\n        seen = { (start_rle, start_hand) }\\n\\n        while dq:\\n            rle, hand_t, steps = dq.popleft()\\n            if not rle:                     # cleared the board\\n                return steps\\n            if not self.solvable(rle, hand_t):\\n                continue\\n\\n            L = len(rle)\\n\\n            # ---- A) boundary insertions (fill + boundary-bridge) ----\\n            for pos in range(L + 1):\\n                left  = rle[pos-1][0] if pos-1 >= 0 else None\\n                right = rle[pos][0]   if pos   <  L else None\\n\\n                for col in range(5):\\n                    if hand_t[col] == 0:\\n                        continue\\n                    touch  = (left == col or right == col)\\n                    bridge = (left is not None and right is not None\\n                              and left == right and left != col)\\n                    if not touch and not bridge:\\n                        continue\\n\\n                    runs = list(rle)\\n                    if left == col and right == col:           # fill middle\\n                        runs[pos-1] = (col, rle[pos-1][1] + 1 + rle[pos][1])\\n                        del runs[pos]\\n                    elif left == col:                          # extend left\\n                        runs[pos-1] = (col, rle[pos-1][1] + 1)\\n                    elif right == col:                         # extend right\\n                        runs[pos]   = (col, rle[pos][1]   + 1)\\n                    else:                                      # boundary bridge\\n                        runs.insert(pos, (col, 1))\\n\\n                    shr   = self.shrink(tuple(runs))\\n                    new_h = list(hand_t); new_h[col] -= 1; new_h = tuple(new_h)\\n                    state = (shr, new_h)\\n                    if state not in seen:\\n                        seen.add(state)\\n                        dq.append((shr, new_h, steps + 1))\\n\\n            # ---- B) split-bridge (inside a run ≥2 with different colour) ----\\n            for i, (c_run, k) in enumerate(rle):\\n                if k < 2:\\n                    continue\\n                for col in range(5):\\n                    if col == c_run or hand_t[col] == 0:\\n                        continue\\n                    runs = list(rle)\\n                    # split: run-colour (1), inserted ball, run-colour (k-1)\\n                    runs[i:i+1] = [(c_run, 1), (col, 1), (c_run, k - 1)]\\n                    shr   = self.shrink(tuple(runs))\\n                    new_h = list(hand_t); new_h[col] -= 1; new_h = tuple(new_h)\\n                    state = (shr, new_h)\\n                    if state not in seen:\\n                        seen.add(state)\\n                        dq.append((shr, new_h, steps + 1))\\n\\n        return -1                          # impossible to clear\\n\"",
  "69_14631217_python-updated-time": "1745014958800",
  "137_14631217_python-updated-time": "1745086824899",
  "3793_14631217_python-updated-time": "1747683206801",
  "2107_14631217_python": "\"class Solution:\\n    def findDifferentBinaryString(self, nums):\\n        n = len(nums)\\n        res = []\\n        for i, s in enumerate(nums):\\n            # flip the i-th bit of the i-th string\\n            res.append('0' if s[i] == '1' else '1')\\n        return ''.join(res)\\n\"",
  "282_14631217_python": "\"class Solution(object):\\n    def addOperators(self, num, target):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        \\n        def backtrack(index, path, value, prev):\\n            if index == len(num):\\n                if value == target:\\n                    res.append(path)\\n                return\\n            \\n            for i in range(index+1, len(num)+1):\\n                temp = num[index:i]\\n                if len(temp) > 1 and temp[0] == '0':\\n                    break\\n                curr = int(temp)\\n                if index == 0:\\n                    backtrack(i, temp, curr, curr)\\n                else:\\n                    backtrack(i, path + '+' + temp, value + curr, curr)\\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\\n                    backtrack(i, path + '*' + temp, value - prev + prev * curr, prev * curr)\\n        \\n        backtrack(0, '', 0, 0)\\n        return res\\n\"",
  "1334_14631217_python": "\"class Solution:\\n    def minimumNumbers(self, num, k):\\n        # Empty set yields sum 0\\n        if num == 0:\\n            return 0\\n        \\n        # Special case k=0: must use multiples of 10, so num%10==0\\n        if k == 0:\\n            return 1 if num % 10 == 0 else -1\\n        \\n        # For k>0, search m from 1..num//k\\n        max_m = num // k\\n        for m in range(1, max_m + 1):\\n            if (num - m * k) % 10 == 0:\\n                return m\\n        \\n        return -1\\n\"",
  "3091_14631217_python-updated-time": "1747307586938",
  "1775_14631217_python-updated-time": "1746445424540",
  "2592_14631217_python": "\"class Solution:\\n    def minimumTotalCost(self, nums1, nums2):\\n        n = len(nums1)\\n        bad = []\\n        freq = {}\\n        for i in range(n):\\n            if nums1[i] == nums2[i]:\\n                bad.append(i)\\n                freq[nums1[i]] = freq.get(nums1[i], 0) + 1\\n\\n        if not bad:\\n            return 0\\n\\n        majority_val = max(freq, key=freq.get)\\n        majority_cnt = freq[majority_val]\\n        need = max(0, 2 * majority_cnt - len(bad))\\n\\n        extra = []\\n        if need:\\n            for i in range(n):\\n                if nums1[i] != nums2[i] and nums1[i] != majority_val and nums2[i] != majority_val:\\n                    extra.append(i)\\n                    if len(extra) == need:\\n                        break\\n            if len(extra) < need:\\n                return -1\\n\\n        return sum(bad) + sum(extra)\\n\"",
  "2173_14631217_python-updated-time": "1746720158183",
  "3524_14631217_python": "\"class Solution(object):\\n    def minFlips(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        # Collect each 4-cell “orbit” under row+column reversal\\n        orbits = []\\n        for i in range((m + 1)//2):\\n            for j in range((n + 1)//2):\\n                cells = {\\n                    (i, j),\\n                    (i, n-1-j),\\n                    (m-1-i, j),\\n                    (m-1-i, n-1-j)\\n                }\\n                ones = sum(grid[x][y] for x, y in cells)\\n                s = len(cells)\\n                c0 = ones        # flips to make all 0\\n                c1 = s - ones    # flips to make all 1\\n                orbits.append((s, c0, c1))\\n\\n        INF = float('inf')\\n        # dp[r] = min flips so far to get total-ones ≡ r (mod 4)\\n        dp = [0, INF, INF, INF]\\n\\n        for s, c0, c1 in orbits:\\n            s_mod = s % 4\\n            new = [INF]*4\\n            for r in range(4):\\n                # option A: set orbit to 0 → ones unchanged\\n                new[r] = min(new[r], dp[r] + c0)\\n                # option B: set orbit to 1 → ones += s\\n                new[(r + s_mod) % 4] = min(new[(r + s_mod) % 4],\\n                                           dp[r] + c1)\\n            dp = new\\n\\n        return dp[0]\\n\"",
  "used-dynamic-layout": "true",
  "2628_14631217_python-updated-time": "1747059353003",
  "1470_14631217_python-updated-time": "1746262094077",
  "949_14631217_python-updated-time": "1746003317243",
  "697_14631217_python-updated-time": "1745786001971",
  "1568_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def pseudoPalindromicPaths(self, root):\\n        self.count = 0\\n        \\n        def dfs(node, mask):\\n            if not node:\\n                return\\n            # toggle the bit corresponding to node.val\\n            mask ^= 1 << node.val\\n            # if it's a leaf, check if at most one bit is set in mask\\n            if not node.left and not node.right:\\n                # mask & (mask - 1) == 0 means at most one bit set\\n                if mask & (mask - 1) == 0:\\n                    self.count += 1\\n            else:\\n                dfs(node.left, mask)\\n                dfs(node.right, mask)\\n        \\n        dfs(root, 0)\\n        return self.count\\n\"",
  "964_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minMalwareSpread(self, graph, initial):\\n        def bfs(blocked):\\n            visited = set()\\n            q = deque()\\n\\n            for node in initial:\\n                if node != blocked:\\n                    q.append(node)\\n                    visited.add(node)\\n\\n            while q:\\n                u = q.popleft()\\n                for v in range(len(graph)):\\n                    if graph[u][v] == 1 and v not in visited and v != blocked:\\n                        visited.add(v)\\n                        q.append(v)\\n            return len(visited)\\n\\n        initial.sort()\\n        min_infected = float('inf')\\n        result = initial[0]\\n\\n        for node in initial:\\n            infected = bfs(node)\\n            if infected < min_infected:\\n                min_infected = infected\\n                result = node\\n\\n        return result\\n\"",
  "2492_14631217_python-updated-time": "1746966463882",
  "1851_14631217_python": "\"from bisect import bisect_right\\n\\nclass Solution(object):\\n    def maxValue(self, events, k):\\n        events.sort()\\n        starts = [e[0] for e in events]\\n        n = len(events)\\n        memo = {}\\n\\n        def dp(i, remaining):\\n            if i == n or remaining == 0:\\n                return 0\\n            if (i, remaining) in memo:\\n                return memo[(i, remaining)]\\n\\n            # Option 1: Skip this event\\n            skip = dp(i + 1, remaining)\\n\\n            # Option 2: Take this event\\n            _, end, val = events[i]\\n            next_i = bisect_right(starts, end)\\n            take = val + dp(next_i, remaining - 1)\\n\\n            memo[(i, remaining)] = max(skip, take)\\n            return memo[(i, remaining)]\\n\\n        return dp(0, k)\\n\"",
  "335_14631217_python": "\"class Solution(object):\\n    def isSelfCrossing(self, distance):\\n        \\\"\\\"\\\"\\n        :type distance: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        for i in range(3, len(distance)):\\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\\n                return True\\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\\n                return True\\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\\n                return True\\n        return False\\n\"",
  "843_14631217_python-updated-time": "1745879083409",
  "396_14631217_python-updated-time": "1745355596370",
  "2149_14631217_python": "\"class Solution(object):\\n    def winnerOfGame(self, colors):\\n        \\\"\\\"\\\"\\n        :type colors: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        a_moves = 0\\n        b_moves = 0\\n        n = len(colors)\\n\\n        i = 0\\n        while i < n:\\n            ch = colors[i]\\n            j = i\\n            while j < n and colors[j] == ch:\\n                j += 1\\n            count = j - i\\n            if count >= 3:\\n                if ch == 'A':\\n                    a_moves += count - 2\\n                else:\\n                    b_moves += count - 2\\n            i = j\\n\\n        return a_moves > b_moves\\n\"",
  "2524_14631217_python": "\"class Solution(object):\\n    def findMaxK(self, nums):\\n        s = set(nums)\\n        ans = -1\\n        for x in nums:\\n            if x > 0 and -x in s and x > ans:\\n                ans = x\\n        return ans\\n\"",
  "3178_14631217_python-updated-time": "1747309601034",
  "1907_14631217_python": "\"class Solution(object):\\n    def countPairs(self, nums, low, high):\\n        # determine bit length needed\\n        bitlen = max(high.bit_length(), max(nums).bit_length())\\n        # maximum number of trie nodes\\n        max_nodes = (len(nums) + 1) * (bitlen + 1)\\n        # children[b][i] = next node index from node i on bit b (0 or 1)\\n        children = [[-1] * max_nodes for _ in range(2)]\\n        # counts[i] = number of values inserted that pass through node i\\n        counts = [0] * max_nodes\\n        # next available node index\\n        node_count = [1]  # use list for mutability in nested scope\\n\\n        def add(x):\\n            node = 0\\n            for i in range(bitlen - 1, -1, -1):\\n                b = (x >> i) & 1\\n                nxt = children[b][node]\\n                if nxt == -1:\\n                    nxt = node_count[0]\\n                    children[b][node] = nxt\\n                    node_count[0] += 1\\n                node = nxt\\n                counts[node] += 1\\n\\n        def query(x, limit):\\n            if limit < 0:\\n                return 0\\n            res = 0\\n            node = 0\\n            for i in range(bitlen - 1, -1, -1):\\n                if node == -1:\\n                    break\\n                b = (x >> i) & 1\\n                l = (limit >> i) & 1\\n                if l:\\n                    # add all in branch where x^y bit = 0 => y bit = b\\n                    child = children[b][node]\\n                    if child != -1:\\n                        res += counts[child]\\n                    # then go to branch where x^y bit = 1 => y bit = 1-b\\n                    node = children[1 - b][node]\\n                else:\\n                    # must go to branch where x^y bit = 0 => y bit = b\\n                    node = children[b][node]\\n            if node != -1:\\n                res += counts[node]\\n            return res\\n\\n        ans = 0\\n        for x in nums:\\n            ans += query(x, high) - query(x, low - 1)\\n            add(x)\\n        return ans\\n\"",
  "719_14631217_python-updated-time": "1745786733018",
  "2559_14631217_python-updated-time": "1746969510447",
  "772_14631217_python-updated-time": "1745358553837",
  "719_14631217_python": "\"class Solution(object):\\n    def smallestDistancePair(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        \\n        # Helper to count number of pairs with distance <= mid\\n        def count_pairs(mid):\\n            count = 0\\n            left = 0\\n            for right in range(n):\\n                while nums[right] - nums[left] > mid:\\n                    left += 1\\n                # All indices in [left, right) form valid pairs with 'right'\\n                count += right - left\\n            return count\\n        \\n        # Binary search on distance\\n        low, high = 0, nums[-1] - nums[0]\\n        while low < high:\\n            mid = (low + high) // 2\\n            if count_pairs(mid) >= k:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n\"",
  "2587_14631217_python": "\"class Allocator:\\n    def __init__(self, n):\\n        self.mem = [0] * n\\n        self.n = n\\n\\n    def allocate(self, size, mID):\\n        i = 0\\n        while i < self.n:\\n            if self.mem[i] != 0:\\n                i += 1\\n                continue\\n            j = i\\n            while j < self.n and self.mem[j] == 0 and j - i + 1 <= size:\\n                j += 1\\n            if j - i >= size:\\n                for k in range(i, i + size):\\n                    self.mem[k] = mID\\n                return i\\n            i = j\\n        return -1\\n\\n    def freeMemory(self, mID):\\n        count = 0\\n        for i in range(self.n):\\n            if self.mem[i] == mID:\\n                self.mem[i] = 0\\n                count += 1\\n        return count\\n\"",
  "878_14631217_python-updated-time": "1745880250485",
  "2684_14631217_python": "\"class Solution(object):\\n    def isWinner(self, player1, player2):\\n        \\\"\\\"\\\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int  # 1 if p1 wins, 2 if p2 wins, 0 if tie\\n        \\\"\\\"\\\"\\n        def score(arr):\\n            total = 0\\n            n = len(arr)\\n            for i in range(n):\\n                x = arr[i]\\n                # check previous two turns\\n                if (i >= 1 and arr[i-1] == 10) or (i >= 2 and arr[i-2] == 10):\\n                    total += 2 * x\\n                else:\\n                    total += x\\n            return total\\n\\n        s1 = score(player1)\\n        s2 = score(player2)\\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        else:\\n            return 0\\n\"",
  "998_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        queue = deque([root])\\n        end = False  # flag to indicate whether a null has been seen\\n\\n        while queue:\\n            node = queue.popleft()\\n            if node is None:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                queue.append(node.left)\\n                queue.append(node.right)\\n\\n        return True\\n\"",
  "2710_14631217_python-updated-time": "1747065872776",
  "3249_14631217_python-updated-time": "1747319770491",
  "1927_14631217_python-updated-time": "1746542952407",
  "2492_14631217_python": "\"class Solution:\\n    def longestContinuousSubstring(self, s):\\n        ans = curr = 1\\n        for i in range(1, len(s)):\\n            if ord(s[i]) - ord(s[i-1]) == 1:\\n                curr += 1\\n            else:\\n                curr = 1\\n            if curr > ans:\\n                ans = curr\\n        return ans\\n\"",
  "2703_14631217_python": "\"class SegTree:\\n    def __init__(self, data):\\n        n = len(data)\\n        size = 1\\n        while size < n:\\n            size <<= 1\\n        self.size = size\\n        self.tree = [0] * (2 * size)\\n        self.lazy = [False] * (2 * size)\\n        for i, v in enumerate(data):\\n            self.tree[size + i] = v\\n        for i in range(size - 1, 0, -1):\\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\\n\\n    def _apply(self, idx, length):\\n        self.tree[idx] = length - self.tree[idx]\\n        self.lazy[idx] = not self.lazy[idx]\\n\\n    def _push(self, idx, length):\\n        if self.lazy[idx]:\\n            mid = length // 2\\n            self._apply(2 * idx, mid)\\n            self._apply(2 * idx + 1, length - mid)\\n            self.lazy[idx] = False\\n\\n    def _update(self, idx, l, r, ql, qr):\\n        if ql > r or qr < l:\\n            return\\n        if ql <= l and r <= qr:\\n            self.tree[idx] = (r - l + 1) - self.tree[idx]\\n            self.lazy[idx] = not self.lazy[idx]\\n            return\\n        self._push(idx, r - l + 1)\\n        m = (l + r) // 2\\n        self._update(2 * idx, l, m, ql, qr)\\n        self._update(2 * idx + 1, m + 1, r, ql, qr)\\n        self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1]\\n\\n    def update(self, l, r):\\n        self._update(1, 0, self.size - 1, l, r)\\n\\n    def query(self, l, r):\\n        return self._query(1, 0, self.size - 1, l, r)\\n\\n    def _query(self, idx, l, r, ql, qr):\\n        if ql > r or qr < l:\\n            return 0\\n        if ql <= l and r <= qr:\\n            return self.tree[idx]\\n        self._push(idx, r - l + 1)\\n        m = (l + r) // 2\\n        return self._query(2 * idx, l, m, ql, qr) + self._query(2 * idx + 1, m + 1, r, ql, qr)\\n\\n\\nclass Solution:\\n    def handleQuery(self, nums1, nums2, queries):\\n        n = len(nums1)\\n        st = SegTree(nums1)\\n        total = sum(nums2)\\n        ans = []\\n        for typ, x, y in queries:\\n            if typ == 1:\\n                st.update(x, y)\\n            elif typ == 2:\\n                cnt1 = st.query(0, n - 1)\\n                total += cnt1 * x\\n            else:\\n                ans.append(total)\\n        return ans\\n\"",
  "1610_14631217_python-updated-time": "1746432825824",
  "3482_14631217_python-updated-time": "1747487183946",
  "84_14631217_python-updated-time": "1745015417053",
  "2124_14631217_python": "\"class Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit):\\n        mod = 10**9 + 7\\n        n = len(nextVisit)\\n        dp = [0] * n  # dp[i] = first day we've been in room i\\n\\n        for i in range(1, n):\\n            dp[i] = (2 * dp[i-1] - dp[nextVisit[i-1]] + 2) % mod\\n\\n        return dp[-1]\\n\"",
  "1831_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def waysToSplit(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        # Build prefix sum: pre[k] = sum of nums[0..k-1]\\n        pre = [0] * (n+1)\\n        for i in range(n):\\n            pre[i+1] = pre[i] + nums[i]\\n        total = pre[n]\\n        \\n        ans = 0\\n        # i is the length of the 'left' segment: valid i in [1 .. n-2]\\n        for i in range(1, n-1):\\n            left_sum = pre[i]\\n            # lower bound on pre[j] is 2*left_sum\\n            lo = bisect.bisect_left(pre, 2*left_sum, i+1, n)\\n            # upper bound on pre[j] is floor((total+left_sum)/2)\\n            bound = (total + left_sum) // 2\\n            hi = bisect.bisect_right(pre, bound, i+1, n) - 1\\n            \\n            if lo <= hi:\\n                ans = (ans + (hi - lo + 1)) % MOD\\n        \\n        return ans\\n\"",
  "2727_14631217_python": "\"class Solution(object):\\n    def countSeniors(self, details):\\n        \\\"\\\"\\\"\\n        :type details: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        for detail in details:\\n            age = int(detail[11:13])\\n            if age > 60:\\n                count += 1\\n        return count\\n\"",
  "2016_14631217_python-updated-time": "1746626449559",
  "517_14631217_python": "\"class Solution:\\n    def findMinMoves(self, machines):\\n        total = sum(machines)\\n        n = len(machines)\\n        if total % n != 0:\\n            return -1\\n        \\n        target = total // n\\n        max_moves = 0\\n        curr_sum = 0\\n        \\n        for load in machines:\\n            curr = load - target\\n            curr_sum += curr\\n            max_moves = max(max_moves, abs(curr_sum), curr)\\n        \\n        return max_moves\\n\"",
  "837_14631217_python": "\"import collections\\nimport re\\n\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        banned_set = set(banned)\\n        words = re.findall(r'\\\\w+', paragraph.lower())\\n        count = collections.Counter(word for word in words if word not in banned_set)\\n        return count.most_common(1)[0][0]\\n\"",
  "1317_14631217_mysql-updated-time": "1746127242761",
  "3292_14631217_python-updated-time": "1747418131481",
  "884_14631217_python-updated-time": "1745953693907",
  "209_14631217_python-updated-time": "1745246013202",
  "416_14631217_python-updated-time": "1745356264414",
  "2659_14631217_python-updated-time": "1747067370924",
  "1294_14631217_python": "\"import collections\\nimport bisect\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        \\\"\\\"\\\"\\n        # Map each value to the sorted list of its positions\\n        self.pos = collections.defaultdict(list)\\n        for i, v in enumerate(arr):\\n            self.pos[v].append(i)\\n\\n    def query(self, left, right, value):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :type value: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If value never appears, frequency is 0\\n        if value not in self.pos:\\n            return 0\\n        lst = self.pos[value]\\n        # Count indices in lst within [left, right]\\n        lo = bisect.bisect_left(lst, left)\\n        hi = bisect.bisect_right(lst, right)\\n        return hi - lo\\n\"",
  "1484_14631217_python-updated-time": "1746345421014",
  "3270_14631217_python-updated-time": "1747392781036",
  "1120_14631217_python": "\"class Solution:\\n    def gardenNoAdj(self, n, paths):\\n        g = [[] for _ in range(n)]\\n        for u, v in paths:\\n            g[u - 1].append(v - 1)\\n            g[v - 1].append(u - 1)\\n\\n        ans = [0] * n\\n        for i in range(n):\\n            used = {ans[v] for v in g[i]}\\n            for c in (1, 2, 3, 4):\\n                if c not in used:\\n                    ans[i] = c\\n                    break\\n        return ans\\n\"",
  "2496_14631217_python-updated-time": "1746966073733",
  "1248_14631217_python": "\"class Solution(object):\\n    def btreeGameWinningMove(self, root, n, x):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type n: int\\n        :type x: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        self.left_count = 0\\n        self.right_count = 0\\n        \\n        def count_nodes(node):\\n            if not node:\\n                return 0\\n            left = count_nodes(node.left)\\n            right = count_nodes(node.right)\\n            if node.val == x:\\n                self.left_count = left\\n                self.right_count = right\\n            return left + right + 1\\n        \\n        count_nodes(root)\\n        \\n        parent_count = n - (self.left_count + self.right_count + 1)\\n        max_region = max(self.left_count, self.right_count, parent_count)\\n        \\n        return max_region > n // 2\\n\"",
  "2717_14631217_python-updated-time": "1747134255858",
  "2767_14631217_python-updated-time": "1747136686222",
  "101_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def isMirror(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if not t1 or not t2 or t1.val != t2.val:\\n                return False\\n            return isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left)\\n        \\n        return isMirror(root, root)\\n\"",
  "56_14631217_python-updated-time": "1745014334936",
  "593_14631217_python-updated-time": "1745448402247",
  "807_14631217_python-updated-time": "1745877802841",
  "925_14631217_python": "\"class Solution(object):\\n    def constructFromPrePost(self, preorder, postorder):\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n        L = postorder.index(preorder[1]) + 1\\n        root.left = self.constructFromPrePost(preorder[1:L+1], postorder[:L])\\n        root.right = self.constructFromPrePost(preorder[L+1:], postorder[L:-1])\\n        return root\"",
  "1522_14631217_python-updated-time": "1746346550059",
  "22_14631217_python-updated-time": "1744987652078",
  "2608_14631217_python": "\"class Solution:\\n    def countDigits(self, num):\\n        return sum(1 for d in str(num) if num % int(d) == 0)\\n\"",
  "956_14631217_python": "\"class Solution:\\n    def numMusicPlaylists(self, n, goal, k):\\n        MOD = 10**9 + 7\\n        \\n        # dp[i][j]: number of playlists of length i with j unique songs\\n        dp = [[0] * (n + 1) for _ in range(goal + 1)]\\n        dp[0][0] = 1\\n\\n        for i in range(1, goal + 1):\\n            for j in range(1, n + 1):\\n                # Add a new unique song\\n                dp[i][j] += dp[i - 1][j - 1] * (n - (j - 1))\\n                dp[i][j] %= MOD\\n                # Replay an old song (but not one of the last k songs)\\n                if j > k:\\n                    dp[i][j] += dp[i - 1][j] * (j - k)\\n                    dp[i][j] %= MOD\\n        \\n        return dp[goal][n]\\n\"",
  "2977_14631217_python-updated-time": "1747225770524",
  "2857_14631217_python-updated-time": "1747221274189",
  "3484_14631217_python": "\"class Solution(object):\\n    def getSmallestString(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        best = s\\n        n = len(s)\\n        for i in xrange(n-1):\\n            if (ord(s[i]) - ord('0')) % 2 == (ord(s[i+1]) - ord('0')) % 2:\\n                t = s[:i] + s[i+1] + s[i] + s[i+2:]\\n                if t < best:\\n                    best = t\\n        return best\\n\"",
  "1096_14631217_python-updated-time": "1746042113604",
  "3296_14631217_python": "\"class Solution(object):\\n    def minimumTimeToInitialState(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        # Compute Z-array\\n        Z = [0] * n\\n        l = r = 0\\n        for i in range(1, n):\\n            if i <= r:\\n                Z[i] = min(r - i + 1, Z[i - l])\\n            while i + Z[i] < n and word[Z[i]] == word[i + Z[i]]:\\n                Z[i] += 1\\n            if i + Z[i] - 1 > r:\\n                l, r = i, i + Z[i] - 1\\n\\n        # t_max = ceil(n / k)\\n        t_max = (n + k - 1) // k\\n        for t in range(1, t_max + 1):\\n            d = t * k\\n            # if we've shifted out the whole string or more, we can rebuild arbitrarily\\n            if d >= n:\\n                return t\\n            # else, check whether suffix at d matches prefix of length n-d\\n            if Z[d] >= n - d:\\n                return t\\n\\n        # Fallback (shouldn't happen)\\n        return t_max\\n\"",
  "3381_14631217_python": "\"class Solution(object):\\n    def minimumSubarrayLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        best = float('inf')\\n        \\n        for i in range(n):\\n            cur_or = 0\\n            # any single element subarray of length 1 suffices when k == 0\\n            # but the loop will catch that anyway\\n            for j in range(i, n):\\n                cur_or |= nums[j]\\n                if cur_or >= k:\\n                    # we found a valid subarray [i..j]\\n                    best = min(best, j - i + 1)\\n                    break  # no need to extend further from this i\\n        \\n        return best if best != float('inf') else -1\\n\"",
  "1050_14631217_python": "\"class Solution:\\n    def bstFromPreorder(self, preorder):\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        for v in preorder[1:]:\\n            node = TreeNode(v)\\n            if v < stack[-1].val:\\n                stack[-1].left = node\\n                stack.append(node)\\n            else:\\n                while stack and stack[-1].val < v:\\n                    last = stack.pop()\\n                last.right = node\\n                stack.append(node)\\n        return root\\n\"",
  "3235_14631217_python-updated-time": "1747318896336",
  "149_14631217_python": "\"class Solution(object):\\n    def maxPoints(self, points):\\n        import collections\\n        if not points:\\n            return 0\\n        n = len(points)\\n        res = 1\\n        for i in range(n):\\n            counter = collections.Counter()\\n            for j in range(i + 1, n):\\n                dx = points[j][0] - points[i][0]\\n                dy = points[j][1] - points[i][1]\\n                gcd = self.gcd(dx, dy)\\n                if gcd != 0:\\n                    dx //= gcd\\n                    dy //= gcd\\n                counter[(dx, dy)] += 1\\n            if counter:\\n                res = max(res, max(counter.values()) + 1)\\n        return res\\n\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n\"",
  "662_14631217_python": "\"class Solution(object):\\n    def widthOfBinaryTree(self, root):\\n        from collections import deque\\n        max_width = 0\\n        queue = deque([(root, 0)])\\n        \\n        while queue:\\n            level_length = len(queue)\\n            _, first_index = queue[0]\\n            for _ in range(level_length):\\n                node, idx = queue.popleft()\\n                if node.left:\\n                    queue.append((node.left, 2 * idx))\\n                if node.right:\\n                    queue.append((node.right, 2 * idx + 1))\\n            if queue:\\n                max_width = max(max_width, queue[-1][1] - queue[0][1] + 1)\\n            else:\\n                max_width = max(max_width, idx - first_index + 1)\\n        \\n        return max_width\\n\"",
  "1206_14631217_python": "\"class Solution(object):\\n    def corpFlightBookings(self, bookings, n):\\n        \\\"\\\"\\\"\\n        :type bookings: List[List[int]]\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        ans = [0] * (n + 1)\\n\\n        for first, last, seats in bookings:\\n            ans[first - 1] += seats\\n            if last < n:\\n                ans[last] -= seats\\n\\n        for i in range(1, n):\\n            ans[i] += ans[i - 1]\\n\\n        return ans[:-1]\\n\"",
  "1585_14631217_python": "\"class Solution(object):\\n    def kthFactor(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        small = []\\n        large = []\\n\\n        for i in range(1, int(n**0.5) + 1):\\n            if n % i == 0:\\n                small.append(i)\\n                if i != n // i:\\n                    large.append(n // i)\\n\\n        factors = small + large[::-1]\\n\\n        return factors[k - 1] if k <= len(factors) else -1\\n\"",
  "1582_14631217_python-updated-time": "1746432427382",
  "1668_14631217_python-updated-time": "1746434328065",
  "55_14631217_python": "\"class Solution(object):\\n    def canJump(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        max_reach = 0\\n        for i, num in enumerate(nums):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i + num)\\n        return True\\n\"",
  "announcementExpiration": "{}",
  "169_14631217_python": "\"class Solution(object):\\n    def majorityElement(self, nums):\\n        count = 0\\n        candidate = None\\n        \\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            count += (1 if num == candidate else -1)\\n        \\n        return candidate\\n\"",
  "3707_14631217_python-updated-time": "1747683770510",
  "2978_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def checkStrings(self, s1, s2):\\n        \\\"\\\"\\\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        even1 = Counter()\\n        odd1 = Counter()\\n        even2 = Counter()\\n        odd2 = Counter()\\n\\n        for i, (c1, c2) in enumerate(zip(s1, s2)):\\n            if i & 1:\\n                odd1[c1] += 1\\n                odd2[c2] += 1\\n            else:\\n                even1[c1] += 1\\n                even2[c2] += 1\\n\\n        return even1 == even2 and odd1 == odd2\\n\"",
  "1484_14631217_python": "\"class Solution(object):\\n    def isSubPath(self, head, root):\\n        def dfs_path_match(tree, list_node):\\n            if list_node is None:\\n                return True\\n            if tree is None or tree.val != list_node.val:\\n                return False\\n            return (dfs_path_match(tree.left, list_node.next) or \\n                    dfs_path_match(tree.right, list_node.next))\\n\\n        def dfs_search(tree):\\n            if tree is None:\\n                return False\\n            return (dfs_path_match(tree, head) or \\n                    dfs_search(tree.left) or \\n                    dfs_search(tree.right))\\n\\n        return dfs_search(root)\\n\"",
  "1338_14631217_mysql-updated-time": "1746259024953",
  "2670_14631217_python-updated-time": "1747134444392",
  "1095_14631217_python-updated-time": "1746042044675",
  "2844_14631217_python": "\"class Solution:\\n    def sumOfSquares(self, nums):\\n        n = len(nums)\\n        total = 0\\n        for i in range(1, n + 1):  # 1-indexed\\n            if n % i == 0:\\n                total += nums[i - 1] ** 2\\n        return total\\n\"",
  "3398_14631217_python": "\"class Solution(object):\\n    def canMakeSquare(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # There are four 2x2 sub-squares in a 3x3 grid\\n        for i in range(2):\\n            for j in range(2):\\n                # count 'B' and 'W' in this 2x2\\n                b = 0\\n                w = 0\\n                for di in (0, 1):\\n                    for dj in (0, 1):\\n                        if grid[i+di][j+dj] == 'B':\\n                            b += 1\\n                        else:\\n                            w += 1\\n                # if we can change at most one cell, we need either 4 or 3 of one color\\n                if b >= 3 or w >= 3:\\n                    return True\\n        return False\"",
  "1873_14631217_python-updated-time": "1746531749955",
  "2438_14631217_python-updated-time": "1746964589839",
  "87_14631217_python": "\"class Solution(object):\\n    def isScramble(self, s1, s2):\\n        \\\"\\\"\\\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        memo = {}\\n\\n        def dfs(s1, s2):\\n            if (s1, s2) in memo:\\n                return memo[(s1, s2)]\\n            if s1 == s2:\\n                memo[(s1, s2)] = True\\n                return True\\n            if sorted(s1) != sorted(s2):\\n                memo[(s1, s2)] = False\\n                return False\\n\\n            n = len(s1)\\n            for i in range(1, n):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                   (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])):\\n                    memo[(s1, s2)] = True\\n                    return True\\n\\n            memo[(s1, s2)] = False\\n            return False\\n\\n        return dfs(s1, s2)\\n\"",
  "1685_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def stoneGameV(self, stoneValue):\\n        n = len(stoneValue)\\n        if n < 2:\\n            return 0\\n\\n        # 1) prefix sums so any sum(i..j) is prefix[j+1]-prefix[i]\\n        prefix = [0]*(n+1)\\n        for i, v in enumerate(stoneValue):\\n            prefix[i+1] = prefix[i] + v\\n\\n        # 2) dp[i][j] = best score for subarray stoneValue[i..j]\\n        dp = [[0]*n for _ in range(n)]\\n\\n        # 3) bestLeft[i][k] = max over t in [i..k] of (prefix[t+1] + dp[i][t])\\n        bestLeft = [[float('-inf')]*n for _ in range(n)]\\n        for i in range(n):\\n            bestLeft[i][i] = prefix[i+1]  # dp[i][i]=0\\n\\n        # 4) fill by increasing j, and for each j scan i downward\\n        for j in range(1, n):\\n            # suffixBest[t] = max(dp[t][j] - prefix[t]) for t in [..j]\\n            # we build it on the fly as i goes down\\n            suffixBest = [float('-inf')] * (n+2)\\n            suffixBest[j] = dp[j][j] - prefix[j]   # = -prefix[j]\\n            suffixBest[j+1] = float('-inf')\\n\\n            for i in range(j-1, -1, -1):\\n                # incorporate dp[i+1][j] into suffixBest[i+1]\\n                val = dp[i+1][j] - prefix[i+1]\\n                old = suffixBest[i+2]\\n                suffixBest[i+1] = val if val > old else old\\n\\n                # find split‐point pivot k0 by binary search:\\n                # first u in [i+1..j] with prefix[u] - prefix[i] >= prefix[j+1] - prefix[u]\\n                S = prefix[j+1] + prefix[i]\\n                M = (S + 1)//2\\n                # prefix[u] >= M  ⇔  left(u-1) >= right(u-1)\\n                u = bisect.bisect_left(prefix, M, i+1, j+1)\\n\\n                best = 0\\n                # A1: splits k where left<right ⇒ k ≤ u-2\\n                left_end = u - 2\\n                if left_end >= i:\\n                    tmp = bestLeft[i][left_end] - prefix[i]\\n                    if tmp > best:\\n                        best = tmp\\n\\n                # A2: splits k where left>right or = ⇒ consider right+dp, t=k+1 ≥ u\\n                if u <= j:\\n                    # right side best: prefix[j+1] + max(dp[t][j] - prefix[t]) for t ≥ u\\n                    tmp = prefix[j+1] + suffixBest[u]\\n                    if tmp > best:\\n                        best = tmp\\n                    # A3: if there is an *equal* split at k_eq=u-1\\n                    if 2*prefix[u] == S:\\n                        left_k = prefix[u] - prefix[i]\\n                        # Alice can also discard *right*, so\\n                        tmp2 = left_k + dp[i][u-1]\\n                        if tmp2 > best:\\n                            best = tmp2\\n\\n                dp[i][j] = best\\n                # update bestLeft[i][j]\\n                prev = bestLeft[i][j-1]\\n                cand = prefix[j+1] + best\\n                bestLeft[i][j] = cand if cand > prev else prev\\n\\n        return dp[0][n-1]\\n\"",
  "419_14631217_python-updated-time": "1745356363239",
  "3791_14631217_python-updated-time": "1747682599549",
  "793_14631217_python": "\"class Solution(object):\\n    def canTransform(self, start, end):\\n        if start.replace('X', '') != end.replace('X', ''):\\n            return False\\n        \\n        n = len(start)\\n        i = j = 0\\n        \\n        while i < n and j < n:\\n            while i < n and start[i] == 'X':\\n                i += 1\\n            while j < n and end[j] == 'X':\\n                j += 1\\n            if i == n and j == n:\\n                return True\\n            if i == n or j == n:\\n                return False\\n            if start[i] != end[j]:\\n                return False\\n            if start[i] == 'L' and i < j:\\n                return False\\n            if start[i] == 'R' and i > j:\\n                return False\\n            i += 1\\n            j += 1\\n        \\n        return True\\n\"",
  "928_14631217_python-updated-time": "1746002091787",
  "1016_14631217_python-updated-time": "1746040000068",
  "3630_14631217_python-updated-time": "1747585845909",
  "1940_14631217_python-updated-time": "1746544208185",
  "1251_14631217_python-updated-time": "1746125900297",
  "658_14631217_python-updated-time": "1745782918712",
  "52_14631217_python": "\"class Solution(object):\\n    def totalNQueens(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        self.count = 0\\n\\n        def backtrack(row, cols, diag1, diag2):\\n            if row == n:\\n                self.count += 1\\n                return\\n            for col in range(n):\\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\\n                    continue\\n                cols.add(col)\\n                diag1.add(row - col)\\n                diag2.add(row + col)\\n                backtrack(row + 1, cols, diag1, diag2)\\n                cols.remove(col)\\n                diag1.remove(row - col)\\n                diag2.remove(row + col)\\n\\n        backtrack(0, set(), set(), set())\\n        return self.count\\n\"",
  "3142_14631217_python": "\"class Solution(object):\\n    def getWordsInLongestSubsequence(self, words, groups):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type groups: List[int]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        n = len(words)\\n\\n        def hamming(a, b):\\n            # Assumes len(a) == len(b)\\n            return sum(x != y for x, y in zip(a, b))\\n\\n        # dp[i]: length of longest valid subsequence ending at i\\n        dp = [1] * n\\n        prev = [-1] * n\\n\\n        best_i = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if groups[j] != groups[i] \\\\\\n                   and len(words[j]) == len(words[i]) \\\\\\n                   and hamming(words[j], words[i]) == 1:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        prev[i] = j\\n            if dp[i] > dp[best_i]:\\n                best_i = i\\n\\n        # Reconstruct subsequence\\n        seq = []\\n        cur = best_i\\n        while cur != -1:\\n            seq.append(words[cur])\\n            cur = prev[cur]\\n        return seq[::-1]\\n\"",
  "637_14631217_python": "\"class Solution(object):\\n    def averageOfLevels(self, root):\\n        from collections import deque\\n        res = []\\n        queue = deque([root])\\n        \\n        while queue:\\n            level_sum = 0\\n            level_count = len(queue)\\n            for _ in range(level_count):\\n                node = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            res.append(level_sum * 1.0 / level_count)\\n        \\n        return res\\n\"",
  "3552_14631217_python-updated-time": "1747502186823",
  "gbFeaturesCache": "[[\"https://ff-proxy.leetcode.com||sdk-T95loa4hi5eg6ak\",{\"data\":{\"status\":200,\"features\":{\"my-feature\":{\"defaultValue\":true},\"string-feature\":{\"defaultValue\":\"leetcode\",\"rules\":[{\"variations\":[\"leetcode1\",\"leetcode2\",\"leetcode3\"],\"weights\":[0.3334,0.3333,0.3333],\"coverage\":1,\"hashAttribute\":\"id\",\"meta\":[{\"key\":\"0\"},{\"key\":\"1\"},{\"key\":\"2\"}]}]},\"new-language\":{\"defaultValue\":\"PostgreSQL\"}},\"dateUpdated\":\"2023-11-29T23:37:44.280Z\"},\"version\":\"2023-11-29T23:37:44.280Z\",\"staleAt\":\"2024-07-13T12:56:51.344Z\"}]]",
  "3498_14631217_python": "\"class Solution(object):\\n    def minChanges(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        P = n // 2\\n        \\n        # A[d] = count of pairs with original difference d\\n        A = [0] * (k+1)\\n        # freqR[r] = count of pairs whose \\\"one-change range\\\" R_i is exactly r\\n        freqR = [0] * (k+1)\\n        \\n        # Build A and freqR\\n        for i in range(P):\\n            a = nums[i]\\n            b = nums[n-1-i]\\n            d = abs(a - b)\\n            A[d] += 1\\n            \\n            # R = max(max(a,k-a), max(b,k-b))\\n            R = max(max(a, k-a), max(b, k-b))\\n            # R is in [0..k]\\n            freqR[R] += 1\\n        \\n        # Build B[X] = sum_{r >= X} freqR[r] via suffix sum\\n        B = [0] * (k+2)\\n        for X in range(k, -1, -1):\\n            B[X] = B[X+1] + freqR[X]\\n        \\n        # Find X that maximizes S[X] = A[X] + B[X]\\n        maxS = 0\\n        for X in range(k+1):\\n            s = A[X] + B[X]\\n            if s > maxS:\\n                maxS = s\\n        \\n        # Minimum total changes = 2*P - maxS\\n        return 2*P - maxS\\n\"",
  "1459_14631217_python-updated-time": "1746345217688",
  "3360_14631217_python": "\"class Solution(object):\\n    def minimumDeletions(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n        import bisect\\n        \\n        # 1) Count frequencies of each letter\\n        cnt = Counter(word)\\n        F = sorted(cnt.values())  # list of positive frequencies\\n        m = len(F)\\n        \\n        # 2) Build prefix sums for fast range‐sum queries\\n        P = [0]*(m+1)\\n        for i in range(m):\\n            P[i+1] = P[i] + F[i]\\n        \\n        total_sum = P[m]\\n        best = total_sum  # upper bound: delete everything\\n        \\n        # 3) Candidate L values: 0 and each unique frequency\\n        candidates_L = {0}\\n        candidates_L.update(F)\\n        \\n        for L in candidates_L:\\n            R = L + k\\n            # sum of deletions for f < L  => delete all of those letters\\n            idx_l = bisect.bisect_left(F, L)\\n            del_low = P[idx_l]\\n            \\n            # sum of deletions for f > R => delete excess above R\\n            idx_r = bisect.bisect_right(F, R)\\n            # sum of f_i for i in [idx_r..m-1] is (P[m]-P[idx_r])\\n            count_high = m - idx_r\\n            sum_high = P[m] - P[idx_r]\\n            del_high = sum_high - count_high * R\\n            \\n            cost = del_low + del_high\\n            if cost < best:\\n                best = cost\\n        \\n        return best\\n\"",
  "3733_14631217_python": "\"class Solution(object):\\n    def lenOfVDiagonal(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(grid), len(grid[0])\\n        # Directions: 0 = NE, 1 = SE, 2 = SW, 3 = NW\\n        dirs = [(-1, 1), (1, 1), (1, -1), (-1, -1)]\\n\\n        # dpStart[i][j][d]: max length starting at (i,j) with a '1', then 2,0,2...\\n        # dpOdd[i][j][d]:   max length starting at (i,j) on an odd-indexed step (needs '2'), then 0,2...\\n        # dpEven[i][j][d]:  max length starting at (i,j) on an even-indexed step>=2 (needs '0'), then 2,0...\\n        dpStart = [[[0]*4 for _ in range(m)] for __ in range(n)]\\n        dpOdd   = [[[0]*4 for _ in range(m)] for __ in range(n)]\\n        dpEven  = [[[0]*4 for _ in range(m)] for __ in range(n)]\\n\\n        def fill_dir(d):\\n            dx, dy = dirs[d]\\n            # scan order so that (i+dx, j+dy) is already computed\\n            i_range = range(n) if dx < 0 else range(n-1, -1, -1)\\n            j_range = range(m) if dy < 0 else range(m-1, -1, -1)\\n            for i in i_range:\\n                for j in j_range:\\n                    ni, nj = i + dx, j + dy\\n                    # odd step: cell must be '2'\\n                    if grid[i][j] == 2:\\n                        dpOdd[i][j][d] = 1\\n                        if 0 <= ni < n and 0 <= nj < m:\\n                            dpOdd[i][j][d] += dpEven[ni][nj][d]\\n                    # even step: cell must be '0'\\n                    if grid[i][j] == 0:\\n                        dpEven[i][j][d] = 1\\n                        if 0 <= ni < n and 0 <= nj < m:\\n                            dpEven[i][j][d] += dpOdd[ni][nj][d]\\n                    # start step: cell must be '1'\\n                    if grid[i][j] == 1:\\n                        dpStart[i][j][d] = 1\\n                        if 0 <= ni < n and 0 <= nj < m:\\n                            dpStart[i][j][d] += dpOdd[ni][nj][d]\\n\\n        # fill DP for each diagonal direction\\n        for d in range(4):\\n            fill_dir(d)\\n\\n        best = 0\\n        # try every start cell and initial direction\\n        for i in range(n):\\n            for j in range(m):\\n                for d in range(4):\\n                    L = dpStart[i][j][d]\\n                    best = max(best, L)        # straight\\n                    if L == 0:\\n                        continue\\n                    dx, dy = dirs[d]\\n                    d2 = (d + 1) & 3           # clockwise turn\\n                    dx2, dy2 = dirs[d2]\\n                    ci, cj = i, j\\n                    # consider turning after each prefix of length k+1\\n                    for k in range(1, L):\\n                        ci += dx\\n                        cj += dy\\n                        ni, nj = ci + dx2, cj + dy2\\n                        if not (0 <= ni < n and 0 <= nj < m):\\n                            break\\n                        # next step index is k+1 → parity = (k+1)&1\\n                        if (k+1) & 1:\\n                            l2 = dpOdd[ni][nj][d2]\\n                        else:\\n                            l2 = dpEven[ni][nj][d2]\\n                        best = max(best, (k+1) + l2)\\n\\n        return best\\n\"",
  "1731_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def isEvenOddTree(self, root):\\n        if not root:\\n            return True\\n\\n        q = deque([root])\\n        level = 0\\n\\n        while q:\\n            size = len(q)\\n            # For even levels we need strictly increasing odd values:\\n            if level % 2 == 0:\\n                prev = 0  # anything > 0 is fine; smallest odd is 1\\n            else:\\n                # For odd levels we need strictly decreasing even values:\\n                prev = float('inf')\\n\\n            for _ in range(size):\\n                node = q.popleft()\\n                val = node.val\\n\\n                # Check parity constraint\\n                if level % 2 == 0:\\n                    # even-indexed level: values must be odd\\n                    if val % 2 == 0 or val <= prev:\\n                        return False\\n                else:\\n                    # odd-indexed level: values must be even\\n                    if val % 2 == 1 or val >= prev:\\n                        return False\\n\\n                # Update prev for strictness check\\n                prev = val\\n\\n                # Enqueue children\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n\\n            level += 1\\n\\n        return True\\n\"",
  "2255_14631217_python": "\"class Solution:\\n    def minSwaps(self, nums):\\n        total_ones = sum(nums)\\n        if total_ones <= 1:\\n            return 0\\n        \\n        n = len(nums)\\n        nums += nums  # extend array to handle circular nature\\n        max_ones_in_window = curr = sum(nums[:total_ones])\\n        for i in range(total_ones, len(nums)):\\n            curr += nums[i] - nums[i - total_ones]\\n            max_ones_in_window = max(max_ones_in_window, curr)\\n\\n        return total_ones - max_ones_in_window\\n\"",
  "176_14631217_mysql": "\"SELECT \\n    (\\n        SELECT DISTINCT salary\\n        FROM Employee\\n        ORDER BY salary DESC\\n        LIMIT 1 OFFSET 1\\n    ) AS SecondHighestSalary;\\n\"",
  "2730_14631217_python-updated-time": "1747137974188",
  "2212_14631217_python": "\"class Solution:\\n    def minimumDeletions(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Find positions of min and max\\n        min_i = max_i = 0\\n        for idx, val in enumerate(nums):\\n            if val < nums[min_i]:\\n                min_i = idx\\n            if val > nums[max_i]:\\n                max_i = idx\\n        \\n        # Let i be the earlier index, j the later\\n        i, j = min(min_i, max_i), max(min_i, max_i)\\n        \\n        # 1) Remove both from front: need j+1 deletions\\n        ops_front = j + 1\\n        # 2) Remove both from back: need n - i deletions\\n        ops_back = n - i\\n        # 3) Remove one from front (i) and one from back (j)\\n        ops_mix1 = (i + 1) + (n - j)\\n        # (The other mixed ordering is always worse, since j>=i)\\n        \\n        return min(ops_front, ops_back, ops_mix1)\\n\"",
  "185_14631217_mysql": "\"WITH RankedSalaries AS (\\n    SELECT \\n        e.id,\\n        e.name,\\n        e.salary,\\n        e.departmentId,\\n        DENSE_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rnk\\n    FROM Employee e\\n)\\nSELECT d.name AS Department, r.name AS Employee, r.salary AS Salary\\nFROM RankedSalaries r\\nJOIN Department d ON r.departmentId = d.id\\nWHERE r.rnk <= 3;\\n\"",
  "2216_14631217_python-updated-time": "1746729704228",
  "401_14631217_python": "\"class Solution:\\n    def readBinaryWatch(self, turnedOn):\\n        res = []\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\\n                    res.append(str(h) + \\\":\\\" + (\\\"%02d\\\" % m))\\n        return res\\n\"",
  "1683_14631217_python": "\"class Solution(object):\\n    def maxCoins(self, piles):\\n        \\\"\\\"\\\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        piles.sort()\\n        n = len(piles) // 3\\n        res = 0\\n        l, r = 0, len(piles) - 1\\n        for _ in range(n):\\n            # We take the triplet (piles[l], piles[r-1], piles[r])\\n            # Alice takes piles[r], we take piles[r-1], Bob takes piles[l]\\n            res += piles[r-1]\\n            l += 1\\n            r -= 2\\n        return res\\n\"",
  "1294_14631217_python-updated-time": "1746729363237",
  "755_14631217_python": "\"class Solution(object):\\n    def reachNumber(self, target):\\n        target = abs(target)\\n        move, total = 0, 0\\n        while total < target or (total - target) % 2 != 0:\\n            move += 1\\n            total += move\\n        return move\\n\"",
  "3535_14631217_python": "\"class Solution(object):\\n    def countOfPairs(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        # dp_prev[a] = # ways for arr1 up to i-1 ending with value a\\n        # initially at i=0: any a in [0..nums[0]] is allowed\\n        dp_prev = [1] * (nums[0] + 1)\\n\\n        for i in range(1, n):\\n            M0 = nums[i-1]\\n            M1 = nums[i]\\n            # d = nums[i] - nums[i-1]\\n            # we need arr1[i] >= arr1[i-1] + d  AND arr1[i]>=arr1[i-1]\\n            # combined as arr1[i] >= arr1[i-1] + max(d,0)\\n            delta = max(nums[i] - nums[i-1], 0)\\n\\n            # build prefix sums of dp_prev\\n            prefix = [0] * (M0 + 2)\\n            for a in range(M0 + 1):\\n                prefix[a+1] = (prefix[a] + dp_prev[a]) % MOD\\n\\n            # now compute dp_cur[b] for b in [0..M1]\\n            dp_cur = [0] * (M1 + 1)\\n            for b in range(delta, M1 + 1):\\n                # we need a ≤ b - delta\\n                limit = min(M0, b - delta)\\n                if limit >= 0:\\n                    # sum dp_prev[0..limit] = prefix[limit+1]\\n                    dp_cur[b] = prefix[limit+1]\\n            dp_prev = dp_cur\\n\\n        # answer = sum of dp_prev[b] over b in [0..nums[n-1]]\\n        return sum(dp_prev) % MOD\\n\"",
  "943_14631217_python": "\"class Solution:\\n    def sumSubarrayMins(self, arr):\\n        n = len(arr)\\n        mod = 10**9 + 7\\n\\n        # prev[i] = index of previous smaller element before i (or -1)\\n        prev = [0] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and arr[stack[-1]] >= arr[i]:\\n                stack.pop()\\n            prev[i] = stack[-1] if stack else -1\\n            stack.append(i)\\n\\n        # next_[i] = index of next smaller-or-equal element after i (or n)\\n        next_ = [0] * n\\n        stack = []  # reset the stack instead of using clear()\\n        for i in range(n - 1, -1, -1):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            next_[i] = stack[-1] if stack else n\\n            stack.append(i)\\n\\n        # sum contributions of each element as the minimum\\n        ans = 0\\n        for i in range(n):\\n            left = i - prev[i]\\n            right = next_[i] - i\\n            ans = (ans + arr[i] * left * right) % mod\\n\\n        return ans\\n\"",
  "3699_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def numberOfSubsequences(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        n = len(nums)\\n        # ratio_map[(a',b')] = {'L': [q1, q2, ...], 'R': [r1, r2, ...]}\\n        ratio_map = {}\\n\\n        # Build left-pairs (p, q) with q - p > 1\\n        for p in range(n - 2):\\n            ap = nums[p]\\n            for q in range(p + 2, n):\\n                bq = nums[q]\\n                g = gcd(ap, bq)\\n                key = (ap // g, bq // g)\\n                ratio_map.setdefault(key, {'L': [], 'R': []})['L'].append(q)\\n\\n        # Build right-pairs (r, s) with s - r > 1\\n        for r in range(2, n - 1):\\n            br = nums[r]\\n            for s in range(r + 2, n):\\n                as_ = nums[s]\\n                g = gcd(as_, br)\\n                key = (as_ // g, br // g)\\n                ratio_map.setdefault(key, {'L': [], 'R': []})['R'].append(r)\\n\\n        total = 0\\n        # For each ratio bucket, count valid (p,q,r,s) with r >= q+2\\n        for bucket in ratio_map.values():\\n            Lq = bucket['L']\\n            Rr = bucket['R']\\n            if not Lq or not Rr:\\n                continue\\n            Lq.sort()\\n            Rr.sort()\\n            m = len(Rr)\\n            for q in Lq:\\n                # find first r >= q + 2\\n                idx = bisect.bisect_left(Rr, q + 2)\\n                total += (m - idx)\\n\\n        return total\\n\"",
  "2018_14631217_python-updated-time": "1746626507536",
  "1031_14631217_python-updated-time": "1746040524131",
  "2395_14631217_python": "\"class Solution:\\n    def longestSubsequence(self, s, k):\\n        value = 0       # numeric value of currently chosen bits\\n        length = 0      # how many bits chosen so far\\n        ans = 0         # length of subsequence\\n\\n        for ch in reversed(s):          # scan from right-most to left\\n            if ch == '0':\\n                # always safe to prepend a 0\\n                length += 1\\n                ans += 1\\n            else:                       # ch == '1'\\n                bit_val = 1 << length   # weight of this '1' if we prepend it\\n                if value + bit_val <= k:\\n                    value += bit_val\\n                    length += 1\\n                    ans += 1\\n                # else we skip this '1'\\n\\n        return ans\\n\"",
  "830_14631217_python": "\"class Solution(object):\\n    def largestTriangleArea(self, points):\\n        def area(p1, p2, p3):\\n            return abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0\\n        \\n        n = len(points)\\n        max_area = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    max_area = max(max_area, area(points[i], points[j], points[k]))\\n        return max_area\\n\"",
  "2663_14631217_python": "\"class Solution(object):\\n    def distMoney(self, money, children):\\n        # 1) Must give at least $1 to each child\\n        if money < children:\\n            return -1\\n        \\n        # 2) Strip off the $1 per child\\n        rem = money - children\\n        \\n        # 3) Greedily give as many “+7” (to make $8 total) as possible\\n        res = min(children, rem // 7)\\n        \\n        # 4) If we gave all children their 8 but still have leftover,\\n        #    that leftover can't be assigned, so drop one 8\\n        if res == children and rem != 7 * children:\\n            res -= 1\\n        \\n        # 5) Finally, avoid the “one child gets exactly $4” trap:\\n        #    if after giving res×7 extra, the single remaining kid\\n        #    would end up with 1+3=4, we must reduce res by 1\\n        if children - res == 1 and rem - res * 7 == 3:\\n            res -= 1\\n        \\n        return res\\n\"",
  "2170_14631217_python-updated-time": "1746720090464",
  "2697_14631217_python-updated-time": "1747134966546",
  "381_14631217_python": "\"import random\\nfrom collections import defaultdict\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        self.val_to_indices = defaultdict(set)\\n        self.nums = []\\n\\n    def insert(self, val):\\n        self.val_to_indices[val].add(len(self.nums))\\n        self.nums.append(val)\\n        return len(self.val_to_indices[val]) == 1\\n\\n    def remove(self, val):\\n        if not self.val_to_indices[val]:\\n            return False\\n        remove_idx = self.val_to_indices[val].pop()\\n        last_val = self.nums[-1]\\n        self.nums[remove_idx] = last_val\\n        self.val_to_indices[last_val].add(remove_idx)\\n        self.val_to_indices[last_val].discard(len(self.nums) - 1)\\n        self.nums.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.nums)\\n\"",
  "297_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root):\\n        \\\"\\\"\\\"Encodes a tree to a single string.\\\"\\\"\\\"\\n        tokens = []\\n        \\n        def dfs(node):\\n            if node is None:\\n                tokens.append('#')    # null marker\\n                return\\n            tokens.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        dfs(root)\\n        return ','.join(tokens)\\n\\n    def deserialize(self, data):\\n        \\\"\\\"\\\"Decodes your encoded data to tree.\\\"\\\"\\\"\\n        if not data:\\n            return None\\n        \\n        tokens = iter(data.split(','))\\n        \\n        def build():\\n            val = next(tokens)\\n            if val == '#':\\n                return None\\n            node = TreeNode(int(val))\\n            node.left = build()\\n            node.right = build()\\n            return node\\n        \\n        return build()\\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree_str = ser.serialize(root)\\n# ans     = deser.deserialize(tree_str)\\n# return ans\\n\"",
  "3498_14631217_python-updated-time": "1747487555193",
  "2295_14631217_python": "\"import math\\n\\nclass Solution:\\n    def minimumFinishTime(self, tires, changeTime, numLaps):\\n        MAX_LAPS = 20  # Reasonable limit since time grows exponentially per tire\\n        INF = float('inf')\\n\\n        # Precompute minimal time for doing i laps without tire change\\n        min_time_for_laps = [INF] * (MAX_LAPS + 1)\\n        for f, r in tires:\\n            total = 0\\n            cur = f\\n            for i in range(1, MAX_LAPS + 1):\\n                total += cur\\n                if total > 10**7:\\n                    break\\n                min_time_for_laps[i] = min(min_time_for_laps[i], total)\\n                cur *= r\\n\\n        # DP to compute minimal total time for numLaps\\n        dp = [INF] * (numLaps + 1)\\n        dp[0] = 0\\n        for i in range(1, numLaps + 1):\\n            for j in range(1, min(i, MAX_LAPS) + 1):\\n                if i == j:\\n                    dp[i] = min(dp[i], min_time_for_laps[j])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - j] + changeTime + min_time_for_laps[j])\\n        return dp[numLaps]\\n\"",
  "1330_14631217_python": "\"class Solution(object):\\n    def longestSubsequence(self, arr, difference):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type difference: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = {}\\n        max_len = 0\\n        for num in arr:\\n            dp[num] = dp.get(num - difference, 0) + 1\\n            max_len = max(max_len, dp[num])\\n        return max_len\\n\"",
  "1442_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def makeConnected(self, n, connections):\\n        # Need at least n-1 cables to connect n computers\\n        if len(connections) < n - 1:\\n            return -1\\n        \\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for u, v in connections:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        visited = [False] * n\\n        components = 0\\n        \\n        # Count connected components with BFS\\n        for i in range(n):\\n            if not visited[i]:\\n                components += 1\\n                queue = deque([i])\\n                visited[i] = True\\n                while queue:\\n                    node = queue.popleft()\\n                    for nei in adj[node]:\\n                        if not visited[nei]:\\n                            visited[nei] = True\\n                            queue.append(nei)\\n        \\n        # To connect k components, need k-1 extra cables\\n        return components - 1\\n\"",
  "1325_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def maxProbability(self, n, edges, succProb, start, end):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type succProb: List[float]\\n        :type start: int\\n        :type end: int\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        # Build graph\\n        graph = defaultdict(list)\\n        for (a, b), prob in zip(edges, succProb):\\n            graph[a].append((b, prob))\\n            graph[b].append((a, prob))\\n\\n        # Max-heap: store (-probability, node)\\n        heap = [(-1.0, start)]\\n        visited = [False] * n\\n\\n        while heap:\\n            prob, node = heapq.heappop(heap)\\n            prob = -prob\\n\\n            if node == end:\\n                return prob\\n\\n            if visited[node]:\\n                continue\\n            visited[node] = True\\n\\n            for neighbor, edge_prob in graph[node]:\\n                if not visited[neighbor]:\\n                    heapq.heappush(heap, (-prob * edge_prob, neighbor))\\n\\n        return 0.0\\n\"",
  "2553_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def totalCost(self, costs, k, candidates):\\n        n = len(costs)\\n        l, r = 0, n - 1\\n        left_heap = []  # (cost, index)\\n        right_heap = []\\n\\n        # Initialize heaps with up to 'candidates' from each end\\n        for _ in range(candidates):\\n            if l <= r:\\n                heapq.heappush(left_heap, (costs[l], l))\\n                l += 1\\n        for _ in range(candidates):\\n            if l <= r:\\n                heapq.heappush(right_heap, (costs[r], r))\\n                r -= 1\\n\\n        total = 0\\n        # Hire k workers\\n        for _ in range(k):\\n            # Decide from which heap to pick\\n            if not right_heap or (left_heap and left_heap[0] <= right_heap[0]):\\n                cost, idx = heapq.heappop(left_heap)\\n                total += cost\\n                # Refill from left side if possible\\n                if l <= r:\\n                    heapq.heappush(left_heap, (costs[l], l))\\n                    l += 1\\n            else:\\n                cost, idx = heapq.heappop(right_heap)\\n                total += cost\\n                # Refill from right side if possible\\n                if l <= r:\\n                    heapq.heappush(right_heap, (costs[r], r))\\n                    r -= 1\\n\\n        return total\\n\"",
  "3778_14631217_python": "\"class Solution(object):\\n    def transformArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Replace even numbers with 0 and odd numbers with 1\\n        transformed = [0 if num % 2 == 0 else 1 for num in nums]\\n        # Sort the transformed list in non-decreasing order\\n        transformed.sort()\\n        return transformed\\n\"",
  "3387_14631217_python-updated-time": "1747423317686",
  "2671_14631217_python": "\"from collections import deque, defaultdict\\n\\nclass Solution:\\n    def findShortestCycle(self, n, edges):\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        min_cycle = float('inf')\\n\\n        for start in range(n):\\n            dist = [-1] * n\\n            parent = [-1] * n\\n            q = deque()\\n            dist[start] = 0\\n            q.append(start)\\n\\n            while q:\\n                u = q.popleft()\\n                for v in g[u]:\\n                    if dist[v] == -1:\\n                        dist[v] = dist[u] + 1\\n                        parent[v] = u\\n                        q.append(v)\\n                    elif parent[u] != v:\\n                        # Found a cycle\\n                        cycle_len = dist[u] + dist[v] + 1\\n                        min_cycle = min(min_cycle, cycle_len)\\n\\n        return min_cycle if min_cycle != float('inf') else -1\\n\"",
  "741_14631217_python": "\"class Solution(object):\\n    def cherryPickup(self, grid):\\n        n = len(grid)\\n        dp = [[[float('-inf')] * n for _ in range(n)] for _ in range(n)]\\n        dp[0][0][0] = grid[0][0]\\n        \\n        for k in range(1, 2 * n - 1):\\n            temp = [[[float('-inf')] * n for _ in range(n)] for _ in range(n)]\\n            for x1 in range(max(0, k - (n - 1)), min(n, k + 1)):\\n                y1 = k - x1\\n                if y1 >= n or grid[x1][y1] == -1:\\n                    continue\\n                for x2 in range(max(0, k - (n - 1)), min(n, k + 1)):\\n                    y2 = k - x2\\n                    if y2 >= n or grid[x2][y2] == -1:\\n                        continue\\n                    best = float('-inf')\\n                    for preX1, preX2 in [(x1 - 1, x2 - 1), (x1 - 1, x2), (x1, x2 - 1), (x1, x2)]:\\n                        if 0 <= preX1 < n and 0 <= preX2 < n:\\n                            best = max(best, dp[preX1][preX2][k-1-preX1-preX2])\\n                    if best != float('-inf'):\\n                        temp[x1][x2][k-x1-x2] = best + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\\n            dp = temp\\n        return max(0, dp[n-1][n-1][0])\\n\"",
  "803_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = collections.defaultdict(list)\\n        for u, v, w in flights:\\n            graph[u].append((v, w))\\n        \\n        dist = [float('inf')] * n\\n        dist[src] = 0\\n        queue = [(src, 0)]\\n        \\n        steps = 0\\n        while queue and steps <= k:\\n            next_dist = dist[:]\\n            for u, cost_u in queue:\\n                for v, price in graph[u]:\\n                    if cost_u + price < next_dist[v]:\\n                        next_dist[v] = cost_u + price\\n            dist = next_dist\\n            queue = [(i, dist[i]) for i in range(n) if dist[i] != float('inf')]\\n            steps += 1\\n        \\n        return -1 if dist[dst] == float('inf') else dist[dst]\\n\"",
  "3408_14631217_python": "\"class Solution(object):\\n    def numberOfSpecialChars(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # collect unique lowercase and uppercase letters\\n        lowers = set()\\n        uppers = set()\\n        for ch in word:\\n            if 'a' <= ch <= 'z':\\n                lowers.add(ch)\\n            elif 'A' <= ch <= 'Z':\\n                uppers.add(ch)\\n        # count characters whose lowercase form appears in both sets\\n        count = 0\\n        for c in lowers:\\n            if c.upper() in uppers:\\n                count += 1\\n        return count\"",
  "3234_14631217_python-updated-time": "1747317321834",
  "1629_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minInteger(self, num, k):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(num)\\n        pos = [[] for _ in range(10)]\\n\\n        # Store positions of each digit\\n        for i in range(n):\\n            pos[int(num[i])].append(i)\\n\\n        used = [0] * n  # Marks if digit is already used\\n        res = []\\n        BIT = [0] * (n + 2)  # Fenwick Tree to count used positions\\n\\n        # Fenwick tree helpers\\n        def update(i):\\n            i += 1\\n            while i < len(BIT):\\n                BIT[i] += 1\\n                i += i & -i\\n\\n        def query(i):\\n            i += 1\\n            s = 0\\n            while i > 0:\\n                s += BIT[i]\\n                i -= i & -i\\n            return s\\n\\n        for _ in range(n):\\n            for d in range(10):\\n                if not pos[d]:\\n                    continue\\n                idx = pos[d][0]\\n                moved = idx - query(idx)\\n                if moved <= k:\\n                    k -= moved\\n                    res.append(str(d))\\n                    update(idx)\\n                    pos[d].pop(0)\\n                    break\\n\\n        return ''.join(res)\\n\"",
  "3071_14631217_pythondata-updated-time": "1747305697122",
  "1468_14631217_python": "\"class Solution:\\n    def checkIfExist(self, arr):\\n        s = set(arr)\\n        # Special case: zero doubled is zero, need at least two zeros\\n        if arr.count(0) > 1:\\n            return True\\n        # For any non-zero x, check if 2*x exists\\n        for x in arr:\\n            if x != 0 and 2 * x in s:\\n                return True\\n        return False\\n\"",
  "2706_14631217_python": "\"class Solution(object):\\n    def minimizeSum(self, nums):\\n        nums.sort()\\n        n = len(nums)\\n        # remove two smallest, two largest, or one of each\\n        return min(\\n            nums[n-3] - nums[0],\\n            nums[n-2] - nums[1],\\n            nums[n-1] - nums[2]\\n        )\\n\"",
  "76_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if not s or not t:\\n            return \\\"\\\"\\n        \\n        t_count = Counter(t)\\n        window_count = {}\\n        have, need = 0, len(t_count)\\n        res = [-1, -1]\\n        res_len = float('inf')\\n        left = 0\\n\\n        for right in range(len(s)):\\n            c = s[right]\\n            window_count[c] = window_count.get(c, 0) + 1\\n\\n            if c in t_count and window_count[c] == t_count[c]:\\n                have += 1\\n\\n            while have == need:\\n                if (right - left + 1) < res_len:\\n                    res = [left, right]\\n                    res_len = right - left + 1\\n\\n                window_count[s[left]] -= 1\\n                if s[left] in t_count and window_count[s[left]] < t_count[s[left]]:\\n                    have -= 1\\n                left += 1\\n\\n        l, r = res\\n        return s[l:r+1] if res_len != float('inf') else \\\"\\\"\\n\"",
  "1205_14631217_python-updated-time": "1746108746927",
  "2596_14631217_python": "\"class Solution:\\n    def isPossible(self, n, edges):\\n        # Build degree array and adjacency sets\\n        deg = [0] * (n + 1)\\n        adj = [set() for _ in range(n + 1)]\\n        for u, v in edges:\\n            deg[u] += 1\\n            deg[v] += 1\\n            adj[u].add(v)\\n            adj[v].add(u)\\n\\n        # Find nodes with odd degree\\n        odd = [i for i in range(1, n + 1) if deg[i] % 2]\\n        k = len(odd)\\n\\n        # 0 odd: already all even\\n        if k == 0:\\n            return True\\n        # Only 2 or 4 odd nodes can be fixed with ≤2 edges\\n        if k not in (2, 4):\\n            return False\\n\\n        # Case k == 2: try one edge or two‐edge workaround\\n        if k == 2:\\n            u, v = odd\\n            # If u and v not already connected, add (u,v)\\n            if v not in adj[u]:\\n                return True\\n            # Otherwise, look for a third node x unconnected to both\\n            forbidden = adj[u] | adj[v] | {u, v}\\n            return len(forbidden) < n\\n\\n        # Case k == 4: try pairing the four odds in any way\\n        a, b, c, d = odd\\n        for x, y, p, q in [(a, b, c, d), (a, c, b, d), (a, d, b, c)]:\\n            if y not in adj[x] and q not in adj[p]:\\n                return True\\n\\n        return False\\n\"",
  "3299_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maximumLength(self, nums):\\n        count = Counter(nums)\\n        ans = 1\\n        # special‐case x = 1: you can form the longest odd palindrome of 1’s\\n        c1 = count.get(1, 0)\\n        if c1 > 0:\\n            if c1 % 2 == 1:\\n                ans = max(ans, c1)\\n            else:\\n                ans = max(ans, c1 - 1)\\n        limit = 10**9\\n        for x in count:\\n            if x == 1:\\n                continue\\n            # build the chain [x, x^2, x^4, ...] until missing or repeats\\n            v = x\\n            seen = set()\\n            chain = []\\n            while v <= limit and v in count and v not in seen:\\n                chain.append(v)\\n                seen.add(v)\\n                v = v * v\\n            # try each possible center at chain[m]\\n            prefix_ok = True\\n            for m in range(1, len(chain)):\\n                if count[chain[m-1]] < 2:\\n                    prefix_ok = False\\n                if not prefix_ok:\\n                    break\\n                # we know chain[m] exists at least once\\n                ans = max(ans, 2*m + 1)\\n        return ans\\n\"",
  "2882_14631217_python": "\"class Solution:\\n    def numberOfWays(self, n, x):\\n        MOD = 10**9 + 7\\n        dp = [0] * (n + 1)\\n        dp[0] = 1\\n        \\n        num = 1\\n        while num**x <= n:\\n            power = num**x\\n            for i in range(n, power - 1, -1):\\n                dp[i] = (dp[i] + dp[i - power]) % MOD\\n            num += 1\\n        \\n        return dp[n]\\n\"",
  "1612_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def avoidFlood(self, rains):\\n        \\\"\\\"\\\"\\n        :type rains: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        full = {}           # Map from lake -> index of last full day\\n        dry_days = []       # Indices of dry days\\n        res = [-1] * len(rains)\\n\\n        for i in range(len(rains)):\\n            lake = rains[i]\\n            if lake == 0:\\n                dry_days.append(i)\\n                res[i] = 1  # Default, will be updated if needed\\n            else:\\n                if lake in full:\\n                    # Need to dry lake before today\\n                    prev_day = full[lake]\\n                    idx = bisect.bisect_right(dry_days, prev_day)\\n                    if idx == len(dry_days):\\n                        return []  # No day to dry the lake → flood\\n                    dry_day = dry_days[idx]\\n                    res[dry_day] = lake\\n                    dry_days.pop(idx)\\n                full[lake] = i  # Mark lake as full\\n\\n        return res\\n\"",
  "1834_14631217_python-updated-time": "1746530377596",
  "452_14631217_python-updated-time": "1745359283165",
  "57_14631217_python-updated-time": "1745014359048",
  "2609_14631217_python-updated-time": "1747060062859",
  "679_14631217_python": "\"class Solution(object):\\n    def judgePoint24(self, cards):\\n        def dfs(nums):\\n            if len(nums) == 1:\\n                return abs(nums[0] - 24) < 1e-6\\n            n = len(nums)\\n            for i in range(n):\\n                for j in range(n):\\n                    if i != j:\\n                        next_nums = []\\n                        for k in range(n):\\n                            if k != i and k != j:\\n                                next_nums.append(nums[k])\\n                        a, b = nums[i], nums[j]\\n                        for op in [a + b, a - b, b - a, a * b]:\\n                            next_nums.append(op)\\n                            if dfs(next_nums):\\n                                return True\\n                            next_nums.pop()\\n                        if abs(b) > 1e-6:\\n                            next_nums.append(a / b)\\n                            if dfs(next_nums):\\n                                return True\\n                            next_nums.pop()\\n                        if abs(a) > 1e-6:\\n                            next_nums.append(b / a)\\n                            if dfs(next_nums):\\n                                return True\\n                            next_nums.pop()\\n            return False\\n        \\n        return dfs(map(float, cards))\\n\"",
  "1255_14631217_python": "\"class Solution:\\n    def maxValueAfterReverse(self, nums):\\n        n = len(nums)\\n        # Base sum of adjacent differences\\n        base = sum(abs(nums[i] - nums[i+1]) for i in range(n-1))\\n\\n        # 1) Best prefix reversal gain\\n        best_prefix = 0\\n        for i in range(n-1):\\n            gain = abs(nums[0] - nums[i+1]) - abs(nums[i] - nums[i+1])\\n            if gain > best_prefix:\\n                best_prefix = gain\\n\\n        # 2) Best suffix reversal gain\\n        best_suffix = 0\\n        for i in range(1, n):\\n            gain = abs(nums[i-1] - nums[n-1]) - abs(nums[i-1] - nums[i])\\n            if gain > best_suffix:\\n                best_suffix = gain\\n\\n        # 3) Best middle reversal gain\\n        # Track min of max(adjacent pair) and max of min(adjacent pair)\\n        min_of_max = float('inf')\\n        max_of_min = float('-inf')\\n        for i in range(n-1):\\n            a, b = nums[i], nums[i+1]\\n            mn, mx = min(a, b), max(a, b)\\n            if mx < min_of_max:\\n                min_of_max = mx\\n            if mn > max_of_min:\\n                max_of_min = mn\\n        best_middle = 2 * (max_of_min - min_of_max)\\n\\n        best_gain = max(best_prefix, best_suffix, best_middle)\\n        return base + best_gain\\n\"",
  "1996_14631217_python-updated-time": "1746625377070",
  "2241_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def recoverArray(self, nums):\\n        nums.sort()\\n        n = len(nums) // 2\\n\\n        for i in range(1, len(nums)):\\n            diff = nums[i] - nums[0]\\n            if diff == 0 or diff % 2 != 0:\\n                continue\\n            k = diff // 2\\n            count = Counter(nums)\\n            res = []\\n            valid = True\\n            for x in nums:\\n                if count[x] == 0:\\n                    continue\\n                if count[x + 2 * k] == 0:\\n                    valid = False\\n                    break\\n                res.append(x + k)\\n                count[x] -= 1\\n                count[x + 2 * k] -= 1\\n            if valid and len(res) == n:\\n                return res\\n\"",
  "1771_14631217_python-updated-time": "1746445202550",
  "2732_14631217_javascript-updated-time": "1747135150413",
  "2275_14631217_python-updated-time": "1746802810187",
  "1433_14631217_python": "\"class Encrypter(object):\\n    def __init__(self, keys, values, dictionary):\\n        # Map from char to its 2-letter encryption\\n        self.enc = {k: v for k, v in zip(keys, values)}\\n        # Precompute how many dictionary words encrypt to a given cipher\\n        self.count = {}\\n        for word in dictionary:\\n            e = self.encrypt(word)\\n            if e:\\n                self.count[e] = self.count.get(e, 0) + 1\\n\\n    def encrypt(self, word1):\\n        res = []\\n        for c in word1:\\n            if c not in self.enc:\\n                return \\\"\\\"\\n            res.append(self.enc[c])\\n        return \\\"\\\".join(res)\\n\\n    def decrypt(self, word2):\\n        return self.count.get(word2, 0)\\n\"",
  "916_14631217_python-updated-time": "1746001703887",
  "2837_14631217_python-updated-time": "1747221706587",
  "3567_14631217_python-updated-time": "1747570933340",
  "2916_14631217_python": "\"class Solution(object):\\n    def canSplitArray(self, nums, m):\\n        n = len(nums)\\n        if n <= 2:\\n            return True\\n        for i in range(n - 1):\\n            if nums[i] + nums[i + 1] >= m:\\n                return True\\n        return False\\n\"",
  "3468_14631217_python-updated-time": "1747487016545",
  "1072_14631217_python-updated-time": "1746041730673",
  "1393_14631217_python": "\"class Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        # dp[j]: max value picking j coins so far\\n        dp = [-10**18] * (k + 1)\\n        dp[0] = 0\\n        for pile in piles:\\n            # compute prefix sums\\n            pre = [0]\\n            for v in pile:\\n                pre.append(pre[-1] + v)\\n            m = len(pile)\\n            # new dp for this pile\\n            ndp = dp[:]  # copy\\n            for j in xrange(k + 1):\\n                if dp[j] < 0:\\n                    continue\\n                # try taking x coins from this pile\\n                # x from 1 to min(m, k-j)\\n                up = min(m, k - j)\\n                for x in xrange(1, up + 1):\\n                    val = dp[j] + pre[x]\\n                    if val > ndp[j + x]:\\n                        ndp[j + x] = val\\n            dp = ndp\\n        return dp[k]\\n\"",
  "1543_14631217_python": "\"class Solution(object):\\n    def simplifiedFractions(self, n):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        res = []\\n        for d in range(2, n + 1):\\n            for num in range(1, d):\\n                if gcd(num, d) == 1:\\n                    res.append(str(num) + \\\"/\\\" + str(d))\\n        return res\\n\"",
  "2509_14631217_python-updated-time": "1746967018369",
  "135_14631217_python-updated-time": "1745086753884",
  "2870_14631217_python": "\"class Solution:\\n    def alternatingSubarray(self, nums):\\n        n = len(nums)\\n        max_len = -1\\n        i = 0\\n\\n        while i < n - 1:\\n            if nums[i + 1] - nums[i] == 1:\\n                length = 2\\n                j = i + 1\\n                expected = -1\\n                while j + 1 < n and nums[j + 1] - nums[j] == expected:\\n                    length += 1\\n                    j += 1\\n                    expected *= -1\\n                max_len = max(max_len, length)\\n                i = j  # skip to end of this valid window\\n            else:\\n                i += 1\\n\\n        return max_len\\n\"",
  "2921_14631217_python": "\"class Solution(object):\\n    def countSteppingNumbers(self, low, high):\\n        \\\"\\\"\\\"\\n        :type low: str\\n        :type high: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n\\n        def dec_str(s):\\n            # subtract 1 from decimal string s (s represents integer >= 1)\\n            lst = list(s)\\n            i = len(lst) - 1\\n            while i >= 0:\\n                if lst[i] == '0':\\n                    lst[i] = '9'\\n                    i -= 1\\n                else:\\n                    lst[i] = str(ord(lst[i]) - ord('0') - 1)\\n                    break\\n            res = ''.join(lst).lstrip('0')\\n            return res if res else \\\"0\\\"\\n\\n        def count_upto(s):\\n            digits = list(map(int, s))\\n            n = len(digits)\\n            memo = {}\\n\\n            def dfs(pos, last, tight, started):\\n                # pos: current index in digits\\n                # last: last digit used (or -1 if not started)\\n                # tight: whether we are matching prefix of s\\n                # started: whether we've placed a nonzero and begun the number\\n                if pos == n:\\n                    return 1 if started else 0\\n\\n                key = (pos, last, tight, started)\\n                if key in memo:\\n                    return memo[key]\\n\\n                limit = digits[pos] if tight else 9\\n                ans = 0\\n\\n                for d in range(0, limit + 1):\\n                    ntight = tight and (d == limit)\\n                    if not started:\\n                        # still skipping leading zeros\\n                        if d == 0:\\n                            ans += dfs(pos + 1, -1, ntight, False)\\n                        else:\\n                            # start the number here\\n                            ans += dfs(pos + 1, d, ntight, True)\\n                    else:\\n                        # already started: enforce |d-last| == 1\\n                        if abs(d - last) == 1:\\n                            ans += dfs(pos + 1, d, ntight, True)\\n                        # else skip\\n\\n                ans %= MOD\\n                memo[key] = ans\\n                return ans\\n\\n            return dfs(0, -1, True, False)\\n\\n        low_minus = dec_str(low)\\n        res = count_upto(high) - count_upto(low_minus)\\n        return res % MOD\\n\"",
  "3416_14631217_python-updated-time": "1747482909724",
  "1923_14631217_python": "\"class Solution(object):\\n    def areSentencesSimilar(self, sentence1, sentence2):\\n        words1 = sentence1.split()\\n        words2 = sentence2.split()\\n        # ensure words1 is the shorter\\n        if len(words1) > len(words2):\\n            words1, words2 = words2, words1\\n        n1, n2 = len(words1), len(words2)\\n        # match prefix\\n        i = 0\\n        while i < n1 and words1[i] == words2[i]:\\n            i += 1\\n        # match suffix\\n        j = 0\\n        while j < n1 - i and words1[-1 - j] == words2[-1 - j]:\\n            j += 1\\n        return i + j == n1\\n\"",
  "3466_14631217_python": "\"class Solution(object):\\n    def countSubarrays(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = 0\\n        # prev holds pairs (and_value, count) for subarrays ending at previous index\\n        prev = []\\n        for x in nums:\\n            curr = [(x, 1)]\\n            # extend previous subarrays by x\\n            for val, cnt in prev:\\n                new_val = val & x\\n                if curr[-1][0] == new_val:\\n                    # merge counts if same AND value\\n                    curr[-1] = (new_val, curr[-1][1] + cnt)\\n                else:\\n                    curr.append((new_val, cnt))\\n            # count those ending here with AND == k\\n            for val, cnt in curr:\\n                if val == k:\\n                    res += cnt\\n            prev = curr\\n        return res\\n\"",
  "2332_14631217_python": "\"class Solution:\\n    def countLatticePoints(self, circles):\\n        # Since 1 <= xi, yi <= 100 and ri <= min(xi, yi),\\n        # all lattice points lie in [0..200] × [0..200].\\n        MAXC = 200\\n        # grid[x][y] = True if (x,y) is in at least one circle\\n        grid = [[False] * (MAXC+1) for _ in range(MAXC+1)]\\n        \\n        for xi, yi, ri in circles:\\n            r2 = ri * ri\\n            # sweep x from xi - ri to xi + ri\\n            x_lo = max(0, xi - ri)\\n            x_hi = min(MAXC, xi + ri)\\n            for x in range(x_lo, x_hi+1):\\n                dx = x - xi\\n                rem = r2 - dx*dx\\n                # largest integer dy with dy^2 <= rem\\n                dy = int(rem**0.5)\\n                y_lo = max(0, yi - dy)\\n                y_hi = min(MAXC, yi + dy)\\n                row = grid[x]\\n                for y in range(y_lo, y_hi+1):\\n                    row[y] = True\\n        \\n        # count marked points\\n        ans = 0\\n        for x in range(MAXC+1):\\n            ans += sum(grid[x])\\n        return ans\\n\"",
  "3234_14631217_python": "\"class Solution(object):\\n    def getGoodIndices(self, variables, target):\\n        \\\"\\\"\\\"\\n        :type variables: List[List[int]]\\n        :type target: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        for i, (a, b, c, m) in enumerate(variables):\\n            # Compute a^b mod 10\\n            x = pow(a, b, 10)\\n            # Then compute x^c mod m\\n            if pow(x, c, m) == target:\\n                res.append(i)\\n        return res\\n\"",
  "60_14631217_python": "\"class Solution(object):\\n    def getPermutation(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        from math import factorial\\n\\n        numbers = [str(i) for i in range(1, n + 1)]\\n        k -= 1\\n        res = \\\"\\\"\\n\\n        for i in range(n, 0, -1):\\n            f = factorial(i - 1)\\n            index = k // f\\n            res += numbers[index]\\n            numbers.pop(index)\\n            k %= f\\n\\n        return res\\n\"",
  "936_14631217_python-updated-time": "1746002441787",
  "2817_14631217_python": "\"class Solution:\\n    def minimumCost(self, s):\\n        n = len(s)\\n        cost = 0\\n\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                cost += min(i, n - i)\\n\\n        return cost\\n\"",
  "1290_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def makeArrayIncreasing(self, arr1, arr2):\\n        arr2 = sorted(set(arr2))  # remove duplicates and sort\\n        memo = {}\\n\\n        def dp(i, prev):\\n            key = (i, prev)\\n            if key in memo:\\n                return memo[key]\\n\\n            if i == len(arr1):\\n                return 0\\n\\n            res = float('inf')\\n\\n            # Option 1: Keep arr1[i] if it's strictly increasing\\n            if arr1[i] > prev:\\n                res = dp(i + 1, arr1[i])\\n\\n            # Option 2: Replace with next greater in arr2\\n            idx = bisect.bisect_right(arr2, prev)\\n            if idx < len(arr2):\\n                res = min(res, 1 + dp(i + 1, arr2[idx]))\\n\\n            memo[key] = res\\n            return res\\n\\n        ans = dp(0, -1)\\n        return ans if ans != float('inf') else -1\\n\"",
  "2106_14631217_python-updated-time": "1746715700171",
  "834_14631217_python": "\"class Solution(object):\\n    def ambiguousCoordinates(self, s):\\n        def make(s):\\n            res = []\\n            if s == \\\"0\\\":\\n                res.append(\\\"0\\\")\\n            elif s[0] == \\\"0\\\":\\n                if s[-1] != \\\"0\\\":\\n                    res.append(s[0] + \\\".\\\" + s[1:])\\n            elif s[-1] == \\\"0\\\":\\n                res.append(s)\\n            else:\\n                res.append(s)\\n                for i in range(1, len(s)):\\n                    res.append(s[:i] + \\\".\\\" + s[i:])\\n            return res\\n        \\n        s = s[1:-1]\\n        n = len(s)\\n        ans = []\\n        for i in range(1, n):\\n            left = make(s[:i])\\n            right = make(s[i:])\\n            for l in left:\\n                for r in right:\\n                    ans.append(\\\"(\\\" + l + \\\", \\\" + r + \\\")\\\")\\n        return ans\\n\"",
  "2342_14631217_python-updated-time": "1746880229051",
  "2232_14631217_python-updated-time": "1746800063170",
  "3841_14631217_python-updated-time": "1747745244084",
  "2115_14631217_python-updated-time": "1746717107522",
  "2855_14631217_python-updated-time": "1747222224047",
  "1236_14631217_python-updated-time": "1746109274419",
  "141_14631217_python-updated-time": "1745086981362",
  "3345_14631217_python-updated-time": "1747420955791",
  "3536_14631217_python": "\"class Solution(object):\\n    def countOfPairs(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        \\n        # dp_prev[a] = number of ways to choose arr1[0..i-1] with arr1[i-1] = a\\n        # For i = 0, arr1[0] can be any a in [0..nums[0]]\\n        dp_prev = [1] * (nums[0] + 1)\\n        \\n        for i in range(1, n):\\n            prev_max = len(dp_prev) - 1\\n            cur_max = nums[i]\\n            # required jump Δ = max(nums[i] - nums[i-1], 0)\\n            delta = max(nums[i] - nums[i-1], 0)\\n            \\n            # build prefix sums of dp_prev for O(1) range sums\\n            prefix = [0] * (prev_max + 2)\\n            for a in range(prev_max + 1):\\n                prefix[a+1] = (prefix[a] + dp_prev[a]) % MOD\\n            \\n            # compute dp_cur[b] for b in [0..cur_max]\\n            dp_cur = [0] * (cur_max + 1)\\n            for b in range(delta, cur_max + 1):\\n                # we need a <= b - delta\\n                limit = b - delta\\n                if limit > prev_max:\\n                    limit = prev_max\\n                # sum of dp_prev[0..limit]:\\n                dp_cur[b] = prefix[limit + 1]\\n            \\n            dp_prev = dp_cur\\n        \\n        # total ways = sum of dp_prev over all possible arr1[n-1] values\\n        return sum(dp_prev) % MOD\\n\"",
  "819_14631217_python": "\"class Solution(object):\\n    def minSwap(self, nums1, nums2):\\n        n = len(nums1)\\n        keep = [float('inf')] * n\\n        swap = [float('inf')] * n\\n        keep[0] = 0\\n        swap[0] = 1\\n        \\n        for i in range(1, n):\\n            if nums1[i] > nums1[i-1] and nums2[i] > nums2[i-1]:\\n                keep[i] = keep[i-1]\\n                swap[i] = swap[i-1] + 1\\n            if nums1[i] > nums2[i-1] and nums2[i] > nums1[i-1]:\\n                keep[i] = min(keep[i], swap[i-1])\\n                swap[i] = min(swap[i], keep[i-1] + 1)\\n        \\n        return min(keep[-1], swap[-1])\\n\"",
  "1147_14631217_python-updated-time": "1746107831603",
  "1027_14631217_python": "\"class Solution:\\n    def sumEvenAfterQueries(self, nums, queries):\\n        result = []\\n        even_sum = sum(x for x in nums if x % 2 == 0)\\n\\n        for val, idx in queries:\\n            if nums[idx] % 2 == 0:\\n                even_sum -= nums[idx]\\n            nums[idx] += val\\n            if nums[idx] % 2 == 0:\\n                even_sum += nums[idx]\\n            result.append(even_sum)\\n\\n        return result\\n\"",
  "3220_14631217_python": "\"class Solution(object):\\n    def countTestedDevices(self, batteryPercentages):\\n        \\\"\\\"\\\"\\n        :type batteryPercentages: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        tested = 0    # number of devices we've tested so far (and hence total decrements applied to future devices)\\n        count = 0     # answer: how many devices get tested\\n        \\n        for b in batteryPercentages:\\n            # effective battery after all prior decrements is b - tested (floored at 0)\\n            if b > tested:\\n                count += 1\\n                tested += 1\\n        \\n        return count\\n\"",
  "3276_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def minimumPushes(self, word):\\n        freq = collections.Counter(word)\\n        freqs = sorted(freq.values(), reverse=True)\\n\\n        total = 0\\n        pos = 0\\n        for f in freqs:\\n            total += (pos // 8 + 1) * f\\n            pos += 1\\n        return total\\n\"",
  "57_14631217_python": "\"class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \\\"\\\"\\\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(newInterval[0], intervals[i][0])\\n            newInterval[1] = max(newInterval[1], intervals[i][1])\\n            i += 1\\n\\n        res.append(newInterval)\\n\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n\\n        return res\\n\"",
  "1553_14631217_python-updated-time": "1746347453185",
  "2367_14631217_python-updated-time": "1746881469691",
  "1574_14631217_python": "\"class Solution(object):\\n    def maxProduct(self, nums):\\n        # Find the two largest numbers in one pass\\n        max1 = max2 = 0\\n        for x in nums:\\n            if x > max1:\\n                max2, max1 = max1, x\\n            elif x > max2:\\n                max2 = x\\n        return (max1 - 1) * (max2 - 1)\\n\"",
  "3626_14631217_python-updated-time": "1747586196566",
  "436_14631217_python-updated-time": "1745358816585",
  "143_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \\\"\\\"\\\"\\n        if not head or not head.next:\\n            return\\n        \\n        # Step 1: Find the middle of the list\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Step 2: Reverse the second half\\n        prev = None\\n        curr = slow.next\\n        slow.next = None  # Cut the list into two halves\\n        while curr:\\n            next_temp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_temp\\n        \\n        # Step 3: Merge two halves\\n        first, second = head, prev\\n        while second:\\n            tmp1 = first.next\\n            tmp2 = second.next\\n\\n            first.next = second\\n            second.next = tmp1\\n\\n            first = tmp1\\n            second = tmp2\\n\"",
  "3845_14631217_python-updated-time": "1747758163338",
  "2032_14631217_python": "\"class Solution:\\n    def largestOddNumber(self, num):\\n        for i in range(len(num) - 1, -1, -1):\\n            if int(num[i]) % 2 == 1:\\n                return num[:i + 1]\\n        return \\\"\\\"\\n\"",
  "2409_14631217_python-updated-time": "1746906738908",
  "3594_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def getLargestOutlier(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = sum(nums)\\n        freq = Counter(nums)\\n        \\n        best = -10**18\\n        for s in nums:\\n            v = total - 2*s\\n            # check if v exists at some index != the one giving s\\n            # if v != s, need freq[v] >= 1; if v == s, need freq[v] >= 2\\n            if v in freq and freq[v] - (1 if v == s else 0) > 0:\\n                best = max(best, v)\\n        \\n        return best\\n\"",
  "1056_14631217_python": "\"class Solution:\\n    def shipWithinDays(self, weights, days):\\n        def canShip(cap):\\n            curr, d = 0, 1\\n            for w in weights:\\n                if curr + w > cap:\\n                    d += 1\\n                    curr = 0\\n                curr += w\\n            return d <= days\\n\\n        left, right = max(weights), sum(weights)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if canShip(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "1899_14631217_python-updated-time": "1746532085801",
  "2051_14631217_python": "\"class Solution(object):\\n    def longestCommonSubpath(self, n, paths):\\n        MOD1 = 1000000007\\n        MOD2 = 1000000009\\n        BASE1 = 9113823\\n        BASE2 = 9726637\\n\\n        def get_hashes(path, L):\\n            h1 = h2 = 0\\n            p1 = pow(BASE1, L, MOD1)\\n            p2 = pow(BASE2, L, MOD2)\\n            s = set()\\n            for i, v in enumerate(path):\\n                h1 = (h1 * BASE1 + v) % MOD1\\n                h2 = (h2 * BASE2 + v) % MOD2\\n                if i >= L:\\n                    h1 = (h1 - path[i - L] * p1) % MOD1\\n                    h2 = (h2 - path[i - L] * p2) % MOD2\\n                if i >= L - 1:\\n                    s.add((h1, h2))\\n            return s\\n\\n        def check(L):\\n            common = get_hashes(paths[0], L)\\n            if not common:\\n                return False\\n            for p in paths[1:]:\\n                common &= get_hashes(p, L)\\n                if not common:\\n                    return False\\n            return True\\n\\n        lo, hi, ans = 1, min(len(p) for p in paths), 0\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if check(mid):\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return ans\\n\"",
  "2146_14631217_python-updated-time": "1746719296860",
  "2518_14631217_python": "\"class Solution(object):\\n    def hardestWorker(self, n, logs):\\n        max_time = -1\\n        worker_id = None\\n        prev_end = 0\\n\\n        for emp_id, leave in logs:\\n            duration = leave - prev_end\\n            if duration > max_time or (duration == max_time and emp_id < worker_id):\\n                max_time = duration\\n                worker_id = emp_id\\n            prev_end = leave\\n\\n        return worker_id\\n\"",
  "1267_14631217_python-updated-time": "1746126311819",
  "10_14631217_python-updated-time": "1744979247432",
  "1251_14631217_python": "\"class Solution(object):\\n    def longestDecomposition(self, text):\\n        \\\"\\\"\\\"\\n        :type text: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(text)\\n        l, r = 0, n - 1\\n        l_sub, r_sub = \\\"\\\", \\\"\\\"\\n        count = 0\\n\\n        for i in range(n):\\n            l_sub += text[i]\\n            r_sub = text[n - 1 - i] + r_sub\\n            if l_sub == r_sub:\\n                count += 1\\n                l_sub, r_sub = \\\"\\\", \\\"\\\"\\n        \\n        return count\\n\"",
  "2873_14631217_python-updated-time": "1747221842441",
  "240_14631217_python": "\"class Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        row, col = 0, n - 1\\n        \\n        while row < m and col >= 0:\\n            if matrix[row][col] == target:\\n                return True\\n            elif matrix[row][col] > target:\\n                col -= 1\\n            else:\\n                row += 1\\n        \\n        return False\\n\"",
  "3714_14631217_python-updated-time": "1747659418708",
  "443_14631217_python": "\"class Solution:\\n    def compress(self, chars):\\n        write = 0\\n        left = 0\\n        \\n        for right in range(len(chars)):\\n            if right == len(chars) - 1 or chars[right] != chars[right + 1]:\\n                chars[write] = chars[right]\\n                write += 1\\n                count = right - left + 1\\n                if count > 1:\\n                    for c in str(count):\\n                        chars[write] = c\\n                        write += 1\\n                left = right + 1\\n        \\n        return write\\n\"",
  "2558_14631217_python-updated-time": "1746969450969",
  "1426_14631217_python": "\"class Solution:\\n    def sumZero(self, n):\\n        res = []\\n        for i in range(1, n // 2 + 1):\\n            res.extend([i, -i])\\n        if n % 2 == 1:\\n            res.append(0)\\n        return res\\n\"",
  "48_14631217_python-updated-time": "1744999577607",
  "232_14631217_python": "\"class MyQueue(object):\\n\\n    def __init__(self):\\n        self.in_stack = []\\n        self.out_stack = []\\n\\n    def push(self, x):\\n        self.in_stack.append(x)\\n\\n    def pop(self):\\n        self.peek()\\n        return self.out_stack.pop()\\n\\n    def peek(self):\\n        if not self.out_stack:\\n            while self.in_stack:\\n                self.out_stack.append(self.in_stack.pop())\\n        return self.out_stack[-1]\\n\\n    def empty(self):\\n        return not self.in_stack and not self.out_stack\\n\"",
  "2845_14631217_python-updated-time": "1747221337327",
  "982_14631217_python": "\"class Solution:\\n    def minIncrementForUnique(self, nums):\\n        nums.sort()\\n        moves = 0\\n        prev = -1  # the last assigned unique value\\n        for x in nums:\\n            # each x must be at least prev + 1\\n            target = max(x, prev + 1)\\n            moves += target - x\\n            prev = target\\n        return moves\\n\"",
  "1647_14631217_python-updated-time": "1746434283514",
  "3252_14631217_python": "\"class Solution(object):\\n    def incremovableSubarrayCount(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def is_strictly_increasing(arr):\\n            for i in range(1, len(arr)):\\n                if arr[i] <= arr[i - 1]:\\n                    return False\\n            return True\\n\\n        n = len(nums)\\n        count = 0\\n        \\n        # Try every possible subarray [i..j]\\n        for i in range(n):\\n            for j in range(i, n):\\n                new_arr = nums[:i] + nums[j+1:]\\n                if is_strictly_increasing(new_arr):\\n                    count += 1\\n        \\n        return count\\n\"",
  "3064_14631217_pythondata-updated-time": "1747305877523",
  "3775_14631217_python": "\"class Solution(object):\\n    def separateSquares(self, squares):\\n        \\\"\\\"\\\"\\n        :type squares: List[List[int]]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        # 1) Build events for the vertical sweep\\n        events = []   # (y, type, x1, x2)\\n        xs = []\\n        for x, y, l in squares:\\n            events.append((y,     1, x,     x + l))\\n            events.append((y + l, -1, x,     x + l))\\n            xs.extend((x, x + l))\\n        if not events:\\n            return 0.0\\n\\n        # 2) Coordinate-compress the x-endpoints\\n        coords = sorted(set(xs))\\n        idx = {v:i for i, v in enumerate(coords)}\\n        M = len(coords)\\n\\n        # 3) Segment-tree to maintain total covered x-length under current active squares\\n        class SegTree:\\n            def __init__(self, coords):\\n                self.coords = coords\\n                self.n = len(coords)\\n                self.count = [0] * (4 * self.n)\\n                self.covered = [0] * (4 * self.n)\\n\\n            def update(self, node, l, r, ql, qr, val):\\n                # no overlap\\n                if ql >= r or qr <= l:\\n                    return\\n                # full cover\\n                if ql <= l and r <= qr:\\n                    self.count[node] += val\\n                else:\\n                    mid = (l + r) // 2\\n                    self.update(node*2,     l,   mid, ql, qr, val)\\n                    self.update(node*2 + 1, mid,   r,  ql, qr, val)\\n\\n                # recalc covered length\\n                if self.count[node] > 0:\\n                    # fully covered\\n                    self.covered[node] = self.coords[r] - self.coords[l]\\n                else:\\n                    if l + 1 == r:\\n                        # leaf segment\\n                        self.covered[node] = 0\\n                    else:\\n                        self.covered[node] = (\\n                            self.covered[node*2] +\\n                            self.covered[node*2 + 1]\\n                        )\\n\\n            def total_covered(self):\\n                return self.covered[1]\\n\\n        # 4) Sort events by y, sweep to build slabs of constant width\\n        events.sort(key=lambda e: e[0])\\n        st = SegTree(coords)\\n\\n        slabs = []   # list of (y_start, y_end, width)\\n        prev_y = events[0][0]\\n        i = 0\\n        n_ev = len(events)\\n\\n        while i < n_ev:\\n            y = events[i][0]\\n            dy = y - prev_y\\n            if dy > 0:\\n                width = st.total_covered()\\n                if width > 0:\\n                    slabs.append((prev_y, y, width))\\n                prev_y = y\\n\\n            # process all events at this y\\n            while i < n_ev and events[i][0] == y:\\n                _, typ, x1, x2 = events[i]\\n                l = idx[x1]\\n                r = idx[x2]\\n                st.update(1, 0, M-1, l, r, typ)\\n                i += 1\\n\\n        # 5) Compute total union area and then find the half-area cut\\n        total = 0.0\\n        for y0, y1, w in slabs:\\n            total += w * (y1 - y0)\\n        half = total / 2.0\\n\\n        acc = 0.0\\n        for y0, y1, w in slabs:\\n            segment_area = w * (y1 - y0)\\n            if acc + segment_area >= half:\\n                # the cut lies in this slab\\n                remain = half - acc\\n                return y0 + remain / w\\n            acc += segment_area\\n\\n        # If we haven't returned yet, the cut is at or above the last event\\n        return float(slabs[-1][1])\\n\"",
  "746_14631217_python-updated-time": "1745875426291",
  "1741_14631217_python": "\"class Solution:\\n    def frequencySort(self, nums):\\n        from collections import Counter\\n        freq = Counter(nums)\\n        nums.sort(key=lambda x: (freq[x], -x))\\n        return nums\\n\"",
  "1813_14631217_python": "\"class Solution(object):\\n    def maximumUniqueSubarray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seen = set()\\n        left = 0\\n        curr_sum = 0\\n        max_sum = 0\\n        \\n        for right, v in enumerate(nums):\\n            while v in seen:\\n                seen.remove(nums[left])\\n                curr_sum -= nums[left]\\n                left += 1\\n            seen.add(v)\\n            curr_sum += v\\n            if curr_sum > max_sum:\\n                max_sum = curr_sum\\n        \\n        return max_sum\\n\"",
  "3094_14631217_python-updated-time": "1747304863922",
  "485_14631217_python-updated-time": "1745441753019",
  "109_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sortedListToBST(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[TreeNode]\\n        \\\"\\\"\\\"\\n        if not head:\\n            return None\\n\\n        def find_mid(left, right):\\n            slow = fast = left\\n            while fast != right and fast.next != right:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return slow\\n\\n        def build(left, right):\\n            if left == right:\\n                return None\\n            mid = find_mid(left, right)\\n            root = TreeNode(mid.val)\\n            root.left = build(left, mid)\\n            root.right = build(mid.next, right)\\n            return root\\n\\n        return build(head, None)\\n\"",
  "1611_14631217_python-updated-time": "1746432862166",
  "2709_14631217_python": "\"class Solution(object):\\n    def squareFreeSubsets(self, nums):\\n        MOD = 10**9 + 7\\n        from collections import Counter\\n        freq = Counter(nums)\\n        ones = freq.get(1, 0)\\n\\n        # primes up to 30 that appear in square-free numbers\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n\\n        # build mask of prime factors for each candidate x > 1 that is square-free\\n        pfmask = {}\\n        for x, cnt in freq.items():\\n            if x == 1:\\n                continue\\n            # skip if x has a squared prime factor\\n            if x % 4 == 0 or x % 9 == 0 or x % 16 == 0 or x % 25 == 0:\\n                continue\\n            m = 0\\n            for i, p in enumerate(primes):\\n                if x % p == 0:\\n                    m |= 1 << i\\n            pfmask[x] = m\\n\\n        # dp[mask] = #ways to pick a subset of types with combined prime‐mask == mask\\n        dp = [0] * (1 << len(primes))\\n        dp[0] = 1\\n\\n        for x, m in pfmask.items():\\n            cnt = freq[x]\\n            new_dp = dp[:]  # copy old\\n            for mask in range(len(dp)):\\n                if dp[mask] and (mask & m) == 0:\\n                    new_dp[mask | m] = (new_dp[mask | m] + dp[mask] * cnt) % MOD\\n            dp = new_dp\\n\\n        # K = total ways including empty subset\\n        K = sum(dp) % MOD\\n\\n        # each subset of non-ones can be paired with any subset of ones:\\n        pow2 = pow(2, ones, MOD)\\n\\n        # subtract 1 to exclude the all-empty subset\\n        return (K * pow2 - 1) % MOD\\n\"",
  "2391_14631217_python-updated-time": "1746882023233",
  "1684_14631217_python": "\"class Solution:\\n    def findLatestStep(self, arr, m):\\n        n = len(arr)\\n        length = [0] * (n + 2)\\n        count = [0] * (n + 1)\\n        res = -1\\n\\n        for step, x in enumerate(arr, 1):\\n            left = length[x - 1]\\n            right = length[x + 1]\\n            new_len = left + 1 + right\\n\\n            # decrement counts of the old segments\\n            if left > 0:\\n                count[left] -= 1\\n            if right > 0:\\n                count[right] -= 1\\n\\n            # update the segment length at the boundaries\\n            length[x - left] = new_len\\n            length[x + right] = new_len\\n\\n            # increment count for the new segment\\n            count[new_len] += 1\\n\\n            # if there's any segment of length m, record this step\\n            if count[m] > 0:\\n                res = step\\n\\n        return res\\n\"",
  "2402_14631217_python-updated-time": "1746882983404",
  "1039_14631217_python": "\"class Solution:\\n    def findJudge(self, n, trust):\\n        trust_score = [0] * (n + 1)\\n\\n        for a, b in trust:\\n            trust_score[a] -= 1  # person a trusts someone\\n            trust_score[b] += 1  # person b is trusted\\n\\n        for i in range(1, n + 1):\\n            if trust_score[i] == n - 1:\\n                return i\\n        return -1\\n\"",
  "414_14631217_python-updated-time": "1745356212395",
  "1747_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def findLexSmallestString(self, s, a, b):\\n        n = len(s)\\n        seen = set([s])\\n        dq = deque([s])\\n        best = s\\n\\n        while dq:\\n            cur = dq.popleft()\\n            # update best\\n            if cur < best:\\n                best = cur\\n\\n            # Operation 1: add 'a' to all odd indices\\n            lst = list(cur)\\n            for i in range(1, n, 2):\\n                lst[i] = str((int(lst[i]) + a) % 10)\\n            added = ''.join(lst)\\n            if added not in seen:\\n                seen.add(added)\\n                dq.append(added)\\n\\n            # Operation 2: rotate right by b\\n            rotated = cur[-b:] + cur[:-b]\\n            if rotated not in seen:\\n                seen.add(rotated)\\n                dq.append(rotated)\\n\\n        return best\\n\"",
  "1985_14631217_python-updated-time": "1746624961466",
  "1680_14631217_python-updated-time": "1746438320138",
  "1995_14631217_python": "\"from collections import Counter\\n\\nclass FindSumPairs:\\n\\n    def __init__(self, nums1, nums2):\\n        self.nums1 = nums1\\n        self.nums2 = nums2\\n        self.freq2 = Counter(nums2)\\n\\n    def add(self, index, val):\\n        old_val = self.nums2[index]\\n        self.freq2[old_val] -= 1\\n        if self.freq2[old_val] == 0:\\n            del self.freq2[old_val]\\n        self.nums2[index] += val\\n        self.freq2[self.nums2[index]] += 1\\n\\n    def count(self, tot):\\n        ans = 0\\n        for x in self.nums1:\\n            ans += self.freq2.get(tot - x, 0)\\n        return ans\\n\"",
  "347_14631217_python-updated-time": "1745354182382",
  "1571_14631217_python": "\"class Solution(object):\\n    def minDistance(self, houses, k):\\n        \\\"\\\"\\\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        houses.sort()\\n        n = len(houses)\\n\\n        # Precompute the cost to put 1 mailbox for each subarray houses[i..j]\\n        cost = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i, n):\\n                median = houses[(i + j) // 2]\\n                for m in range(i, j + 1):\\n                    cost[i][j] += abs(houses[m] - median)\\n\\n        memo = {}\\n\\n        def dp(i, k):\\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n            if k == 0 and i == n:\\n                return 0\\n            if k == 0 or i == n:\\n                return float('inf')\\n\\n            res = float('inf')\\n            for j in range(i, n):\\n                res = min(res, cost[i][j] + dp(j + 1, k - 1))\\n\\n            memo[(i, k)] = res\\n            return res\\n\\n        result = dp(0, k)\\n        return result if result != float('inf') else -1\\n\"",
  "521_14631217_python-updated-time": "1745446536165",
  "2418_14631217_python": "\"from bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\\n        # total available single-step reductions\\n        K = k1 + k2\\n        n = len(nums1)\\n        \\n        # compute and sort absolute differences\\n        diffs = [abs(a - b) for a, b in zip(nums1, nums2)]\\n        diffs.sort()\\n        \\n        # build prefix sums of diffs and diffs^2\\n        pref = [0] * (n + 1)\\n        pref_sq = [0] * (n + 1)\\n        for i, d in enumerate(diffs):\\n            pref[i+1] = pref[i] + d\\n            pref_sq[i+1] = pref_sq[i] + d * d\\n        \\n        # cost(T): how many single-step reductions needed\\n        # to bring every diff down to at most T\\n        def cost(T):\\n            idx = bisect_right(diffs, T)\\n            # sum(diffs[idx:]) - (n - idx) * T\\n            return (pref[n] - pref[idx]) - (n - idx) * T\\n        \\n        # binary search the smallest T so cost(T) <= K\\n        low, high = 0, diffs[-1]\\n        while low < high:\\n            mid = (low + high) // 2\\n            if cost(mid) <= K:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        T = low\\n        \\n        # if T == 0, we can zero out all differences\\n        if T == 0:\\n            return 0\\n        \\n        # how many operations used to bring >T down to T\\n        used = cost(T)\\n        leftover = K - used\\n        \\n        # count how many diffs are exactly T (after leveling)\\n        idx_ge = bisect_left(diffs, T)\\n        C = n - idx_ge\\n        \\n        # sum of squares for those originally below T\\n        sum_below = pref_sq[idx_ge]\\n        \\n        # of the C entries at T, we use 'leftover' of them to reduce to T-1\\n        L = leftover  # guaranteed L < C\\n        \\n        # total sum of squares\\n        total = sum_below\\n        total += L * (T-1) * (T-1)\\n        total += (C - L) * T * T\\n        \\n        return total\\n\"",
  "946_14631217_python-updated-time": "1746003107865",
  "2301_14631217_python-updated-time": "1746803683391",
  "3172_14631217_python-updated-time": "1747306138424",
  "377_14631217_python-updated-time": "1745354747010",
  "856_14631217_python-updated-time": "1745879280602",
  "1710_14631217_python": "\"import heapq\\n\\nclass BIT:\\n    def __init__(self, n):\\n        # 1-indexed BIT internally, size = n\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def build(self, data):\\n        # data: list of length n (0-indexed)\\n        for i, v in enumerate(data, start=1):\\n            self.tree[i] += v\\n        for i in range(1, self.n + 1):\\n            j = i + (i & -i)\\n            if j <= self.n:\\n                self.tree[j] += self.tree[i]\\n\\n    def update(self, idx, delta):\\n        # add delta at data[idx] (0-indexed)\\n        i = idx + 1\\n        while i <= self.n:\\n            self.tree[i] += delta\\n            i += i & -i\\n\\n    def query(self, idx):\\n        # prefix sum data[0..idx], 0-indexed\\n        i = idx + 1\\n        s = 0\\n        while i > 0:\\n            s += self.tree[i]\\n            i -= i & -i\\n        return s\\n\\n    def find_kth(self, k):\\n        # find smallest idx such that prefix sum >= k\\n        # assume 1 <= k <= total sum\\n        idx = 0\\n        bit_mask = 1 << (self.n.bit_length())  # largest power of two >= n\\n        while bit_mask:\\n            t = idx + bit_mask\\n            if t <= self.n and self.tree[t] < k:\\n                idx = t\\n                k -= self.tree[t]\\n            bit_mask >>= 1\\n        return idx  # idx is 1-based sum < k, so 0-based index is idx\\n\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        # BIT to track which servers are free (1 = free, 0 = busy)\\n        bit = BIT(k)\\n        bit.build([1] * k)\\n\\n        busy = []   # min-heap of (free_time, server_id)\\n        count = [0] * k\\n        m = len(arrival)\\n\\n        for i in range(m):\\n            t = arrival[i]\\n            # free up servers that have completed by time t\\n            while busy and busy[0][0] <= t:\\n                _, srv = heapq.heappop(busy)\\n                bit.update(srv, +1)  # mark server free\\n\\n            # total free?\\n            total_free = bit.query(k - 1)\\n            if total_free == 0:\\n                continue  # drop request\\n\\n            # preferred server\\n            start = i % k\\n            # free in [start..k-1] ?\\n            free_after = total_free - (bit.query(start - 1) if start > 0 else 0)\\n            if free_after > 0:\\n                # the first free in [start..]\\n                # we want the (prefix before start)+1 -th free in whole\\n                prev_count = bit.query(start - 1) if start > 0 else 0\\n                srv = bit.find_kth(prev_count + 1)\\n            else:\\n                # wrap around: take the very first free\\n                srv = bit.find_kth(1)\\n\\n            # assign request to srv\\n            count[srv] += 1\\n            bit.update(srv, -1)  # mark busy\\n            heapq.heappush(busy, (t + load[i], srv))\\n\\n        # find max handled\\n        mx = max(count)\\n        return [i for i, c in enumerate(count) if c == mx]\\n\"",
  "1891_14631217_python": "\"from collections import defaultdict\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def countPairs(self, n, edges, queries):\\n        deg = [0] * (n + 1)\\n        freq = defaultdict(int)\\n\\n        for u, v in edges:\\n            deg[u] += 1\\n            deg[v] += 1\\n            if u > v:\\n                u, v = v, u\\n            freq[(u, v)] += 1\\n\\n        sorted_deg = sorted(deg[1:])\\n        res = []\\n\\n        for q in queries:\\n            count = 0\\n            l, r = 0, n - 1\\n\\n            # Two-pointer approach to count pairs (i, j) with deg[i] + deg[j] > q\\n            while l < r:\\n                if sorted_deg[l] + sorted_deg[r] <= q:\\n                    l += 1\\n                else:\\n                    count += r - l\\n                    r -= 1\\n\\n            # Subtract overcounted pairs where shared edge count makes sum <= q\\n            for (u, v), shared in freq.items():\\n                if deg[u] + deg[v] > q and deg[u] + deg[v] - shared <= q:\\n                    count -= 1\\n\\n            res.append(count)\\n\\n        return res\\n\"",
  "3079_14631217_python": "\"class Solution(object):\\n    def minOperationsQueries(self, n, edges, queries):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        import sys\\n        sys.setrecursionlimit(1000000)\\n        \\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n        \\n        LOG = (n-1).bit_length()\\n        parent = [[-1]*n for _ in range(LOG)]\\n        depth = [0]*n\\n        \\n        # cnt[u][w] = number of edges of weight w on path from root to u\\n        # weights are 1..26, we'll zero-index them 0..25\\n        cnt = [[0]*26 for _ in range(n)]\\n        \\n        # DFS to set depth, parent[0], and cnt\\n        def dfs(u, p):\\n            for v, w in adj[u]:\\n                if v == p:\\n                    continue\\n                depth[v] = depth[u] + 1\\n                parent[0][v] = u\\n                # inherit counts from u\\n                cnt[v] = cnt[u][:]  # copy list\\n                cnt[v][w-1] += 1\\n                dfs(v, u)\\n        \\n        # root the tree at 0\\n        dfs(0, -1)\\n        \\n        # Build binary lifting table\\n        for k in range(1, LOG):\\n            for v in range(n):\\n                pv = parent[k-1][v]\\n                parent[k][v] = parent[k-1][pv] if pv != -1 else -1\\n        \\n        # LCA function\\n        def lca(u, v):\\n            if depth[u] < depth[v]:\\n                u, v = v, u\\n            # lift u up to depth[v]\\n            diff = depth[u] - depth[v]\\n            b = 0\\n            while diff:\\n                if diff & 1:\\n                    u = parent[b][u]\\n                diff >>= 1\\n                b += 1\\n            if u == v:\\n                return u\\n            # lift both\\n            for k in range(LOG-1, -1, -1):\\n                pu = parent[k][u]\\n                pv = parent[k][v]\\n                if pu != pv:\\n                    u = pu\\n                    v = pv\\n            return parent[0][u]\\n        \\n        res = []\\n        for a, b in queries:\\n            c = lca(a, b)\\n            # path length in edges\\n            d = depth[a] + depth[b] - 2*depth[c]\\n            # find maximum frequency of any weight on the path\\n            maxf = 0\\n            for w in range(26):\\n                f = cnt[a][w] + cnt[b][w] - 2*cnt[c][w]\\n                if f > maxf:\\n                    maxf = f\\n            # minimum ops = path length - most common weight count\\n            res.append(d - maxf)\\n        return res\\n\"",
  "3375_14631217_python-updated-time": "1747423841888",
  "226_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def invertTree(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        if not root:\\n            return None\\n        \\n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\\n        \\n        return root\\n\"",
  "3692_14631217_python-updated-time": "1747680241205",
  "3744_14631217_python-updated-time": "1747741951417",
  "2507_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def commonFactors(self, a, b):\\n        # Compute GCD with a simple loop (math.gcd may not be available)\\n        def gcd(x, y):\\n            while y:\\n                x, y = y, x % y\\n            return x\\n\\n        g = gcd(a, b)\\n        # Count divisors of g\\n        cnt = 0\\n        root = int(g**0.5)\\n        for i in range(1, root + 1):\\n            if g % i == 0:\\n                cnt += 1\\n                if i != g // i:\\n                    cnt += 1\\n        return cnt\\n\"",
  "3338_14631217_python": "\"class Solution(object):\\n    def countSubmatrices(self, grid, k):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        # build 2D prefix sums\\n        # PS[i][j] = sum over r<=i, c<=j of grid[r][c]\\n        PS = [[0]*n for _ in range(m)]\\n        count = 0\\n        \\n        for i in range(m):\\n            row_sum = 0\\n            for j in range(n):\\n                row_sum += grid[i][j]\\n                PS[i][j] = row_sum\\n                if i > 0:\\n                    PS[i][j] += PS[i-1][j]\\n                \\n                # if the submatrix (0,0)-(i,j) has sum <= k, count it\\n                if PS[i][j] <= k:\\n                    count += 1\\n        \\n        return count\\n\"",
  "1270_14631217_python-updated-time": "1746126350079",
  "395_14631217_python": "\"class Solution:\\n    def longestSubstring(self, s, k):\\n        if len(s) < k:\\n            return 0\\n        \\n        counter = {}\\n        for ch in s:\\n            counter[ch] = counter.get(ch, 0) + 1\\n        \\n        for ch in counter:\\n            if counter[ch] < k:\\n                return max(self.longestSubstring(t, k) for t in s.split(ch))\\n        \\n        return len(s)\\n\"",
  "1733_14631217_python": "\"import math\\n\\nclass Solution:\\n    def visiblePoints(self, points, angle, location):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :type angle: int\\n        :type location: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        px, py = location\\n        same_spot = 0\\n        angles = []\\n\\n        # 1) Separate points at the observer location\\n        for x, y in points:\\n            dx, dy = x - px, y - py\\n            if dx == 0 and dy == 0:\\n                same_spot += 1\\n            else:\\n                # compute angle in degrees from east\\n                theta = math.degrees(math.atan2(dy, dx))\\n                if theta < 0:\\n                    theta += 360\\n                angles.append(theta)\\n\\n        # 2) Sort the angles and duplicate with +360 for wraparound\\n        angles.sort()\\n        m = len(angles)\\n        angles += [a + 360 for a in angles]\\n\\n        # 3) Two-pointer sweep to find max points in any angle-window\\n        best = 0\\n        left = 0\\n        for right in range(len(angles)):\\n            # shrink window from left if it exceeds the allowed angle\\n            while angles[right] - angles[left] > angle:\\n                left += 1\\n            # window [left..right] is within 'angle'\\n            best = max(best, right - left + 1)\\n\\n        # 4) include points at the same spot (always visible)\\n        return best + same_spot\\n\"",
  "406_14631217_python-updated-time": "1745356023099",
  "1917_14631217_python-updated-time": "1746542735352",
  "3492_14631217_python-updated-time": "1747487120237",
  "85_14631217_python": "\"class Solution(object):\\n    def maximalRectangle(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not matrix:\\n            return 0\\n\\n        max_area = 0\\n        n = len(matrix[0])\\n        heights = [0] * n\\n\\n        for row in matrix:\\n            for i in range(n):\\n                if row[i] == '1':\\n                    heights[i] += 1\\n                else:\\n                    heights[i] = 0\\n\\n            max_area = max(max_area, self.largestRectangleArea(heights))\\n\\n        return max_area\\n\\n    def largestRectangleArea(self, heights):\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i, h in enumerate(heights):\\n            while stack and heights[stack[-1]] > h:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n            stack.append(i)\\n\\n        heights.pop()\\n        return max_area\\n\"",
  "1040_14631217_python": "\"class Solution:\\n    def insertIntoMaxTree(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n        if val > root.val:\\n            new_root = TreeNode(val)\\n            new_root.left = root\\n            return new_root\\n        root.right = self.insertIntoMaxTree(root.right, val)\\n        return root\\n\"",
  "1740_14631217_python": "\"class Solution:\\n    def countSubgraphsForEachDiameter(self, n, edges):\\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            u -= 1  # convert to 0-based\\n            v -= 1\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # Precompute all-pairs shortest path distances (BFS from each node)\\n        dist = [[0]*n for _ in range(n)]\\n        from collections import deque\\n        for src in range(n):\\n            dq = deque([src])\\n            seen = {src}\\n            d = 0\\n            # BFS layer by layer\\n            while dq:\\n                for _ in range(len(dq)):\\n                    u = dq.popleft()\\n                    dist[src][u] = d\\n                    for w in adj[u]:\\n                        if w not in seen:\\n                            seen.add(w)\\n                            dq.append(w)\\n                d += 1\\n        \\n        # Prepare answer array for diameters 1..n-1 (index 0..n-2)\\n        ans = [0] * (n-1)\\n        \\n        # Iterate over every non-empty subset of nodes via bitmask\\n        # We only care about subsets of size >= 2\\n        full = 1 << n\\n        for mask in range(full):\\n            # Quick skip if fewer than 2 bits set\\n            if mask & (mask - 1) == 0:\\n                # either 0 or 1 bit set\\n                continue\\n            \\n            # Extract nodes in this subset\\n            nodes = [i for i in range(n) if (mask >> i) & 1]\\n            \\n            # Check connectivity of the induced subgraph\\n            # BFS/DFS constrained to 'nodes'\\n            seen = {nodes[0]}\\n            stack = [nodes[0]]\\n            node_set = set(nodes)\\n            while stack:\\n                u = stack.pop()\\n                for w in adj[u]:\\n                    if w in node_set and w not in seen:\\n                        seen.add(w)\\n                        stack.append(w)\\n            if len(seen) != len(nodes):\\n                continue  # not connected\\n            \\n            # Compute diameter: max dist between any two in 'nodes'\\n            dmax = 0\\n            L = len(nodes)\\n            for i in range(L):\\n                u = nodes[i]\\n                for j in range(i+1, L):\\n                    v = nodes[j]\\n                    if dist[u][v] > dmax:\\n                        dmax = dist[u][v]\\n            \\n            # diameter dmax is between 1 and n-1\\n            if dmax > 0:\\n                ans[dmax-1] += 1\\n        \\n        return ans\\n\"",
  "342_14631217_python": "\"class Solution(object):\\n    def isPowerOfFour(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\\n\"",
  "1446_14631217_python": "\"class Solution:\\n    def angleClock(self, hour, minutes):\\n        # Calculate the angles of the hour and minute hands\\n        minute_angle = 6 * minutes\\n        hour_angle = 30 * (hour % 12) + 0.5 * minutes\\n        \\n        # Compute the absolute difference\\n        diff = abs(hour_angle - minute_angle)\\n        # Return the smaller of diff and 360 - diff\\n        return min(diff, 360 - diff)\\n\"",
  "2655_14631217_python-updated-time": "1747066887426",
  "378_14631217_python-updated-time": "1745354783067",
  "3181_14631217_python-updated-time": "1747312212334",
  "2145_14631217_python-updated-time": "1746719217505",
  "841_14631217_python": "\"class Solution(object):\\n    def shortestToChar(self, s, c):\\n        n = len(s)\\n        res = [n] * n\\n        prev = -n\\n        for i in range(n):\\n            if s[i] == c:\\n                prev = i\\n            res[i] = i - prev\\n        prev = 2 * n\\n        for i in range(n-1, -1, -1):\\n            if s[i] == c:\\n                prev = i\\n            res[i] = min(res[i], prev - i)\\n        return res\\n\"",
  "2164_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def maxTwoEvents(self, events):\\n        \\\"\\\"\\\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sort events by start time\\n        events.sort(key=lambda e: e[0])\\n        starts = [e[0] for e in events]\\n        n = len(events)\\n        \\n        # Build suffix-max array of single-event values\\n        # suffix_max[i] = max value of any event in events[i:]\\n        suffix_max = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            suffix_max[i] = max(suffix_max[i + 1], events[i][2])\\n        \\n        ans = 0\\n        # Try taking each event as the first one\\n        for i, (s, e, v) in enumerate(events):\\n            # Option 1: take only this event\\n            ans = max(ans, v)\\n            \\n            # Option 2: take this event + best non-overlapping one\\n            # find first event whose start > e\\n            j = bisect.bisect_right(starts, e)\\n            if j < n:\\n                ans = max(ans, v + suffix_max[j])\\n        \\n        return ans\\n\"",
  "2631_14631217_python": "\"class Solution:\\n    def sortTheStudents(self, score, k):\\n        return sorted(score, key=lambda row: row[k], reverse=True)\\n\"",
  "3427_14631217_python": "\"class Solution:\\n    def isArraySpecial(self, nums, queries):\\n        n = len(nums)\\n        # 1) mark “bad” adjacent pairs (same parity)\\n        bad = [0] * n\\n        for i in range(1, n):\\n            if nums[i] % 2 == nums[i-1] % 2:\\n                bad[i] = 1\\n\\n        # 2) build prefix sums over bad[]\\n        pref = [0] * n\\n        for i in range(1, n):\\n            pref[i] = pref[i-1] + bad[i]\\n\\n        # 3) answer each query in O(1)\\n        ans = []\\n        for l, r in queries:\\n            if l == r:\\n                # single element is always “special”\\n                ans.append(True)\\n            else:\\n                # if there are no bad marks between l+1 and r, it’s special\\n                ans.append(pref[r] - pref[l] == 0)\\n        return ans\\n\"",
  "45_14631217_python": "\"class Solution(object):\\n    def jump(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        jumps = 0\\n        current_end = 0\\n        farthest = 0\\n\\n        for i in range(len(nums) - 1):\\n            farthest = max(farthest, i + nums[i])\\n            if i == current_end:\\n                jumps += 1\\n                current_end = farthest\\n\\n        return jumps\\n\"",
  "738_14631217_python-updated-time": "1745787480558",
  "442_14631217_python-updated-time": "1745358983638",
  "2700_14631217_python-updated-time": "1747065268605",
  "610_14631217_mysql": "\"SELECT\\n  x,\\n  y,\\n  z,\\n  CASE\\n    WHEN x + y > z\\n      AND x + z > y\\n      AND y + z > x\\n    THEN 'Yes'\\n    ELSE 'No'\\n  END AS triangle\\nFROM Triangle;\\n\"",
  "199_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        queue = [root]\\n        result = []\\n        \\n        while queue:\\n            level_size = len(queue)\\n            for i in range(level_size):\\n                node = queue.pop(0)\\n                if i == level_size - 1:\\n                    result.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        return result\\n\"",
  "989_14631217_python-updated-time": "1746038580308",
  "350_14631217_python-updated-time": "1745257185430",
  "409_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        count = Counter(s)\\n        length = 0\\n        odd_found = False\\n        \\n        for freq in count.values():\\n            length += (freq // 2) * 2\\n            if freq % 2 == 1:\\n                odd_found = True\\n        \\n        if odd_found:\\n            length += 1\\n        \\n        return length\\n\"",
  "3346_14631217_python": "\"class Solution(object):\\n    def getSmallestString(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        def dist(a, b):\\n            # cyclic distance on 26‐letter ring\\n            d = abs(ord(a) - ord(b))\\n            return min(d, 26 - d)\\n        \\n        rem = k\\n        res = []\\n        for ch in s:\\n            # try letters from 'a' to 'z'\\n            for c in map(chr, range(ord('a'), ord('z')+1)):\\n                d = dist(ch, c)\\n                if d <= rem:\\n                    res.append(c)\\n                    rem -= d\\n                    break\\n        return ''.join(res)\\n\"",
  "3821_14631217_python-updated-time": "1747683859513",
  "1018_14631217_python": "\"class Solution:\\n    def largestPerimeter(self, nums):\\n        nums.sort(reverse=True)\\n        for i in range(len(nums) - 2):\\n            a, b, c = nums[i], nums[i+1], nums[i+2]\\n            if b + c > a:\\n                return a + b + c\\n        return 0\\n\"",
  "3737_14631217_python-updated-time": "1747659606435",
  "1448_14631217_python": "\"class Solution:\\n    def maximum69Number (self, num):\\n        s = list(str(num))\\n        for i, ch in enumerate(s):\\n            if ch == '6':\\n                s[i] = '9'\\n                break\\n        return int(''.join(s))\\n\"",
  "3355_14631217_python-updated-time": "1747422755164",
  "1277_14631217_python": "\"class Solution(object):\\n    def largestMultipleOfThree(self, digits):\\n        digits.sort(reverse=True)\\n        total = sum(digits)\\n        mod1, mod2 = [], []\\n\\n        for d in digits:\\n            if d % 3 == 1:\\n                mod1.append(d)\\n            elif d % 3 == 2:\\n                mod2.append(d)\\n\\n        remainder = total % 3\\n\\n        if remainder == 1:\\n            if mod1:\\n                digits.remove(min(mod1))\\n            elif len(mod2) >= 2:\\n                digits.remove(min(mod2))\\n                mod2.remove(min(mod2))\\n                digits.remove(min(mod2))\\n            else:\\n                return \\\"\\\"\\n        elif remainder == 2:\\n            if mod2:\\n                digits.remove(min(mod2))\\n            elif len(mod1) >= 2:\\n                digits.remove(min(mod1))\\n                mod1.remove(min(mod1))\\n                digits.remove(min(mod1))\\n            else:\\n                return \\\"\\\"\\n\\n        if not digits:\\n            return \\\"\\\"\\n        if digits[0] == 0:\\n            return \\\"0\\\"\\n\\n        digits.sort(reverse=True)\\n        return ''.join(map(str, digits))\\n\"",
  "3367_14631217_python-updated-time": "1747420647590",
  "236_14631217_python-updated-time": "1745247421675",
  "2351_14631217_python-updated-time": "1746879600453",
  "3264_14631217_python-updated-time": "1747486878073",
  "1533_14631217_python-updated-time": "1746346884261",
  "3761_14631217_python-updated-time": "1747819403586",
  "3632_14631217_python": "\"class Solution(object):\\n    def buttonWithLongestTime(self, events):\\n        \\\"\\\"\\\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        prev_time = 0\\n        best_time = -1\\n        best_idx = float('inf')\\n        \\n        for idx, t in events:\\n            # time to press this button\\n            duration = t - prev_time\\n            # update best\\n            if duration > best_time or (duration == best_time and idx < best_idx):\\n                best_time = duration\\n                best_idx = idx\\n            prev_time = t\\n        \\n        return best_idx\\n\"",
  "3250_14631217_python": "\"class Solution(object):\\n    def maximizeSquareArea(self, m, n, hFences, vFences):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :type hFences: List[int]\\n        :type vFences: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        \\n        # build sorted lists of fence positions including boundaries\\n        xs = [1] + sorted(hFences) + [m]\\n        ys = [1] + sorted(vFences) + [n]\\n        \\n        # compute all possible interval lengths on x-axis\\n        x_diffs = set()\\n        Lx = len(xs)\\n        for i in range(Lx):\\n            for j in range(i+1, Lx):\\n                x_diffs.add(xs[j] - xs[i])\\n        \\n        # compute all possible interval lengths on y-axis\\n        y_diffs = set()\\n        Ly = len(ys)\\n        for i in range(Ly):\\n            for j in range(i+1, Ly):\\n                y_diffs.add(ys[j] - ys[i])\\n        \\n        # find the largest common length\\n        common = x_diffs & y_diffs\\n        if not common:\\n            return -1\\n        \\n        L = max(common)\\n        return (L * L) % MOD\\n\"",
  "1390_14631217_mysql": "\"SELECT \\n    p.product_id,\\n    ROUND(COALESCE(SUM(p.price * u.units) / NULLIF(SUM(u.units), 0), 0), 2) AS average_price\\nFROM Prices p\\nLEFT JOIN UnitsSold u\\n  ON p.product_id = u.product_id\\n AND u.purchase_date BETWEEN p.start_date AND p.end_date\\nGROUP BY p.product_id\\n\"",
  "3799_14631217_python": "\"from collections import Counter\\nfrom itertools import permutations\\n\\nclass Solution(object):\\n    def totalNumbers(self, digits):\\n        count = 0\\n        seen = set()\\n        digit_counter = Counter(digits)\\n\\n        for perm in permutations(digits, 3):\\n            if perm[0] == 0 or perm[2] % 2 != 0:\\n                continue\\n            if perm in seen:\\n                continue\\n            if all(Counter(perm)[d] <= digit_counter[d] for d in perm):\\n                seen.add(perm)\\n                count += 1\\n\\n        return count\\n\"",
  "680_14631217_python": "\"class Solution(object):\\n    def validPalindrome(self, s):\\n        def is_palindrome(left, right):\\n            while left < right:\\n                if s[left] != s[right]:\\n                    return False\\n                left += 1\\n                right -= 1\\n            return True\\n        \\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                return is_palindrome(left + 1, right) or is_palindrome(left, right - 1)\\n            left += 1\\n            right -= 1\\n        return True\\n\"",
  "2161_14631217_python-updated-time": "1746719719420",
  "3305_14631217_python": "\"class Solution(object):\\n    def countPrefixSuffixPairs(self, words):\\n        # two independent rolling‐hashes to avoid 64-bit collisions\\n        B1, B2 = 91138233, 97266353\\n        MOD1, MOD2 = 10**9+7, 10**9+9\\n\\n        # seen_by_len[len] = { (h1, h2): count_of_words_of_that_hash_and_len }\\n        seen_by_len = {}\\n        result = 0\\n\\n        for w in words:\\n            n = len(w)\\n\\n            # 1) build prefix hashes h1, h2\\n            h1 = [0] * (n + 1)\\n            h2 = [0] * (n + 1)\\n            v1 = v2 = 0\\n            for i, ch in enumerate(w, 1):\\n                code = ord(ch)\\n                v1 = (v1 * B1 + code) % MOD1\\n                v2 = (v2 * B2 + code) % MOD2\\n                h1[i] = v1\\n                h2[i] = v2\\n\\n            # 2) build KMP pi array\\n            pi = [0] * n\\n            for i in range(1, n):\\n                j = pi[i-1]\\n                while j and w[i] != w[j]:\\n                    j = pi[j-1]\\n                if w[i] == w[j]:\\n                    j += 1\\n                pi[i] = j\\n\\n            # 3) walk *all* borders ℓ = n, π[n-1], π[π[n-1]-1], … > 0\\n            border = n\\n            while border > 0:\\n                d = seen_by_len.get(border)\\n                if d:\\n                    result += d.get((h1[border], h2[border]), 0)\\n                border = pi[border-1]\\n\\n            # 4) record this full word under its length\\n            key = (h1[n], h2[n])\\n            bucket = seen_by_len.setdefault(n, {})\\n            bucket[key] = bucket.get(key, 0) + 1\\n\\n        return result\\n\"",
  "1382_14631217_python": "\"class Solution:\\n    def calculateTax(self, brackets, income):\\n        tax = 0.0\\n        prev_upper = 0\\n        \\n        for upper, pct in brackets:\\n            if income <= prev_upper:\\n                break\\n            # amount taxed in this bracket\\n            taxable = min(income, upper) - prev_upper\\n            tax += taxable * pct / 100.0\\n            prev_upper = upper\\n        \\n        return tax\\n\"",
  "2632_14631217_python-updated-time": "1747061790869",
  "2848_14631217_python": "\"class Solution:\\n    def specialPerm(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        \\n        # Precompute adjacency: allowed[i][j] = True if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0\\n        allowed = [[False]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i != j:\\n                    a, b = nums[i], nums[j]\\n                    if a % b == 0 or b % a == 0:\\n                        allowed[i][j] = True\\n        \\n        size = 1 << n\\n        # dp[mask][last] = number of ways to form permutation using exactly the set bits in mask,\\n        # ending at index 'last'\\n        dp = [ [0]*n for _ in range(size) ]\\n        \\n        # Base case: single-element permutations\\n        for i in range(n):\\n            dp[1<<i][i] = 1\\n        \\n        for mask in range(size):\\n            # try to extend each permutation represented by (mask, last)\\n            for last in range(n):\\n                cnt = dp[mask][last]\\n                if cnt == 0:\\n                    continue\\n                # try to append a new element 'nxt'\\n                rem = (~mask) & (size - 1)\\n                # iterate over bits in rem\\n                m = rem\\n                while m:\\n                    nxt_bit = m & -m\\n                    m -= nxt_bit\\n                    nxt = (nxt_bit.bit_length() - 1)\\n                    if allowed[last][nxt]:\\n                        dp[mask | nxt_bit][nxt] = (dp[mask | nxt_bit][nxt] + cnt) % MOD\\n        \\n        full = size - 1\\n        ans = sum(dp[full][i] for i in range(n)) % MOD\\n        return ans\\n\"",
  "3221_14631217_python-updated-time": "1747315602381",
  "3055_14631217_python": "\"class Solution(object):\\n    def maximumOddBinaryNumber(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        ones = s.count('1')\\n        zeros = len(s) - ones\\n        return '1' * (ones - 1) + '0' * zeros + '1'\\n\"",
  "211_14631217_python-updated-time": "1745246083440",
  "1897_14631217_python-updated-time": "1746532013189",
  "477_14631217_python-updated-time": "1745360129901",
  "2409_14631217_python": "\"class Solution:\\n    def countPaths(self, grid):\\n        MOD = 10**9 + 7\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dp[i][j]: number of increasing paths ending at (i, j)\\n        dp = [[1] * n for _ in range(m)]\\n        \\n        # process cells in ascending order of value\\n        cells = [(grid[i][j], i, j) for i in range(m) for j in range(n)]\\n        cells.sort()\\n        \\n        for val, i, j in cells:\\n            for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] < val:\\n                    dp[i][j] = (dp[i][j] + dp[ni][nj]) % MOD\\n        \\n        # sum all dp[i][j]\\n        total = 0\\n        for i in range(m):\\n            for j in range(n):\\n                total = (total + dp[i][j]) % MOD\\n        \\n        return total\\n\"",
  "3176_14631217_python": "\"class Solution(object):\\n    def minimumSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        ans = float('inf')\\n        for j in range(1, n-1):\\n            # find smallest nums[i] for i<j with nums[i]<nums[j]\\n            best_i = float('inf')\\n            for i in range(j):\\n                if nums[i] < nums[j] and nums[i] < best_i:\\n                    best_i = nums[i]\\n            # find smallest nums[k] for k>j with nums[k]<nums[j]\\n            best_k = float('inf')\\n            for k in range(j+1, n):\\n                if nums[k] < nums[j] and nums[k] < best_k:\\n                    best_k = nums[k]\\n            if best_i < float('inf') and best_k < float('inf'):\\n                ans = min(ans, best_i + nums[j] + best_k)\\n        return ans if ans < float('inf') else -1\\n\"",
  "433_14631217_python-updated-time": "1745358735170",
  "1917_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxAverageRatio(self, classes, extraStudents):\\n        def gain(p, t):\\n            return (p + 1) / (t + 1.0) - p / (t + 0.0)\\n\\n        heap = []\\n        for p, t in classes:\\n            heapq.heappush(heap, (-gain(p, t), p, t))\\n\\n        for _ in range(extraStudents):\\n            _, p, t = heapq.heappop(heap)\\n            p += 1\\n            t += 1\\n            heapq.heappush(heap, (-gain(p, t), p, t))\\n\\n        return sum(p / float(t) for _, p, t in heap) / len(classes)\\n\"",
  "3601_14631217_python-updated-time": "1747575511672",
  "911_14631217_python-updated-time": "1746001678266",
  "GLOBAL_DATA:value-updated-time": "1747738765139",
  "2135_14631217_python-updated-time": "1746719470275",
  "2429_14631217_python": "\"import heapq\\n\\nclass FoodRatings:\\n    def __init__(self, foods, cuisines, ratings):\\n        # Map food -> current rating\\n        self.food_rating = {}\\n        # Map food -> its cuisine\\n        self.food_cuisine = {}\\n        # Map cuisine -> max-heap of (-rating, food)\\n        self.cuisine_heaps = {}\\n        \\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            self.food_rating[food] = rating\\n            self.food_cuisine[food] = cuisine\\n            if cuisine not in self.cuisine_heaps:\\n                self.cuisine_heaps[cuisine] = []\\n            heapq.heappush(self.cuisine_heaps[cuisine], (-rating, food))\\n\\n    def changeRating(self, food, newRating):\\n        # Update the rating and push new entry onto the cuisine heap\\n        cuisine = self.food_cuisine[food]\\n        self.food_rating[food] = newRating\\n        heapq.heappush(self.cuisine_heaps[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine):\\n        heap = self.cuisine_heaps[cuisine]\\n        # Clean up outdated entries\\n        while heap:\\n            neg_rating, food = heap[0]\\n            # If the rating matches current, it's valid\\n            if -neg_rating == self.food_rating[food]:\\n                return food\\n            # Otherwise discard\\n            heapq.heappop(heap)\\n        return \\\"\\\"  # Should never happen per problem constraints\\n\"",
  "1386_14631217_python": "\"class Solution:\\n    def shiftGrid(self, grid, k):\\n        m, n = len(grid), len(grid[0])\\n        total = m * n\\n        k %= total\\n\\n        # Flatten the grid\\n        flat = [grid[i][j] for i in range(m) for j in range(n)]\\n        # Shift\\n        flat = flat[-k:] + flat[:-k]\\n        # Reshape\\n        return [flat[i * n:(i + 1) * n] for i in range(m)]\\n\"",
  "912_14631217_python": "\"import random\\nimport bisect\\n\\nclass Solution:\\n\\n    def __init__(self, w):\\n        self.prefix = []\\n        total = 0\\n        for weight in w:\\n            total += weight\\n            self.prefix.append(total)\\n        self.total = total\\n\\n    def pickIndex(self):\\n        target = random.randint(1, self.total)\\n        return bisect.bisect_left(self.prefix, target)\\n\"",
  "1245_14631217_mysql": "\"SELECT \\n    activity_date AS day,\\n    COUNT(DISTINCT user_id) AS active_users\\nFROM \\n    Activity\\nWHERE \\n    activity_date BETWEEN DATE('2019-07-27') - INTERVAL 29 DAY AND DATE('2019-07-27')\\nGROUP BY \\n    activity_date;\\n\"",
  "2999_14631217_python-updated-time": "1747226547836",
  "457_14631217_python": "\"class Solution:\\n    def circularArrayLoop(self, nums):\\n        n = len(nums)\\n\\n        def next_index(i):\\n            return (i + nums[i]) % n\\n\\n        for i in range(n):\\n            if nums[i] == 0:\\n                continue\\n\\n            slow, fast = i, next_index(i)\\n            while nums[slow] * nums[fast] > 0 and nums[slow] * nums[next_index(fast)] > 0:\\n                if slow == fast:\\n                    if slow == next_index(slow):\\n                        break\\n                    return True\\n                slow = next_index(slow)\\n                fast = next_index(next_index(fast))\\n\\n            # mark the path as visited\\n            j = i\\n            while nums[j] * nums[next_index(j)] > 0:\\n                temp = j\\n                j = next_index(j)\\n                nums[temp] = 0\\n\\n        return False\\n\"",
  "99_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \\\"\\\"\\\"\\n        first = second = prev = None\\n        stack = []\\n        curr = root\\n\\n        while stack or curr:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            curr = stack.pop()\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n            curr = curr.right\\n        \\n        first.val, second.val = second.val, first.val\\n\"",
  "3629_14631217_python-updated-time": "1747585704492",
  "2751_14631217_python": "\"class Solution(object):\\n    def getSubarrayBeauty(self, nums, k, x):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type x: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # freq of negatives from -50 to -1 mapped to 0..49\\n        freq = [0] * 50\\n        res = []\\n        neg_count = 0\\n\\n        # Initialize first window\\n        for i in range(k):\\n            v = nums[i]\\n            if v < 0:\\n                idx = v + 50\\n                freq[idx] += 1\\n                neg_count += 1\\n\\n        def get_xth():\\n            \\\"\\\"\\\"Return x-th smallest negative or 0 if not enough\\\"\\\"\\\"\\n            if neg_count < x:\\n                return 0\\n            cnt = 0\\n            for idx in range(50):\\n                cnt += freq[idx]\\n                if cnt >= x:\\n                    return idx - 50\\n            return 0  # fallback\\n\\n        # Record for the first window\\n        res.append(get_xth())\\n\\n        # Slide window\\n        for i in range(k, n):\\n            # Remove nums[i-k]\\n            old = nums[i - k]\\n            if old < 0:\\n                oi = old + 50\\n                freq[oi] -= 1\\n                neg_count -= 1\\n            # Add nums[i]\\n            new = nums[i]\\n            if new < 0:\\n                ni = new + 50\\n                freq[ni] += 1\\n                neg_count += 1\\n\\n            res.append(get_xth())\\n\\n        return res\\n\"",
  "3678_14631217_python-updated-time": "1747653327266",
  "2816_14631217_python": "\"class Solution(object):\\n    def makeSmallestPalindrome(self, s):\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[i] != s[j]:\\n                if s[i] < s[j]:\\n                    s[j] = s[i]\\n                else:\\n                    s[i] = s[j]\\n            i += 1\\n            j -= 1\\n        return ''.join(s)\\n\"",
  "1025_14631217_python": "\"class Solution:\\n    def mincostTickets(self, days, costs):\\n        day_set = set(days)\\n        last_day = days[-1]\\n        dp = [0] * (last_day + 1)\\n\\n        for d in range(1, last_day + 1):\\n            if d not in day_set:\\n                dp[d] = dp[d - 1]\\n            else:\\n                dp[d] = min(\\n                    dp[max(0, d - 1)] + costs[0],\\n                    dp[max(0, d - 7)] + costs[1],\\n                    dp[max(0, d - 30)] + costs[2],\\n                )\\n\\n        return dp[last_day]\\n\"",
  "1483_14631217_python": "\"class Solution(object):\\n    def rankTeams(self, votes):\\n        if len(votes) == 1:\\n            return votes[0]\\n\\n        n = len(votes[0])\\n        rank = {char: [0] * n for char in votes[0]}\\n\\n        for vote in votes:\\n            for i, char in enumerate(vote):\\n                rank[char][i] -= 1  # negative for max-heap like sorting\\n\\n        # Sort by rank values and then alphabetically\\n        return ''.join(sorted(votes[0], key=lambda x: (rank[x], x)))\\n\"",
  "1630_14631217_python": "\"class Solution(object):\\n    def countOdds(self, low, high):\\n        \\\"\\\"\\\"\\n        :type low: int\\n        :type high: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return (high + 1) // 2 - (low // 2)\\n\"",
  "1282_14631217_python-updated-time": "1746126461363",
  "1268_14631217_mysql-updated-time": "1746126081873",
  "1797_14631217_python": "\"class Solution(object):\\n    def interpret(self, command):\\n        res = []\\n        i = 0\\n        while i < len(command):\\n            if command[i] == 'G':\\n                res.append('G')\\n                i += 1\\n            elif command[i:i+2] == '()':\\n                res.append('o')\\n                i += 2\\n            else:\\n                res.append('al')\\n                i += 4\\n        return ''.join(res)\\n\"",
  "1961_14631217_python-updated-time": "1746544292337",
  "3551_14631217_python-updated-time": "1747570897990",
  "2329_14631217_python-updated-time": "1746879296216",
  "3056_14631217_python-updated-time": "1747227018566",
  "3172_14631217_python": "\"class Solution(object):\\n    def differenceOfSums(self, n, m):\\n        total = n * (n + 1) // 2\\n        count = n // m\\n        sum_multiples = m * count * (count + 1) // 2\\n        return total - 2 * sum_multiples\\n\"",
  "3371_14631217_python-updated-time": "1747423040411",
  "3397_14631217_python": "\"class Solution(object):\\n    def addedInteger(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sort both arrays\\n        nums1_sorted = sorted(nums1)\\n        nums2_sorted = sorted(nums2)\\n        # The difference between any corresponding elements is the same x\\n        return nums2_sorted[0] - nums1_sorted[0]\\n\"",
  "1837_14631217_mysql-updated-time": "1746453178115",
  "1227_14631217_python-updated-time": "1746109155905",
  "2002_14631217_python": "\"class Solution:\\n    def stoneGameVIII(self, stones):\\n        # n stones, stones[i] values\\n        n = len(stones)\\n        # prefix sums: pre[i] = sum of stones[0..i]\\n        pre = [0] * n\\n        pre[0] = stones[0]\\n        for i in range(1, n):\\n            pre[i] = pre[i - 1] + stones[i]\\n        # if only 2 stones, Alice must take both at once\\n        if n == 2:\\n            return pre[1]\\n        # dp = best score difference starting when only pre[i..] matter\\n        # initialize dp at last index = pre[n-1]\\n        dp = pre[n - 1]\\n        # iterate i = n-2 down to 1\\n        for i in range(n - 2, 0, -1):\\n            # either skip this prefix (dp stays), or take prefix up to i:\\n            # Alice gets pre[i], then Bob plays optimally giving dp next,\\n            # so net = pre[i] - dp.\\n            dp = max(dp, pre[i] - dp)\\n        # dp at i=1 is the answer\\n        return dp\\n\"",
  "1406_14631217_python": "\"class Solution:\\n    def subtractProductAndSum(self, n):\\n        product = 1\\n        summation = 0\\n        while n > 0:\\n            digit = n % 10\\n            product *= digit\\n            summation += digit\\n            n //= 10\\n        return product - summation\\n\"",
  "2703_14631217_python-updated-time": "1747065704139",
  "3239_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minimumOperationsToMakeEqual(self, x, y):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :type y: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if x == y:\\n            return 0\\n        \\n        visited = set()\\n        queue = deque()\\n        queue.append((x, 0))  # (current value, steps)\\n\\n        while queue:\\n            curr, steps = queue.popleft()\\n            if curr == y:\\n                return steps\\n\\n            if curr in visited:\\n                continue\\n            visited.add(curr)\\n\\n            # Try all four operations:\\n            # Increment and decrement\\n            if curr + 1 <= 20000:  # upper bound to avoid explosion\\n                queue.append((curr + 1, steps + 1))\\n            if curr - 1 >= 1:\\n                queue.append((curr - 1, steps + 1))\\n\\n            # Divide by 5 or 11 if divisible\\n            if curr % 5 == 0:\\n                queue.append((curr // 5, steps + 1))\\n            if curr % 11 == 0:\\n                queue.append((curr // 11, steps + 1))\\n\\n        return -1  # Should not reach here\\n\"",
  "3248_14631217_python-updated-time": "1747318653455",
  "141_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        slow = fast = head\\n\\n        while fast and fast.next:\\n            slow = slow.next         # Move slow pointer by 1\\n            fast = fast.next.next    # Move fast pointer by 2\\n            if slow == fast:\\n                return True\\n\\n        return False\\n\"",
  "260_14631217_python-updated-time": "1745247886062",
  "3196_14631217_python-updated-time": "1747318336405",
  "1349_14631217_python": "\"class Solution:\\n    def checkStraightLine(self, coordinates):\\n        x0, y0 = coordinates[0]\\n        x1, y1 = coordinates[1]\\n        for x, y in coordinates[2:]:\\n            if (y1 - y0) * (x - x0) != (y - y0) * (x1 - x0):\\n                return False\\n        return True\\n\"",
  "2284_14631217_python": "\"class Solution:\\n    def smallestNumber(self, num):\\n        if num == 0:\\n            return 0\\n\\n        digits = list(str(abs(num)))\\n        if num > 0:\\n            digits.sort()\\n            if digits[0] == '0':\\n                for i in range(1, len(digits)):\\n                    if digits[i] != '0':\\n                        digits[0], digits[i] = digits[i], digits[0]\\n                        break\\n            return int(\\\"\\\".join(digits))\\n        else:\\n            digits.sort(reverse=True)\\n            return -int(\\\"\\\".join(digits))\\n\"",
  "567_14631217_python": "\"class Solution(object):\\n    def checkInclusion(self, s1, s2):\\n        m, n = len(s1), len(s2)\\n        if m > n:\\n            return False\\n        # frequency arrays\\n        cnt1 = [0]*26\\n        cnt2 = [0]*26\\n        for i in range(m):\\n            cnt1[ord(s1[i]) - 97] += 1\\n            cnt2[ord(s2[i]) - 97] += 1\\n        if cnt1 == cnt2:\\n            return True\\n        for i in range(m, n):\\n            cnt2[ord(s2[i]) - 97] += 1\\n            cnt2[ord(s2[i-m]) - 97] -= 1\\n            if cnt1 == cnt2:\\n                return True\\n        return False\\n\"",
  "598_14631217_python": "\"class Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \\\"\\\"\\\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not ops:\\n            return m * n\\n        # The cells with maximum value are those in the intersection\\n        # of all operation rectangles: [0, min_ai) × [0, min_bi)\\n        min_a = min(a for a, _ in ops)\\n        min_b = min(b for _, b in ops)\\n        return min_a * min_b\\n\"",
  "2266_14631217_python-updated-time": "1746802970157",
  "3278_14631217_python-updated-time": "1747413116633",
  "31_14631217_python-updated-time": "1744988448266",
  "1770_14631217_python-updated-time": "1746445168696",
  "2529_14631217_python-updated-time": "1746967764504",
  "391_14631217_python": "\"class Solution:\\n    def isRectangleCover(self, rectangles):\\n        min_x = min_y = float('inf')\\n        max_x = max_y = float('-inf')\\n        points = set()\\n        area = 0\\n        \\n        for x1, y1, x2, y2 in rectangles:\\n            min_x = min(min_x, x1)\\n            min_y = min(min_y, y1)\\n            max_x = max(max_x, x2)\\n            max_y = max(max_y, y2)\\n            area += (x2 - x1) * (y2 - y1)\\n            \\n            for point in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\\n                if point in points:\\n                    points.remove(point)\\n                else:\\n                    points.add(point)\\n        \\n        if len(points) != 4 or (min_x, min_y) not in points or (min_x, max_y) not in points or (max_x, min_y) not in points or (max_x, max_y) not in points:\\n            return False\\n        \\n        return area == (max_x - min_x) * (max_y - min_y)\\n\"",
  "2759_14631217_javascript-updated-time": "1747135362865",
  "3429_14631217_python": "\"class Solution(object):\\n    def isArraySpecial(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # Iterate over each adjacent pair\\n        for i in range(1, len(nums)):\\n            # If both even or both odd, parity is the same → not special\\n            if nums[i] % 2 == nums[i-1] % 2:\\n                return False\\n        # If we never found a same-parity pair, it's special\\n        return True\\n\"",
  "986_14631217_python": "\"from itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr):\\n        max_time = -1\\n        \\n        # Try every permutation of the 4 digits\\n        for h1, h2, m1, m2 in permutations(arr):\\n            hours = h1 * 10 + h2\\n            minutes = m1 * 10 + m2\\n            # Check if valid time\\n            if 0 <= hours < 24 and 0 <= minutes < 60:\\n                total = hours * 60 + minutes\\n                if total > max_time:\\n                    max_time = total\\n        \\n        if max_time < 0:\\n            return \\\"\\\"\\n        \\n        hh = max_time // 60\\n        mm = max_time % 60\\n        # Format with leading zeros without using f-strings\\n        return \\\"{:02d}:{:02d}\\\".format(hh, mm)\\n\"",
  "942_14631217_python-updated-time": "1746002864753",
  "1449_14631217_python-updated-time": "1746261381329",
  "2344_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        src, dst = (0,0), (m-1, n-1)\\n        \\n        def inb(r,c):\\n            return 0 <= r < m and 0 <= c < n\\n        \\n        # 1) fire_time BFS\\n        INF = 10**18\\n        fire_time = [[INF]*n for _ in range(m)]\\n        q = deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fire_time[i][j] = 0\\n                    q.append((i,j,0))\\n                elif grid[i][j] == 2:\\n                    fire_time[i][j] = -1\\n        \\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n        while q:\\n            r,c,t = q.popleft()\\n            for dr,dc in dirs:\\n                nr,nc = r+dr, c+dc\\n                if not inb(nr,nc) or grid[nr][nc]==2: continue\\n                if fire_time[nr][nc] > t+1:\\n                    fire_time[nr][nc] = t+1\\n                    q.append((nr,nc,t+1))\\n        \\n        # 2) plain reachability\\n        seen = [[False]*n for _ in range(m)]\\n        dq = deque([src])\\n        seen[0][0] = True\\n        reachable = False\\n        while dq:\\n            r,c = dq.popleft()\\n            if (r,c)==dst:\\n                reachable = True\\n                break\\n            for dr,dc in dirs:\\n                nr,nc = r+dr, c+dc\\n                if inb(nr,nc) and not seen[nr][nc] and grid[nr][nc]!=2:\\n                    seen[nr][nc] = True\\n                    dq.append((nr,nc))\\n        if not reachable:\\n            return -1\\n        \\n        # 3) infinite‐wait case\\n        if fire_time[dst[0]][dst[1]] == INF:\\n            return 10**9\\n        \\n        # 4) can_wait(T) with corrected stepping rule\\n        def can_wait(T):\\n            if T > fire_time[src[0]][src[1]]:\\n                return False\\n            vis = [[False]*n for _ in range(m)]\\n            dq = deque()\\n            vis[0][0] = True\\n            dq.append((0,0,T))\\n            \\n            while dq:\\n                r,c,t = dq.popleft()\\n                if (r,c)==dst and t <= fire_time[r][c]:\\n                    return True\\n                for dr,dc in dirs:\\n                    nr,nc = r+dr, c+dc\\n                    nt = t+1\\n                    if (not inb(nr,nc) or vis[nr][nc] or grid[nr][nc]==2):\\n                        continue\\n                    # **strict** check: must have fire_time > nt, unless it's the dest\\n                    if nt >= fire_time[nr][nc] and (nr,nc) != dst:\\n                        continue\\n                    vis[nr][nc] = True\\n                    dq.append((nr,nc,nt))\\n            return False\\n        \\n        # 5) binary‐search T\\n        lo, hi = 0, fire_time[src[0]][src[1]]\\n        ans = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if can_wait(mid):\\n                ans = mid\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n        \\n        return ans\\n\"",
  "655_14631217_python-updated-time": "1745782850009",
  "3244_14631217_python": "\"class Solution(object):\\n    def minimumArrayLength(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m = min(nums)\\n        cnt = nums.count(m)\\n        # If any b>m is not divisible by m, we can generate a new smaller positive\\n        # then eliminate everything down to one copy of it.\\n        for b in nums:\\n            if b > m and b % m != 0:\\n                return 1\\n        # Otherwise all are multiples of m; we end up with ceil(cnt/2).\\n        return (cnt + 1) // 2\\n\"",
  "1563_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def numPoints(self, darts, r):\\n        n = len(darts)\\n        if n == 0:\\n            return 0\\n        res = 1\\n        r2 = r * r\\n        for i in range(n):\\n            x1, y1 = darts[i]\\n            # Center at dart i\\n            cnt = 0\\n            for xk, yk in darts:\\n                if (xk - x1) ** 2 + (yk - y1) ** 2 <= r2:\\n                    cnt += 1\\n            res = max(res, cnt)\\n            # Circles through dart i and dart j\\n            for j in range(i + 1, n):\\n                x2, y2 = darts[j]\\n                dx, dy = x2 - x1, y2 - y1\\n                d2 = dx*dx + dy*dy\\n                if d2 > 4 * r2:\\n                    continue\\n                d = math.sqrt(d2)\\n                # midpoint\\n                mx, my = (x1 + x2) / 2.0, (y1 + y2) / 2.0\\n                # distance from midpoint to centers\\n                h = math.sqrt(r2 - (d/2.0)**2)\\n                # unit perpendicular\\n                ux, uy = -dy / d, dx / d\\n                # two possible centers\\n                for sign in (1, -1):\\n                    cx = mx + sign * h * ux\\n                    cy = my + sign * h * uy\\n                    cnt = 0\\n                    for xk, yk in darts:\\n                        if (xk - cx) ** 2 + (yk - cy) ** 2 <= r2 + 1e-9:\\n                            cnt += 1\\n                    res = max(res, cnt)\\n        return res\\n\"",
  "1252_14631217_python-updated-time": "1746261486190",
  "1663_14631217_python-updated-time": "1746434797322",
  "3332_14631217_python-updated-time": "1747420045497",
  "2270_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def findLonely(self, nums):\\n        freq = Counter(nums)\\n        res = []\\n        for num in freq:\\n            if freq[num] == 1 and freq[num - 1] == 0 and freq[num + 1] == 0:\\n                res.append(num)\\n        return res\\n\"",
  "134_14631217_python": "\"class Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \\\"\\\"\\\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total_tank = 0\\n        curr_tank = 0\\n        starting_station = 0\\n        \\n        for i in range(len(gas)):\\n            total_tank += gas[i] - cost[i]\\n            curr_tank += gas[i] - cost[i]\\n            \\n            if curr_tank < 0:\\n                # Cannot reach station i+1, start from next station\\n                starting_station = i + 1\\n                curr_tank = 0\\n        \\n        if total_tank >= 0:\\n            return starting_station\\n        else:\\n            return -1\\n\"",
  "1487_14631217_python": "\"class Solution(object):\\n    def maxNumberOfFamilies(self, n, reservedSeats):\\n        from collections import defaultdict\\n\\n        reserved = defaultdict(set)\\n        for row, seat in reservedSeats:\\n            reserved[row].add(seat)\\n\\n        result = 0\\n        for row in reserved:\\n            seats = reserved[row]\\n            count = 0\\n            if not (2 in seats or 3 in seats or 4 in seats or 5 in seats):\\n                count += 1\\n            if not (6 in seats or 7 in seats or 8 in seats or 9 in seats):\\n                count += 1\\n            if count == 0 and not (4 in seats or 5 in seats or 6 in seats or 7 in seats):\\n                count = 1\\n            result += count\\n\\n        return result + (n - len(reserved)) * 2\\n\"",
  "3326_14631217_python-updated-time": "1747420090328",
  "40_14631217_python-updated-time": "1744999271279",
  "1541_14631217_mysql-updated-time": "1746346579415",
  "1811_14631217_mysql-updated-time": "1746445803207",
  "1337_14631217_python-updated-time": "1746127524756",
  "726_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def countOfAtoms(self, formula):\\n        \\\"\\\"\\\"\\n        :type formula: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        stack = [collections.Counter()]\\n        i, n = 0, len(formula)\\n        \\n        while i < n:\\n            ch = formula[i]\\n            if ch == '(':\\n                # Start a new group\\n                stack.append(collections.Counter())\\n                i += 1\\n            elif ch == ')':\\n                # End current group; pop and apply multiplier\\n                top = stack.pop()\\n                i += 1\\n                # Parse multiplier (if any)\\n                start = i\\n                while i < n and formula[i].isdigit():\\n                    i += 1\\n                mul = int(formula[start:i] or 1)\\n                # Merge into previous level\\n                for atom, cnt in top.items():\\n                    stack[-1][atom] += cnt * mul\\n            else:\\n                # Parse atom name\\n                # Uppercase letter\\n                start = i\\n                i += 1\\n                # Following lowercase letters\\n                while i < n and formula[i].islower():\\n                    i += 1\\n                atom = formula[start:i]\\n                # Parse count (if any)\\n                start_count = i\\n                while i < n and formula[i].isdigit():\\n                    i += 1\\n                cnt = int(formula[start_count:i] or 1)\\n                # Add to current level\\n                stack[-1][atom] += cnt\\n        \\n        # Final counts in stack[0]\\n        counts = stack.pop()\\n        # Build output: sorted atom names\\n        atoms = sorted(counts.keys())\\n        res = []\\n        for atom in atoms:\\n            res.append(atom)\\n            if counts[atom] > 1:\\n                res.append(str(counts[atom]))\\n        return \\\"\\\".join(res)\\n\"",
  "2456_14631217_python-updated-time": "1746964924771",
  "310_14631217_python-updated-time": "1745255889510",
  "795_14631217_python-updated-time": "1745877323925",
  "1196_14631217_python": "\"class Solution(object):\\n    def minHeightShelves(self, books, shelfWidth):\\n        \\\"\\\"\\\"\\n        :type books: List[List[int]]\\n        :type shelfWidth: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(books)\\n        dp = [0] + [float('inf')] * n\\n\\n        for i in range(1, n + 1):\\n            width = 0\\n            height = 0\\n            for j in range(i, 0, -1):\\n                width += books[j - 1][0]\\n                if width > shelfWidth:\\n                    break\\n                height = max(height, books[j - 1][1])\\n                dp[i] = min(dp[i], dp[j - 1] + height)\\n\\n        return dp[n]\\n\"",
  "951_14631217_python": "\"class Solution:\\n    def partitionDisjoint(self, nums):\\n        n = len(nums)\\n        max_left = nums[0]\\n        curr_max = nums[0]\\n        partition_idx = 0\\n\\n        for i in range(1, n):\\n            curr_max = max(curr_max, nums[i])\\n            if nums[i] < max_left:\\n                partition_idx = i\\n                max_left = curr_max\\n\\n        return partition_idx + 1\\n\"",
  "754_14631217_python-updated-time": "1745875671373",
  "2039_14631217_python": "\"class Solution(object):\\n    def sumGame(self, num):\\n        n = len(num)\\n        half = n // 2\\n        lsum = rsum = 0\\n        lq = rq = 0\\n        for i, ch in enumerate(num):\\n            if ch == '?':\\n                if i < half: lq += 1\\n                else:        rq += 1\\n            else:\\n                if i < half: lsum += int(ch)\\n                else:        rsum += int(ch)\\n\\n        total_q = lq + rq\\n        # If odd number of moves, Alice gets extra move => she can force inequality\\n        if total_q & 1:\\n            return True\\n\\n        # Let D = lsum - rsum. Let x = (rq - lq)//2 * 9.\\n        D = lsum - rsum\\n        x = (rq - lq) // 2 * 9\\n        # If D equals x, Bob can balance; otherwise Alice wins\\n        return D != x\\n\"",
  "2164_14631217_python-updated-time": "1746720396189",
  "2261_14631217_python": "\"class Solution:\\n    def maxScoreIndices(self, nums):\\n        total_ones = sum(nums)\\n        max_score = total_ones  # i = 0, numsleft = [], numsright = nums\\n        zeros_left = 0\\n        result = [0]\\n\\n        for i, num in enumerate(nums):\\n            if num == 0:\\n                zeros_left += 1\\n            else:\\n                total_ones -= 1\\n            score = zeros_left + total_ones\\n            if score > max_score:\\n                max_score = score\\n                result = [i + 1]\\n            elif score == max_score:\\n                result.append(i + 1)\\n        return result\\n\"",
  "1136_14631217_mysql-updated-time": "1746107533969",
  "3070_14631217_pythondata-updated-time": "1747305842738",
  "119_14631217_python": "\"class Solution(object):\\n    def getRow(self, rowIndex):\\n        \\\"\\\"\\\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        row = [1]\\n        for i in range(1, rowIndex + 1):\\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\\n        return row\\n\"",
  "2834_14631217_python-updated-time": "1747222077965",
  "1691_14631217_python-updated-time": "1746438061544",
  "3567_14631217_python": "\"class Solution(object):\\n    def convertDateToBinary(self, date):\\n        y, m, d = date.split('-')\\n        return \\\"{}-{}-{}\\\".format(bin(int(y))[2:], bin(int(m))[2:], bin(int(d))[2:])\\n\"",
  "3716_14631217_python": "\"class Solution(object):\\n    def longestSubsequence(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        V = 300\\n        # best[val][d]: best length of subseq ending at value `val` with last diff = d\\n        best = [[0]*(V+1) for _ in range(V+1)]\\n        # best_max[val][d] = max(best[val][d], best[val][d+1], ..., best[val][V])\\n        best_max = [[0]*(V+1) for _ in range(V+1)]\\n        \\n        ans = 1  # a single element always gives length 1\\n        \\n        for a in nums:\\n            # Build updates for this a:\\n            upd = [0]*(V+1)\\n            # Try to transition from every possible previous value v=1..V\\n            for v in range(1, V+1):\\n                diff = abs(a - v)\\n                # best chain we can extend whose last diff >= diff\\n                prev_best = best_max[v][diff]\\n                # if prev_best==0, we start a new length-2 subseq (v→a)\\n                cand = prev_best + 1\\n                if cand > upd[diff]:\\n                    upd[diff] = cand\\n            \\n            # Merge the updates into best[a][*]\\n            for d in range(V+1):\\n                if upd[d] > best[a][d]:\\n                    best[a][d] = upd[d]\\n            \\n            # Recompute best_max[a][*] by scanning from high diffs downwards\\n            best_max[a][V] = best[a][V]\\n            for d in range(V-1, -1, -1):\\n                # either take best[a][d] itself or carry forward the max from d+1\\n                m = best[a][d]\\n                if best_max[a][d+1] > m:\\n                    m = best_max[a][d+1]\\n                best_max[a][d] = m\\n            \\n            # The best subsequence ending in `a` can be any diff >= 0\\n            if best_max[a][0] > ans:\\n                ans = best_max[a][0]\\n        \\n        return ans\\n\"",
  "3604_14631217_python-updated-time": "1747578227900",
  "2858_14631217_javascript-updated-time": "1747140857644",
  "437_14631217_python-updated-time": "1745358842061",
  "870_14631217_python": "\"class Solution(object):\\n    def numMagicSquaresInside(self, grid):\\n        def is_magic(r, c):\\n            s = set()\\n            for i in range(3):\\n                for j in range(3):\\n                    if not (1 <= grid[r+i][c+j] <= 9):\\n                        return False\\n                    s.add(grid[r+i][c+j])\\n            if len(s) != 9:\\n                return False\\n            rows = [sum(grid[r+i][c:c+3]) for i in range(3)]\\n            cols = [sum(grid[r+i][c+j] for i in range(3)) for j in range(3)]\\n            diag1 = sum(grid[r+i][c+i] for i in range(3))\\n            diag2 = sum(grid[r+i][c+2-i] for i in range(3))\\n            return len(set(rows + cols + [diag1, diag2])) == 1\\n        \\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in range(m-2):\\n            for j in range(n-2):\\n                if grid[i+1][j+1] == 5 and is_magic(i, j):\\n                    count += 1\\n        return count\\n\"",
  "3525_14631217_python": "\"class Solution(object):\\n    def maxEnergyBoost(self, energyDrinkA, energyDrinkB):\\n        \\\"\\\"\\\"\\n        :type energyDrinkA: List[int]\\n        :type energyDrinkB: List[int]\\n        :rtype: int\\n        Computes the maximum total energy boost over n hours when switching drinks incurs a 1-hour cleanse (zero boost).\\n        \\\"\\\"\\\"\\n        n = len(energyDrinkA)\\n        # dpA: ending with A, dpB: ending with B, dpC: currently cleansing\\n        dpA = energyDrinkA[0]\\n        dpB = energyDrinkB[0]\\n        dpC = 0\\n        for i in range(1, n):\\n            a = energyDrinkA[i]\\n            b = energyDrinkB[i]\\n            # If we drink A now, we could have come from A or from cleansing\\n            newA = a + max(dpA, dpC)\\n            # If we drink B now, come from B or cleansing\\n            newB = b + max(dpB, dpC)\\n            # If we cleanse now, we skip boost, coming from any state\\n            newC = max(dpA, dpB, dpC)\\n            dpA, dpB, dpC = newA, newB, newC\\n        return max(dpA, dpB, dpC)\"",
  "2067_14631217_python-updated-time": "1746638353647",
  "570_14631217_mysql": "\"SELECT name\\nFROM Employee\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    WHERE managerId IS NOT NULL\\n    GROUP BY managerId\\n    HAVING COUNT(*) >= 5\\n);\\n\"",
  "102_14631217_python-updated-time": "1745080948276",
  "1145_14631217_python-updated-time": "1746107897425",
  "1827_14631217_mysql-updated-time": "1746452879903",
  "1957_14631217_python-updated-time": "1746544642022",
  "653_14631217_python": "\"class Solution(object):\\n    def findTarget(self, root, k):\\n        seen = set()\\n        \\n        def dfs(node):\\n            if not node:\\n                return False\\n            if k - node.val in seen:\\n                return True\\n            seen.add(node.val)\\n            return dfs(node.left) or dfs(node.right)\\n        \\n        return dfs(root)\\n\"",
  "561_14631217_python-updated-time": "1745447651826",
  "576_14631217_python-updated-time": "1745447938500",
  "2833_14631217_python": "\"class Solution:\\n    def countServers(self, n, logs, x, queries):\\n        from collections import defaultdict\\n\\n        # Sort logs by time\\n        logs.sort(key=lambda t: t[1])\\n        # Pair queries with their indices to return answers in order\\n        sorted_queries = sorted((q, i) for i, q in enumerate(queries))\\n        ans = [0] * len(queries)\\n\\n        left = 0\\n        right = 0\\n        count = defaultdict(int)\\n        active_servers = 0\\n\\n        for q_time, q_index in sorted_queries:\\n            # Expand window to include logs within [q_time - x, q_time]\\n            while right < len(logs) and logs[right][1] <= q_time:\\n                server_id = logs[right][0]\\n                count[server_id] += 1\\n                if count[server_id] == 1:\\n                    active_servers += 1\\n                right += 1\\n\\n            # Shrink window from left: logs with time < q_time - x\\n            while left < len(logs) and logs[left][1] < q_time - x:\\n                server_id = logs[left][0]\\n                count[server_id] -= 1\\n                if count[server_id] == 0:\\n                    active_servers -= 1\\n                left += 1\\n\\n            ans[q_index] = n - active_servers\\n\\n        return ans\\n\"",
  "1127_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones):\\n        # max-heap via negatives\\n        heap = [-s for s in stones]\\n        heapq.heapify(heap)\\n        while len(heap) > 1:\\n            x = -heapq.heappop(heap)  # largest\\n            y = -heapq.heappop(heap)  # second largest\\n            if x != y:\\n                # remaining stone of weight |x - y|\\n                heapq.heappush(heap, -(x - y))\\n        return -heap[0] if heap else 0\\n\"",
  "3799_14631217_python-updated-time": "1747681419330",
  "832_14631217_python-updated-time": "1745878670026",
  "2632_14631217_python": "\"class Solution:\\n    def makeStringsEqual(self, s, target):\\n        return ('1' in s) == ('1' in target)\\n\"",
  "3659_14631217_python-updated-time": "1747597932279",
  "546_14631217_python": "\"class Solution:\\n    def removeBoxes(self, boxes):\\n        memo = {}\\n\\n        def dp(l, r, k):\\n            if l > r:\\n                return 0\\n            if (l, r, k) in memo:\\n                return memo[(l, r, k)]\\n\\n            # Merge boxes of the same color at the end\\n            orig_r = r\\n            orig_k = k\\n            while r > l and boxes[r] == boxes[r - 1]:\\n                r -= 1\\n                k += 1\\n\\n            res = dp(l, r - 1, 0) + (k + 1) ** 2\\n            for i in range(l, r):\\n                if boxes[i] == boxes[r]:\\n                    res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\\n\\n            memo[(l, orig_r, orig_k)] = res\\n            return res\\n\\n        return dp(0, len(boxes) - 1, 0)\\n\"",
  "1274_14631217_python": "\"from datetime import datetime\\n\\nclass Solution(object):\\n    def daysBetweenDates(self, date1, date2):\\n        d1 = datetime.strptime(date1, \\\"%Y-%m-%d\\\")\\n        d2 = datetime.strptime(date2, \\\"%Y-%m-%d\\\")\\n        return abs((d1 - d2).days)\\n\"",
  "112_14631217_python-updated-time": "1745081296679",
  "2504_14631217_python-updated-time": "1746966630281",
  "838_14631217_python-updated-time": "1745786425259",
  "165_14631217_python": "\"class Solution(object):\\n    def compareVersion(self, version1, version2):\\n        v1 = list(map(int, version1.split('.')))\\n        v2 = list(map(int, version2.split('.')))\\n        \\n        max_len = max(len(v1), len(v2))\\n        \\n        for i in range(max_len):\\n            num1 = v1[i] if i < len(v1) else 0\\n            num2 = v2[i] if i < len(v2) else 0\\n            if num1 > num2:\\n                return 1\\n            elif num1 < num2:\\n                return -1\\n        \\n        return 0\\n\"",
  "3676_14631217_python": "\"class Solution(object):\\n    def smallestNumber(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Let b = number of bits needed to represent n in binary,\\n        # i.e. b = floor(log2(n)) + 1\\n        b = n.bit_length()\\n        # candidate = 2^b - 1\\n        cand = (1 << b) - 1\\n        # if it's already >= n, that's our answer; otherwise we need one more bit\\n        if cand >= n:\\n            return cand\\n        else:\\n            return (1 << (b + 1)) - 1\\n\"",
  "3434_14631217_python": "\"class Solution(object):\\n    def queryResults(self, limit, queries):\\n        \\\"\\\"\\\"\\n        :type limit: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Track current color of each ball (sparse, since labels can be large)\\n        ball_color = {}\\n        # Count how many balls have each color\\n        color_count = {}\\n        # Number of distinct colors currently in use\\n        distinct = 0\\n        \\n        result = []\\n        for x, y in queries:\\n            # Remove old color of ball x, if any\\n            old = ball_color.get(x)\\n            if old is not None:\\n                color_count[old] -= 1\\n                if color_count[old] == 0:\\n                    # that color is no longer present\\n                    distinct -= 1\\n            \\n            # Assign new color y to ball x\\n            ball_color[x] = y\\n            if color_count.get(y, 0) == 0:\\n                # this color was not in use before\\n                distinct += 1\\n            color_count[y] = color_count.get(y, 0) + 1\\n            \\n            # Record the current number of distinct colors\\n            result.append(distinct)\\n        \\n        return result\"",
  "70_14631217_python-updated-time": "1745014990776",
  "2710_14631217_python": "\"class Solution(object):\\n    def minOperations(self, n):\\n        ops = 0\\n        while n > 0:\\n            if n & 1 == 0:\\n                # even: no ±-2ᶦ operation needed, just shift\\n                n >>= 1\\n            else:\\n                # odd: decide whether to +1 or −1\\n                # best to subtract when n%4==1 or n==3; otherwise add\\n                if n == 3 or (n & 3) == 1:\\n                    n -= 1\\n                else:\\n                    n += 1\\n                ops += 1\\n                n >>= 1\\n        return ops\\n\"",
  "3678_14631217_python": "\"import heapq\\n\\nclass TaskManager(object):\\n    def __init__(self, tasks):\\n        \\\"\\\"\\\"\\n        :type tasks: List[List[int]]   # each [userId, taskId, priority]\\n        \\\"\\\"\\\"\\n        # info: taskId -> (userId, priority)\\n        self.info = {}\\n        # max-heap storing (-priority, -taskId, taskId)\\n        self.heap = []\\n        \\n        for userId, taskId, priority in tasks:\\n            self.info[taskId] = (userId, priority)\\n            heapq.heappush(self.heap, (-priority, -taskId, taskId))\\n\\n    def add(self, userId, taskId, priority):\\n        \\\"\\\"\\\"\\n        :type userId: int\\n        :type taskId: int\\n        :type priority: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        # insert new task\\n        self.info[taskId] = (userId, priority)\\n        heapq.heappush(self.heap, (-priority, -taskId, taskId))\\n\\n    def edit(self, taskId, newPriority):\\n        \\\"\\\"\\\"\\n        :type taskId: int\\n        :type newPriority: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        userId, _old = self.info[taskId]\\n        # update mapping\\n        self.info[taskId] = (userId, newPriority)\\n        # push updated entry\\n        heapq.heappush(self.heap, (-newPriority, -taskId, taskId))\\n\\n    def rmv(self, taskId):\\n        \\\"\\\"\\\"\\n        :type taskId: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        # lazy-delete by removing from info\\n        if taskId in self.info:\\n            del self.info[taskId]\\n\\n    def execTop(self):\\n        \\\"\\\"\\\"\\n        :rtype: int  # userId of executed task, or -1 if none\\n        \\\"\\\"\\\"\\n        # pop until we find a valid top\\n        while self.heap:\\n            neg_prio, neg_tid, tid = heapq.heappop(self.heap)\\n            prio, tid_pos = -neg_prio, -neg_tid\\n            # check consistency with current info\\n            if tid_pos in self.info:\\n                userId, cur_prio = self.info[tid_pos]\\n                if cur_prio == prio:\\n                    # this is the true top; execute it\\n                    del self.info[tid_pos]\\n                    return userId\\n            # otherwise it's stale—keep popping\\n        return -1\\n\"",
  "181_14631217_mysql-updated-time": "1745092497345",
  "2388_14631217_python": "\"class Solution:\\n    def arrayChange(self, nums, operations):\\n        # Map each value to its index in nums\\n        pos = {val: i for i, val in enumerate(nums)}\\n        \\n        # Apply each operation\\n        for old, new in operations:\\n            idx = pos.pop(old)   # get and remove the old value's index\\n            nums[idx] = new      # replace in the array\\n            pos[new] = idx       # record the new value's index\\n        \\n        return nums\\n\"",
  "399_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def calcEquation(self, equations, values, queries):\\n        graph = defaultdict(dict)\\n        \\n        # Build the graph\\n        for (a, b), v in zip(equations, values):\\n            graph[a][b] = v\\n            graph[b][a] = 1 / v\\n        \\n        def dfs(x, y, visited):\\n            if x not in graph or y not in graph:\\n                return -1.0\\n            if x == y:\\n                return 1.0\\n            visited.add(x)\\n            for nei, val in graph[x].items():\\n                if nei not in visited:\\n                    res = dfs(nei, y, visited)\\n                    if res != -1.0:\\n                        return res * val\\n            return -1.0\\n        \\n        results = []\\n        for a, b in queries:\\n            results.append(dfs(a, b, set()))\\n        \\n        return results\\n\"",
  "2698_14631217_python-updated-time": "1747065159279",
  "3741_14631217_python-updated-time": "1747674459972",
  "586_14631217_mysql": "\"SELECT\\n    customer_number\\nFROM Orders\\nGROUP BY customer_number\\nORDER BY COUNT(*) DESC\\nLIMIT 1;\\n\"",
  "2639_14631217_python-updated-time": "1747064836310",
  "931_14631217_python-updated-time": "1746002189273",
  "3379_14631217_python3-updated-time": "1720875096801",
  "3326_14631217_python": "\"class Solution(object):\\n    def countPairsOfConnectableServers(self, edges, signalSpeed):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type signalSpeed: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        from collections import defaultdict, deque\\n        \\n        n = len(edges) + 1\\n        # build adjacency list: (neighbor, weight)\\n        adj = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n        \\n        res = [0] * n\\n        \\n        # for each server c, treat it as center:\\n        for c in range(n):\\n            branch_counts = []\\n            # explore each neighbor-subtree separately:\\n            for (nei, w0) in adj[c]:\\n                count = 0\\n                # stack holds (node, parent, dist_from_c)\\n                stack = [(nei, c, w0)]\\n                while stack:\\n                    u, p, dist = stack.pop()\\n                    # check divisibility\\n                    if dist % signalSpeed == 0:\\n                        count += 1\\n                    # go deeper\\n                    for v, w in adj[u]:\\n                        if v == p:\\n                            continue\\n                        stack.append((v, u, dist + w))\\n                branch_counts.append(count)\\n            \\n            # now sum up all unordered pairs between different branches\\n            total = 0\\n            prefix = 0\\n            for cnt in branch_counts:\\n                total += prefix * cnt\\n                prefix += cnt\\n            \\n            res[c] = total\\n        \\n        return res\\n\"",
  "61_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def rotateRight(self, head, k):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :type k: int\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        if not head or not head.next or k == 0:\\n            return head\\n\\n        # Find the length of the list\\n        length = 1\\n        current = head\\n        while current.next:\\n            current = current.next\\n            length += 1\\n\\n        # Make it a circular list\\n        current.next = head\\n\\n        # Find the new head\\n        k = k % length\\n        steps_to_new_head = length - k\\n        new_tail = head\\n        for _ in range(steps_to_new_head - 1):\\n            new_tail = new_tail.next\\n\\n        new_head = new_tail.next\\n        new_tail.next = None\\n\\n        return new_head\\n\"",
  "633_14631217_python-updated-time": "1745782285503",
  "1699_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        MOD = 10**9 + 7\\n        \\n        # frequency maps\\n        freq1 = collections.Counter(nums1)\\n        freq2 = collections.Counter(nums2)\\n        uniq1 = list(freq1.keys())\\n        uniq2 = list(freq2.keys())\\n        \\n        ans = 0\\n        \\n        # Type 1: nums1[i]^2 == nums2[j] * nums2[k]\\n        for x in uniq1:\\n            T = x * x\\n            # count pairs in nums2 whose product is T\\n            p = 0\\n            for v in uniq2:\\n                if T % v != 0:\\n                    continue\\n                w = T // v\\n                if w not in freq2:\\n                    continue\\n                if v < w:\\n                    p += freq2[v] * freq2[w]\\n                elif v == w:\\n                    c = freq2[v]\\n                    p += c * (c - 1) // 2\\n            ans = (ans + freq1[x] * p) % MOD\\n        \\n        # Type 2: nums2[i]^2 == nums1[j] * nums1[k]\\n        for y in uniq2:\\n            T = y * y\\n            # count pairs in nums1 whose product is T\\n            p = 0\\n            for v in uniq1:\\n                if T % v != 0:\\n                    continue\\n                w = T // v\\n                if w not in freq1:\\n                    continue\\n                if v < w:\\n                    p += freq1[v] * freq1[w]\\n                elif v == w:\\n                    c = freq1[v]\\n                    p += c * (c - 1) // 2\\n            ans = (ans + freq2[y] * p) % MOD\\n        \\n        return ans\\n\"",
  "1583_14631217_python": "\"class Solution(object):\\n    def minCost(self, houses, cost, m, n, target):\\n        \\\"\\\"\\\"\\n        :type houses: List[int]\\n        :type cost: List[List[int]]\\n        :type m: int\\n        :type n: int\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        INF = float('inf')\\n        cache = {}\\n\\n        def dp(i, prev_color, neighborhoods):\\n            if neighborhoods > target:\\n                return INF\\n            if i == m:\\n                return 0 if neighborhoods == target else INF\\n\\n            key = (i, prev_color, neighborhoods)\\n            if key in cache:\\n                return cache[key]\\n\\n            if houses[i] != 0:\\n                new_neigh = neighborhoods + (1 if houses[i] != prev_color else 0)\\n                res = dp(i + 1, houses[i], new_neigh)\\n            else:\\n                res = INF\\n                for color in range(1, n + 1):\\n                    new_neigh = neighborhoods + (1 if color != prev_color else 0)\\n                    paint_cost = cost[i][color - 1]\\n                    total = paint_cost + dp(i + 1, color, new_neigh)\\n                    res = min(res, total)\\n\\n            cache[key] = res\\n            return res\\n\\n        result = dp(0, 0, 0)\\n        return -1 if result == INF else result\\n\"",
  "2060_14631217_python-updated-time": "1746638174267",
  "2746_14631217_javascript": "\"function filter(arr, fn) {\\n  const result = [];\\n  for (let i = 0; i < arr.length; i += 1) {\\n    if (fn(arr[i], i)) {\\n      result.push(arr[i]);\\n    }\\n  }\\n  return result;\\n}\\n\"",
  "1529_14631217_python": "\"class Solution:\\n    def maxDiff(self, num):\\n        s = str(num)\\n\\n        # Maximize: replace first non-9 digit with 9\\n        for ch in s:\\n            if ch != '9':\\n                max_num = int(s.replace(ch, '9'))\\n                break\\n        else:\\n            max_num = num\\n\\n        # Minimize: replace first digit (if not 1) with 1, or else replace any non-0 (not first) with 0\\n        if s[0] != '1':\\n            min_num = int(s.replace(s[0], '1'))\\n        else:\\n            for ch in s[1:]:\\n                if ch != '0' and ch != '1':\\n                    min_num = int(s.replace(ch, '0'))\\n                    break\\n            else:\\n                min_num = num\\n\\n        return max_num - min_num\\n\"",
  "2119_14631217_python": "\"class Solution:\\n    def minOperations(self, nums):\\n        n = len(nums)\\n        # Get sorted list of unique values\\n        A = sorted(set(nums))\\n        \\n        max_keep = 0\\n        m = len(A)\\n        r = 0\\n        \\n        # Slide window over A: for each l, advance r so that A[r] - A[l] <= n-1\\n        for l in range(m):\\n            # Ensure r is at least l\\n            if r < l:\\n                r = l\\n            # Extend r while within a span of length n\\n            while r + 1 < m and A[r+1] - A[l] <= n - 1:\\n                r += 1\\n            # Window [l..r] fits within some consecutive block of size n\\n            max_keep = max(max_keep, r - l + 1)\\n        \\n        # We can keep at most max_keep original elements;\\n        # the rest must be changed.\\n        return n - max_keep\\n\"",
  "528_14631217_python-updated-time": "1746454426953",
  "712_14631217_python": "\"class Solution(object):\\n    def minimumDeleteSum(self, s1, s2):\\n        m, n = len(s1), len(s2)\\n        # dp[i][j]: min ASCII delete sum to make s1[:i] and s2[:j] equal\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        # Base cases: delete all from one string to match empty other\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i-1][0] + ord(s1[i-1])\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j-1] + ord(s2[j-1])\\n        \\n        # Fill DP table\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    cost1 = dp[i-1][j] + ord(s1[i-1])  # delete from s1\\n                    cost2 = dp[i][j-1] + ord(s2[j-1])  # delete from s2\\n                    dp[i][j] = min(cost1, cost2)\\n        \\n        return dp[m][n]\\n\"",
  "812_14631217_python-updated-time": "1745877955304",
  "1122_14631217_python": "\"class Solution:\\n    def longestDupSubstring(self, s):\\n        n = len(s)\\n        nums = [ord(c) - 97 for c in s]   # map a..z to 0..25\\n        mod1, mod2 = 10**9 + 7, 10**9 + 9\\n        base = 26\\n\\n        # pre-compute powers\\n        pow1 = [1] * (n + 1)\\n        pow2 = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            pow1[i] = (pow1[i - 1] * base) % mod1\\n            pow2[i] = (pow2[i - 1] * base) % mod2\\n\\n        def check(L):\\n            \\\"\\\"\\\"return start index of a duplicate substring of length L or -1\\\"\\\"\\\"\\n            h1 = h2 = 0\\n            for i in range(L):\\n                h1 = (h1 * base + nums[i]) % mod1\\n                h2 = (h2 * base + nums[i]) % mod2\\n            seen = {(h1, h2)}\\n            for i in range(L, n):\\n                h1 = (h1 * base - nums[i - L] * pow1[L] + nums[i]) % mod1\\n                h2 = (h2 * base - nums[i - L] * pow2[L] + nums[i]) % mod2\\n                key = (h1, h2)\\n                if key in seen:\\n                    return i - L + 1\\n                seen.add(key)\\n            return -1\\n\\n        lo, hi, idx = 1, n - 1, -1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            pos = check(mid)\\n            if pos != -1:\\n                lo, idx, best = mid + 1, pos, mid\\n            else:\\n                hi = mid - 1\\n        return \\\"\\\" if idx == -1 else s[idx:idx + best]\\n\"",
  "3309_14631217_python-updated-time": "1747416429085",
  "2713_14631217_python": "\"class Solution(object):\\n    def divisibilityArray(self, word, m):\\n        res = []\\n        curr = 0\\n        for ch in word:\\n            curr = (curr * 10 + int(ch)) % m\\n            res.append(1 if curr == 0 else 0)\\n        return res\\n\"",
  "383_14631217_python-updated-time": "1745355139671",
  "2363_14631217_python": "\"class Solution:\\n    def maxTrailingZeros(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Step 1: factor each cell into counts of 2s and 5s\\n        f2 = [[0]*n for _ in range(m)]\\n        f5 = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                c2 = c5 = 0\\n                while x % 2 == 0:\\n                    x //= 2; c2 += 1\\n                while x % 5 == 0:\\n                    x //= 5; c5 += 1\\n                f2[i][j], f5[i][j] = c2, c5\\n\\n        # Step 2: build row‐prefixes and row‐suffixes of f2/f5\\n        row2 = [[0]*n for _ in range(m)]\\n        row5 = [[0]*n for _ in range(m)]\\n        row2r = [[0]*n for _ in range(m)]\\n        row5r = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            a2 = a5 = 0\\n            for j in range(n):\\n                a2 += f2[i][j]\\n                a5 += f5[i][j]\\n                row2[i][j], row5[i][j] = a2, a5\\n            a2 = a5 = 0\\n            for j in range(n-1, -1, -1):\\n                a2 += f2[i][j]\\n                a5 += f5[i][j]\\n                row2r[i][j], row5r[i][j] = a2, a5\\n\\n        # Step 3: build column‐prefixes and column‐suffixes of f2/f5\\n        col2 = [[0]*n for _ in range(m)]\\n        col5 = [[0]*n for _ in range(m)]\\n        col2r = [[0]*n for _ in range(m)]\\n        col5r = [[0]*n for _ in range(m)]\\n        for j in range(n):\\n            a2 = a5 = 0\\n            for i in range(m):\\n                a2 += f2[i][j]\\n                a5 += f5[i][j]\\n                col2[i][j], col5[i][j] = a2, a5\\n            a2 = a5 = 0\\n            for i in range(m-1, -1, -1):\\n                a2 += f2[i][j]\\n                a5 += f5[i][j]\\n                col2r[i][j], col5r[i][j] = a2, a5\\n\\n        # Step 4: try each cell as the “corner” of the L\\n        best = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # For convenience\\n                c2, c5 = f2[i][j], f5[i][j]\\n\\n                # 4 choices: up+left, up+right, down+left, down+right\\n                # each = (vertical leg) + (horizontal leg) − (cell counted twice)\\n                # and trailing zeros = min(total2, total5)\\n                \\n                # up + left\\n                t2 = col2[i][j] + row2[i][j] - c2\\n                t5 = col5[i][j] + row5[i][j] - c5\\n                best = max(best, min(t2, t5))\\n                \\n                # up + right\\n                t2 = col2[i][j] + row2r[i][j] - c2\\n                t5 = col5[i][j] + row5r[i][j] - c5\\n                best = max(best, min(t2, t5))\\n                \\n                # down + left\\n                t2 = col2r[i][j] + row2[i][j] - c2\\n                t5 = col5r[i][j] + row5[i][j] - c5\\n                best = max(best, min(t2, t5))\\n                \\n                # down + right\\n                t2 = col2r[i][j] + row2r[i][j] - c2\\n                t5 = col5r[i][j] + row5r[i][j] - c5\\n                best = max(best, min(t2, t5))\\n\\n        return best\\n\"",
  "1219_14631217_python-updated-time": "1746109087692",
  "1758_14631217_python": "\"class Solution:\\n    def canDistribute(self, nums, quantity):\\n        from collections import Counter\\n        \\n        m = len(quantity)\\n        full = (1<<m) - 1\\n        \\n        # 1) Count capacities of each distinct value\\n        caps = list(Counter(nums).values())\\n        \\n        # 2) Precompute demand[mask]\\n        demand = [0] * (1<<m)\\n        for mask in range(1, 1<<m):\\n            # lowest set bit\\n            lsb = mask & -mask\\n            i = (lsb.bit_length() - 1)\\n            prev = mask ^ lsb\\n            demand[mask] = demand[prev] + quantity[i]\\n        \\n        # 3) For each capacity, list valid subsets\\n        valid = []\\n        for c in caps:\\n            lst = []\\n            for mask in range(1<<m):\\n                if demand[mask] <= c:\\n                    lst.append(mask)\\n            valid.append(lst)\\n        \\n        # 4) DP over masks\\n        dp = [False] * (1<<m)\\n        dp[0] = True\\n        \\n        for lst in valid:\\n            next_dp = dp[:]  # copy\\n            for old in range(1<<m):\\n                if not dp[old]:\\n                    continue\\n                free = full ^ old\\n                # try every subset we can serve with this capacity\\n                for sub in lst:\\n                    if sub & old == 0:      # sub ⊆ free\\n                        next_dp[old | sub] = True\\n            dp = next_dp\\n        \\n        return dp[full]\\n\"",
  "2435_14631217_python-updated-time": "1746907786530",
  "1049_14631217_python": "\"class Solution:\\n    def minDominoRotations(self, tops, bottoms):\\n        def check(x):\\n            rotations_top = rotations_bottom = 0\\n            for t, b in zip(tops, bottoms):\\n                if t != x and b != x:\\n                    return float('inf')\\n                if t != x:\\n                    rotations_top += 1\\n                if b != x:\\n                    rotations_bottom += 1\\n            return min(rotations_top, rotations_bottom)\\n\\n        candidates = {tops[0], bottoms[0]}\\n        res = min(check(x) for x in candidates)\\n        return res if res != float('inf') else -1\\n\"",
  "401_14631217_python-updated-time": "1745355839015",
  "1835_14631217_python-updated-time": "1746530417669",
  "1070_14631217_python-updated-time": "1746041670284",
  "2188_14631217_python-updated-time": "1746720947987",
  "51_14631217_python-updated-time": "1745014202107",
  "1674_14631217_python": "\"class Solution(object):\\n    def minOperations(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return (n * n) // 4\\n\"",
  "1871_14631217_python": "\"class Solution(object):\\n    def checkPartitioning(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        \\n        # Step 1: Precompute palindrome substrings\\n        dp = [[False] * n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            for j in range(i, n):\\n                if s[i] == s[j] and (j - i < 2 or dp[i+1][j-1]):\\n                    dp[i][j] = True\\n        \\n        # Step 2: Try all split positions\\n        for i in range(1, n - 1):\\n            for j in range(i + 1, n):\\n                if dp[0][i - 1] and dp[i][j - 1] and dp[j][n - 1]:\\n                    return True\\n        return False\\n\"",
  "3490_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Count how many evens and odds we have\\n        cnt_even = 0\\n        for x in nums:\\n            if x & 1 == 0:\\n                cnt_even += 1\\n        cnt_odd = n - cnt_even\\n        \\n        # Case 1: all same parity → adjacent sums are even (0 mod 2)\\n        max_uniform = max(cnt_even, cnt_odd)\\n        \\n        # Case 2: alternating parity → adjacent sums are odd (1 mod 2)\\n        # Try starting with parity 0, then with parity 1\\n        # Greedily pick the earliest possible next element of required parity\\n        alt0 = 0\\n        cur = 0\\n        for x in nums:\\n            if (x & 1) == cur:\\n                alt0 += 1\\n                cur ^= 1\\n        \\n        alt1 = 0\\n        cur = 1\\n        for x in nums:\\n            if (x & 1) == cur:\\n                alt1 += 1\\n                cur ^= 1\\n        \\n        return max(max_uniform, alt0, alt1)\\n\"",
  "289_14631217_python": "\"class Solution(object):\\n    def gameOfLife(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[int]]\\n        :rtype: None. Do not return anything, modify board in-place instead.\\n        \\\"\\\"\\\"\\n        m, n = len(board), len(board[0])\\n\\n        def countLiveNeighbors(r, c):\\n            directions = [(-1, -1), (-1, 0), (-1, 1),\\n                          ( 0, -1),          ( 0, 1),\\n                          ( 1, -1), ( 1, 0), ( 1, 1)]\\n            count = 0\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\\n                    count += 1\\n            return count\\n\\n        # First pass: encode changes\\n        for i in range(m):\\n            for j in range(n):\\n                live_neighbors = countLiveNeighbors(i, j)\\n\\n                if board[i][j] == 1:\\n                    if live_neighbors < 2 or live_neighbors > 3:\\n                        board[i][j] = 2  # Live → Dead\\n                elif board[i][j] == 0:\\n                    if live_neighbors == 3:\\n                        board[i][j] = 3  # Dead → Live\\n\\n        # Second pass: finalize new state\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 2:\\n                    board[i][j] = 0\\n                elif board[i][j] == 3:\\n                    board[i][j] = 1\\n\"",
  "685_14631217_python-updated-time": "1745785146903",
  "1007_14631217_python": "\"class Solution:\\n    def numsSameConsecDiff(self, n, k):\\n        res = []\\n\\n        def dfs(num, length):\\n            if length == n:\\n                res.append(num)\\n                return\\n            last_digit = num % 10\\n            next_digits = set()\\n            if last_digit + k < 10:\\n                next_digits.add(last_digit + k)\\n            if last_digit - k >= 0:\\n                next_digits.add(last_digit - k)\\n            for d in next_digits:\\n                dfs(num * 10 + d, length + 1)\\n\\n        for i in range(1, 10):  # no leading zero\\n            dfs(i, 1)\\n\\n        return res\\n\"",
  "1133_14631217_python": "\"class Solution(object):\\n    def lastSubstring(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        i, j, k = 0, 1, 0\\n        n = len(s)\\n        while j + k < n:\\n            if s[i + k] == s[j + k]:\\n                k += 1\\n            elif s[i + k] < s[j + k]:\\n                i = max(i + k + 1, j)\\n                j = i + 1\\n                k = 0\\n            else:\\n                j = j + k + 1\\n                k = 0\\n        return s[i:]\\n\"",
  "2332_14631217_python-updated-time": "1746880004183",
  "905_14631217_python": "\"class Solution(object):\\n    def lenLongestFibSubseq(self, arr):\\n        index = {x: i for i, x in enumerate(arr)}\\n        n = len(arr)\\n        dp = {}\\n        max_len = 0\\n\\n        for i in range(n):\\n            for j in range(i):\\n                k = index.get(arr[i] - arr[j], None)\\n                if k is not None and k < j:\\n                    dp[j, i] = dp.get((k, j), 2) + 1\\n                    max_len = max(max_len, dp[j, i])\\n\\n        return max_len if max_len >= 3 else 0\\n\"",
  "2093_14631217_python": "\"class Solution(object):\\n    def isPrefixString(self, s, words):\\n        prefix = \\\"\\\"\\n        for w in words:\\n            prefix += w\\n            if prefix == s:\\n                return True\\n            if not s.startswith(prefix):\\n                return False\\n        return False\\n\"",
  "2160_14631217_python-updated-time": "1746719691293",
  "406_14631217_python": "\"class Solution:\\n    def reconstructQueue(self, people):\\n        people.sort(key=lambda x: (-x[0], x[1]))\\n        queue = []\\n        for p in people:\\n            queue.insert(p[1], p)\\n        return queue\\n\"",
  "28_14631217_python-updated-time": "1744987878979",
  "3044_14631217_python": "\"class Solution:\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seen = set()\\n        ops = 0\\n        n = len(nums)\\n        for i in range(n-1, -1, -1):\\n            ops += 1\\n            x = nums[i]\\n            # only 1..k matter\\n            if 1 <= x <= k and x not in seen:\\n                seen.add(x)\\n                if len(seen) == k:\\n                    return ops\\n        # problem guarantees we can collect 1..k\\n        return ops\\n\"",
  "1370_14631217_python": "\"class Solution:\\n    def numberOfSubarrays(self, nums, k):\\n        from collections import defaultdict\\n\\n        count = defaultdict(int)\\n        count[0] = 1\\n        res = odd = 0\\n\\n        for num in nums:\\n            if num % 2 == 1:\\n                odd += 1\\n            res += count[odd - k]\\n            count[odd] += 1\\n\\n        return res\\n\"",
  "3455_14631217_python-updated-time": "1747487464759",
  "3193_14631217_python-updated-time": "1747310722260",
  "2573_14631217_python-updated-time": "1747057430643",
  "1444_14631217_python": "\"class Solution:\\n    def numberOfSteps(self, num):\\n        steps = 0\\n        while num:\\n            if num & 1:\\n                num -= 1\\n            else:\\n                num >>= 1\\n            steps += 1\\n        return steps\\n\"",
  "1896_14631217_python": "\"class Solution(object):\\n    def maximumScore(self, nums, multipliers):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type multipliers: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(nums), len(multipliers)\\n        memo = {}\\n\\n        def dp(i, left):\\n            if i == m:\\n                return 0\\n            if (i, left) in memo:\\n                return memo[(i, left)]\\n\\n            right = n - 1 - (i - left)\\n            pick_left = multipliers[i] * nums[left] + dp(i + 1, left + 1)\\n            pick_right = multipliers[i] * nums[right] + dp(i + 1, left)\\n            memo[(i, left)] = max(pick_left, pick_right)\\n            return memo[(i, left)]\\n\\n        return dp(0, 0)\\n\"",
  "421_14631217_python-updated-time": "1745358430480",
  "3307_14631217_python-updated-time": "1747420174284",
  "1625_14631217_mysql-updated-time": "1746432801871",
  "699_14631217_python": "\"class Solution(object):\\n    def fallingSquares(self, positions):\\n        ans = []\\n        intervals = []\\n        max_height = 0\\n        \\n        for left, size in positions:\\n            right = left + size\\n            height = size\\n            for l, r, h in intervals:\\n                if not (right <= l or left >= r):\\n                    height = max(height, h + size)\\n            intervals.append((left, right, height))\\n            max_height = max(max_height, height)\\n            ans.append(max_height)\\n        \\n        return ans\\n\"",
  "205_14631217_python": "\"class Solution(object):\\n    def isIsomorphic(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return self.transform(s) == self.transform(t)\\n    \\n    def transform(self, s):\\n        mapping = {}\\n        res = []\\n        count = 0\\n        for c in s:\\n            if c not in mapping:\\n                mapping[c] = count\\n                count += 1\\n            res.append(mapping[c])\\n        return res\\n\"",
  "1817_14631217_python-updated-time": "1746454076338",
  "974_14631217_python-updated-time": "1746004285894",
  "2679_14631217_python-updated-time": "1747061890857",
  "1407_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def groupThePeople(self, groupSizes):\\n        groups = defaultdict(list)\\n        result = []\\n\\n        for i, size in enumerate(groupSizes):\\n            groups[size].append(i)\\n            if len(groups[size]) == size:\\n                result.append(groups[size])\\n                groups[size] = []\\n\\n        return result\\n\"",
  "1460_14631217_python-updated-time": "1746345239147",
  "851_14631217_python": "\"class Solution(object):\\n    def toGoatLatin(self, sentence):\\n        vowels = set('aeiouAEIOU')\\n        words = sentence.split()\\n        res = []\\n        \\n        for i, word in enumerate(words):\\n            if word[0] in vowels:\\n                res.append(word + 'ma' + 'a' * (i + 1))\\n            else:\\n                res.append(word[1:] + word[0] + 'ma' + 'a' * (i + 1))\\n        \\n        return ' '.join(res)\\n\"",
  "1121_14631217_python": "\"class Solution:\\n    def maxSumAfterPartitioning(self, arr, k):\\n        n = len(arr)\\n        dp = [0] * (n + 1)          # dp[i] = max sum for first i elements\\n        for i in range(1, n + 1):\\n            cur_max = 0\\n            for l in range(1, min(k, i) + 1):   # partition length l ending at i-1\\n                cur_max = max(cur_max, arr[i - l])\\n                dp[i] = max(dp[i], dp[i - l] + cur_max * l)\\n        return dp[n]\\n\"",
  "210_14631217_python-updated-time": "1745246046944",
  "153_14631217_python-updated-time": "1745090880883",
  "2682_14631217_python": "\"class Solution(object):\\n    def countQuadruplets(self, nums):\\n        n = len(nums)\\n        bit = [0] * (n + 1)\\n\\n        def add(i, v):\\n            while i <= n:\\n                bit[i] += v\\n                i += i & -i\\n\\n        def query(i):\\n            s = 0\\n            while i:\\n                s += bit[i]\\n                i -= i & -i\\n            return s\\n\\n        ans = 0\\n        for j in xrange(1, n - 2):\\n            add(nums[j - 1], 1)\\n            greater = 0\\n            for k in xrange(n - 1, j, -1):\\n                if nums[k] > nums[j]:\\n                    greater += 1\\n                elif nums[k] < nums[j]:\\n                    ans += query(nums[k] - 1) * greater\\n        return ans\\n\"",
  "2480_14631217_python": "\"class Solution(object):\\n    def findSubarrays(self, nums):\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            s = nums[i] + nums[i + 1]\\n            if s in seen:\\n                return True\\n            seen.add(s)\\n        return False\\n\"",
  "3681_14631217_python": "\"from itertools import combinations\\n\\nclass Solution(object):\\n    def maxRectangleArea(self, points):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        pts = set((x, y) for x, y in points)\\n        n = len(points)\\n        best = 0\\n        \\n        # For each choice of 4 distinct points:\\n        for quad in combinations(points, 4):\\n            xs = sorted(p[0] for p in quad)\\n            ys = sorted(p[1] for p in quad)\\n            minx, maxx = xs[0], xs[-1]\\n            miny, maxy = ys[0], ys[-1]\\n            # Area must be positive\\n            if minx == maxx or miny == maxy:\\n                continue\\n            \\n            # Required corners\\n            corners = {\\n                (minx, miny),\\n                (minx, maxy),\\n                (maxx, miny),\\n                (maxx, maxy),\\n            }\\n            if set(map(tuple, quad)) != corners:\\n                continue\\n            \\n            # Check no other point lies inside or on the border\\n            ok = True\\n            for x, y in pts - corners:\\n                if minx <= x <= maxx and miny <= y <= maxy:\\n                    ok = False\\n                    break\\n            if not ok:\\n                continue\\n            \\n            # Valid rectangle\\n            area = (maxx - minx) * (maxy - miny)\\n            best = max(best, area)\\n        \\n        return best if best > 0 else -1\\n\"",
  "2834_14631217_python": "\"class Solution:\\n    def relocateMarbles(self, nums, moveFrom, moveTo):\\n        occupied = set(nums)\\n\\n        for frm, to in zip(moveFrom, moveTo):\\n            if frm in occupied:\\n                occupied.remove(frm)\\n                occupied.add(to)\\n\\n        return sorted(occupied)\\n\"",
  "2541_14631217_python-updated-time": "1746968074789",
  "1243_14631217_python": "\"class Solution:\\n    def sumEvenGrandparent(self, root):\\n        stack = [(root, None, None)]\\n        total = 0\\n        while stack:\\n            node, parent, grand = stack.pop()\\n            if not node:\\n                continue\\n            if grand and grand.val % 2 == 0:\\n                total += node.val\\n            stack.append((node.left, node, parent))\\n            stack.append((node.right, node, parent))\\n        return total\\n\"",
  "2574_14631217_python-updated-time": "1747057559825",
  "783_14631217_python-updated-time": "1745786174503",
  "605_14631217_python": "\"class Solution(object):\\n    def canPlaceFlowers(self, flowerbed, n):\\n        \\\"\\\"\\\"\\n        :type flowerbed: List[int]\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        length = len(flowerbed)\\n        for i in range(length):\\n            if n == 0:\\n                return True\\n            if flowerbed[i] == 0:\\n                empty_left = (i == 0) or (flowerbed[i-1] == 0)\\n                empty_right = (i == length - 1) or (flowerbed[i+1] == 0)\\n                if empty_left and empty_right:\\n                    flowerbed[i] = 1\\n                    n -= 1\\n        return n == 0\\n\"",
  "2099_14631217_python": "\"class Solution(object):\\n    def numOfStrings(self, patterns, word):\\n        count = 0\\n        for p in patterns:\\n            if p in word:\\n                count += 1\\n        return count\\n\"",
  "526_14631217_python-updated-time": "1745446663382",
  "853_14631217_python-updated-time": "1745879203887",
  "696_14631217_python": "\"class Solution(object):\\n    def countBinarySubstrings(self, s):\\n        prev = 0\\n        curr = 1\\n        count = 0\\n        \\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                curr += 1\\n            else:\\n                count += min(prev, curr)\\n                prev = curr\\n                curr = 1\\n        \\n        count += min(prev, curr)\\n        return count\\n\"",
  "661_14631217_python-updated-time": "1745782996038",
  "1664_14631217_postgresql": "\"-- Write your PostgreSQL query statement below\\nSELECT user_id, name, mail\\nFROM Users\\nWHERE \\n    -- Must match the domain exactly\\n    mail LIKE '%@leetcode.com' \\n    -- Must start with a letter and allowed characters before the @\\n    AND mail REGEXP '^[a-zA-Z][a-zA-Z0-9._-]*@leetcode\\\\.com$';\\n\"",
  "3763_14631217_python-updated-time": "1747680067548",
  "1208_14631217_python-updated-time": "1746108820597",
  "906_14631217_python": "\"class Solution(object):\\n    def robotSim(self, commands, obstacles):\\n        direction = [(0,1), (1,0), (0,-1), (-1,0)]  # North, East, South, West\\n        dir_idx = 0\\n        x = y = 0\\n        max_dist = 0\\n        obstacle_set = set(map(tuple, obstacles))\\n\\n        for cmd in commands:\\n            if cmd == -2:\\n                dir_idx = (dir_idx - 1) % 4\\n            elif cmd == -1:\\n                dir_idx = (dir_idx + 1) % 4\\n            else:\\n                dx, dy = direction[dir_idx]\\n                for _ in range(cmd):\\n                    if (x + dx, y + dy) in obstacle_set:\\n                        break\\n                    x += dx\\n                    y += dy\\n                    max_dist = max(max_dist, x*x + y*y)\\n\\n        return max_dist\\n\"",
  "2001_14631217_python-updated-time": "1746625916273",
  "1244_14631217_python": "\"class Solution:\\n    def distinctEchoSubstrings(self, text):\\n        n = len(text)\\n        # 64-bit mask\\n        mask = (1 << 64) - 1\\n        base = 1315423911\\n\\n        # Precompute prefix hashes and powers\\n        h = [0] * (n + 1)\\n        p = [1] * (n + 1)\\n        for i, ch in enumerate(text):\\n            h[i+1] = ((h[i] * base) + (ord(ch))) & mask\\n            p[i+1] = (p[i] * base) & mask\\n\\n        def get_hash(i, j):\\n            # hash of text[i:j]\\n            return (h[j] - (h[i] * p[j - i] & mask)) & mask\\n\\n        seen = set()\\n        # iterate possible half-lengths\\n        for l in range(1, n // 2 + 1):\\n            # for each start of substring of length 2*l\\n            for i in range(0, n - 2*l + 1):\\n                if get_hash(i, i + l) == get_hash(i + l, i + 2*l):\\n                    seen.add(get_hash(i, i + 2*l))\\n        return len(seen)\\n\"",
  "2267_14631217_python-updated-time": "1746803008507",
  "1523_14631217_mysql": "\"WITH OrderedOps AS (\\n    SELECT *,\\n           ROW_NUMBER() OVER (PARTITION BY stock_name, operation ORDER BY operation_day) AS rn\\n    FROM Stocks\\n),\\nBuyOps AS (\\n    SELECT stock_name, operation_day AS buy_day, price AS buy_price, rn\\n    FROM OrderedOps\\n    WHERE operation = 'Buy'\\n),\\nSellOps AS (\\n    SELECT stock_name, operation_day AS sell_day, price AS sell_price, rn\\n    FROM OrderedOps\\n    WHERE operation = 'Sell'\\n)\\nSELECT b.stock_name,\\n       SUM(s.sell_price - b.buy_price) AS capital_gain_loss\\nFROM BuyOps b\\nJOIN SellOps s\\n  ON b.stock_name = s.stock_name AND b.rn = s.rn\\nGROUP BY b.stock_name;\\n\"",
  "1113_14631217_python-updated-time": "1746042677190",
  "215_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def findKthLargest(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return heapq.nlargest(k, nums)[-1]\\n\"",
  "75_14631217_python-updated-time": "1745015147903",
  "2709_14631217_python-updated-time": "1747065937849",
  "3527_14631217_python-updated-time": "1747501148247",
  "1692_14631217_python-updated-time": "1746438124542",
  "1705_14631217_python": "\"class Solution:\\n    def unhappyFriends(self, n, preferences, pairs):\\n        # partner[i] = the friend paired with i\\n        partner = [0] * n\\n        for x, y in pairs:\\n            partner[x] = y\\n            partner[y] = x\\n\\n        # rank[i][j] = how much i prefers j (lower is better)\\n        rank = [[0]*n for _ in range(n)]\\n        for i, prefs in enumerate(preferences):\\n            for idx, friend in enumerate(prefs):\\n                rank[i][friend] = idx\\n\\n        unhappy = 0\\n        # check each friend x\\n        for x in range(n):\\n            y = partner[x]\\n            # go through all u that x prefers over y\\n            for u in preferences[x]:\\n                if u == y:\\n                    break\\n                v = partner[u]\\n                # if u prefers x over their partner v, x is unhappy\\n                if rank[u][x] < rank[u][v]:\\n                    unhappy += 1\\n                    break\\n\\n        return unhappy\\n\"",
  "950_14631217_python": "\"from collections import Counter\\nfrom functools import reduce\\n\\nclass Solution:\\n    def hasGroupsSizeX(self, deck):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        count = Counter(deck).values()\\n        g = reduce(gcd, count)\\n        return g >= 2\\n\"",
  "3522_14631217_python-updated-time": "1747501420709",
  "1011_14631217_python": "\"class Solution:\\n    def flipMatchVoyage(self, root, voyage):\\n        self.i = 0\\n        self.res = []\\n\\n        def dfs(node):\\n            if not node:\\n                return True\\n            if node.val != voyage[self.i]:\\n                return False\\n            self.i += 1\\n            if node.left and node.left.val != voyage[self.i]:\\n                # Flip needed\\n                self.res.append(node.val)\\n                return dfs(node.right) and dfs(node.left)\\n            return dfs(node.left) and dfs(node.right)\\n\\n        return self.res if dfs(root) else [-1]\\n\"",
  "2553_14631217_python-updated-time": "1746968975180",
  "91_14631217_python-updated-time": "1745015651625",
  "1539_14631217_python-updated-time": "1746347078556",
  "712_14631217_python-updated-time": "1745786526527",
  "2711_14631217_python-updated-time": "1747066190278",
  "3390_14631217_python": "\"class Solution(object):\\n    def minRectanglesToCoverPoints(self, points, w):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :type w: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # extract and sort x-coordinates\\n        xs = sorted(x for x, _ in points)\\n        n = len(xs)\\n        ans = 0\\n        i = 0\\n        \\n        while i < n:\\n            # place one rectangle covering [xs[i], xs[i] + w]\\n            start = xs[i]\\n            limit = start + w\\n            ans += 1\\n            # skip all points covered by this interval\\n            while i < n and xs[i] <= limit:\\n                i += 1\\n        \\n        return ans\\n\"",
  "2267_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        n = len(nums) // 3\\n        \\n        # Prefix: max heap to track smallest n elements from the left\\n        left_heap = []\\n        left_sum = 0\\n        prefix = [0] * (2 * n + 1)\\n        \\n        for i in range(2 * n):\\n            heapq.heappush(left_heap, -nums[i])\\n            left_sum += nums[i]\\n            if len(left_heap) > n:\\n                left_sum += heapq.heappop(left_heap)  # Remove largest (smallest negative)\\n            if len(left_heap) == n:\\n                prefix[i + 1] = left_sum\\n        \\n        # Suffix: min heap to track largest n elements from the right\\n        right_heap = []\\n        right_sum = 0\\n        suffix = [0] * (2 * n + 1)\\n        \\n        for i in range(3 * n - 1, n - 1, -1):\\n            heapq.heappush(right_heap, nums[i])\\n            right_sum += nums[i]\\n            if len(right_heap) > n:\\n                right_sum -= heapq.heappop(right_heap)\\n            if len(right_heap) == n:\\n                suffix[i] = right_sum\\n        \\n        # Find minimum difference\\n        res = float('inf')\\n        for i in range(n, 2 * n + 1):\\n            res = min(res, prefix[i] - suffix[i])\\n        \\n        return res\\n\"",
  "3303_14631217_python": "\"class Solution(object):\\n    def beautifulIndices(self, s, a, b, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type a: str\\n        :type b: str\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def kmp_search(text, pat):\\n            \\\"\\\"\\\"Return list of all start‐indices where pat occurs in text.\\\"\\\"\\\"\\n            n, m = len(text), len(pat)\\n            # Build LPS array for pat\\n            lps = [0]*m\\n            length = 0\\n            i = 1\\n            while i < m:\\n                if pat[i] == pat[length]:\\n                    length += 1\\n                    lps[i] = length\\n                    i += 1\\n                else:\\n                    if length:\\n                        length = lps[length-1]\\n                    else:\\n                        lps[i] = 0\\n                        i += 1\\n            # KMP scan\\n            res = []\\n            i = j = 0\\n            while i < n:\\n                if text[i] == pat[j]:\\n                    i += 1\\n                    j += 1\\n                    if j == m:\\n                        res.append(i-j)\\n                        j = lps[j-1]\\n                else:\\n                    if j:\\n                        j = lps[j-1]\\n                    else:\\n                        i += 1\\n            return res\\n\\n        # 1) Find all start indices of 'a' and 'b' in s\\n        posA = kmp_search(s, a)\\n        posB = kmp_search(s, b)\\n\\n        # If b never occurs, no i can be beautiful\\n        if not posB:\\n            return []\\n\\n        # 2) Two‐pointer sweep to check for each i in posA\\n        #    whether there’s some j in posB with |j-i| <= k.\\n        res = []\\n        j = 0\\n        m = len(posB)\\n        for i in posA:\\n            # advance j until posB[j] >= i-k\\n            while j < m and posB[j] < i - k:\\n                j += 1\\n            # now posB[j] is the first candidate ≥ i-k\\n            if j < m and posB[j] <= i + k:\\n                res.append(i)\\n\\n        return res\\n\"",
  "2475_14631217_python-updated-time": "1746965098654",
  "1042_14631217_python": "\"class Solution:\\n    def mergeStones(self, stones, k):\\n        n = len(stones)\\n        if (n - 1) % (k - 1):  # not mergeable into one pile\\n            return -1\\n\\n        prefix = [0] * (n + 1)\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + stones[i]\\n\\n        dp = [[0] * n for _ in range(n)]\\n\\n        for length in range(k, n + 1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                dp[i][j] = float('inf')\\n                for mid in range(i, j, k - 1):\\n                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j])\\n                if (length - 1) % (k - 1) == 0:\\n                    dp[i][j] += prefix[j + 1] - prefix[i]\\n\\n        return dp[0][n - 1]\\n\"",
  "2112_14631217_python-updated-time": "1746716899691",
  "410_14631217_python-updated-time": "1745356132497",
  "2677_14631217_python-updated-time": "1747135938776",
  "671_14631217_python-updated-time": "1745783280640",
  "2510_14631217_python-updated-time": "1746967238277",
  "3813_14631217_python-updated-time": "1747744756632",
  "2824_14631217_python": "\"class Solution(object):\\n    def isFascinating(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        concatenated = str(n) + str(n * 2) + str(n * 3)\\n        if '0' in concatenated or len(concatenated) != 9:\\n            return False\\n        return sorted(concatenated) == list('123456789')\\n\"",
  "3685_14631217_python": "\"class Solution(object):\\n    def countSubarrays(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        for i in range(len(nums) - 2):\\n            a, b, c = nums[i], nums[i+1], nums[i+2]\\n            if a + c == b / 2.0:\\n                count += 1\\n        return count\\n\"",
  "3331_14631217_python-updated-time": "1747420009089",
  "1389_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minPushBox(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n\\n        # Find initial positions of box, target and player\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 'S':\\n                    sx, sy = i, j\\n                elif grid[i][j] == 'B':\\n                    bx, by = i, j\\n                elif grid[i][j] == 'T':\\n                    tx, ty = i, j\\n\\n        # Check if player can reach (px, py) from (sx, sy) without crossing box\\n        def can_reach(sx, sy, px, py, bx, by):\\n            visited = [[False]*n for _ in range(m)]\\n            queue = deque([(sx, sy)])\\n            visited[sx][sy] = True\\n            while queue:\\n                x, y = queue.popleft()\\n                if x == px and y == py:\\n                    return True\\n                for dx, dy in directions:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != '#' and (nx, ny) != (bx, by):\\n                        visited[nx][ny] = True\\n                        queue.append((nx, ny))\\n            return False\\n\\n        # BFS on box pushes\\n        visited = set()\\n        queue = deque()\\n        queue.append((bx, by, sx, sy, 0))  # box_x, box_y, player_x, player_y, pushes\\n        visited.add((bx, by, sx, sy))\\n\\n        while queue:\\n            bx, by, px, py, pushes = queue.popleft()\\n            if (bx, by) == (tx, ty):\\n                return pushes\\n            for dx, dy in directions:\\n                nbx, nby = bx + dx, by + dy  # new box position\\n                ppx, ppy = bx - dx, by - dy  # required player position to push\\n                if 0 <= nbx < m and 0 <= nby < n and 0 <= ppx < m and 0 <= ppy < n:\\n                    if grid[nbx][nby] == '#' or grid[ppx][ppy] == '#':\\n                        continue\\n                    if not can_reach(px, py, ppx, ppy, bx, by):\\n                        continue\\n                    if (nbx, nby, bx, by) in visited:\\n                        continue\\n                    visited.add((nbx, nby, bx, by))\\n                    queue.append((nbx, nby, bx, by, pushes + 1))\\n\\n        return -1\\n\"",
  "581_14631217_python": "\"class Solution(object):\\n    def findUnsortedSubarray(self, nums):\\n        n = len(nums)\\n        left, right = n, 0\\n        max_seen = float('-inf')\\n        for i in range(n):\\n            if nums[i] < max_seen:\\n                right = i\\n            else:\\n                max_seen = nums[i]\\n        min_seen = float('inf')\\n        for i in range(n-1, -1, -1):\\n            if nums[i] > min_seen:\\n                left = i\\n            else:\\n                min_seen = nums[i]\\n        return right - left + 1 if right > left else 0\\n\"",
  "455_14631217_python-updated-time": "1745359369302",
  "1262_14631217_python-updated-time": "1746126045274",
  "2200_14631217_python-updated-time": "1746801989904",
  "2095_14631217_python": "\"class Solution(object):\\n    def minSwaps(self, s):\\n        balance = 0\\n        max_unbalanced = 0\\n        for c in s:\\n            if c == '[':\\n                balance += 1\\n            else:  # c == ']'\\n                balance -= 1\\n                if balance < 0:\\n                    # one more ']' than '[' → unbalanced\\n                    max_unbalanced = max(max_unbalanced, -balance)\\n        # Each swap fixes two unbalanced brackets\\n        return (max_unbalanced + 1) // 2\\n\"",
  "25_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def reverseKGroup(self, head, k):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :type k: int\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        def get_kth(curr, k):\\n            while curr and k > 0:\\n                curr = curr.next\\n                k -= 1\\n            return curr\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        group_prev = dummy\\n\\n        while True:\\n            kth = get_kth(group_prev, k)\\n            if not kth:\\n                break\\n            group_next = kth.next\\n\\n            prev, curr = kth.next, group_prev.next\\n            while curr != group_next:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            tmp = group_prev.next\\n            group_prev.next = kth\\n            group_prev = tmp\\n\\n        return dummy.next\\n\"",
  "1970_14631217_python": "\"class Solution:\\n    def sortSentence(self, s):\\n        words = s.split()\\n        res = [\\\"\\\"] * len(words)\\n        for w in words:\\n            idx = int(w[-1]) - 1\\n            res[idx] = w[:-1]\\n        return \\\" \\\".join(res)\\n\"",
  "1934_14631217_python-updated-time": "1746543513229",
  "3491_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # dp[i][r]: best length ending at i with adjacent‐sum mod == r\\n        dp = [[0]*k for _ in range(n)]\\n        ans = 1\\n        \\n        for i in range(n):\\n            dpi = dp[i]\\n            for j in range(i):\\n                r = (nums[j] + nums[i]) % k\\n                # either start new pair (length=2) or extend dp[j][r]\\n                val = dp[j][r] + 1 if dp[j][r] else 2\\n                if val > dpi[r]:\\n                    dpi[r] = val\\n                if val > ans:\\n                    ans = val\\n        \\n        return ans\\n\"",
  "2760_14631217_javascript-updated-time": "1747135282014",
  "3789_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxSubarrays(self, n, conflictingPairs):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type conflictingPairs: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        P = len(conflictingPairs)\\n        # For each pair, store (l, r-1) and an ID\\n        by_l = [[] for _ in range(n+2)]\\n        for pid, (a, b) in enumerate(conflictingPairs):\\n            l, r = min(a, b), max(a, b)\\n            by_l[l].append((r-1, pid))\\n\\n        heap = []  # will store (r-1, pid)\\n        baseline = 0\\n        # For each pair ID, track total delta when removed\\n        delta = [0]*P\\n\\n        # Process i = n down to 1\\n        for i in range(n, 0, -1):\\n            # add all pairs whose l == i\\n            for item in by_l[i]:\\n                heapq.heappush(heap, item)\\n\\n            # find best1 and best2 among current heap\\n            if not heap:\\n                best1 = best2 = n\\n                pid1 = -1\\n            else:\\n                # pop smallest\\n                r1, pid1 = heapq.heappop(heap)\\n                best1 = r1\\n                if heap:\\n                    best2 = heap[0][0]\\n                else:\\n                    best2 = n\\n                # push back\\n                heapq.heappush(heap, (r1, pid1))\\n\\n            # limit for subarrays starting at i is up to min(best1, n)\\n            end = min(best1, n)\\n            if end >= i:\\n                baseline += (end - i + 1)\\n\\n            # if this best1 came from a real pair, record its effect\\n            if pid1 >= 0:\\n                # removing that pair would raise limit from best1 to best2\\n                # so #subarrays from i rises by (best2 - best1)\\n                delta[pid1] += (best2 - best1)\\n\\n        # The best we can do is remove the pair with max delta\\n        best_extra = max(0, max(delta))\\n        return baseline + best_extra\\n\"",
  "528_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def swapNodes(self, head, k):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        # 1) Find the k-th node from the beginning\\n        front = head\\n        for _ in range(k - 1):\\n            front = front.next\\n        \\n        # 2) Use two-pointer technique to find k-th from the end\\n        back = head\\n        runner = front\\n        while runner.next:\\n            runner = runner.next\\n            back = back.next\\n        \\n        # 3) Swap their values\\n        front.val, back.val = back.val, front.val\\n        \\n        return head\\n\"",
  "147_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0)  # Dummy node for the new sorted list\\n        curr = head\\n\\n        while curr:\\n            prev = dummy\\n            # Find the position to insert the current node\\n            while prev.next and prev.next.val < curr.val:\\n                prev = prev.next\\n\\n            next_temp = curr.next  # Save next node to process\\n            # Insert current node between prev and prev.next\\n            curr.next = prev.next\\n            prev.next = curr\\n\\n            curr = next_temp  # Move to the next node to sort\\n\\n        return dummy.next\\n\"",
  "1541_14631217_mysql": "\"SELECT \\n    u.name,\\n    COALESCE(SUM(r.distance), 0) AS travelled_distance\\nFROM Users u\\nLEFT JOIN Rides r ON u.id = r.user_id\\nGROUP BY u.id, u.name\\nORDER BY travelled_distance DESC, u.name ASC;\\n\"",
  "64_14631217_python": "\"class Solution(object):\\n    def minPathSum(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n\\n        return grid[m-1][n-1]\\n\"",
  "9_14631217_python": "\"class Solution(object):\\n    def isPalindrome(self, x):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if x < 0 or (x % 10 == 0 and x != 0):\\n            return False\\n\\n        rev = 0\\n        while x > rev:\\n            rev = rev * 10 + x % 10\\n            x //= 10\\n\\n        return x == rev or x == rev // 10\\n\"",
  "1844_14631217_python-updated-time": "1746531212938",
  "175_14631217_mysql-updated-time": "1745092221985",
  "1130_14631217_python-updated-time": "1746043037334",
  "2066_14631217_python-updated-time": "1746638320853",
  "1218_14631217_python-updated-time": "1746109058426",
  "3502_14631217_python": "\"class Solution(object):\\n    def numberOfSubstrings(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        total_bad = 0\\n        base = ord('a')\\n        \\n        # For each start i, find the longest prefix length l_i\\n        # so that no character in s[i:i+l_i] reaches k occurrences.\\n        # Then all substrings of length 1..l_i starting at i are \\\"bad\\\"\\n        # (i.e. have max freq < k).\\n        for i in range(n):\\n            cnt = [0]*26\\n            # default: if we never hit k, we can go all the way to the end\\n            l_i = n - i\\n            for j in range(i, n):\\n                idx = ord(s[j]) - base\\n                cnt[idx] += 1\\n                if cnt[idx] == k:\\n                    # the substring s[i:j+1] just became \\\"good\\\",\\n                    # so the longest all-\\\"bad\\\" prefix ends at j-1\\n                    l_i = j - i\\n                    break\\n            total_bad += l_i\\n\\n        # total substrings = n*(n+1)//2\\n        total_subs = n*(n+1)//2\\n        # answer = those with at least one char >= k = total_subs - total_bad\\n        return total_subs - total_bad\\n\"",
  "2792_14631217_python-updated-time": "1747138558433",
  "1890_14631217_python-updated-time": "1746532342120",
  "833_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def numBusesToDestination(self, routes, source, target):\\n        if source == target:\\n            return 0\\n        \\n        stop_to_buses = collections.defaultdict(set)\\n        for i, route in enumerate(routes):\\n            for stop in route:\\n                stop_to_buses[stop].add(i)\\n        \\n        queue = collections.deque()\\n        visited_buses = set()\\n        visited_stops = set()\\n        queue.append((source, 0))\\n        \\n        while queue:\\n            stop, buses = queue.popleft()\\n            for bus in stop_to_buses[stop]:\\n                if bus in visited_buses:\\n                    continue\\n                visited_buses.add(bus)\\n                for next_stop in routes[bus]:\\n                    if next_stop == target:\\n                        return buses + 1\\n                    if next_stop not in visited_stops:\\n                        visited_stops.add(next_stop)\\n                        queue.append((next_stop, buses + 1))\\n        return -1\\n\"",
  "1227_14631217_python": "\"class Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \\\"\\\"\\\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        count = defaultdict(int)\\n        res = 0\\n\\n        for a, b in dominoes:\\n            key = tuple(sorted((a, b)))\\n            res += count[key]\\n            count[key] += 1\\n\\n        return res\\n\"",
  "2348_14631217_python-updated-time": "1746880824373",
  "990_14631217_python-updated-time": "1746038605752",
  "2858_14631217_javascript": "\"function join(arr1, arr2) {\\n  const map = new Map();\\n\\n  // First, add all from arr1\\n  for (const obj of arr1) {\\n    map.set(obj.id, { ...obj });\\n  }\\n\\n  // Then merge/override with arr2\\n  for (const obj of arr2) {\\n    if (map.has(obj.id)) {\\n      map.set(obj.id, { ...map.get(obj.id), ...obj });\\n    } else {\\n      map.set(obj.id, { ...obj });\\n    }\\n  }\\n\\n  // Collect and sort by id\\n  return Array.from(map.values()).sort((a, b) => a.id - b.id);\\n}\\n\"",
  "669_14631217_python-updated-time": "1745783239752",
  "928_14631217_lang-updated-time": "1744902601547",
  "2920_14631217_python": "\"class Solution(object):\\n    def minimumSeconds(self, nums):\\n        from collections import defaultdict\\n\\n        n = len(nums)\\n        pos = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            pos[v].append(i)\\n\\n        best = float('inf')\\n        for indices in pos.values():\\n            indices.sort()\\n            max_gap = 0\\n            k = len(indices)\\n            for i in range(k):\\n                j = (i + 1) % k\\n                # number of untouched slots between indices[i] and indices[j]\\n                gap = (indices[j] - indices[i] - 1) % n\\n                max_gap = max(max_gap, gap)\\n            # each second the two ends of a gap move inward by 1 total,\\n            # so it takes ceil(gap/2) = (gap+1)//2 seconds to fill\\n            best = min(best, (max_gap + 1) // 2)\\n\\n        return best\\n\"",
  "222_14631217_python-updated-time": "1745246747073",
  "3069_14631217_pythondata": "\"import pandas as pd\\n\\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame students with a float 'grade' column,\\n    converts 'grade' to integer type and returns the DataFrame.\\n    \\\"\\\"\\\"\\n    students['grade'] = students['grade'].astype(int)\\n    return students\\n\"",
  "2845_14631217_python": "\"class Solution:\\n    def findValueOfPartition(self, nums):\\n        nums.sort()\\n        ans = float('inf')\\n        for i in range(len(nums) - 1):\\n            diff = nums[i+1] - nums[i]\\n            if diff < ans:\\n                ans = diff\\n        return ans\\n\"",
  "103_14631217_python-updated-time": "1745081037116",
  "462_14631217_python-updated-time": "1745359610741",
  "837_14631217_python-updated-time": "1745878822845",
  "190_14631217_python-updated-time": "1745092741891",
  "2601_14631217_python-updated-time": "1747060008652",
  "1978_14631217_python": "\"class Solution(object):\\n    def getMinSwaps(self, num, k):\\n        # compute the k-th next permutation (the k-th smallest wonderful integer)\\n        t = list(num)\\n        for _ in range(k):\\n            # next_permutation on t\\n            i = len(t) - 2\\n            while i >= 0 and t[i] >= t[i+1]:\\n                i -= 1\\n            # swap pivot with next larger element\\n            j = len(t) - 1\\n            while j > i and t[j] <= t[i]:\\n                j -= 1\\n            t[i], t[j] = t[j], t[i]\\n            # reverse suffix\\n            t[i+1:] = reversed(t[i+1:])\\n        # count adjacent swaps to turn num into that target\\n        s_list = list(num)\\n        ans = 0\\n        n = len(s_list)\\n        for i in range(n):\\n            if s_list[i] == t[i]:\\n                continue\\n            # find the target digit in s_list\\n            j = i + 1\\n            while s_list[j] != t[i]:\\n                j += 1\\n            # bring it to position i by swapping adjacent digits\\n            while j > i:\\n                s_list[j], s_list[j-1] = s_list[j-1], s_list[j]\\n                ans += 1\\n                j -= 1\\n        return ans\\n\"",
  "1784_14631217_python-updated-time": "1746445778390",
  "3431_14631217_python-updated-time": "1747482742552",
  "1298_14631217_python": "\"class Solution(object):\\n    def reverseParentheses(self, s):\\n        stack = []\\n        for c in s:\\n            if c == ')':\\n                temp = []\\n                while stack[-1] != '(':\\n                    temp.append(stack.pop())\\n                stack.pop()  # remove '('\\n                stack.extend(temp)\\n            else:\\n                stack.append(c)\\n        return ''.join(stack)\\n\"",
  "1415_14631217_mysql": "\"SELECT \\n    s.student_id,\\n    s.student_name,\\n    sub.subject_name,\\n    COUNT(e.subject_name) AS attended_exams\\nFROM Students s\\nCROSS JOIN Subjects sub\\nLEFT JOIN Examinations e\\n    ON s.student_id = e.student_id AND sub.subject_name = e.subject_name\\nGROUP BY s.student_id, s.student_name, sub.subject_name\\nORDER BY s.student_id, sub.subject_name;\\n\"",
  "1260_14631217_python": "\"class Solution(object):\\n    def dayOfYear(self, date):\\n        \\\"\\\"\\\"\\n        :type date: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        year, month, day = map(int, date.split('-'))\\n        days_in_month = [31, 28 + self.is_leap(year), 31, 30, 31, 30, \\n                         31, 31, 30, 31, 30, 31]\\n        return sum(days_in_month[:month - 1]) + day\\n\\n    def is_leap(self, year):\\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\\n\"",
  "1706_14631217_python": "\"class Solution(object):\\n    def minCostConnectPoints(self, points):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(points)\\n        if n <= 1:\\n            return 0\\n        \\n        # Prim's algorithm in O(n^2) without explicitly building all edges\\n        in_mst = [False] * n\\n        # min_cost[i] = minimum cost to connect point i to the current MST\\n        min_cost = [float('inf')] * n\\n        min_cost[0] = 0  # start from point 0\\n        \\n        total_cost = 0\\n        \\n        for _ in range(n):\\n            # pick the next point u not in MST with smallest connection cost\\n            u = -1\\n            cheapest = float('inf')\\n            for i in range(n):\\n                if not in_mst[i] and min_cost[i] < cheapest:\\n                    cheapest = min_cost[i]\\n                    u = i\\n            \\n            # add u to MST\\n            in_mst[u] = True\\n            total_cost += cheapest\\n            \\n            # update the connection costs using u\\n            ux, uy = points[u]\\n            for v in range(n):\\n                if not in_mst[v]:\\n                    vx, vy = points[v]\\n                    cost = abs(ux - vx) + abs(uy - vy)\\n                    if cost < min_cost[v]:\\n                        min_cost[v] = cost\\n        \\n        return total_cost\\n\"",
  "2804_14631217_javascript": "\"function compactObject(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj\\n      .map(compactObject)\\n      .filter(Boolean);\\n  }\\n\\n  if (obj !== null && typeof obj === 'object') {\\n    const result = {};\\n    for (const [key, value] of Object.entries(obj)) {\\n      const compacted = compactObject(value);\\n      if (Boolean(compacted)) {\\n        result[key] = compacted;\\n      }\\n    }\\n    return result;\\n  }\\n\\n  return obj;\\n}\\n\"",
  "3184_14631217_python-updated-time": "1747309944136",
  "506_14631217_python": "\"class Solution:\\n    def findRelativeRanks(self, score):\\n        sorted_score = sorted(enumerate(score), key=lambda x: -x[1])\\n        res = [\\\"\\\"] * len(score)\\n        for i, (idx, _) in enumerate(sorted_score):\\n            if i == 0:\\n                res[idx] = \\\"Gold Medal\\\"\\n            elif i == 1:\\n                res[idx] = \\\"Silver Medal\\\"\\n            elif i == 2:\\n                res[idx] = \\\"Bronze Medal\\\"\\n            else:\\n                res[idx] = str(i + 1)\\n        return res\\n\"",
  "136_14631217_python-updated-time": "1745086787230",
  "3546_14631217_python-updated-time": "1747502336186",
  "2389_14631217_python": "\"class TextEditor:\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text):\\n        for ch in text:\\n            self.left.append(ch)\\n\\n    def deleteText(self, k):\\n        removed = min(k, len(self.left))\\n        for _ in range(removed):\\n            self.left.pop()\\n        return removed\\n\\n    def cursorLeft(self, k):\\n        move = min(k, len(self.left))\\n        for _ in range(move):\\n            self.right.append(self.left.pop())\\n        return ''.join(self.left[-10:])\\n\\n    def cursorRight(self, k):\\n        move = min(k, len(self.right))\\n        for _ in range(move):\\n            self.left.append(self.right.pop())\\n        return ''.join(self.left[-10:])\\n\"",
  "2610_14631217_python": "\"class Solution:\\n    def closestPrimes(self, left, right):\\n        # Sieve of Eratosthenes up to 'right'\\n        n = right\\n        is_prime = [True] * (n + 1)\\n        is_prime[0:2] = [False, False]\\n        p = 2\\n        while p * p <= n:\\n            if is_prime[p]:\\n                for multiple in range(p * p, n + 1, p):\\n                    is_prime[multiple] = False\\n            p += 1\\n\\n        last = -1\\n        best_diff = float('inf')\\n        ans = [-1, -1]\\n\\n        # Iterate through the range, track the closest pair\\n        for num in range(max(left, 2), right + 1):\\n            if is_prime[num]:\\n                if last != -1:\\n                    diff = num - last\\n                    if diff < best_diff:\\n                        best_diff = diff\\n                        ans = [last, num]\\n                        # Minimal possible diff is 1 for consecutive integers;\\n                        # primes differ by at least 2 except (2,3). We can break early\\n                        # if best_diff == 1 or (last == 2 and num == 3).\\n                        if best_diff <= 2:\\n                            break\\n                last = num\\n\\n        return ans\\n\"",
  "1303_14631217_python-updated-time": "1746802193892",
  "2181_14631217_python": "\"class Solution:\\n    def smallestEqual(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        for i, v in enumerate(nums):\\n            if i % 10 == v:\\n                return i\\n        return -1\"",
  "2512_14631217_python": "\"class LUPrefix:\\n    def __init__(self, n):\\n        # Track which videos have been uploaded\\n        self.uploaded = [False] * (n + 2)\\n        # Pointer to the smallest missing video in the prefix\\n        self.curr = 1\\n        self.n = n\\n\\n    def upload(self, video):\\n        # Mark this video as uploaded\\n        self.uploaded[video] = True\\n        # Advance curr while the next video is uploaded\\n        while self.curr <= self.n and self.uploaded[self.curr]:\\n            self.curr += 1\\n\\n    def longest(self):\\n        # All videos 1..curr-1 have been uploaded\\n        return self.curr - 1\\n\"",
  "799_14631217_python": "\"class Solution(object):\\n    def minDiffInBST(self, root):\\n        self.prev = None\\n        self.min_diff = float('inf')\\n        \\n        def inorder(node):\\n            if not node:\\n                return\\n            inorder(node.left)\\n            if self.prev is not None:\\n                self.min_diff = min(self.min_diff, node.val - self.prev)\\n            self.prev = node.val\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return self.min_diff\\n\"",
  "29_14631217_python": "\"class Solution(object):\\n    def divide(self, dividend, divisor):\\n        \\\"\\\"\\\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        INT_MAX = 2**31 - 1\\n        INT_MIN = -2**31\\n\\n        if dividend == INT_MIN and divisor == -1:\\n            return INT_MAX\\n\\n        negatives = 2\\n        if dividend > 0:\\n            dividend = -dividend\\n            negatives -= 1\\n        if divisor > 0:\\n            divisor = -divisor\\n            negatives -= 1\\n\\n        quotient = 0\\n        while dividend <= divisor:\\n            power_of_two = 1\\n            value = divisor\\n            while value >= (INT_MIN >> 1) and dividend <= (value + value):\\n                value += value\\n                power_of_two += power_of_two\\n            dividend -= value\\n            quotient += power_of_two\\n\\n        return quotient if negatives != 1 else -quotient\\n\"",
  "2280_14631217_python": "\"class Fenwick:\\n    def __init__(self, size):\\n        self.bit = [0] * (size + 1)\\n\\n    def update(self, i, v):\\n        i += 1\\n        while i < len(self.bit):\\n            self.bit[i] += v\\n            i += i & -i\\n\\n    def query(self, i):\\n        i += 1\\n        res = 0\\n        while i:\\n            res += self.bit[i]\\n            i -= i & -i\\n        return res\\n\\nclass Solution:\\n    def goodTriplets(self, nums1, nums2):\\n        n = len(nums1)\\n        pos2 = [0] * n\\n        for i, v in enumerate(nums2):\\n            pos2[v] = i\\n        \\n        arr = [pos2[v] for v in nums1]\\n        \\n        leftBIT = Fenwick(n)\\n        left = [0] * n\\n        for i in range(n):\\n            left[i] = leftBIT.query(arr[i] - 1)\\n            leftBIT.update(arr[i], 1)\\n        \\n        rightBIT = Fenwick(n)\\n        right = [0] * n\\n        for i in range(n - 1, -1, -1):\\n            right[i] = rightBIT.query(n - 1) - rightBIT.query(arr[i])\\n            rightBIT.update(arr[i], 1)\\n        \\n        return sum(l * r for l, r in zip(left, right))\\n\"",
  "1203_14631217_lang": "\"java\"",
  "1547_14631217_python-updated-time": "1746347226730",
  "2292_14631217_python": "\"class Solution:\\n    def prefixCount(self, words, pref):\\n        return sum(w.startswith(pref) for w in words)\\n\"",
  "3444_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def numberOfPairs(self, nums1, nums2, k):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) Build frequency array for nums1 up to its maximum value\\n        M = max(nums1)\\n        freqA = [0] * (M + 1)\\n        for a in nums1:\\n            freqA[a] += 1\\n        \\n        # 2) Build a Counter of all d = b * k that might actually divide something in nums1\\n        freqD = Counter()\\n        for b in nums2:\\n            d = b * k\\n            if d <= M:\\n                freqD[d] += 1\\n        \\n        # 3) For each distinct d, add up freqD[d] * (count of multiples of d in nums1)\\n        ans = 0\\n        for d, cntD in freqD.items():\\n            # walk through d, 2d, 3d, ... ≤ M\\n            for multiple in range(d, M + 1, d):\\n                ans += cntD * freqA[multiple]\\n        \\n        return ans\\n\"",
  "2182_14631217_python": "\"class Solution:\\n    def nodesBetweenCriticalPoints(self, head):\\n        \\\"\\\"\\\"\\n        :param head: ListNode\\n        :return: List[int]  # [minDistance, maxDistance]\\n        \\\"\\\"\\\"\\n        # List to record the indices of critical points (1-based)\\n        critical_idxs = []\\n        # Initialize pointers and index\\n        idx = 1\\n        prev = head\\n        curr = head.next\\n        # Traverse until the node before tail\\n        while curr and curr.next:\\n            nxt = curr.next\\n            # Check if curr is a local max or min\\n            if (curr.val > prev.val and curr.val > nxt.val) or (curr.val < prev.val and curr.val < nxt.val):\\n                critical_idxs.append(idx)\\n            # Move window forward\\n            prev, curr = curr, nxt\\n            idx += 1\\n\\n        # If fewer than two critical points, return [-1, -1]\\n        if len(critical_idxs) < 2:\\n            return [-1, -1]\\n\\n        # Compute minimum distance between consecutive critical points\\n        min_dist = float('inf')\\n        for i in range(1, len(critical_idxs)):\\n            dist = critical_idxs[i] - critical_idxs[i-1]\\n            if dist < min_dist:\\n                min_dist = dist\\n        # Maximum distance between first and last critical point\\n        max_dist = critical_idxs[-1] - critical_idxs[0]\\n\\n        return [min_dist, max_dist]\"",
  "355_14631217_python": "\"import collections\\nimport heapq\\n\\nclass Twitter(object):\\n    def __init__(self):\\n        self.time = 0\\n        self.tweets = collections.defaultdict(list)\\n        self.following = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].append((-self.time, tweetId))\\n        self.time += 1\\n\\n    def getNewsFeed(self, userId):\\n        heap = []\\n        users = self.following[userId] | {userId}\\n        for user in users:\\n            heap.extend(self.tweets[user])\\n        heapq.heapify(heap)\\n        res = []\\n        for _ in range(min(10, len(heap))):\\n            res.append(heapq.heappop(heap)[1])\\n        return res\\n\\n    def follow(self, followerId, followeeId):\\n        if followerId != followeeId:\\n            self.following[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        if followeeId in self.following[followerId]:\\n            self.following[followerId].remove(followeeId)\\n\"",
  "3275_14631217_python": "\"class Solution(object):\\n    def minimumPushes(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        # keys 2 to 9 → 8 keys\\n        # assign 1st 8 letters to push 1\\n        # next 8 to push 2, etc.\\n        pushes = 0\\n        for i in range(n):\\n            pushes += (i // 8) + 1\\n        return pushes\\n\"",
  "3337_14631217_python-updated-time": "1747421016250",
  "2240_14631217_python": "\"from collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def getDistances(self, arr):\\n        pos = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            pos[val].append(i)\\n\\n        res = [0] * len(arr)\\n\\n        for indices in pos.values():\\n            prefix = [0] * (len(indices) + 1)\\n            for i in range(len(indices)):\\n                prefix[i + 1] = prefix[i] + indices[i]\\n\\n            for i, idx in enumerate(indices):\\n                left = i * idx - prefix[i]\\n                right = (prefix[-1] - prefix[i + 1]) - (len(indices) - i - 1) * idx\\n                res[idx] = left + right\\n\\n        return res\\n\"",
  "3208_14631217_python-updated-time": "1747314648687",
  "789_14631217_python-updated-time": "1745875236104",
  "148_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def sortList(self, head):\\n        if not head or not head.next:\\n            return head\\n\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        mid = slow.next\\n        slow.next = None\\n\\n        left = self.sortList(head)\\n        right = self.sortList(mid)\\n\\n        return self.merge(left, right)\\n\\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n\\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n\\n        curr.next = l1 or l2\\n        return dummy.next\\n\"",
  "2606_14631217_python-updated-time": "1747057076744",
  "3346_14631217_python-updated-time": "1747423261406",
  "1832_14631217_python-updated-time": "1746454044321",
  "2047_14631217_python": "\"class Solution:\\n    def findPeakGrid(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        left, right = 0, n - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            # Find the row index of the max element in the middle column\\n            max_row = 0\\n            for i in range(m):\\n                if mat[i][mid] > mat[max_row][mid]:\\n                    max_row = i\\n\\n            # Compare with left and right neighbors\\n            left_val = mat[max_row][mid - 1] if mid - 1 >= 0 else -1\\n            right_val = mat[max_row][mid + 1] if mid + 1 < n else -1\\n            curr_val = mat[max_row][mid]\\n\\n            if curr_val > left_val and curr_val > right_val:\\n                return [max_row, mid]\\n            elif left_val > curr_val:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n\"",
  "2758_14631217_javascript": "\"function checkIfInstanceOf(val, cls) {\\n  // cls must be a constructor function\\n  if (typeof cls !== 'function') return false;\\n  // null/undefined can’t be instances of anything\\n  if (val == null) return false;\\n\\n  // Box primitives so that, e.g., 5 → Number(5), and still treat functions/objects as is\\n  const wrapped = (typeof val !== 'object' && typeof val !== 'function')\\n    ? Object(val)\\n    : val;\\n\\n  // Rely on JavaScript’s instanceof to check the prototype chain\\n  return wrapped instanceof cls;\\n}\\n\"",
  "461_14631217_python-updated-time": "1745359582161",
  "3753_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxDifference(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        freq = Counter(s)\\n        # collect odd and even frequencies\\n        odd_freqs = [f for f in freq.values() if f % 2 == 1]\\n        even_freqs = [f for f in freq.values() if f % 2 == 0]\\n\\n        # problem guarantees at least one odd and one even, but we guard just in case\\n        if not odd_freqs or not even_freqs:\\n            return 0\\n\\n        return max(odd_freqs) - min(even_freqs)\\n\"",
  "3213_14631217_python-updated-time": "1747317873690",
  "1159_14631217_python-updated-time": "1746108132708",
  "1523_14631217_mysql-updated-time": "1746346198089",
  "3391_14631217_python": "\"class Solution(object):\\n    def maxScore(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        NEG_INF = -10**18\\n\\n        # Tables for suffix‐max, suffix‐2nd‐max, and \\\"another max exists\\\"\\n        m1 = [[0]*n for _ in range(m)]\\n        m2 = [[NEG_INF]*n for _ in range(m)]\\n        has_same = [[False]*n for _ in range(m)]\\n\\n        # Build from bottom‐right upward\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                v = grid[i][j]\\n                # Collect up to two top candidates from self, right, and down\\n                cand = [v]\\n                if j+1 < n:\\n                    cand.append(m1[i][j+1])\\n                    cand.append(m2[i][j+1])\\n                if i+1 < m:\\n                    cand.append(m1[i+1][j])\\n                    cand.append(m2[i+1][j])\\n                # Keep unique descending\\n                uniq = sorted(set(cand), reverse=True)\\n                m1[i][j] = uniq[0]\\n                m2[i][j] = uniq[1] if len(uniq) > 1 else NEG_INF\\n\\n                # Mark if a child suffix also has m1 => another occurrence\\n                same = False\\n                if j+1 < n and m1[i][j+1] == m1[i][j]:\\n                    same = True\\n                if i+1 < m and m1[i+1][j] == m1[i][j]:\\n                    same = True\\n                has_same[i][j] = same\\n\\n        # Now compute the best possible score over all valid starts\\n        ans = NEG_INF\\n        for i in range(m):\\n            for j in range(n):\\n                # must make at least one move\\n                if i == m-1 and j == n-1:\\n                    continue\\n                v = grid[i][j]\\n                if m1[i][j] > v:\\n                    score = m1[i][j] - v\\n                elif m1[i][j] == v and has_same[i][j]:\\n                    score = 0\\n                else:\\n                    score = m2[i][j] - v\\n                ans = max(ans, score)\\n\\n        return ans\\n\"",
  "1803_14631217_python-updated-time": "1746453494533",
  "1721_14631217_python-updated-time": "1746443752721",
  "2238_14631217_python": "\"class Solution:\\n    def isSameAfterReversals(self, num):\\n        return int(str(int(str(num)[::-1]))[::-1]) == num\\n\"",
  "397_14631217_python": "\"class Solution:\\n    def integerReplacement(self, n):\\n        steps = 0\\n        while n != 1:\\n            if n % 2 == 0:\\n                n //= 2\\n            else:\\n                if n == 3 or ((n >> 1) & 1) == 0:\\n                    n -= 1\\n                else:\\n                    n += 1\\n            steps += 1\\n        return steps\\n\"",
  "43_14631217_python-updated-time": "1744999395221",
  "2548_14631217_python-updated-time": "1746968385185",
  "27_14631217_python": "\"class Solution(object):\\n    def removeElement(self, nums, val):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        k = 0\\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[k] = nums[i]\\n                k += 1\\n        return k\\n\"",
  "2292_14631217_python-updated-time": "1746803710493",
  "1972_14631217_python-updated-time": "1746625197886",
  "3677_14631217_python": "\"class Solution(object):\\n    def maximumAmount(self, coins):\\n        \\\"\\\"\\\"\\n        :type coins: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m = len(coins)\\n        n = len(coins[0])\\n        # Use a very large negative for -infinity\\n        NEG_INF = -10**18\\n        # dp[i][j][k]: max coins at (i,j) having used k neutralizations\\n        dp = [[[NEG_INF] * 3 for _ in range(n)] for __ in range(m)]\\n        # Initialize start cell (0,0)\\n        start = coins[0][0]\\n        if start >= 0:\\n            dp[0][0][0] = start\\n        else:\\n            # without using neutralization\\n            dp[0][0][0] = start\\n            # use one neutralization here\\n            dp[0][0][1] = 0\\n        # Fill first row\\n        for j in range(1, n):\\n            val = coins[0][j]\\n            for k in range(3):\\n                prev = dp[0][j-1][k]\\n                if prev == NEG_INF:\\n                    continue\\n                # take cell normally\\n                dp[0][j][k] = max(dp[0][j][k], prev + val)\\n                # if it's a robber, try neutralizing\\n                if val < 0 and k + 1 < 3:\\n                    dp[0][j][k+1] = max(dp[0][j][k+1], prev)\\n        # Fill first column\\n        for i in range(1, m):\\n            val = coins[i][0]\\n            for k in range(3):\\n                prev = dp[i-1][0][k]\\n                if prev == NEG_INF:\\n                    continue\\n                dp[i][0][k] = max(dp[i][0][k], prev + val)\\n                if val < 0 and k + 1 < 3:\\n                    dp[i][0][k+1] = max(dp[i][0][k+1], prev)\\n        # Fill interior cells\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                val = coins[i][j]\\n                for k in range(3):\\n                    # non-neutral transition\\n                    best_prev = NEG_INF\\n                    up = dp[i-1][j][k]\\n                    left = dp[i][j-1][k]\\n                    if up != NEG_INF:\\n                        best_prev = max(best_prev, up)\\n                    if left != NEG_INF:\\n                        best_prev = max(best_prev, left)\\n                    if best_prev != NEG_INF:\\n                        dp[i][j][k] = max(dp[i][j][k], best_prev + val)\\n                    # neutralize if robber and we have neutralizations left\\n                    if val < 0 and k > 0:\\n                        prev_neut = NEG_INF\\n                        upn = dp[i-1][j][k-1]\\n                        lfn = dp[i][j-1][k-1]\\n                        if upn != NEG_INF:\\n                            prev_neut = max(prev_neut, upn)\\n                        if lfn != NEG_INF:\\n                            prev_neut = max(prev_neut, lfn)\\n                        if prev_neut != NEG_INF:\\n                            dp[i][j][k] = max(dp[i][j][k], prev_neut)\\n        # The result is the best we can do at the bottom-right with up to 2 neutrals\\n        return max(dp[m-1][n-1])\"",
  "2583_14631217_python-updated-time": "1747058003152",
  "1695_14631217_python-updated-time": "1746438741611",
  "3692_14631217_python": "\"class Solution(object):\\n    def shortestMatchingSubstring(self, s, p):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type p: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n\\n        # Split p into A, B, C around the two '*' characters\\n        parts = p.split('*')\\n        A, B, C = parts[0], parts[1], parts[2]\\n\\n        # Helper: compute all match positions of pattern pat in text s\\n        # Returns a boolean list match of length n+1, where match[i] is True\\n        # iff s[i:i+len(pat)] == pat.  Empty pat matches everywhere.\\n        def compute_matches(pat):\\n            m = len(pat)\\n            if m == 0:\\n                return [True] * (n + 1)\\n            # Build LPS array for KMP\\n            lps = [0] * m\\n            length = 0\\n            i = 1\\n            while i < m:\\n                if pat[i] == pat[length]:\\n                    length += 1\\n                    lps[i] = length\\n                    i += 1\\n                else:\\n                    if length:\\n                        length = lps[length - 1]\\n                    else:\\n                        lps[i] = 0\\n                        i += 1\\n            # KMP search\\n            match = [False] * (n + 1)\\n            j = 0  # index in pat\\n            i = 0  # index in s\\n            while i < n:\\n                if s[i] == pat[j]:\\n                    i += 1\\n                    j += 1\\n                    if j == m:\\n                        # match ends at i, starts at i-m\\n                        match[i - m] = True\\n                        j = lps[j - 1]\\n                else:\\n                    if j:\\n                        j = lps[j - 1]\\n                    else:\\n                        i += 1\\n            return match\\n\\n        matchA = compute_matches(A)\\n        matchB = compute_matches(B)\\n        matchC = compute_matches(C)\\n\\n        INF = n + 1\\n\\n        # Build next-occurrence arrays for B and C\\n        nxtB = [INF] * (n + 2)\\n        nxtC = [INF] * (n + 2)\\n        # We only need to fill up to index n\\n        for i in range(n, -1, -1):\\n            if i < n + 1 and matchB[i]:\\n                nxtB[i] = i\\n            else:\\n                nxtB[i] = nxtB[i + 1]\\n            if i < n + 1 and matchC[i]:\\n                nxtC[i] = i\\n            else:\\n                nxtC[i] = nxtC[i + 1]\\n\\n        ans = INF\\n        lenA, lenB, lenC = len(A), len(B), len(C)\\n\\n        # Try every start index i where A matches\\n        for i in range(0, n + 1):\\n            if not matchA[i]:\\n                continue\\n            # substring must start at i, so A occupies [i, i+lenA)\\n            a_end = i + lenA\\n            if a_end > n:\\n                continue\\n            # find B at j >= a_end\\n            j = nxtB[a_end]\\n            if j > n:\\n                continue\\n            b_end = j + lenB\\n            if b_end > n:\\n                continue\\n            # find C at k >= b_end\\n            k = nxtC[b_end]\\n            if k > n:\\n                continue\\n            t_end = k + lenC\\n            if t_end > n:\\n                continue\\n            # candidate substring is s[i:t_end], length t_end - i\\n            length = t_end - i\\n            if length < ans:\\n                ans = length\\n\\n        return ans if ans <= n else -1\\n\"",
  "984_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def removeStones(self, stones):\\n        n = len(stones)\\n        parent = list(range(n))\\n\\n        def find(x):\\n            # Path compression\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx != ry:\\n                parent[ry] = rx\\n\\n        # Group stone indices by row and by column\\n        rows = defaultdict(list)\\n        cols = defaultdict(list)\\n        for i, (r, c) in enumerate(stones):\\n            rows[r].append(i)\\n            cols[c].append(i)\\n\\n        # Union all stones in the same row\\n        for idxs in rows.values():\\n            first = idxs[0]\\n            for i in idxs[1:]:\\n                union(first, i)\\n\\n        # Union all stones in the same column\\n        for idxs in cols.values():\\n            first = idxs[0]\\n            for i in idxs[1:]:\\n                union(first, i)\\n\\n        # Count distinct connected components (unique roots)\\n        roots = {find(i) for i in range(n)}\\n\\n        # We can remove all stones except one per component\\n        return n - len(roots)\\n\"",
  "2572_14631217_python-updated-time": "1747057401344",
  "129_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def dfs(node, current_num):\\n            if not node:\\n                return 0\\n            \\n            # Update the current number\\n            current_num = current_num * 10 + node.val\\n            \\n            # If this is a leaf node, return the current path's number\\n            if not node.left and not node.right:\\n                return current_num\\n            \\n            # Otherwise, recurse on left and right children\\n            left_sum = dfs(node.left, current_num)\\n            right_sum = dfs(node.right, current_num)\\n            \\n            return left_sum + right_sum\\n        \\n        return dfs(root, 0)\"",
  "2133_14631217_python-updated-time": "1746719410981",
  "3643_14631217_python": "\"class Solution(object):\\n    def minZeroArray(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        m = len(queries)\\n\\n        # If it's already a zero array, zero queries are needed.\\n        if all(v == 0 for v in nums):\\n            return 0\\n\\n        # Helper: can we zero out with the first k queries?\\n        def can(k):\\n            diff = [0] * (n + 1)\\n            for i in range(k):\\n                l, r, v = queries[i]\\n                diff[l]   += v\\n                diff[r+1] -= v\\n            c = 0\\n            for i in range(n):\\n                c += diff[i]\\n                if c < nums[i]:\\n                    return False\\n            return True\\n\\n        # If even all queries can't do it, return -1\\n        if not can(m):\\n            return -1\\n\\n        # Binary search the smallest k in [1..m] for which can(k) is True\\n        lo, hi = 1, m\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if can(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n\"",
  "1353_14631217_python": "\"class Solution:\\n    def removeAnagrams(self, words):\\n        res = []\\n        prev_sig = None\\n        for w in words:\\n            sig = ''.join(sorted(w))\\n            if sig != prev_sig:\\n                res.append(w)\\n                prev_sig = sig\\n        return res\\n\"",
  "3848_14631217_mysql": "\"SELECT\\n  ua.user_id,\\n  -- Average trial duration, rounded to 2 decimals\\n  ROUND(AVG(CASE WHEN ua.activity_type = 'free_trial'\\n                 THEN ua.activity_duration\\n            END), 2) AS trial_avg_duration,\\n  -- Average paid duration, rounded to 2 decimals\\n  ROUND(AVG(CASE WHEN ua.activity_type = 'paid'\\n                 THEN ua.activity_duration\\n            END), 2) AS paid_avg_duration\\nFROM UserActivity AS ua\\nGROUP BY ua.user_id\\nHAVING \\n  -- must have at least one free_trial\\n  SUM(CASE WHEN ua.activity_type = 'free_trial' THEN 1 ELSE 0 END) > 0\\n  -- must have at least one paid\\n  AND SUM(CASE WHEN ua.activity_type = 'paid' THEN 1 ELSE 0 END) > 0\\nORDER BY ua.user_id;\\n\"",
  "3174_14631217_python": "\"class Solution(object):\\n    def minChanges(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        res = 0\\n        i = 0\\n        while i < n:\\n            # evaluate block s[i] and s[i+1]\\n            if s[i] != s[i+1]:\\n                res += 1  # need 1 change to make the pair same\\n            i += 2\\n        return res\\n\"",
  "1794_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumDeviation(self, nums):\\n        # initialize max-heap and track current minimum\\n        heap = []\\n        mi = float('inf')\\n        for x in nums:\\n            if x % 2:      # make all numbers even\\n                x *= 2\\n            heap.append(-x)\\n            mi = min(mi, x)\\n        heapq.heapify(heap)\\n        \\n        # initial deviation\\n        res = -heap[0] - mi\\n        \\n        # keep reducing the maximum until it's odd\\n        while True:\\n            x = -heapq.heappop(heap)\\n            res = min(res, x - mi)\\n            if x % 2:      # can't reduce further\\n                break\\n            x //= 2\\n            mi = min(mi, x)\\n            heapq.heappush(heap, -x)\\n        \\n        return res\\n\"",
  "258_14631217_python": "\"class Solution(object):\\n    def addDigits(self, num):\\n        \\\"\\\"\\\"\\n        :type num: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if num == 0:\\n            return 0\\n        return 1 + (num - 1) % 9\\n\"",
  "1458_14631217_python": "\"class Solution(object):\\n    def sortByBits(self, arr):\\n        return sorted(arr, key=lambda x: (bin(x).count('1'), x))\\n\"",
  "3203_14631217_python": "\"class Solution(object):\\n    def canMakePalindromeQueries(self, s, queries):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        half = n // 2\\n\\n        # 1) Build prefix‐counts for each letter over the whole string\\n        #    prefix[ch][i] = count of letter ch in s[0:i]\\n        prefix = [[0]*(n+1) for _ in range(26)]\\n        for i, ch in enumerate(s):\\n            idx = ord(ch) - 97\\n            for c in range(26):\\n                prefix[c][i+1] = prefix[c][i]\\n            prefix[idx][i+1] += 1\\n\\n        # 2) Build a mismatch array for the first half,\\n        #    mismatch[i] = 1 if s[i] != s[n-1-i], else 0\\n        mismatch = [0]*half\\n        for i in range(half):\\n            if s[i] != s[n-1-i]:\\n                mismatch[i] = 1\\n\\n        # 3) Build its prefix‐sum so we can query any sub‐range\\n        pm = [0]*(half+1)\\n        for i in range(half):\\n            pm[i+1] = pm[i] + mismatch[i]\\n        total_mismatch = pm[half]\\n\\n        ans = []\\n        for a, b, c, d in queries:\\n            # ----  Step A: Check fixed‐outside windows are already palindromic  ----\\n            # I1 = [a..b] in left half,   I2 = mirror of [c..d] is [n-1-d..n-1-c]\\n            i1_l, i1_r = a, b\\n            i2_l, i2_r = n-1-d, n-1-c\\n\\n            # mismatches inside I1\\n            m1 = pm[i1_r+1] - pm[i1_l]\\n            # mismatches inside I2\\n            m2 = pm[i2_r+1] - pm[i2_l]\\n            # but I1 and I2 may overlap; subtract their intersection once\\n            ol = max(i1_l, i2_l)\\n            or_ = min(i1_r, i2_r)\\n            mo = 0\\n            if ol <= or_:\\n                mo = pm[or_+1] - pm[ol]\\n\\n            if m1 + m2 - mo != total_mismatch:\\n                # Some mismatch cannot be fixed since neither position is in a movable window\\n                ans.append(False)\\n                continue\\n\\n            # ----  Step B: Count how many chars we must “use up” to match fixed partners  ----\\n            # L window = [a..b],   R window = [c..d]\\n            # Mirror of L is M1 = [n-1-b..n-1-a]\\n            # Mirror of R is M2 = [n-1-d..n-1-c]\\n            m1_l, m1_r = n-1-b, n-1-a\\n            m2_l, m2_r = i2_l, i2_r\\n\\n            # 1) Multiset of chars in each window\\n            Lcnt = [0]*26\\n            Rcnt = [0]*26\\n            for ch in range(26):\\n                Lcnt[ch] = prefix[ch][b+1] - prefix[ch][a]\\n                Rcnt[ch] = prefix[ch][d+1] - prefix[ch][c]\\n\\n            # 2) For left window positions whose mirror is NOT in R:\\n            #    those i in M1 but outside [c..d] must match the fixed s[j].\\n            needL = [0]*26\\n            # segment1 = [m1_l .. min(m1_r, c-1)]\\n            s1, e1 = m1_l, min(m1_r, c-1)\\n            if s1 <= e1:\\n                for ch in range(26):\\n                    needL[ch] += prefix[ch][e1+1] - prefix[ch][s1]\\n            # segment2 = [max(m1_l, d+1) .. m1_r]\\n            s2, e2 = max(m1_l, d+1), m1_r\\n            if s2 <= e2:\\n                for ch in range(26):\\n                    needL[ch] += prefix[ch][e2+1] - prefix[ch][s2]\\n\\n            # 3) For right window positions whose mirror is NOT in L:\\n            #    those j in M2 but outside [a..b] must match the fixed s[i].\\n            needR = [0]*26\\n            # segment1 = [m2_l .. min(m2_r, a-1)]\\n            s1, e1 = m2_l, min(m2_r, a-1)\\n            if s1 <= e1:\\n                for ch in range(26):\\n                    needR[ch] += prefix[ch][e1+1] - prefix[ch][s1]\\n            # segment2 = [max(m2_l, b+1) .. m2_r]\\n            s2, e2 = max(m2_l, b+1), m2_r\\n            if s2 <= e2:\\n                for ch in range(26):\\n                    needR[ch] += prefix[ch][e2+1] - prefix[ch][s2]\\n\\n            # ----  Step C: Check resource feasibility and balance  ----\\n            #  * needL[ch] <= Lcnt[ch], needR[ch] <= Rcnt[ch]\\n            #  * after using up fixed‐matching chars, leftover multisets must be equal\\n            ok = True\\n            for ch in range(26):\\n                nl, nr = needL[ch], needR[ch]\\n                lm, rm = Lcnt[ch], Rcnt[ch]\\n                if nl > lm or nr > rm or (lm - nl) != (rm - nr):\\n                    ok = False\\n                    break\\n\\n            ans.append(ok)\\n\\n        return ans\\n\"",
  "801_14631217_python": "\"class Solution(object):\\n    def isBipartite(self, graph):\\n        n = len(graph)\\n        color = {}\\n        \\n        def dfs(node, c):\\n            if node in color:\\n                return color[node] == c\\n            color[node] = c\\n            for nei in graph[node]:\\n                if not dfs(nei, 1 - c):\\n                    return False\\n            return True\\n        \\n        for i in range(n):\\n            if i not in color:\\n                if not dfs(i, 0):\\n                    return False\\n        return True\\n\"",
  "491_14631217_python-updated-time": "1745445830621",
  "3510_14631217_python": "\"class Solution(object):\\n    def maximumTotalSum(self, maximumHeight):\\n        \\\"\\\"\\\"\\n        :type maximumHeight: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        maximumHeight.sort()\\n        n = len(maximumHeight)\\n        \\n        total = 0\\n        last_height = float('inf')  # Last height assigned\\n\\n        for i in range(n - 1, -1, -1):\\n            height = min(maximumHeight[i], last_height - 1)\\n            if height <= 0:\\n                return -1\\n            total += height\\n            last_height = height\\n\\n        return total\\n\"",
  "872_14631217_python": "\"class Solution(object):\\n    def splitIntoFibonacci(self, num):\\n        res = []\\n\\n        def backtrack(index):\\n            if index == len(num) and len(res) >= 3:\\n                return True\\n            for i in range(index, len(num)):\\n                if num[index] == '0' and i > index:\\n                    break\\n                n = int(num[index:i+1])\\n                if n >= 2**31:\\n                    break\\n                if len(res) >= 2 and res[-1] + res[-2] != n:\\n                    if res[-1] + res[-2] < n:\\n                        break\\n                    continue\\n                res.append(n)\\n                if backtrack(i+1):\\n                    return True\\n                res.pop()\\n            return False\\n\\n        backtrack(0)\\n        return res\\n\"",
  "1388_14631217_python-updated-time": "1746259926702",
  "1538_14631217_python": "\"class Solution:\\n    def maxScore(self, cardPoints, k):\\n        total = sum(cardPoints[:k])\\n        max_score = total\\n        n = len(cardPoints)\\n\\n        for i in range(1, k + 1):\\n            total += cardPoints[-i] - cardPoints[k - i]\\n            max_score = max(max_score, total)\\n\\n        return max_score\\n\"",
  "632_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        heap = []\\n        max_val = float('-inf')\\n        \\n        for i in range(len(nums)):\\n            heapq.heappush(heap, (nums[i][0], i, 0))\\n            max_val = max(max_val, nums[i][0])\\n        \\n        result = [float('-inf'), float('inf')]\\n        \\n        while True:\\n            min_val, row, idx = heapq.heappop(heap)\\n            if max_val - min_val < result[1] - result[0] or (max_val - min_val == result[1] - result[0] and min_val < result[0]):\\n                result = [min_val, max_val]\\n            if idx + 1 == len(nums[row]):\\n                break\\n            next_val = nums[row][idx + 1]\\n            heapq.heappush(heap, (next_val, row, idx + 1))\\n            max_val = max(max_val, next_val)\\n        \\n        return result\\n\"",
  "1008_14631217_python-updated-time": "1746039744461",
  "638_14631217_python": "\"class Solution(object):\\n    def shoppingOffers(self, price, special, needs):\\n        memo = {}\\n        \\n        def dfs(cur_needs):\\n            if tuple(cur_needs) in memo:\\n                return memo[tuple(cur_needs)]\\n            \\n            res = sum(cur_needs[i] * price[i] for i in range(len(price)))\\n            \\n            for offer in special:\\n                new_needs = []\\n                for i in range(len(price)):\\n                    if cur_needs[i] < offer[i]:\\n                        break\\n                    new_needs.append(cur_needs[i] - offer[i])\\n                else:\\n                    res = min(res, offer[-1] + dfs(new_needs))\\n                    \\n            memo[tuple(cur_needs)] = res\\n            return res\\n        \\n        return dfs(needs)\\n\"",
  "3646_14631217_python": "\"class Solution(object):\\n    def sumOfGoodSubsequences(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        if not nums:\\n            return 0\\n\\n        # Determine the maximum value in nums to size our DP arrays\\n        mx = max(nums)\\n        size = mx + 3  # +3 so we can safely access x+1\\n\\n        # dp_count[v]: number of good subsequences ending with value v seen so far\\n        # dp_sum[v]: sum of all elements across those subsequences ending with v\\n        dp_count = [0] * size\\n        dp_sum   = [0] * size\\n\\n        total = 0\\n        for x in nums:\\n            # Extend from x-1\\n            if x > 0:\\n                c1 = dp_count[x-1]\\n                s1 = dp_sum[x-1]\\n            else:\\n                c1 = 0\\n                s1 = 0\\n\\n            # Extend from x+1\\n            c2 = dp_count[x+1]\\n            s2 = dp_sum[x+1]\\n\\n            # Subsequences ending here:\\n            # 1) The singleton [x]\\n            # 2) Extend each subsequence ending in x-1 by appending x\\n            # 3) Extend each subsequence ending in x+1 by appending x\\n            new_count = (1 + c1 + c2) % MOD\\n            # The total sum contributed by those new subsequences:\\n            # - singleton: x\\n            # - from x-1: each existing sum s1, plus c1 copies of x\\n            # - from x+1: each existing sum s2, plus c2 copies of x\\n            new_sum = (\\n                x\\n                + (s1 + c1 * x) % MOD\\n                + (s2 + c2 * x) % MOD\\n            ) % MOD\\n\\n            # Add to global total\\n            total = (total + new_sum) % MOD\\n\\n            # Update our DP for future extensions\\n            dp_count[x] = (dp_count[x] + new_count) % MOD\\n            dp_sum[x]   = (dp_sum[x]   + new_sum)   % MOD\\n\\n        return total\\n\"",
  "2749_14631217_javascript-updated-time": "1747135749317",
  "1806_14631217_python": "\"class Solution(object):\\n    def numberOfMatches(self, n):\\n        return n - 1\\n\"",
  "466_14631217_python": "\"class Solution:\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        if n1 == 0:\\n            return 0\\n\\n        index = 0  # index in s2\\n        s2cnt = 0  # how many times s2 matched\\n        recall = dict()\\n        s1cnt = 0  # how many s1 blocks processed\\n\\n        while s1cnt < n1:\\n            for ch in s1:\\n                if ch == s2[index]:\\n                    index += 1\\n                    if index == len(s2):\\n                        index = 0\\n                        s2cnt += 1\\n            s1cnt += 1\\n\\n            if index in recall:\\n                # Loop detected\\n                s1cnt_prev, s2cnt_prev = recall[index]\\n                pre_loop_s1cnt = s1cnt_prev\\n                pre_loop_s2cnt = s2cnt_prev\\n\\n                loop_s1cnt = s1cnt - s1cnt_prev\\n                loop_s2cnt = s2cnt - s2cnt_prev\\n\\n                loops = (n1 - pre_loop_s1cnt) // loop_s1cnt\\n                s1cnt = pre_loop_s1cnt + loops * loop_s1cnt\\n                s2cnt = pre_loop_s2cnt + loops * loop_s2cnt\\n                break\\n            else:\\n                recall[index] = (s1cnt, s2cnt)\\n\\n        # Remaining s1 blocks after loop\\n        rest_s2cnt = 0\\n        index = index\\n        for _ in range(s1cnt, n1):\\n            for ch in s1:\\n                if ch == s2[index]:\\n                    index += 1\\n                    if index == len(s2):\\n                        index = 0\\n                        rest_s2cnt += 1\\n\\n        return (s2cnt + rest_s2cnt) // n2\\n\"",
  "504_14631217_python-updated-time": "1745446181406",
  "959_14631217_python-updated-time": "1746003715534",
  "1146_14631217_python": "\"class Solution(object):\\n    def gcdOfStrings(self, str1, str2):\\n        \\\"\\\"\\\"\\n        :type str1: str\\n        :type str2: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        if str1 + str2 != str2 + str1:\\n            return \\\"\\\"\\n        gcd_len = gcd(len(str1), len(str2))\\n        return str1[:gcd_len]\\n\"",
  "3819_14631217_python-updated-time": "1747683920469",
  "1021_14631217_python-updated-time": "1746040162703",
  "1876_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        \\\"\\\"\\\"\\n        :type isWater: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        m, n = len(isWater), len(isWater[0])\\n        height = [[-1] * n for _ in range(m)]\\n        queue = deque()\\n\\n        # Initialize water cells with height 0\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    height[i][j] = 0\\n                    queue.append((i, j))\\n\\n        # BFS from all water cells\\n        directions = [(0,1), (1,0), (-1,0), (0,-1)]\\n        while queue:\\n            x, y = queue.popleft()\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:\\n                    height[nx][ny] = height[x][y] + 1\\n                    queue.append((nx, ny))\\n\\n        return height\\n\"",
  "3778_14631217_python-updated-time": "1747681252270",
  "1024_14631217_python-updated-time": "1746040295525",
  "2743_14631217_javascript-updated-time": "1747135421480",
  "736_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        tokens = collections.deque(expression.replace('(', ' ( ').replace(')', ' ) ').split())\\n        \\n        def helper(env):\\n            tok = tokens.popleft()\\n            if tok != '(':\\n                if tok.lstrip('-').isdigit():\\n                    return int(tok)\\n                for scope in reversed(env):\\n                    if tok in scope:\\n                        return scope[tok]\\n                return 0\\n            \\n            op = tokens.popleft()\\n            if op == 'let':\\n                env.append({})\\n                val = 0\\n                while True:\\n                    if tokens[0] == ')':\\n                        tokens.popleft()\\n                        break\\n                    if tokens[0][0].isalpha() and tokens[1] != ')':\\n                        var = tokens.popleft()\\n                        v = helper(env)\\n                        env[-1][var] = v\\n                    else:\\n                        val = helper(env)\\n                        tokens.popleft()\\n                        break\\n                env.pop()\\n                return val\\n            \\n            if op == 'add':\\n                a = helper(env)\\n                b = helper(env)\\n                tokens.popleft()\\n                return a + b\\n            \\n            if op == 'mult':\\n                a = helper(env)\\n                b = helper(env)\\n                tokens.popleft()\\n                return a * b\\n            \\n            return 0\\n        \\n        return helper([])\\n\"",
  "481_14631217_python": "\"class Solution(object):\\n    def magicalString(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if n <= 0:\\n            return 0\\n        if n <= 3:\\n            return 1\\n\\n        s = [1, 2, 2]\\n        i = 2\\n        num = 1\\n        count = 1  # one '1' in the initial \\\"122\\\"\\n\\n        while len(s) < n:\\n            times = s[i]\\n            s.extend([num] * times)\\n            if num == 1:\\n                count += min(n - len(s) + times, times)\\n            num ^= 3  # toggle between 1 and 2\\n            i += 1\\n\\n        return count\\n\"",
  "2021_14631217_python-updated-time": "1746637122306",
  "2237_14631217_python-updated-time": "1746801958270",
  "138_14631217_python-updated-time": "1745086863075",
  "686_14631217_python": "\"class Solution(object):\\n    def repeatedStringMatch(self, a, b):\\n        repeated = a\\n        count = 1\\n        while len(repeated) < len(b):\\n            repeated += a\\n            count += 1\\n        if b in repeated:\\n            return count\\n        repeated += a\\n        if b in repeated:\\n            return count + 1\\n        return -1\\n\"",
  "1013_14631217_python-updated-time": "1745446283416",
  "3627_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nmod = 10**9 + 7\\n\\nclass Solution(object):\\n    def minTimeToReach(self, moveTime):\\n        \\\"\\\"\\\"\\n        :type moveTime: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import heapq\\n        n = len(moveTime)\\n        m = len(moveTime[0])\\n        # dist[r][c]: min time to arrive at room (r,c)\\n        INF = 10**30\\n        dist = [[INF] * m for _ in range(n)]\\n        # start at (0,0) at time 0\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]  # (time, r, c)\\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        while pq:\\n            t, r, c = heapq.heappop(pq)\\n            if t > dist[r][c]:\\n                continue\\n            # reached target\\n            if r == n-1 and c == m-1:\\n                return t\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < n and 0 <= nc < m:\\n                    # can depart at time >= open time of neighbor\\n                    depart = max(t, moveTime[nr][nc])\\n                    arrive = depart + 1\\n                    if arrive < dist[nr][nc]:\\n                        dist[nr][nc] = arrive\\n                        heapq.heappush(pq, (arrive, nr, nc))\\n        # unreachable\\n        return -1\\n\\n# existing methods below remain unchanged\\n    def lengthAfterTransformations(self, s, t, nums):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        A = [[0] * 26 for _ in range(26)]\\n        for i in range(26):\\n            for k in range(1, nums[i] + 1):\\n                j = (i + k) % 26\\n                A[i][j] = 1\\n\\n        def mat_mult(X, Y):\\n            Z = [[0] * 26 for _ in range(26)]\\n            for i in range(26):\\n                for k in range(26):\\n                    if X[i][k]:\\n                        for j in range(26):\\n                            Z[i][j] = (Z[i][j] + X[i][k] * Y[k][j]) % mod\\n            return Z\\n\\n        def mat_pow(mat, power):\\n            res = [[int(i == j) for j in range(26)] for i in range(26)]\\n            while power:\\n                if power % 2:\\n                    res = mat_mult(res, mat)\\n                mat = mat_mult(mat, mat)\\n                power //= 2\\n            return res\\n\\n        if t == 0:\\n            return len(s) % mod\\n\\n        At = mat_pow(A, t)\\n        f = [sum(At[c]) % mod for c in range(26)]\\n\\n        return sum(f[ord(ch) - ord('a')] for ch in s) % mod\\n\\n    def isBalanced(self, num):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\\n        return even_sum == odd_sum\\n\"",
  "3291_14631217_python-updated-time": "1747399415672",
  "3316_14631217_python-updated-time": "1747423005256",
  "1951_14631217_python-updated-time": "1746543907172",
  "2588_14631217_python-updated-time": "1747059018919",
  "3426_14631217_python": "\"class Solution(object):\\n    def minimumChairs(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        current = 0\\n        max_chairs = 0\\n        \\n        for ch in s:\\n            if ch == 'E':\\n                current += 1\\n                max_chairs = max(max_chairs, current)\\n            else:  # 'L'\\n                current -= 1\\n        \\n        return max_chairs\\n\"",
  "1422_14631217_python-updated-time": "1746260467967",
  "2679_14631217_python": "\"class Solution:\\n    def distinctIntegers(self, n):\\n        visited = set()\\n        stack = [n]\\n\\n        while stack:\\n            x = stack.pop()\\n            if x in visited:\\n                continue\\n            visited.add(x)\\n            for i in range(1, n + 1):\\n                if x % i == 1 and i not in visited:\\n                    stack.append(i)\\n\\n        return len(visited)\\n\"",
  "2186_14631217_python": "\"class Solution:\\n    def countVowelSubstrings(self, word):\\n        \\\"\\\"\\\"\\n        :param word: str\\n        :return: int  # number of vowel-only substrings containing all 5 vowels\\n        \\\"\\\"\\\"\\n        vowels = set('aeiou')\\n        n = len(word)\\n        count = 0\\n\\n        # Try every start index\\n        for i in range(n):\\n            seen = set()\\n            # Extend the substring from i to j\\n            for j in range(i, n):\\n                c = word[j]\\n                # If we hit a consonant, no longer a vowel-only substring\\n                if c not in vowels:\\n                    break\\n                seen.add(c)\\n                # Once we've seen all 5 vowels, every further extension\\n                # (still vowel-only) counts as another valid substring\\n                if len(seen) == 5:\\n                    count += 1\\n\\n        return count\\n\"",
  "2488_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def minGroups(self, intervals):\\n        # Sort intervals by start time\\n        intervals.sort(key=lambda x: x[0])\\n        # Min-heap of end times of current overlapping group\\n        heap = []\\n        max_groups = 0\\n\\n        for start, end in intervals:\\n            # Remove intervals that ended before this one starts (no overlap)\\n            while heap and heap[0] < start:\\n                heapq.heappop(heap)\\n            # Add this interval's end time\\n            heapq.heappush(heap, end)\\n            # The heap size is the number of overlapping intervals at this point\\n            max_groups = max(max_groups, len(heap))\\n\\n        return max_groups\\n\"",
  "1664_14631217_postgresql-updated-time": "1744902451434",
  "1558_14631217_python": "\"class Solution(object):\\n    def checkIfPrerequisite(self, numCourses, prerequisites, queries):\\n        n = numCourses\\n        # reach[i][j] will be True if i is a prerequisite of j\\n        reach = [[False] * n for _ in range(n)]\\n        # initialize direct prerequisites\\n        for u, v in prerequisites:\\n            reach[u][v] = True\\n        # Floyd–Warshall for transitive closure\\n        for k in range(n):\\n            for i in range(n):\\n                if reach[i][k]:\\n                    for j in range(n):\\n                        if reach[k][j]:\\n                            reach[i][j] = True\\n        # answer queries\\n        return [reach[u][v] for u, v in queries]\\n\"",
  "518_14631217_python": "\"class Solution:\\n    def change(self, amount, coins):\\n        dp = [0] * (amount + 1)\\n        dp[0] = 1\\n        \\n        for coin in coins:\\n            for x in range(coin, amount + 1):\\n                dp[x] += dp[x - coin]\\n        \\n        return dp[amount]\\n\"",
  "2662_14631217_python-updated-time": "1747133513985",
  "2179_14631217_python-updated-time": "1746728470739",
  "1258_14631217_mysql": "\"SELECT DISTINCT author_id AS id\\nFROM Views\\nWHERE author_id = viewer_id\\nORDER BY id;\\n\"",
  "3837_14631217_python-updated-time": "1747684273700",
  "968_14631217_python": "\"class Solution:\\n    def beautifulArray(self, n):\\n        memo = {}\\n\\n        def helper(n):\\n            if n in memo:\\n                return memo[n]\\n            if n == 1:\\n                return [1]\\n            odd = helper((n + 1) // 2)\\n            even = helper(n // 2)\\n            res = [2 * x - 1 for x in odd] + [2 * x for x in even]\\n            memo[n] = res\\n            return res\\n\\n        return helper(n)\\n\"",
  "2117_14631217_python-updated-time": "1746717964773",
  "49_14631217_python": "\"class Solution(object):\\n    def groupAnagrams(self, strs):\\n        \\\"\\\"\\\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        anagrams = defaultdict(list)\\n        for word in strs:\\n            key = ''.join(sorted(word))\\n            anagrams[key].append(word)\\n\\n        return list(anagrams.values())\\n\"",
  "492_14631217_python-updated-time": "1745445879023",
  "1871_14631217_python-updated-time": "1746531339438",
  "3422_14631217_python-updated-time": "1747484805766",
  "2236_14631217_python-updated-time": "1746801930675",
  "3032_14631217_python": "\"class Solution(object):\\n    def getMaxFunctionValue(self, receiver, k):\\n        \\\"\\\"\\\"\\n        :type receiver: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(receiver)\\n        # Maximum power for k up to 1e10 -> log2(k) ~ 34\\n        LOG = k.bit_length()  # enough bits to cover k\\n        # up[i][j] = node reached from i after 2^j passes\\n        up = [[0]*LOG for _ in range(n)]\\n        # sumUp[i][j] = sum of the indices of the 2^j nodes we pass through\\n        # starting from i (excluding i itself, including the 2^j-th node)\\n        sumUp = [[0]*LOG for _ in range(n)]\\n\\n        # Initialize 2^0 = 1 pass\\n        for i in range(n):\\n            nxt = receiver[i]\\n            up[i][0] = nxt\\n            sumUp[i][0] = nxt  # one pass lands on nxt\\n\\n        # Build binary lifting tables\\n        for j in range(1, LOG):\\n            for i in range(n):\\n                mid = up[i][j-1]\\n                up[i][j] = up[mid][j-1]\\n                # sum of first 2^j passes = sum of first 2^(j-1) + \\n                # then from the mid node another 2^(j-1) passes\\n                sumUp[i][j] = sumUp[i][j-1] + sumUp[mid][j-1]\\n\\n        ans = 0\\n        # For each starting i, compute sum over k passes\\n        for i in range(n):\\n            total = i  # include the starting player\\n            curr = i\\n            rem = k\\n            b = 0\\n            while rem > 0:\\n                if rem & 1:\\n                    total += sumUp[curr][b]\\n                    curr = up[curr][b]\\n                rem >>= 1\\n                b += 1\\n            if total > ans:\\n                ans = total\\n\\n        return ans\\n\"",
  "1027_14631217_python-updated-time": "1746040405133",
  "3270_14631217_python": "\"class Solution(object):\\n    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):\\n        # Check if rook can capture queen directly (same row)\\n        if a == e:\\n            col_min, col_max = sorted([b, f])\\n            if not (col_min < d < col_max and c == a):  # bishop not blocking\\n                return 1\\n        # Check if rook can capture queen directly (same column)\\n        if b == f:\\n            row_min, row_max = sorted([a, e])\\n            if not (row_min < c < row_max and d == b):  # bishop not blocking\\n                return 1\\n\\n        # Check if bishop can capture queen directly (diagonal)\\n        if abs(c - e) == abs(d - f):\\n            dx = 1 if e > c else -1\\n            dy = 1 if f > d else -1\\n            x, y = c + dx, d + dy\\n            blocked = False\\n            while (x, y) != (e, f):\\n                if (x, y) == (a, b):  # rook blocks bishop\\n                    blocked = True\\n                    break\\n                x += dx\\n                y += dy\\n            if not blocked:\\n                return 1\\n\\n        return 2\\n\"",
  "2102_14631217_python": "\"class Solution:\\n    def findMiddleIndex(self, nums):\\n        total = sum(nums)\\n        left = 0\\n        for i, num in enumerate(nums):\\n            if left == total - left - num:\\n                return i\\n            left += num\\n        return -1\\n\"",
  "990_14631217_python": "\"class Solution:\\n    def isAlienSorted(self, words, order):\\n        index = {ch: i for i, ch in enumerate(order)}\\n        \\n        def in_order(w1, w2):\\n            for c1, c2 in zip(w1, w2):\\n                if c1 != c2:\\n                    return index[c1] < index[c2]\\n            return len(w1) <= len(w2)\\n        \\n        for i in range(len(words) - 1):\\n            if not in_order(words[i], words[i + 1]):\\n                return False\\n        return True\\n\"",
  "2621_14631217_python": "\"class Solution:\\n    def xorBeauty(self, nums):\\n        res = 0\\n        for x in nums:\\n            res ^= x\\n        return res\\n\"",
  "1692_14631217_python": "\"class Solution(object):\\n    def numOfWays(self, nums):\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        # precompute factorials and inverse factorials\\n        fac = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            fac[i] = fac[i-1] * i % mod\\n        invfac = [1] * (n + 1)\\n        invfac[n] = pow(fac[n], mod-2, mod)\\n        for i in range(n, 0, -1):\\n            invfac[i-1] = invfac[i] * i % mod\\n\\n        def comb(a, b):\\n            if b < 0 or b > a:\\n                return 0\\n            return fac[a] * invfac[b] % mod * invfac[a-b] % mod\\n\\n        def dfs(arr):\\n            m = len(arr)\\n            if m <= 2:\\n                return 1\\n            root = arr[0]\\n            left = [x for x in arr[1:] if x < root]\\n            right = [x for x in arr[1:] if x > root]\\n            wl = dfs(left)\\n            wr = dfs(right)\\n            return wl * wr % mod * comb(len(left) + len(right), len(left)) % mod\\n\\n        return (dfs(nums) - 1) % mod\\n\"",
  "1930_14631217_python": "\"class Solution(object):\\n    def getMaximumConsecutive(self, coins):\\n        coins.sort()\\n        max_reach = 0  # The maximum value we can make so far (inclusive)\\n\\n        for coin in coins:\\n            if coin > max_reach + 1:\\n                break\\n            max_reach += coin\\n\\n        return max_reach + 1  # Include 0\\n\"",
  "187_14631217_python-updated-time": "1745092654856",
  "1359_14631217_python": "\"class Solution:\\n    def circularPermutation(self, n, start):\\n        res = []\\n        for i in range(1 << n):\\n            res.append(start ^ (i ^ (i >> 1)))\\n        return res\\n\"",
  "3334_14631217_python-updated-time": "1747420447807",
  "1970_14631217_python-updated-time": "1746625117747",
  "766_14631217_python": "\"\\\"\\\"\\\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, prev, next, child):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n        self.child = child\\n\\\"\\\"\\\"\\n\\nclass Solution:\\n    def flatten(self, head):\\n        if not head:\\n            return head\\n        \\n        def flatten_dfs(prev, curr):\\n            if not curr:\\n                return prev\\n            curr.prev = prev\\n            prev.next = curr\\n            \\n            # Save next because current.next may be overwritten after child flatten\\n            temp_next = curr.next\\n            \\n            tail = flatten_dfs(curr, curr.child)\\n            curr.child = None  # clear child after flattening\\n            \\n            return flatten_dfs(tail, temp_next)\\n        \\n        dummy = Node(0)\\n        flatten_dfs(dummy, head)\\n        \\n        dummy.next.prev = None\\n        return dummy.next\"",
  "2953_14631217_python": "\"class Solution(object):\\n    def countPairs(self, coordinates, k):\\n        \\\"\\\"\\\"\\n        :type coordinates: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        freq = defaultdict(int)\\n        ans = 0\\n\\n        # Precompute all (dx, dy) with dx + dy == k\\n        deltas = [(dx, k - dx) for dx in range(k + 1)]\\n\\n        for x, y in coordinates:\\n            # For each possible delta, look up matching previous points\\n            for dx, dy in deltas:\\n                xx = x ^ dx\\n                yy = y ^ dy\\n                ans += freq[(xx, yy)]\\n            # Now include current point in freq\\n            freq[(x, y)] += 1\\n\\n        return ans\\n\"",
  "1789_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):\\n        \\\"\\\"\\\"\\n        :type boxes: List[List[int]]\\n        :type portsCount: int\\n        :type maxBoxes: int\\n        :type maxWeight: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(boxes)\\n        # 1) build prefix‐sums of weight W[i] and port‐changes P[i]\\n        W = [0] * (n+1)\\n        P = [0] * (n+1)\\n        for i in range(1, n+1):\\n            port, wt = boxes[i-1]\\n            W[i] = W[i-1] + wt\\n            if i > 1 and port != boxes[i-2][0]:\\n                P[i] = P[i-1] + 1\\n            else:\\n                P[i] = P[i-1]\\n\\n        INF = 10**18\\n        dp = [INF] * (n+1)\\n        dp[0] = 0\\n\\n        # f[l] = dp[l-1] - P[l]; \\n        # we store candidate l's in deque, increasing by f[l].\\n        deq = deque()\\n        # initial candidate l = 1\\n        # f[1] = dp[0] - P[1] = 0 - 0 = 0\\n        deq.append(1)\\n\\n        wl = 0  # pointer for weight‐constraint\\n\\n        for r in range(1, n+1):\\n            # advance wl so that W[wl] >= W[r] - maxWeight\\n            while wl < r and W[wl] < W[r] - maxWeight:\\n                wl += 1\\n\\n            # leftmost valid l must satisfy:\\n            #   l >= wl+1  (weight)\\n            #   l >= r-maxBoxes+1  (count)\\n            L = max(wl+1, r - maxBoxes + 1, 1)\\n\\n            # pop off any l < L\\n            while deq and deq[0] < L:\\n                deq.popleft()\\n\\n            # if there's no valid batch-start, dp[r] stays INF\\n            if deq:\\n                best_l = deq[0]\\n                # dp[r] = min over l of dp[l-1] + (2 + P[r] - P[l])\\n                dp[r] = 2 + P[r] + (dp[best_l-1] - P[best_l])\\n\\n            # prepare candidate l = r+1 for future r's\\n            if r < n and dp[r] < INF:\\n                f_next = dp[r] - P[r+1]\\n                # maintain deque monotonic by f[]\\n                while deq and (dp[deq[-1]-1] - P[deq[-1]]) >= f_next:\\n                    deq.pop()\\n                deq.append(r+1)\\n\\n        return dp[n] if dp[n] < INF else -1\\n\"",
  "1642_14631217_python": "\"class Solution(object):\\n    def numWaterBottles(self, numBottles, numExchange):\\n        \\\"\\\"\\\"\\n        :type numBottles: int\\n        :type numExchange: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = numBottles\\n        empty = numBottles\\n\\n        while empty >= numExchange:\\n            new_full = empty // numExchange\\n            total += new_full\\n            empty = empty % numExchange + new_full\\n\\n        return total\\n\"",
  "1940_14631217_python": "\"class Solution(object):\\n    def getMaximumXor(self, nums, maximumBit):\\n        mask = (1 << maximumBit) - 1\\n        total_xor = 0\\n        for x in nums:\\n            total_xor ^= x\\n        n = len(nums)\\n        ans = [0] * n\\n        for i in range(n):\\n            # at this step, total_xor is XOR of nums[0..n-1-i]\\n            ans[i] = total_xor ^ mask\\n            # remove the last element for next step\\n            total_xor ^= nums[n-1-i]\\n        return ans\\n\"",
  "1360_14631217_python-updated-time": "1746259389709",
  "2635_14631217_python": "\"class Solution:\\n    def isReachable(self, targetX, targetY):\\n        # Compute gcd with Euclid's algorithm\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        g = gcd(targetX, targetY)\\n        # Check if g is a power of two (including 1)\\n        return g > 0 and (g & (g - 1)) == 0\\n\"",
  "2182_14631217_python-updated-time": "1746720684966",
  "347_14631217_python": "\"from collections import Counter\\nimport heapq\\n\\nclass Solution:\\n    def topKFrequent(self, nums, k):\\n        count = Counter(nums)\\n        return heapq.nlargest(k, count.keys(), key=count.get)\\n\"",
  "1063_14631217_python-updated-time": "1746041514170",
  "197_14631217_mysql": "\"# Write your MySQL query statement below\\nSELECT w1.id\\nFROM Weather w1\\nJOIN Weather w2\\n  ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature;\\n\"",
  "3243_14631217_python": "\"class Solution(object):\\n    def numberOfPowerfulInt(self, start, finish, limit, s):\\n        suffix = int(s)\\n        L = len(s)\\n        base = 10 ** L\\n        if finish < suffix:\\n            return 0\\n        # compute t range so that t*base + suffix ∈ [start, finish]\\n        t_min = 0\\n        if start > suffix:\\n            t_min = (start - suffix + base - 1) // base\\n        t_max = (finish - suffix) // base\\n        if t_max < t_min:\\n            return 0\\n\\n        def count(N):\\n            if N < 0:\\n                return 0\\n            digs = list(map(int, str(N)))\\n            n = len(digs)\\n            memo = {}\\n            def dp(pos, tight):\\n                if pos == n:\\n                    return 1\\n                key = (pos, tight)\\n                if key in memo:\\n                    return memo[key]\\n                if tight:\\n                    up = min(digs[pos], limit)\\n                else:\\n                    up = limit\\n                total = 0\\n                for d in range(up + 1):\\n                    total += dp(pos + 1, tight and d == digs[pos])\\n                memo[key] = total\\n                return total\\n            return dp(0, True)\\n\\n        return count(t_max) - count(t_min - 1)\\n\"",
  "3329_14631217_python-updated-time": "1747416488749",
  "309_14631217_python-updated-time": "1745255821370",
  "1350_14631217_python-updated-time": "1746259257732",
  "1737_14631217_python-updated-time": "1746444107300",
  "3631_14631217_python-updated-time": "1747587773390",
  "2415_14631217_python-updated-time": "1746907432590",
  "2733_14631217_javascript-updated-time": "1747135173185",
  "2854_14631217_python-updated-time": "1747221585724",
  "242_14631217_python": "\"class Solution(object):\\n    def isAnagram(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if len(s) != len(t):\\n            return False\\n        count = {}\\n        for char in s:\\n            count[char] = count.get(char, 0) + 1\\n        for char in t:\\n            if char not in count or count[char] == 0:\\n                return False\\n            count[char] -= 1\\n        return True\\n\"",
  "3736_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def findValidPair(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Count total occurrences of each digit in s\\n        freq = Counter(s)\\n        \\n        # Scan adjacent pairs from left to right\\n        for i in range(len(s) - 1):\\n            d1, d2 = s[i], s[i+1]\\n            if d1 != d2:\\n                # Check if each digit's count equals its numeric value\\n                if freq[d1] == int(d1) and freq[d2] == int(d2):\\n                    return d1 + d2\\n        \\n        # No valid pair found\\n        return \\\"\\\"\\n\"",
  "1421_14631217_python-updated-time": "1746260446258",
  "148_14631217_python-updated-time": "1745090687554",
  "2190_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def countWords(self, words1, words2):\\n        \\\"\\\"\\\"\\n        :type words1: List[str]\\n        :type words2: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        c1 = Counter(words1)\\n        c2 = Counter(words2)\\n        \\n        count = 0\\n        # Only strings appearing in both can qualify\\n        for word in c1:\\n            if c1[word] == 1 and c2.get(word, 0) == 1:\\n                count += 1\\n        \\n        return count\\n\"",
  "2248_14631217_python": "\"class Solution:\\n    def minimumCost(self, cost):\\n        cost.sort(reverse=True)\\n        total = 0\\n        for i in range(len(cost)):\\n            if i % 3 != 2:\\n                total += cost[i]\\n        return total\\n\"",
  "1988_14631217_python-updated-time": "1746626112036",
  "106_14631217_python-updated-time": "1745081130601",
  "2343_14631217_python-updated-time": "1746880295522",
  "748_14631217_python": "\"class Solution(object):\\n    def dominantIndex(self, nums):\\n        max_num = max(nums)\\n        index = nums.index(max_num)\\n        for num in nums:\\n            if num != max_num and max_num < 2 * num:\\n                return -1\\n        return index\\n\"",
  "2081_14631217_python": "\"class Solution(object):\\n    def minSpaceWastedKResizing(self, nums, k):\\n        n = len(nums)\\n        # prefix sums\\n        prefix = [0] * (n + 1)\\n        for i in range(n):\\n            prefix[i+1] = prefix[i] + nums[i]\\n        # maxv[i][j] = max of nums[i..j]\\n        maxv = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            m = nums[i]\\n            maxv[i][i] = m\\n            for j in range(i+1, n):\\n                if nums[j] > m:\\n                    m = nums[j]\\n                maxv[i][j] = m\\n\\n        def waste(i, j):\\n            length = j - i + 1\\n            return maxv[i][j] * length - (prefix[j+1] - prefix[i])\\n\\n        max_seg = min(k+1, n)\\n        INF = 10**30\\n        dp = [[INF]*n for _ in range(max_seg+1)]\\n        # Base: one segment\\n        for i in range(n):\\n            dp[1][i] = waste(0, i)\\n\\n        for seg in range(2, max_seg+1):\\n            for i in range(seg-1, n):\\n                best = INF\\n                for p in range(seg-2, i):\\n                    val = dp[seg-1][p] + waste(p+1, i)\\n                    if val < best:\\n                        best = val\\n                dp[seg][i] = best\\n\\n        return dp[max_seg][n-1]\\n\"",
  "111_14631217_python-updated-time": "1745081266920",
  "824_14631217_python": "\"class Solution(object):\\n    def numberOfLines(self, widths, s):\\n        lines = 1\\n        curr_width = 0\\n        for c in s:\\n            w = widths[ord(c) - ord('a')]\\n            if curr_width + w > 100:\\n                lines += 1\\n                curr_width = w\\n            else:\\n                curr_width += w\\n        return [lines, curr_width]\\n\"",
  "829_14631217_python": "\"class Solution(object):\\n    def subdomainVisits(self, cpdomains):\\n        count = {}\\n        for entry in cpdomains:\\n            rep, domain = entry.split()\\n            rep = int(rep)\\n            frags = domain.split('.')\\n            for i in range(len(frags)):\\n                subdomain = '.'.join(frags[i:])\\n                count[subdomain] = count.get(subdomain, 0) + rep\\n        return [str(v) + \\\" \\\" + k for k, v in count.items()]\\n\"",
  "2307_14631217_python-updated-time": "1746810198582",
  "54_14631217_python": "\"class Solution(object):\\n    def spiralOrder(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        if not matrix:\\n            return res\\n\\n        top, bottom = 0, len(matrix) - 1\\n        left, right = 0, len(matrix[0]) - 1\\n\\n        while top <= bottom and left <= right:\\n            for i in range(left, right + 1):\\n                res.append(matrix[top][i])\\n            top += 1\\n\\n            for i in range(top, bottom + 1):\\n                res.append(matrix[i][right])\\n            right -= 1\\n\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    res.append(matrix[bottom][i])\\n                bottom -= 1\\n\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    res.append(matrix[i][left])\\n                left += 1\\n\\n        return res\\n\"",
  "3578_14631217_python-updated-time": "1747577462789",
  "3047_14631217_python-updated-time": "1747227617789",
  "902_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        max_heap = []\\n        i = 0\\n        fuel = startFuel\\n        stops = 0\\n        \\n        while fuel < target:\\n            while i < len(stations) and stations[i][0] <= fuel:\\n                heapq.heappush(max_heap, -stations[i][1])\\n                i += 1\\n            if not max_heap:\\n                return -1\\n            fuel += -heapq.heappop(max_heap)\\n            stops += 1\\n        \\n        return stops\\n\"",
  "2147_14631217_python-updated-time": "1746719367474",
  "3772_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumPairRemoval(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n <= 1:\\n            return 0\\n\\n        # Doubly‐linked‐list pointers\\n        left  = [i-1 for i in range(n)]\\n        right = [i+1 for i in range(n)]\\n        right[n-1] = -1\\n\\n        alive = [True]*n\\n        vals  = nums[:]\\n\\n        # Count initial inversions: positions i where vals[i] < vals[i-1]\\n        inv_count = 0\\n        for i in range(1, n):\\n            if vals[i] < vals[i-1]:\\n                inv_count += 1\\n        if inv_count == 0:\\n            return 0\\n\\n        # Min‐heap of (sum, left_index)\\n        heap = [(vals[i] + vals[i+1], i) for i in range(n-1)]\\n        heapq.heapify(heap)\\n\\n        ops = 0\\n        while inv_count > 0 and heap:\\n            s, i = heapq.heappop(heap)\\n            j = right[i]\\n            # stale?\\n            if j == -1 or not alive[i] or not alive[j] or s != vals[i] + vals[j]:\\n                continue\\n\\n            # Before removal: remove any inversions involving j or its neighbors\\n            #  — the pairs (j, left[j]) and (right[j], j)\\n            if left[j] != -1 and vals[j] < vals[left[j]]:\\n                inv_count -= 1\\n            if right[j] != -1 and vals[right[j]] < vals[j]:\\n                inv_count -= 1\\n\\n            # Also remove the inversion at (i, left[i]) if it exists,\\n            # because vals[i] is about to change\\n            if left[i] != -1 and vals[i] < vals[left[i]]:\\n                inv_count -= 1\\n\\n            # Merge j into i\\n            vals[i] = s\\n            alive[j] = False\\n\\n            # Relink: skip over j\\n            r = right[j]\\n            right[i] = r\\n            if r != -1:\\n                left[r] = i\\n\\n            # Push the two new adjacent sums involving i\\n            if left[i] != -1:\\n                heapq.heappush(heap, (vals[left[i]] + vals[i], left[i]))\\n            if r != -1:\\n                heapq.heappush(heap, (vals[i] + vals[r], i))\\n\\n            # After merge: recheck the two adjacencies that may now be inverted\\n            #  — at (i, left[i]) and at (r, i)\\n            if left[i] != -1 and vals[i] < vals[left[i]]:\\n                inv_count += 1\\n            if r     != -1 and vals[r] < vals[i]:\\n                inv_count += 1\\n\\n            ops += 1\\n\\n        return ops\\n\"",
  "1327_14631217_mysql": "\"WITH boarding AS (\\n  SELECT\\n    person_name,\\n    weight,\\n    SUM(weight) OVER (ORDER BY turn) AS total_weight,\\n    turn\\n  FROM Queue\\n)\\nSELECT person_name\\nFROM boarding\\nWHERE total_weight <= 1000\\nORDER BY turn DESC\\nLIMIT 1;\\n\"",
  "608_14631217_mysql": "\"SELECT\\n    t.id,\\n    CASE\\n        WHEN t.p_id IS NULL THEN 'Root'\\n        WHEN EXISTS (\\n            SELECT 1\\n            FROM Tree c\\n            WHERE c.p_id = t.id\\n        ) THEN 'Inner'\\n        ELSE 'Leaf'\\n    END AS type\\nFROM Tree t;\\n\"",
  "717_14631217_python-updated-time": "1745786657685",
  "787_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def slidingPuzzle(self, board):\\n        target = \\\"123450\\\"\\n        start = ''.join(str(c) for row in board for c in row)\\n        \\n        neighbors = {\\n            0: [1, 3],\\n            1: [0, 2, 4],\\n            2: [1, 5],\\n            3: [0, 4],\\n            4: [1, 3, 5],\\n            5: [2, 4]\\n        }\\n        \\n        queue = deque([(start, 0)])\\n        visited = set([start])\\n        \\n        while queue:\\n            state, step = queue.popleft()\\n            if state == target:\\n                return step\\n            idx = state.index('0')\\n            for nei in neighbors[idx]:\\n                lst = list(state)\\n                lst[idx], lst[nei] = lst[nei], lst[idx]\\n                new_state = ''.join(lst)\\n                if new_state not in visited:\\n                    visited.add(new_state)\\n                    queue.append((new_state, step + 1))\\n        \\n        return -1\\n\"",
  "2855_14631217_python": "\"class Solution:\\n    def maximumJumps(self, nums, target):\\n        n = len(nums)\\n        dp = [-1] * n\\n        dp[0] = 0\\n\\n        for i in range(n):\\n            if dp[i] == -1:\\n                continue\\n            for j in range(i + 1, n):\\n                if abs(nums[j] - nums[i]) <= target:\\n                    dp[j] = max(dp[j], dp[i] + 1)\\n\\n        return dp[-1]\\n\"",
  "1316_14631217_python": "\"import threading\\n\\nclass FizzBuzz(object):\\n    def __init__(self, n):\\n        self.n = n\\n        self.current = 1\\n        self.cond = threading.Condition()\\n\\n    def fizz(self, printFizz):\\n        while True:\\n            with self.cond:\\n                while self.current <= self.n and (self.current % 3 != 0 or self.current % 5 == 0):\\n                    self.cond.wait()\\n                if self.current > self.n:\\n                    self.cond.notify_all()\\n                    return\\n                printFizz()\\n                self.current += 1\\n                self.cond.notify_all()\\n\\n    def buzz(self, printBuzz):\\n        while True:\\n            with self.cond:\\n                while self.current <= self.n and (self.current % 5 != 0 or self.current % 3 == 0):\\n                    self.cond.wait()\\n                if self.current > self.n:\\n                    self.cond.notify_all()\\n                    return\\n                printBuzz()\\n                self.current += 1\\n                self.cond.notify_all()\\n\\n    def fizzbuzz(self, printFizzBuzz):\\n        while True:\\n            with self.cond:\\n                while self.current <= self.n and (self.current % 3 != 0 or self.current % 5 != 0):\\n                    self.cond.wait()\\n                if self.current > self.n:\\n                    self.cond.notify_all()\\n                    return\\n                printFizzBuzz()\\n                self.current += 1\\n                self.cond.notify_all()\\n\\n    def number(self, printNumber):\\n        while True:\\n            with self.cond:\\n                while self.current <= self.n and (self.current % 3 == 0 or self.current % 5 == 0):\\n                    self.cond.wait()\\n                if self.current > self.n:\\n                    self.cond.notify_all()\\n                    return\\n                printNumber(self.current)\\n                self.current += 1\\n                self.cond.notify_all()\\n\"",
  "3659_14631217_python": "\"class Solution(object):\\n    def countPathsWithXorValue(self, grid, k):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dp[i][j][x] = #paths to (i,j) whose XOR-sum is x\\n        dp = [[[0]*16 for _ in range(n)] for _ in range(m)]\\n        dp[0][0][ grid[0][0] ] = 1\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # propagate from (i,j) to right/down\\n                for x in range(16):\\n                    cnt = dp[i][j][x]\\n                    if not cnt:\\n                        continue\\n                    # move right\\n                    if j+1 < n:\\n                        nx = x ^ grid[i][j+1]\\n                        dp[i][j+1][nx] = (dp[i][j+1][nx] + cnt) % MOD\\n                    # move down\\n                    if i+1 < m:\\n                        nx = x ^ grid[i+1][j]\\n                        dp[i+1][j][nx] = (dp[i+1][j][nx] + cnt) % MOD\\n        \\n        return dp[m-1][n-1][k] % MOD\\n\"",
  "834_14631217_python-updated-time": "1745878740454",
  "456_14631217_python": "\"class Solution:\\n    def find132pattern(self, nums):\\n        stack = []\\n        third = float('-inf')\\n        for n in reversed(nums):\\n            if n < third:\\n                return True\\n            while stack and n > stack[-1]:\\n                third = stack.pop()\\n            stack.append(n)\\n        return False\\n\"",
  "1335_14631217_python": "\"class Solution(object):\\n    def maximumCandies(self, candies, k):\\n        lo, hi = 1, max(candies)\\n        ans = 0\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            cnt = 0\\n            for c in candies:\\n                cnt += c // mid\\n                if cnt >= k:\\n                    break\\n            if cnt >= k:\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return ans\\n\"",
  "2008_14631217_python": "\"class Solution:\\n    def minOperationsToFlip(self, expression):\\n        # ------------------------------------------------------------\\n        # For every sub-expression we keep a pair (val, flip)\\n        #   val   : 0 or 1  –  the value of the sub-expression\\n        #   flip  : minimum operations needed to flip that value\\n        #\\n        # For a literal:\\n        #   '0' → (0, 1)     (flip it by turning it to '1')\\n        #   '1' → (1, 1)     (flip it by turning it to '0')\\n        #\\n        # While combining two sub-expressions we evaluate the operator\\n        # that is really present and *also* consider flipping it\\n        # (cost +1) to find the cheapest way to reach both results 0\\n        # and 1.  Finally we return the cost that flips the actual\\n        # result.\\n        # ------------------------------------------------------------\\n        vals, ops = [], []\\n\\n        # helper that returns (val, flip) for a ←op→ b\\n        def combine(a, b, op):\\n            v1, f1 = a\\n            v2, f2 = b\\n\\n            # cost to force a (sub-)expression to 0 / 1\\n            a0 = 0 if v1 == 0 else f1\\n            a1 = 0 if v1 == 1 else f1\\n            b0 = 0 if v2 == 0 else f2\\n            b1 = 0 if v2 == 1 else f2\\n\\n            if op == '&':\\n                res = v1 & v2\\n                # keep '&'\\n                keep0 = min(a0 + b0, a0 + b1, a1 + b0)\\n                keep1 = a1 + b1\\n                # flip to '|'\\n                flip0 = 1 + (a0 + b0)\\n                flip1 = 1 + min(a1 + b1, a1 + b0, a0 + b1)\\n            else:  # op == '|'\\n                res = v1 | v2\\n                # keep '|'\\n                keep0 = a0 + b0\\n                keep1 = min(a1 + b1, a1 + b0, a0 + b1)\\n                # flip to '&'\\n                flip0 = 1 + min(a0 + b0, a0 + b1, a1 + b0)\\n                flip1 = 1 + (a1 + b1)\\n\\n            best0 = min(keep0, flip0)\\n            best1 = min(keep1, flip1)\\n            flip = best1 if res == 0 else best0\\n            return (res, flip)\\n\\n        def apply():\\n            b = vals.pop()\\n            a = vals.pop()\\n            op = ops.pop()\\n            vals.append(combine(a, b, op))\\n\\n        for ch in expression:\\n            if ch in '01':\\n                vals.append((int(ch), 1))\\n            elif ch == '(':\\n                ops.append(ch)\\n            elif ch in '&|':\\n                # '&' and '|' have the same precedence and are\\n                # evaluated left-to-right.\\n                while ops and ops[-1] in '&|':\\n                    apply()\\n                ops.append(ch)\\n            else:  # ch == ')'\\n                while ops and ops[-1] != '(':\\n                    apply()\\n                ops.pop()          # discard '('\\n\\n        while ops:\\n            apply()\\n\\n        # vals[0] now holds (value, min cost to flip)\\n        return vals[0][1]\\n\"",
  "2187_14631217_python": "\"class Solution:\\n    def countVowels(self, word):\\n        \\\"\\\"\\\"\\n        :param word: str\\n        :return: int  # sum of vowels over all substrings\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        vowels = set('aeiou')\\n        total = 0\\n\\n        for i, ch in enumerate(word):\\n            if ch in vowels:\\n                # number of substrings including position i is (i+1)*(n-i)\\n                total += (i + 1) * (n - i)\\n\\n        return total\\n\"",
  "675_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        if not forest or not forest[0]:\\n            return -1\\n        \\n        m, n = len(forest), len(forest[0])\\n        trees = sorted((h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1)\\n        \\n        def bfs(sx, sy, tx, ty):\\n            if sx == tx and sy == ty:\\n                return 0\\n            visited = [[False] * n for _ in range(m)]\\n            queue = deque([(sx, sy, 0)])\\n            visited[sx][sy] = True\\n            while queue:\\n                x, y, d = queue.popleft()\\n                for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and forest[nx][ny] != 0:\\n                        if nx == tx and ny == ty:\\n                            return d + 1\\n                        visited[nx][ny] = True\\n                        queue.append((nx, ny, d + 1))\\n            return -1\\n        \\n        sx = sy = 0\\n        total_steps = 0\\n        for h, tx, ty in trees:\\n            steps = bfs(sx, sy, tx, ty)\\n            if steps == -1:\\n                return -1\\n            total_steps += steps\\n            sx, sy = tx, ty\\n        \\n        return total_steps\\n\"",
  "1025_14631217_python-updated-time": "1746040335631",
  "1682_14631217_python": "\"class Solution(object):\\n    def mostVisited(self, n, rounds):\\n        start, end = rounds[0], rounds[-1]\\n        if start <= end:\\n            return list(range(start, end + 1))\\n        return list(range(1, end + 1)) + list(range(start, n + 1))\\n\"",
  "1667_14631217_python-updated-time": "1746434375988",
  "1093_14631217_python-updated-time": "1746041998874",
  "1491_14631217_python-updated-time": "1746345718051",
  "862_14631217_python-updated-time": "1745879391228",
  "notification-status:numUnread-updated-time": "1747318045122",
  "2100_14631217_python": "\"class Solution(object):\\n    def minNonZeroProduct(self, p):\\n        MOD = 10**9 + 7\\n        # M = 2^p\\n        M = 1 << p\\n        M1 = M - 1             # 2^p - 1\\n        base = M1 - 1          # 2^p - 2\\n        exp = (M1) // 2        # (2^p - 1)//2 = 2^{p-1} - 1\\n        return (M1 % MOD) * pow(base % MOD, exp, MOD) % MOD\\n\"",
  "3788_14631217_python-updated-time": "1747681552733",
  "1458_14631217_python-updated-time": "1746345196299",
  "378_14631217_python": "\"class Solution:\\n    def kthSmallest(self, matrix, k):\\n        n = len(matrix)\\n        \\n        def count_less_equal(x):\\n            count = 0\\n            row, col = n - 1, 0\\n            while row >= 0 and col < n:\\n                if matrix[row][col] <= x:\\n                    count += row + 1\\n                    col += 1\\n                else:\\n                    row -= 1\\n            return count\\n        \\n        left, right = matrix[0][0], matrix[-1][-1]\\n        while left < right:\\n            mid = (left + right) // 2\\n            if count_less_equal(mid) < k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n\"",
  "446_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums):\\n        n = len(nums)\\n        dp = [defaultdict(int) for _ in range(n)]\\n        res = 0\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                diff = nums[i] - nums[j]\\n                count = dp[j][diff]\\n                res += count\\n                dp[i][diff] += count + 1\\n        \\n        return res\\n\"",
  "480_14631217_python-updated-time": "1745441585621",
  "1313_14631217_python": "\"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(1 << 20)\\n\\nMOD = 10**9 + 7\\n\\nclass Solution:\\n    def waysToBuildRooms(self, prevRoom):\\n        n = len(prevRoom)\\n        tree = defaultdict(list)\\n        for child, parent in enumerate(prevRoom):\\n            if parent != -1:\\n                tree[parent].append(child)\\n\\n        # Precompute factorials and inverse factorials\\n        fact = [1] * (n + 1)\\n        inv_fact = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            fact[i] = fact[i - 1] * i % MOD\\n\\n        inv_fact[n] = pow(fact[n], MOD - 2, MOD)\\n        for i in range(n - 1, 0, -1):\\n            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\\n\\n        def comb_mod(n, k):\\n            return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\\n\\n        def dfs(node):\\n            total_size = 1\\n            total_ways = 1\\n\\n            for child in tree[node]:\\n                size_c, ways_c = dfs(child)\\n                total_ways = total_ways * ways_c % MOD\\n                total_ways = total_ways * comb_mod(total_size + size_c - 1, size_c) % MOD\\n                total_size += size_c\\n\\n            return total_size, total_ways\\n\\n        return dfs(0)[1]\\n\"",
  "2893_14631217_python-updated-time": "1747222535000",
  "496_14631217_python": "\"class Solution:\\n    def nextGreaterElement(self, nums1, nums2):\\n        stack = []\\n        next_greater = {}\\n        \\n        for num in nums2:\\n            while stack and stack[-1] < num:\\n                prev = stack.pop()\\n                next_greater[prev] = num\\n            stack.append(num)\\n        \\n        return [next_greater.get(num, -1) for num in nums1]\\n\"",
  "2486_14631217_python-updated-time": "1746965923119",
  "2665_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def repairCars(self, ranks, cars):\\n        # 1) Group mechanics by rank\\n        freq = [0] * 101\\n        r_min = float('inf')\\n        for r in ranks:\\n            freq[r] += 1\\n            if r < r_min:\\n                r_min = r\\n\\n        # 2) Binary‐search the minimal time T\\n        lo, hi = 0, r_min * (cars ** 2)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            total = 0\\n            for r in range(1, 101):\\n                if freq[r]:\\n                    # max cars one rank-r mechanic can do in 'mid' minutes:\\n                    # solve r * n^2 <= mid  →  n <= sqrt(mid/r)\\n                    # use float sqrt then floor\\n                    done = int(math.sqrt(mid // r))\\n                    total += freq[r] * done\\n                    if total >= cars:\\n                        break\\n            if total >= cars:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n\"",
  "776_14631217_python-updated-time": "1745448221698",
  "88_14631217_python": "\"class Solution(object):\\n    def merge(self, nums1, m, nums2, n):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type m: int\\n        :type nums2: List[int]\\n        :type n: int\\n        :rtype: None Do not return anything, modify nums1 in-place instead.\\n        \\\"\\\"\\\"\\n        p1 = m - 1\\n        p2 = n - 1\\n        p = m + n - 1\\n\\n        while p1 >= 0 and p2 >= 0:\\n            if nums1[p1] > nums2[p2]:\\n                nums1[p] = nums1[p1]\\n                p1 -= 1\\n            else:\\n                nums1[p] = nums2[p2]\\n                p2 -= 1\\n            p -= 1\\n\\n        while p2 >= 0:\\n            nums1[p] = nums2[p2]\\n            p2 -= 1\\n            p -= 1\\n\"",
  "3201_14631217_python-updated-time": "1747310375974",
  "116_14631217_python-updated-time": "1745081425856",
  "2129_14631217_python-updated-time": "1746717611618",
  "2283_14631217_python-updated-time": "1746803052426",
  "1848_14631217_python-updated-time": "1746531363087",
  "1537_14631217_python-updated-time": "1746347002376",
  "3832_14631217_python": "\"class Solution(object):\\n    def minCosts(self, cost):\\n        \\\"\\\"\\\"\\n        :type cost: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(cost)\\n        answer = [0] * n\\n        prefix_min = float('inf')\\n        \\n        for i in range(n):\\n            prefix_min = min(prefix_min, cost[i])\\n            answer[i] = prefix_min\\n        \\n        return answer\\n\"",
  "1772_14631217_python": "\"class Solution:\\n    def createSortedArray(self, instructions):\\n        MOD = 10**9 + 7\\n        # Coordinate maximum\\n        M = max(instructions)\\n        # Fenwick tree for frequencies, size M+1 (1-indexed)\\n        bit = [0] * (M + 2)\\n        \\n        def update(i, v):\\n            while i <= M+1:\\n                bit[i] += v\\n                i += i & -i\\n        \\n        def query(i):\\n            # sum from 1..i\\n            s = 0\\n            while i > 0:\\n                s += bit[i]\\n                i -= i & -i\\n            return s\\n        \\n        cost = 0\\n        total = 0  # total elements inserted so far\\n        \\n        for x in instructions:\\n            # map x to index x+1 in BIT to avoid zero\\n            idx = x + 1\\n            less = query(idx - 1)\\n            greater = total - query(idx)\\n            cost += min(less, greater)\\n            cost %= MOD\\n            \\n            # insert x\\n            update(idx, 1)\\n            total += 1\\n        \\n        return cost\\n\"",
  "3476_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ops = 0\\n        for x in nums:\\n            r = x % 3\\n            ops += min(r, 3 - r)\\n        return ops\\n\"",
  "2495_14631217_mysql": "\"SELECT\\n  teacher_id,\\n  COUNT(DISTINCT subject_id) AS cnt\\nFROM Teacher\\nGROUP BY teacher_id;\\n\"",
  "3000_14631217_python-updated-time": "1747225396656",
  "1587_14631217_python-updated-time": "1746433024591",
  "3690_14631217_python-updated-time": "1747651788678",
  "1020_14631217_python-updated-time": "1746040132508",
  "75_14631217_python": "\"class Solution(object):\\n    def sortColors(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        low, mid, high = 0, 0, len(nums) - 1\\n\\n        while mid <= high:\\n            if nums[mid] == 0:\\n                nums[low], nums[mid] = nums[mid], nums[low]\\n                low += 1\\n                mid += 1\\n            elif nums[mid] == 1:\\n                mid += 1\\n            else:\\n                nums[mid], nums[high] = nums[high], nums[mid]\\n                high -= 1\\n\"",
  "1762_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def furthestBuilding(self, heights, bricks, ladders):\\n        min_heap = []\\n        \\n        for i in range(len(heights) - 1):\\n            climb = heights[i+1] - heights[i]\\n            if climb > 0:\\n                heapq.heappush(min_heap, climb)\\n                # If we've used more climbs than ladders, pay the smallest with bricks\\n                if len(min_heap) > ladders:\\n                    bricks -= heapq.heappop(min_heap)\\n                    if bricks < 0:\\n                        # Can't afford even the smallest climb\\n                        return i\\n        # If we never ran out of resources, we reach the last building\\n        return len(heights) - 1\\n\"",
  "3166_14631217_python": "\"from collections import Counter\\nimport math\\n\\nclass Solution:\\n    def minGroupsForValidAssignment(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # frequency of each distinct value\\n        cnt = Counter(nums).values()\\n        min_cnt = min(cnt)                # smallest frequency among all values\\n        ans = float(\\\"inf\\\")\\n\\n        # Let g be the minimum size of any box (1 … min_cnt).\\n        # Every box then has size g or g+1.\\n        # For a count c, the fewest boxes needed is ceil(c/(g+1)).\\n        # Try every g; the total work over all g is O(sum cnt) ≤ 1e5.\\n        for g in range(1, min_cnt + 1):\\n            total_boxes = 0\\n            ok = True\\n            for c in cnt:\\n                # number of boxes for this value\\n                boxes = (c + g) // (g + 1)    # == ceil(c/(g+1))\\n                # Each box must have at least g balls,\\n                # so we need boxes * g ≤ c.  If not, g is impossible.\\n                if boxes * g > c:\\n                    ok = False\\n                    break\\n                total_boxes += boxes\\n            if ok:\\n                ans = min(ans, total_boxes)\\n\\n        return ans if ans != float(\\\"inf\\\") else len(nums)\\n\"",
  "1395_14631217_python": "\"class Solution:\\n    def minTimeToVisitAllPoints(self, points):\\n        time = 0\\n        for i in range(1, len(points)):\\n            x0, y0 = points[i - 1]\\n            x1, y1 = points[i]\\n            dx = abs(x1 - x0)\\n            dy = abs(y1 - y0)\\n            time += max(dx, dy)\\n        return time\\n\"",
  "382_14631217_python": "\"import random\\n\\nclass Solution:\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        current = self.head\\n        chosen = current.val\\n        count = 1\\n        \\n        while current:\\n            if random.randint(1, count) == 1:\\n                chosen = current.val\\n            current = current.next\\n            count += 1\\n        \\n        return chosen\\n\"",
  "678_14631217_python-updated-time": "1745784942570",
  "2015_14631217_python-updated-time": "1746626425783",
  "3687_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def longestSpecialPath(self, edges, nums):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type nums:   List[int]\\n        :rtype:       List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # 1) Build undirected adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n\\n        # 2) Root the tree at 0 with a BFS: record parent, depth, and children[]\\n        parent   = [-1] * n\\n        parent[0] = 0\\n        depth    = [0] * n\\n        children = [[] for _ in range(n)]\\n        dq = deque([0])\\n        while dq:\\n            u = dq.popleft()\\n            for v, w in adj[u]:\\n                if parent[v] == -1:\\n                    parent[v] = u\\n                    depth[v]  = depth[u] + w\\n                    children[u].append(v)\\n                    dq.append(v)\\n\\n        # 3) State for our DFS + sliding window:\\n        path_nodes     = []    # stack of node-ids on the root→u path\\n        dist_prefix    = []    # dist_prefix[i] = depth[path_nodes[i]]\\n        last_occurrence = {}   # maps value → last index in path_nodes\\n\\n        # wrap scalars in lists so we can mutate them inside dfs()\\n        start_idx    = [0]\\n        ans_length   = [0]\\n        ans_node_cnt = [1]      # even a single node (0‐length path) counts\\n\\n        def dfs(u):\\n            idx = len(path_nodes)\\n            prev_start = start_idx[0]\\n            prev_last  = last_occurrence.get(nums[u], None)\\n\\n            # push u\\n            path_nodes.append(u)\\n            dist_prefix.append(depth[u])\\n\\n            # if we saw nums[u] in the current window, slide start up\\n            if prev_last is not None and prev_last >= start_idx[0]:\\n                start_idx[0] = prev_last + 1\\n            last_occurrence[nums[u]] = idx\\n\\n            # compute special‐path length & node count\\n            cur_len = dist_prefix[idx] - dist_prefix[start_idx[0]]\\n            cur_cnt = idx - start_idx[0] + 1\\n            # update global best\\n            if (cur_len > ans_length[0]) or \\\\\\n               (cur_len == ans_length[0] and cur_cnt < ans_node_cnt[0]):\\n                ans_length[0]   = cur_len\\n                ans_node_cnt[0] = cur_cnt\\n\\n            # recurse to children\\n            for v in children[u]:\\n                dfs(v)\\n\\n            # backtrack\\n            path_nodes.pop()\\n            dist_prefix.pop()\\n            if prev_last is None:\\n                del last_occurrence[nums[u]]\\n            else:\\n                last_occurrence[nums[u]] = prev_last\\n            start_idx[0] = prev_start\\n\\n        # kick off\\n        dfs(0)\\n        return [ans_length[0], ans_node_cnt[0]]\\n\"",
  "961_14631217_python": "\"class Solution:\\n    def isLongPressedName(self, name, typed):\\n        i = j = 0\\n        while j < len(typed):\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif j > 0 and typed[j] == typed[j - 1]:\\n                j += 1\\n            else:\\n                return False\\n        return i == len(name)\\n\"",
  "183_14631217_mysql-updated-time": "1745092553221",
  "65_14631217_python": "\"class Solution(object):\\n    def isNumber(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        s = s.strip()\\n        if not s:\\n            return False\\n        \\n        seen_digit = seen_dot = seen_exp = False\\n\\n        for i, char in enumerate(s):\\n            if char.isdigit():\\n                seen_digit = True\\n            elif char in ['+', '-']:\\n                if i > 0 and s[i-1] not in ['e', 'E']:\\n                    return False\\n            elif char == '.':\\n                if seen_dot or seen_exp:\\n                    return False\\n                seen_dot = True\\n            elif char in ['e', 'E']:\\n                if seen_exp or not seen_digit:\\n                    return False\\n                seen_exp = True\\n                seen_digit = False\\n            else:\\n                return False\\n        \\n        return seen_digit\\n\"",
  "1273_14631217_python": "\"from bisect import bisect_right\\n\\nclass Solution(object):\\n    def numSmallerByFrequency(self, queries, words):\\n        \\\"\\\"\\\"\\n        :type queries: List[str]\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def f(s):\\n            return s.count(min(s))\\n\\n        word_freqs = sorted(f(w) for w in words)\\n        result = []\\n\\n        for q in queries:\\n            fq = f(q)\\n            # Find how many word frequencies are > fq\\n            count = len(word_freqs) - bisect_right(word_freqs, fq)\\n            result.append(count)\\n\\n        return result\\n\"",
  "1801_14631217_mysql": "\"SELECT\\n  machine_id,\\n  ROUND(\\n    AVG(end_time - start_time),\\n    3\\n  ) AS processing_time\\nFROM (\\n  SELECT\\n    machine_id,\\n    process_id,\\n    MAX(CASE WHEN activity_type = 'end'   THEN timestamp END) AS end_time,\\n    MAX(CASE WHEN activity_type = 'start' THEN timestamp END) AS start_time\\n  FROM Activity\\n  GROUP BY machine_id, process_id\\n) AS proc_times\\nGROUP BY machine_id;\\n\"",
  "3859_14631217_python": "\"class Solution(object):\\n    def maxProduct(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Extract digits\\n        digits = [int(d) for d in str(n)]\\n        # Sort descending\\n        digits.sort(reverse=True)\\n        # The maximum product is the product of the two largest digits\\n        return digits[0] * digits[1]\\n\"",
  "394_14631217_python": "\"class Solution:\\n    def decodeString(self, s):\\n        stack = []\\n        current_num = 0\\n        current_str = ''\\n        \\n        for char in s:\\n            if char.isdigit():\\n                current_num = current_num * 10 + int(char)\\n            elif char == '[':\\n                stack.append((current_str, current_num))\\n                current_str = ''\\n                current_num = 0\\n            elif char == ']':\\n                prev_str, num = stack.pop()\\n                current_str = prev_str + current_str * num\\n            else:\\n                current_str += char\\n        \\n        return current_str\\n\"",
  "1643_14631217_python-updated-time": "1746433641186",
  "2333_14631217_python-updated-time": "1746880141880",
  "2414_14631217_python-updated-time": "1746907356635",
  "1738_14631217_python-updated-time": "1746444132033",
  "2571_14631217_python": "\"class Solution(object):\\n    def pivotInteger(self, n):\\n        total = n * (n + 1) // 2\\n        r = int(total**0.5)\\n        return r if r * r == total else -1\\n\"",
  "830_14631217_python-updated-time": "1745878608251",
  "1689_14631217_python-updated-time": "1746438008153",
  "1631_14631217_python": "\"class Solution(object):\\n    def numOfSubarrays(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        odd = 0\\n        even = 1  # empty prefix\\n        total = 0\\n        prefix = 0\\n\\n        for num in arr:\\n            prefix += num\\n            if prefix % 2 == 0:\\n                total += odd\\n                even += 1\\n            else:\\n                total += even\\n                odd += 1\\n\\n        return total % MOD\\n\"",
  "2792_14631217_python": "\"class Solution:\\n    def doesValidArrayExist(self, derived):\\n        xor_sum = 0\\n        for val in derived:\\n            xor_sum ^= val\\n        return xor_sum == 0\\n\"",
  "1185_14631217_python": "\"# This is the MountainArray's API interface.\\n# You should not implement it, or speculate about its implementation.\\n# class MountainArray(object):\\n#     def get(self, index):\\n#         # Returns the element at index\\n#     def length(self):\\n#         # Returns the length of the array\\n\\nclass Solution(object):\\n    def findInMountainArray(self, target, mountain_arr):\\n        \\\"\\\"\\\"\\n        :type target: int\\n        :type mountain_arr: MountainArray\\n        :rtype: int\\n        \\\"\\\"\\\"\\n\\n        def find_peak():\\n            left, right = 0, mountain_arr.length() - 1\\n            while left < right:\\n                mid = (left + right) // 2\\n                if mountain_arr.get(mid) < mountain_arr.get(mid + 1):\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            return left\\n\\n        def binary_search(left, right, target, ascending=True):\\n            while left <= right:\\n                mid = (left + right) // 2\\n                val = mountain_arr.get(mid)\\n                if val == target:\\n                    return mid\\n                if ascending:\\n                    if val < target:\\n                        left = mid + 1\\n                    else:\\n                        right = mid - 1\\n                else:\\n                    if val > target:\\n                        left = mid + 1\\n                    else:\\n                        right = mid - 1\\n            return -1\\n\\n        peak = find_peak()\\n        res = binary_search(0, peak, target, ascending=True)\\n        if res != -1:\\n            return res\\n        return binary_search(peak + 1, mountain_arr.length() - 1, target, ascending=False)\\n\"",
  "1250_14631217_python-updated-time": "1746125745129",
  "611_14631217_python-updated-time": "1745780437225",
  "594_14631217_python-updated-time": "1745448423711",
  "2288_14631217_python": "\"class Solution(object):\\n    def countOperations(self, num1, num2):\\n        ops = 0\\n        while num1 != 0 and num2 != 0:\\n            if num1 >= num2:\\n                ops += num1 // num2\\n                num1 %= num2\\n            else:\\n                ops += num2 // num1\\n                num2 %= num1\\n        return ops\\n\"",
  "2778_14631217_python-updated-time": "1747137269277",
  "2739_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # Helper to find path and increment freq\\n        freq = [0]*n\\n        def dfs_path(src, dst):\\n            # return path list from src to dst\\n            stack = [(src, -1)]\\n            parent = {src: None}\\n            while stack:\\n                u, p = stack.pop()\\n                if u==dst: break\\n                for v in adj[u]:\\n                    if v==p: continue\\n                    if v not in parent:\\n                        parent[v]=u\\n                        stack.append((v,u))\\n            # reconstruct path\\n            path = []\\n            cur = dst\\n            while cur is not None:\\n                path.append(cur)\\n                cur = parent[cur]\\n            path.reverse()\\n            return path\\n        # accumulate frequencies\\n        for s,t in trips:\\n            path = dfs_path(s,t)\\n            for u in path:\\n                freq[u]+=1\\n        # base cost\\n        base = sum(freq[i]*price[i] for i in range(n))\\n        # compute savings weights\\n        weight = [freq[i]*price[i]//2 for i in range(n)]\\n        # DP on tree for maximum savings\\n        # root at 0\\n        seen = [False]*n\\n        def dfs(u):\\n            seen[u]=True\\n            take = weight[u]  # if we take u\\n            notake = 0        # if we don't take u\\n            for v in adj[u]:\\n                if seen[v]: continue\\n                t_v, nt_v = dfs(v)\\n                # if u taken, children cannot be taken\\n                take += nt_v\\n                # if u not taken, children may be taken or not\\n                notake += max(t_v, nt_v)\\n            return take, notake\\n        max_save, no_save = dfs(0)\\n        best_save = max(max_save, no_save)\\n        return base - best_save\"",
  "2849_14631217_python": "\"class Solution:\\n    def sumImbalanceNumbers(self, nums):\\n        n = len(nums)\\n        total = 0\\n        \\n        for i in range(n):\\n            seen = set()\\n            cur = 0\\n            seen.add(nums[i])\\n            for j in range(i + 1, n):\\n                x = nums[j]\\n                if x not in seen:\\n                    if x - 1 in seen and x + 1 in seen:\\n                        cur -= 1\\n                    elif x - 1 not in seen and x + 1 not in seen:\\n                        cur += 1\\n                    # else: exactly one neighbor is in → imbalance doesn't change\\n                seen.add(x)\\n                total += cur\\n        \\n        return total\\n\"",
  "953_14631217_python": "\"class Solution:\\n    def reverseOnlyLetters(self, s):\\n        letters = [c for c in s if c.isalpha()]\\n        res = []\\n        for c in s:\\n            if c.isalpha():\\n                res.append(letters.pop())\\n            else:\\n                res.append(c)\\n        return ''.join(res)\\n\"",
  "2521_14631217_python-updated-time": "1746967657021",
  "1146_14631217_python-updated-time": "1746107802011",
  "225_14631217_python-updated-time": "1745246923920",
  "2998_14631217_python": "\"class Solution(object):\\n    def countSymmetricIntegers(self, low, high):\\n        \\\"\\\"\\\"\\n        :type low: int\\n        :type high: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        cnt = 0\\n        for x in range(low, high + 1):\\n            s = str(x)\\n            L = len(s)\\n            if L % 2 != 0:\\n                continue\\n            half = L // 2\\n            if sum(int(c) for c in s[:half]) == sum(int(c) for c in s[half:]):\\n                cnt += 1\\n        return cnt\\n\"",
  "1073_14631217_python-updated-time": "1746041758399",
  "1710_14631217_python-updated-time": "1746443948741",
  "1322_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        n = len(grid)\\n        # state: (r, c, orient) orient: 0=horizontal (tail at r,c, head at r,c+1), 1=vertical (tail at r,c, head at r+1,c)\\n        start = (0, 0, 0)\\n        target = (n-1, n-2, 0)\\n        seen = set([start])\\n        dq = deque([(start, 0)])\\n        while dq:\\n            (r, c, o), d = dq.popleft()\\n            if (r, c, o) == target:\\n                return d\\n            # move right\\n            if o == 0:\\n                # horizontal: head at (r, c+1), new tail at (r, c+1), new head at (r, c+2)\\n                if c+2 < n and grid[r][c+2] == 0:\\n                    nxt = (r, c+1, 0)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n            else:\\n                # vertical: head at (r+1, c), new tail at (r, c+1)\\n                if c+1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    nxt = (r, c+1, 1)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n            # move down\\n            if o == 0:\\n                # horizontal: tail at (r,c),(r,c+1) -> new tail at (r+1,c),(r+1,c+1)\\n                if r+1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    nxt = (r+1, c, 0)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n            else:\\n                # vertical: tail at (r,c),(r+1,c) -> new tail at (r+1,c),(r+2,c)\\n                if r+2 < n and grid[r+2][c] == 0:\\n                    nxt = (r+1, c, 1)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n            # rotate clockwise\\n            if o == 0:\\n                # horizontal -> vertical around tail: need cells (r+1,c) and (r+1,c+1)\\n                if r+1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    nxt = (r, c, 1)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n            else:\\n                # rotate counterclockwise: vertical -> horizontal around tail: need cells (r,c+1) and (r+1,c+1)\\n                if c+1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    nxt = (r, c, 0)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        dq.append((nxt, d+1))\\n        return -1\"",
  "2305_14631217_python": "\"class Solution(object):\\n    def minimalKSum(self, nums, k):\\n        nums = sorted(set(nums))\\n        ans = 0\\n        cur = 1\\n\\n        for x in nums:\\n            if cur >= x:           # current already inside or past this number\\n                cur = x + 1\\n                continue\\n\\n            gap = x - cur          # how many missing before x\\n            take = min(gap, k)     # how many of them we still need\\n\\n            last = cur + take - 1\\n            ans += (cur + last) * take // 2  # sum of arithmetic sequence\\n            k -= take\\n            if k == 0:\\n                return ans\\n\\n            cur = x + 1            # move just after x\\n\\n        # still need k numbers after largest x\\n        last = cur + k - 1\\n        ans += (cur + last) * k // 2\\n        return ans\\n\"",
  "3267_14631217_python-updated-time": "1747319247819",
  "2169_14631217_python": "\"class Bank(object):\\n    def __init__(self, balance):\\n        \\\"\\\"\\\"\\n        :type balance: List[int]\\n        \\\"\\\"\\\"\\n        self.balance = balance\\n        self.n = len(balance)\\n\\n    def _valid_account(self, account):\\n        return 1 <= account <= self.n\\n\\n    def transfer(self, account1, account2, money):\\n        \\\"\\\"\\\"\\n        :type account1: int\\n        :type account2: int\\n        :type money: long\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not self._valid_account(account1) or not self._valid_account(account2):\\n            return False\\n        if self.balance[account1 - 1] < money:\\n            return False\\n        self.balance[account1 - 1] -= money\\n        self.balance[account2 - 1] += money\\n        return True\\n\\n    def deposit(self, account, money):\\n        \\\"\\\"\\\"\\n        :type account: int\\n        :type money: long\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not self._valid_account(account):\\n            return False\\n        self.balance[account - 1] += money\\n        return True\\n\\n    def withdraw(self, account, money):\\n        \\\"\\\"\\\"\\n        :type account: int\\n        :type money: long\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not self._valid_account(account):\\n            return False\\n        if self.balance[account - 1] < money:\\n            return False\\n        self.balance[account - 1] -= money\\n        return True\\n\"",
  "1682_14631217_python-updated-time": "1746434818621",
  "3832_14631217_python-updated-time": "1747681680687",
  "867_14631217_python-updated-time": "1745879612262",
  "1451_14631217_python-updated-time": "1746261436836",
  "1063_14631217_python": "\"class Solution:\\n    def maxScoreSightseeingPair(self, values):\\n        max_i = values[0]  # values[i] + i\\n        max_score = 0\\n\\n        for j in range(1, len(values)):\\n            max_score = max(max_score, max_i + values[j] - j)\\n            max_i = max(max_i, values[j] + j)\\n\\n        return max_score\\n\"",
  "2227_14631217_python-updated-time": "1746799920526",
  "3178_14631217_python": "\"class Solution(object):\\n    def minIncrementOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # cover[i] = True if nums[i] >= k initially\\n        cover = [num >= k for num in nums]\\n        # cost to raise nums[i] up to k (0 if already >= k)\\n        cost = [max(0, k - num) for num in nums]\\n\\n        def solve_segment(costs):\\n            \\\"\\\"\\\"\\n            Given a list of costs for a consecutive segment of zeros (where cover=False),\\n            return the minimum total cost to select some positions so that\\n            no three consecutive positions remain unselected.\\n            Uses a small DP over states of consecutive unselected count.\\n            \\\"\\\"\\\"\\n            L = len(costs)\\n            INF = 10**30\\n            # dp[d] = min cost up to previous position,\\n            # with exactly d consecutive unselected positions at the end (d in {0,1,2})\\n            dp = [0, INF, INF]\\n\\n            for w in costs:\\n                ndp = [INF, INF, INF]\\n                for d in (0, 1, 2):\\n                    cur = dp[d]\\n                    if cur >= INF:\\n                        continue\\n                    # Option 1: select this position (pay w), resets run of unselected\\n                    ndp[0] = min(ndp[0], cur + w)\\n                    # Option 2: do not select: only if it won't create 3 unselected in a row\\n                    if d < 2:\\n                        ndp[d + 1] = min(ndp[d + 1], cur)\\n                dp = ndp\\n\\n            # any ending run of length 0,1,2 is fine\\n            res = min(dp)\\n            return res if res < INF else None\\n\\n        ans = 0\\n        i = 0\\n        while i < n:\\n            if cover[i]:\\n                i += 1\\n            else:\\n                # find the end of this zero-segment\\n                j = i\\n                while j < n and not cover[j]:\\n                    j += 1\\n                seg_cost = solve_segment(cost[i:j])\\n                if seg_cost is None:\\n                    return -1\\n                ans += seg_cost\\n                i = j\\n\\n        return ans\\n\"",
  "1770_14631217_python": "\"class Solution:\\n    def minDeletions(self, s):\\n        from collections import Counter\\n        \\n        freq_counts = list(Counter(s).values())\\n        freq_counts.sort(reverse=True)\\n        \\n        used = set()\\n        deletions = 0\\n        \\n        for f in freq_counts:\\n            # Decrease f until it's unique (or zero)\\n            while f > 0 and f in used:\\n                f -= 1\\n                deletions += 1\\n            if f > 0:\\n                used.add(f)\\n        \\n        return deletions\\n\"",
  "2394_14631217_python-updated-time": "1746882142616",
  "1956_14631217_python": "\"class Solution(object):\\n    def maximumElementAfterDecrementingAndRearranging(self, arr):\\n        arr.sort()\\n        cur = 1\\n        for x in arr:\\n            if x >= cur:\\n                cur += 1\\n        return cur - 1\\n\"",
  "3831_14631217_python-updated-time": "1747683730532",
  "682_14631217_python": "\"class Solution(object):\\n    def calPoints(self, ops):\\n        stack = []\\n        for op in ops:\\n            if op == '+':\\n                stack.append(stack[-1] + stack[-2])\\n            elif op == 'D':\\n                stack.append(2 * stack[-1])\\n            elif op == 'C':\\n                stack.pop()\\n            else:\\n                stack.append(int(op))\\n        return sum(stack)\\n\"",
  "2027_14631217_python-updated-time": "1746627094807",
  "2443_14631217_python": "\"class Solution(object):\\n    def validPartition(self, nums):\\n        n = len(nums)\\n        dp = [True, False, nums[0] == nums[1], False]\\n\\n        for i in range(2, n):\\n            two_equal = nums[i] == nums[i - 1]\\n            three_equal = nums[i] == nums[i - 1] == nums[i - 2]\\n            three_consec = nums[i] - 1 == nums[i - 1] and nums[i - 1] - 1 == nums[i - 2]\\n\\n            valid = False\\n            if two_equal and dp[1]:\\n                valid = True\\n            if (three_equal or three_consec) and dp[0]:\\n                valid = True\\n\\n            dp = [dp[1], dp[2], valid]\\n\\n        return dp[2]\\n\"",
  "2498_14631217_python-updated-time": "1746966142976",
  "575_14631217_python-updated-time": "1745447905957",
  "1086_14631217_python-updated-time": "1746041901864",
  "2350_14631217_python": "\"class Solution:\\n    def findClosestNumber(self, nums):\\n        best = nums[0]\\n        for x in nums:\\n            if abs(x) < abs(best) or (abs(x) == abs(best) and x > best):\\n                best = x\\n        return best\\n\"",
  "2805_14631217_javascript-updated-time": "1747139100109",
  "234_14631217_python-updated-time": "1745247335156",
  "6_14631217_python-updated-time": "1744978994443",
  "226_14631217_python-updated-time": "1745246960202",
  "2825_14631217_python": "\"class Solution:\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n\"",
  "1901_14631217_python-updated-time": "1746532187618",
  "2680_14631217_python": "\"class Solution:\\n    def monkeyMove(self, n):\\n        MOD = 10**9 + 7\\n        return (pow(2, n, MOD) - 2) % MOD\\n\"",
  "3708_14631217_python": "\"class Solution(object):\\n    def zigzagTraversal(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        m = len(grid)\\n        if m == 0:\\n            return []\\n        flat = []\\n        for i in range(m):\\n            row = grid[i]\\n            if i % 2 == 1:\\n                row = row[::-1]\\n            flat.extend(row)\\n        # skip every alternate: take even indices\\n        return flat[::2]\\n\"",
  "629_14631217_python-updated-time": "1745782197807",
  "1535_14631217_python-updated-time": "1746346977019",
  "1820_14631217_python": "\"class Solution(object):\\n    def checkWays(self, pairs):\\n        from collections import defaultdict\\n\\n        # 1) Build adjacency and collect all distinct nodes\\n        adj = defaultdict(set)\\n        nodes = set()\\n        for x, y in pairs:\\n            adj[x].add(y)\\n            adj[y].add(x)\\n            nodes.add(x)\\n            nodes.add(y)\\n        n = len(nodes)\\n\\n        # 2) Compute degrees\\n        deg = {u: len(adj[u]) for u in nodes}\\n\\n        # 3) Identify root candidates: must connect to all other nodes\\n        maxdeg = n - 1\\n        roots = [u for u in nodes if deg[u] == maxdeg]\\n        # If no node has degree n-1, impossible to have a root ancestor of all → 0 ways\\n        if not roots:\\n            return 0\\n        # If more than one node has degree n-1, there are at least 2 choices of root → at least 2 ways\\n        ways = 1 if len(roots) == 1 else 2\\n        chosen_root = roots[0]  # pick any one to run the check for consistency\\n\\n        # 4) For each non-root node, pick its parent among its neighbors\\n        #    The parent must have degree ≥ deg[u], and among those the smallest such degree.\\n        for u in nodes:\\n            if u == chosen_root:\\n                continue\\n            best_parent = None\\n            best_deg = float('inf')\\n            for v in adj[u]:\\n                if deg[v] >= deg[u] and deg[v] < best_deg:\\n                    best_parent = v\\n                    best_deg = deg[v]\\n            # If we found no valid parent, it's impossible\\n            if best_parent is None:\\n                return 0\\n\\n            # 5) Check that u's entire neighbor‐set (except the parent) \\n            #    is a subset of best_parent's neighbor‐set.\\n            #    This enforces that every neighbor of u is indeed an ancestor or descendant\\n            #    correctly nested under best_parent in the rooted tree.\\n            for v in adj[u]:\\n                if v is best_parent:\\n                    continue\\n                if v not in adj[best_parent]:\\n                    return 0\\n\\n            # 6) If deg[parent] == deg[u], swapping parent/child roles still satisfies\\n            #    all adjacency constraints → multiple valid trees.\\n            if deg[best_parent] == deg[u]:\\n                ways = 2\\n\\n        return ways\\n\"",
  "1577_14631217_python-updated-time": "1746432349783",
  "2363_14631217_python-updated-time": "1746879882890",
  "37_14631217_python": "\"class Solution(object):\\n    def solveSudoku(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \\\"\\\"\\\"\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        boxes = [set() for _ in range(9)]\\n        empty = []\\n\\n        # Pre-fill the sets and collect empty cells\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] != '.':\\n                    num = board[r][c]\\n                    rows[r].add(num)\\n                    cols[c].add(num)\\n                    boxes[(r // 3) * 3 + (c // 3)].add(num)\\n                else:\\n                    empty.append((r, c))\\n\\n        def backtrack(index):\\n            if index == len(empty):\\n                return True\\n\\n            r, c = empty[index]\\n            box_idx = (r // 3) * 3 + (c // 3)\\n\\n            for num in '123456789':\\n                if num not in rows[r] and num not in cols[c] and num not in boxes[box_idx]:\\n                    board[r][c] = num\\n                    rows[r].add(num)\\n                    cols[c].add(num)\\n                    boxes[box_idx].add(num)\\n\\n                    if backtrack(index + 1):\\n                        return True\\n\\n                    # Undo the move\\n                    board[r][c] = '.'\\n                    rows[r].remove(num)\\n                    cols[c].remove(num)\\n                    boxes[box_idx].remove(num)\\n\\n            return False\\n\\n        backtrack(0)\\n\"",
  "960_14631217_python": "\"class Solution:\\n    def minMalwareSpread(self, graph, initial):\\n        n = len(graph)\\n        parent = list(range(n))\\n\\n        # Union-Find with path compression\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent[find(x)] = find(y)\\n\\n        # Step 1: Group nodes into connected components\\n        for i in range(n):\\n            for j in range(n):\\n                if graph[i][j]:\\n                    union(i, j)\\n\\n        # Step 2: Count size of each component\\n        size = [0] * n\\n        for i in range(n):\\n            root = find(i)\\n            size[root] += 1\\n\\n        # Step 3: Count malware in each component\\n        malware_count = [0] * n\\n        for node in initial:\\n            malware_count[find(node)] += 1\\n\\n        # Step 4: Pick best node to remove\\n        result = None\\n        max_saved = -1\\n        for node in sorted(initial):\\n            root = find(node)\\n            if malware_count[root] == 1:\\n                if size[root] > max_saved:\\n                    max_saved = size[root]\\n                    result = node\\n\\n        # If no node can reduce spread, return the one with smallest index\\n        return result if result is not None else min(initial)\\n\"",
  "2838_14631217_python": "\"class Solution:\\n    def matrixSumQueries(self, n, queries):\\n        seen_rows = set()\\n        seen_cols = set()\\n        total = 0\\n\\n        for t, idx, val in reversed(queries):\\n            if t == 0:  # row\\n                if idx not in seen_rows:\\n                    seen_rows.add(idx)\\n                    total += val * (n - len(seen_cols))\\n            else:  # column\\n                if idx not in seen_cols:\\n                    seen_cols.add(idx)\\n                    total += val * (n - len(seen_rows))\\n        return total\\n\"",
  "563_14631217_python-updated-time": "1745447684239",
  "2511_14631217_python": "\"class Solution:\\n    def minimumPartition(self, s, k):\\n        count = 1\\n        curr = 0\\n        for ch in s:\\n            curr = curr * 10 + (ord(ch) - ord('0'))\\n            if curr > k:\\n                # start a new substring at ch\\n                count += 1\\n                curr = ord(ch) - ord('0')\\n                if curr > k:\\n                    return -1\\n        return count\\n\"",
  "2704_14631217_python": "\"class Solution(object):\\n    def minMaxDifference(self, num):\\n        s = str(num)\\n        max_val = num\\n        min_val = num\\n        for d1 in '0123456789':\\n            for d2 in '0123456789':\\n                if d1 == d2:\\n                    continue\\n                t = s.replace(d1, d2)\\n                v = int(t)\\n                if v > max_val:\\n                    max_val = v\\n                if v < min_val:\\n                    min_val = v\\n        return max_val - min_val\\n\"",
  "2427_14631217_python": "\"class Solution:\\n    def repeatedCharacter(self, s):\\n        seen = set()\\n        for ch in s:\\n            if ch in seen:\\n                return ch\\n            seen.add(ch)\\n\"",
  "3744_14631217_python": "\"class Solution(object):\\n    def minOperations(self, queries):\\n        import bisect\\n        \\n        # Precompute boundaries b[k] = 4^(k-1) for k=1..K\\n        b = [1]\\n        while b[-1] <= 10**9:\\n            b.append(b[-1] * 4)\\n        K = len(b)  # ~16\\n        \\n        # Precompute prefix counts Ck[x] = # a<=x with floor(log4 a)+1 >= k\\n        # Equivalently, Ck(x) = max(0, x - (4^(k-1)-1))\\n        def Ck(x, k):\\n            if x < b[k-1]:\\n                return 0\\n            return x - (b[k-1] - 1)\\n        \\n        ans = 0\\n        for l, r in queries:\\n            # sum of picks = sum_k [Ck(r,k) - Ck(l-1,k)]\\n            total_picks = 0\\n            for k in range(1, K+1):\\n                total_picks += Ck(r, k) - Ck(l-1, k)\\n            # max single\\n            # find k s.t. b[k-1]<=r and b[k]>l-1\\n            max_pick = bisect.bisect_right(b, r)\\n            # operations\\n            ops = max(max_pick, (total_picks + 1)//2)\\n            ans += ops\\n        \\n        return ans\\n\"",
  "1428_14631217_python-updated-time": "1746260671786",
  "873_14631217_python-updated-time": "1745880076760",
  "1329_14631217_python-updated-time": "1746127669206",
  "349_14631217_python-updated-time": "1745257159436",
  "2277_14631217_python": "\"class Solution:\\n    def countPairs(self, nums, k):\\n        n = len(nums)\\n        count = 0\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if nums[i] == nums[j] and (i * j) % k == 0:\\n                    count += 1\\n        return count\\n\"",
  "1182_14631217_mysql": "\"WITH FirstLogin AS (\\n    SELECT player_id, MIN(event_date) AS first_login\\n    FROM Activity\\n    GROUP BY player_id\\n),\\nLoggedInAgain AS (\\n    SELECT DISTINCT a1.player_id\\n    FROM Activity a1\\n    JOIN FirstLogin fl\\n        ON a1.player_id = fl.player_id\\n    WHERE DATEDIFF(a1.event_date, fl.first_login) = 1\\n)\\nSELECT \\n    ROUND(COUNT(DISTINCT la.player_id) * 1.0 / COUNT(DISTINCT a.player_id), 2) AS fraction\\nFROM \\n    Activity a\\nLEFT JOIN \\n    LoggedInAgain la\\n    ON a.player_id = la.player_id;\\n\"",
  "1656_14631217_python-updated-time": "1746434059294",
  "3278_14631217_python": "\"class Solution(object):\\n    def numberOfPairs(self, points):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(points)\\n        ans = 0\\n        \\n        for i in range(n):\\n            ax, ay = points[i]\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                bx, by = points[j]\\n                \\n                # 1) Is A on the upper-left side of B (allowing horizontal/vertical lines)?\\n                if ax <= bx and ay >= by:\\n                    # 2) Check that no other point lies within the rectangle [ax..bx] × [by..ay]\\n                    ok = True\\n                    for k in range(n):\\n                        if k == i or k == j:\\n                            continue\\n                        xk, yk = points[k]\\n                        if ax <= xk <= bx and by <= yk <= ay:\\n                            ok = False\\n                            break\\n                    if ok:\\n                        ans += 1\\n        \\n        return ans\\n\"",
  "890_14631217_python": "\"class Solution(object):\\n    def lemonadeChange(self, bills):\\n        five, ten = 0, 0\\n        for bill in bills:\\n            if bill == 5:\\n                five += 1\\n            elif bill == 10:\\n                if five == 0:\\n                    return False\\n                five -= 1\\n                ten += 1\\n            else:\\n                if ten > 0 and five > 0:\\n                    ten -= 1\\n                    five -= 1\\n                elif five >= 3:\\n                    five -= 3\\n                else:\\n                    return False\\n        return True\\n\"",
  "2755_14631217_python-updated-time": "1747139898112",
  "922_14631217_python-updated-time": "1746001901975",
  "1070_14631217_python": "\"class Solution:\\n    def baseNeg2(self, n):\\n        if n == 0:\\n            return \\\"0\\\"\\n        digits = []\\n        while n != 0:\\n            n, rem = divmod(n, -2)\\n            if rem < 0:\\n                rem += 2\\n                n += 1\\n            digits.append(str(rem))\\n        return ''.join(reversed(digits))\\n\"",
  "1444_14631217_python-updated-time": "1746261866435",
  "935_14631217_python-updated-time": "1746002420008",
  "300_14631217_python-updated-time": "1745255609220",
  "1170_14631217_python": "\"class Solution(object):\\n    def shortestCommonSupersequence(self, str1, str2):\\n        \\\"\\\"\\\"\\n        :type str1: str\\n        :type str2: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Step 1: Compute LCS\\n        m, n = len(str1), len(str2)\\n        dp = [[\\\"\\\"] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if str1[i] == str2[j]:\\n                    dp[i+1][j+1] = dp[i][j] + str1[i]\\n                else:\\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j], key=len)\\n\\n        # Step 2: Build SCS from LCS\\n        lcs = dp[m][n]\\n        i = j = 0\\n        result = []\\n\\n        for c in lcs:\\n            while str1[i] != c:\\n                result.append(str1[i])\\n                i += 1\\n            while str2[j] != c:\\n                result.append(str2[j])\\n                j += 1\\n            result.append(c)\\n            i += 1\\n            j += 1\\n\\n        # Add remaining characters\\n        result.extend(str1[i:])\\n        result.extend(str2[j:])\\n        return ''.join(result)\\n\"",
  "SIDEBAR_WIDTH": "240",
  "1531_14631217_python-updated-time": "1746347189708",
  "3847_14631217_python": "\"class Solution(object):\\n    def minSwaps(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        \\n        # 1) Compute key = (digit_sum, value)\\n        def digit_sum(x):\\n            s = 0\\n            while x:\\n                s += x % 10\\n                x //= 10\\n            return s\\n        \\n        # 2) Pair with original index\\n        arr = [((digit_sum(nums[i]), nums[i]), i) for i in range(n)]\\n        \\n        # 3) Sort by key\\n        arr.sort(key=lambda x: x[0])\\n        \\n        # 4) Build P: current index -> target index in sorted array\\n        P = [0] * n\\n        for sorted_pos, (_, orig_i) in enumerate(arr):\\n            P[orig_i] = sorted_pos\\n        \\n        # 5) Count cycles in P\\n        visited = [False] * n\\n        swaps = 0\\n        for i in range(n):\\n            if visited[i]:\\n                continue\\n            # traverse the cycle\\n            cycle_len = 0\\n            j = i\\n            while not visited[j]:\\n                visited[j] = True\\n                j = P[j]\\n                cycle_len += 1\\n            # a cycle of length c needs c-1 swaps\\n            if cycle_len > 0:\\n                swaps += cycle_len - 1\\n        \\n        return swaps\\n\"",
  "3072_14631217_pythondata": "\"import pandas as pd\\n\\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame `weather` with columns ['city', 'month', 'temperature'],\\n    pivots it so that each row index is a month (sorted alphabetically),\\n    each city is a column, and the values are the temperatures.\\n    \\\"\\\"\\\"\\n    # Pivot so that months become the index and cities become columns\\n    df_pivot = weather.pivot(index='month', columns='city', values='temperature')\\n    # Sort the months (the index) alphabetically\\n    df_pivot = df_pivot.sort_index()\\n    # Sort the city columns alphabetically\\n    df_pivot = df_pivot[sorted(df_pivot.columns)]\\n    return df_pivot\\n\"",
  "1195_14631217_python": "\"class Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n        \\\"\\\"\\\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = [0] * num_people\\n        i = 0\\n        give = 1\\n\\n        while candies > 0:\\n            res[i % num_people] += min(give, candies)\\n            candies -= give\\n            give += 1\\n            i += 1\\n\\n        return res\\n\"",
  "3363_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def mostFrequentIDs(self, nums, freq):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type freq: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        count = defaultdict(int)       # current count of each ID\\n        freq_count = defaultdict(int)  # how many IDs have a given count\\n        max_heap = []                  # max-heap of counts (stored as negatives)\\n        ans = [0] * n\\n\\n        for i in range(n):\\n            x = nums[i]\\n            delta = freq[i]\\n\\n            old = count[x]\\n            new = old + delta\\n\\n            # remove from old bucket\\n            if old > 0:\\n                freq_count[old] -= 1\\n\\n            # update count[x]\\n            if new > 0:\\n                count[x] = new\\n                freq_count[new] += 1\\n                heapq.heappush(max_heap, -new)\\n            else:\\n                # new == 0 → remove entirely\\n                count.pop(x, None)\\n\\n            # lazy-pop from heap until top is valid\\n            while max_heap and freq_count[-max_heap[0]] == 0:\\n                heapq.heappop(max_heap)\\n\\n            # top of heap is current max count\\n            ans[i] = -max_heap[0] if max_heap else 0\\n\\n        return ans\\n\"",
  "2392_14631217_python-updated-time": "1746882054113",
  "3808_14631217_python-updated-time": "1747761782838",
  "1471_14631217_python-updated-time": "1746262131794",
  "570_14631217_mysql-updated-time": "1745447847474",
  "2159_14631217_python": "\"class Solution(object):\\n    def twoOutOfThree(self, nums1, nums2, nums3):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type nums3: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        count = defaultdict(int)\\n\\n        for num in set(nums1):\\n            count[num] += 1\\n        for num in set(nums2):\\n            count[num] += 1\\n        for num in set(nums3):\\n            count[num] += 1\\n\\n        result = []\\n        for num in count:\\n            if count[num] >= 2:\\n                result.append(num)\\n\\n        return result\\n\"",
  "3820_14631217_python": "\"import functools\\n\\nclass Solution(object):\\n    def uniqueXorTriplets(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # If nums empty\\n        if not nums:\\n            return 0\\n        # Determine size for FWHT: next power of two > max possible XOR\\n        maxv = max(nums)\\n        size = 1 << (maxv.bit_length())\\n        # Presence vector\\n        P = [0] * size\\n        for v in nums:\\n            P[v] = 1\\n        # Fast Walsh-Hadamard Transform for XOR-convolution\\n        def fwht(a, inverse=False):\\n            n = len(a)\\n            h = 1\\n            while h < n:\\n                for i in range(0, n, h*2):\\n                    for j in range(i, i+h):\\n                        x = a[j]\\n                        y = a[j+h]\\n                        a[j] = x + y\\n                        a[j+h] = x - y\\n                h *= 2\\n            if inverse:\\n                for i in range(n):\\n                    a[i] //= n\\n        # Convolve P with itself three times\\n        A = P[:]\\n        fwht(A)\\n        # Pointwise cube for triple convolution\\n        for i in range(size):\\n            A[i] = A[i] ** 3\\n        fwht(A, inverse=True)\\n        # Count how many XOR values are achievable (A[x] > 0)\\n        # We only care about XOR results within [0..size)\\n        count = 0\\n        for x in range(size):\\n            if A[x] > 0:\\n                count += 1\\n        return count\"",
  "1451_14631217_python": "\"class Solution:\\n    def minTaps(self, n, ranges):\\n        # Build maxReach: for each position i, the farthest right endpoint\\n        # of any interval starting at i\\n        maxReach = [0] * (n + 1)\\n        for i, r in enumerate(ranges):\\n            left = max(0, i - r)\\n            right = min(n, i + r)\\n            maxReach[left] = max(maxReach[left], right)\\n        \\n        taps = 0\\n        curr_end = 0\\n        next_end = 0\\n        i = 0\\n        \\n        # Greedy jump through [0..n]\\n        while curr_end < n:\\n            # Extend coverage as far as possible from any start <= curr_end\\n            while i <= curr_end:\\n                next_end = max(next_end, maxReach[i])\\n                i += 1\\n            # If we cannot extend beyond curr_end, fail\\n            if next_end == curr_end:\\n                return -1\\n            # Use one more tap to extend coverage\\n            taps += 1\\n            curr_end = next_end\\n        \\n        return taps\\n\"",
  "194_14631217_bash-updated-time": "1745093407662",
  "754_14631217_python": "\"class Solution(object):\\n    def crackSafe(self, n, k):\\n        seen = set()\\n        ans = []\\n        \\n        def dfs(node):\\n            for x in range(k):\\n                nei = node + str(x)\\n                if nei not in seen:\\n                    seen.add(nei)\\n                    dfs(nei[1:])\\n                    ans.append(str(x))\\n        \\n        dfs('0' * (n-1))\\n        return ''.join(ans) + '0' * (n-1)\\n\"",
  "2832_14631217_python-updated-time": "1747225880807",
  "1094_14631217_python": "\"class Solution:\\n    def allCellsDistOrder(self, rows, cols, rCenter, cCenter):\\n        cells = [[i, j] for i in range(rows) for j in range(cols)]\\n        cells.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))\\n        return cells\\n\"",
  "3139_14631217_python": "\"class Solution(object):\\n    def sumCounts(self, nums):\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        size = 4 * n + 4\\n        sum_val = [0] * size          # Σ a\\n        sum_sq  = [0] * size          # Σ a²\\n        lazy    = [0] * size\\n\\n        def apply(node, l, r, d):\\n            length = r - l + 1\\n            d %= MOD\\n            sum_sq[node] = (sum_sq[node] + 2 * d * sum_val[node] + d * d * length) % MOD\\n            sum_val[node] = (sum_val[node] + d * length) % MOD\\n            lazy[node] = (lazy[node] + d) % MOD\\n\\n        def push(node, l, r):\\n            if lazy[node] and l != r:\\n                m = (l + r) // 2\\n                d = lazy[node]\\n                apply(node * 2,     l,     m, d)\\n                apply(node * 2 + 1, m + 1, r, d)\\n                lazy[node] = 0\\n\\n        def update(node, l, r, ql, qr):\\n            if qr < l or ql > r:\\n                return\\n            if ql <= l and r <= qr:\\n                apply(node, l, r, 1)\\n                return\\n            push(node, l, r)\\n            m = (l + r) // 2\\n            update(node * 2,     l,     m, ql, qr)\\n            update(node * 2 + 1, m + 1, r, ql, qr)\\n            sum_val[node] = (sum_val[node * 2] + sum_val[node * 2 + 1]) % MOD\\n            sum_sq[node]  = (sum_sq[node  * 2] + sum_sq[node  * 2 + 1]) % MOD\\n\\n        last = {}\\n        res  = 0\\n        for i, v in enumerate(nums):\\n            update(1, 0, n - 1, last.get(v, -1) + 1, i)\\n            last[v] = i\\n            res = (res + sum_sq[1]) % MOD\\n        return res\\n\"",
  "1695_14631217_python": "\"class Solution(object):\\n    def maxSumRangeQuery(self, nums, requests):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type requests: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        \\n        # 1) Build frequency array via difference array\\n        freq = [0] * (n + 1)\\n        for l, r in requests:\\n            freq[l] += 1\\n            if r + 1 < n:\\n                freq[r + 1] -= 1\\n        \\n        # 2) Prefix sum to get frequencies for each index\\n        for i in range(1, n):\\n            freq[i] += freq[i - 1]\\n        freq.pop()  # drop the extra\\n        \\n        # 3) Sort nums and freq\\n        nums.sort()\\n        freq.sort()\\n        \\n        # 4) Greedily match largest num with largest freq\\n        total = 0\\n        for a, f in zip(nums, freq):\\n            if f > 0:\\n                total = (total + a * f) % mod\\n        \\n        return total\\n\"",
  "3626_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nmod = 10**9 + 7\\n\\nclass Solution(object):\\n    def minTimeToReach(self, moveTime):\\n        \\\"\\\"\\\"\\n        :type moveTime: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import heapq\\n        n = len(moveTime)\\n        m = len(moveTime[0])\\n        # dist[r][c]: min time to arrive at room (r,c)\\n        INF = 10**30\\n        dist = [[INF] * m for _ in range(n)]\\n        # start at (0,0) at time 0\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]  # (time, r, c)\\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        while pq:\\n            t, r, c = heapq.heappop(pq)\\n            if t > dist[r][c]:\\n                continue\\n            # reached target\\n            if r == n-1 and c == m-1:\\n                return t\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < n and 0 <= nc < m:\\n                    # can depart at time >= open time of neighbor\\n                    depart = max(t, moveTime[nr][nc])\\n                    arrive = depart + 1\\n                    if arrive < dist[nr][nc]:\\n                        dist[nr][nc] = arrive\\n                        heapq.heappush(pq, (arrive, nr, nc))\\n        # unreachable\\n        return -1\\n\\n# existing methods below remain unchanged\\n    def lengthAfterTransformations(self, s, t, nums):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        A = [[0] * 26 for _ in range(26)]\\n        for i in range(26):\\n            for k in range(1, nums[i] + 1):\\n                j = (i + k) % 26\\n                A[i][j] = 1\\n\\n        def mat_mult(X, Y):\\n            Z = [[0] * 26 for _ in range(26)]\\n            for i in range(26):\\n                for k in range(26):\\n                    if X[i][k]:\\n                        for j in range(26):\\n                            Z[i][j] = (Z[i][j] + X[i][k] * Y[k][j]) % mod\\n            return Z\\n\\n        def mat_pow(mat, power):\\n            res = [[int(i == j) for j in range(26)] for i in range(26)]\\n            while power:\\n                if power % 2:\\n                    res = mat_mult(res, mat)\\n                mat = mat_mult(mat, mat)\\n                power //= 2\\n            return res\\n\\n        if t == 0:\\n            return len(s) % mod\\n\\n        At = mat_pow(A, t)\\n        f = [sum(At[c]) % mod for c in range(26)]\\n\\n        return sum(f[ord(ch) - ord('a')] for ch in s) % mod\\n\\n    def isBalanced(self, num):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\\n        return even_sum == odd_sum\\n\\n    def smallestNumber(self, n, t):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type t: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        x = n\\n        while True:\\n            # compute product of digits\\n            prod = 1\\n            for ch in str(x):\\n                prod *= int(ch)\\n            # zeros produce prod=0 which is divisible by any t>0\\n            if prod % t == 0:\\n                return x\\n            x += 1\\n\"",
  "3721_14631217_python": "\"class Solution(object):\\n    def countMentions(self, numberOfUsers, events):\\n        \\\"\\\"\\\"\\n        :type numberOfUsers: int\\n        :type events: List[List[str]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # 1) Expand each OFFLINE into an OFF (at t) and an ON (at t+60)\\n        timeline = []\\n        for typ, t_str, data in events:\\n            t = int(t_str)\\n            if typ == \\\"OFFLINE\\\":\\n                uid = int(data)\\n                timeline.append((t,    \\\"OFF\\\", uid))\\n                timeline.append((t+60, \\\"ON\\\",  uid))\\n            else:  # MESSAGE\\n                timeline.append((t, \\\"MSG\\\", data))\\n\\n        # 2) Sort by (timestamp, kind), **with ON < OFF < MSG** at the same time\\n        weight = {\\\"ON\\\": 0, \\\"OFF\\\": 1, \\\"MSG\\\": 2}\\n        timeline.sort(key=lambda ev: (ev[0], weight[ev[1]]))\\n\\n        # 3) Sweep: track who’s online and count mentions\\n        online   = [True] * numberOfUsers\\n        mentions = [0]    * numberOfUsers\\n\\n        for _, typ, payload in timeline:\\n            if typ == \\\"ON\\\":\\n                online[payload] = True\\n            elif typ == \\\"OFF\\\":\\n                online[payload] = False\\n            else:  # \\\"MSG\\\"\\n                s = payload\\n                if s == \\\"ALL\\\":\\n                    # mention everyone\\n                    for u in range(numberOfUsers):\\n                        mentions[u] += 1\\n                elif s == \\\"HERE\\\":\\n                    # mention only those currently online\\n                    for u in range(numberOfUsers):\\n                        if online[u]:\\n                            mentions[u] += 1\\n                else:\\n                    # explicit tokens e.g. \\\"id3 id0 id3\\\"\\n                    for tok in s.split():\\n                        u = int(tok[2:])\\n                        mentions[u] += 1\\n\\n        return mentions\\n\"",
  "3649_14631217_python": "\"class Solution(object):\\n    def findMinimumTime(self, strength, k):\\n        \\\"\\\"\\\"\\n        :type strength: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(strength)\\n        ALL = (1<<n) - 1\\n        INF = 10**18\\n\\n        # dp[mask] = min time to break exactly the locks in 'mask'\\n        dp = [INF] * (1<<n)\\n        dp[0] = 0\\n\\n        for mask in range(1<<n):\\n            base = dp[mask]\\n            if base == INF:\\n                continue\\n\\n            # count how many locks already broken\\n            c = bin(mask).count('1')\\n            x = 1 + c * k\\n\\n            for i in range(n):\\n                if not (mask & (1<<i)):\\n                    # time to break lock i at factor x\\n                    t = (strength[i] + x - 1) // x\\n                    new_mask = mask | (1<<i)\\n                    if base + t < dp[new_mask]:\\n                        dp[new_mask] = base + t\\n\\n        return dp[ALL]\\n\"",
  "217_14631217_python-updated-time": "1745246350879",
  "2428_14631217_python-updated-time": "1746907835133",
  "1999_14631217_python-updated-time": "1746625408797",
  "3420_14631217_python": "\"class Solution(object):\\n    def occurrencesOfElement(self, nums, queries, x):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[int]\\n        :type x: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Record all the indices where nums[i] == x\\n        positions = []\\n        for i, num in enumerate(nums):\\n            if num == x:\\n                positions.append(i)\\n        \\n        # For each query, pick the (q-1)-th index if it exists\\n        answer = []\\n        count = len(positions)\\n        for q in queries:\\n            if q <= count:\\n                answer.append(positions[q-1])\\n            else:\\n                answer.append(-1)\\n        \\n        return answer\"",
  "2190_14631217_python-updated-time": "1746729432753",
  "3648_14631217_python": "\"class Solution(object):\\n    def maxCollectedFruits(self, fruits):\\n        \\\"\\\"\\\"\\n        :type fruits: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(fruits)\\n        NEG = -10**18\\n\\n        # 1) Green child collects the main diagonal:\\n        diag_sum = 0\\n        for i in range(n):\\n            diag_sum += fruits[i][i]\\n            fruits[i][i] = 0  # zero it so red/blue won't double-count\\n\\n        # 2) Red child DP (from (0,n-1) down to (n-1,n-1)):\\n        #    moves are (i,j) → (i+1, j-1),(i+1, j),(i+1, j+1)\\n        dp2 = [NEG] * n\\n        dp2[n-1] = fruits[0][n-1]\\n        for i in range(1, n):\\n            new = [NEG] * n\\n            for j in range(n):\\n                best_prev = dp2[j]\\n                if j > 0:      best_prev = max(best_prev, dp2[j-1])\\n                if j + 1 < n:  best_prev = max(best_prev, dp2[j+1])\\n                new[j] = best_prev + fruits[i][j]\\n            dp2 = new\\n        red_score = dp2[n-1]\\n\\n        # 3) Blue child DP (from (n-1,0) to (n-1,n-1)):\\n        #    moves are (i,j) → (i-1, j+1),(i, j+1),(i+1, j+1)\\n        dp3 = [NEG] * n\\n        dp3[n-1] = fruits[n-1][0]  # <-- FIXED: start at row n-1, col 0\\n        for j in range(1, n):\\n            new = [NEG] * n\\n            for i in range(n):\\n                best_prev = dp3[i]\\n                if i > 0:      best_prev = max(best_prev, dp3[i-1])\\n                if i + 1 < n:  best_prev = max(best_prev, dp3[i+1])\\n                new[i] = best_prev + fruits[i][j]\\n            dp3 = new\\n        blue_score = dp3[n-1]\\n\\n        return diag_sum + red_score + blue_score\\n\"",
  "999_14631217_python-updated-time": "1746038889582",
  "3071_14631217_pythondata": "\"import pandas as pd\\n\\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame customers with columns ['customer_id', 'name', 'email'],\\n    returns a new DataFrame with duplicate emails dropped, keeping only the first occurrence.\\n    \\\"\\\"\\\"\\n    return customers.drop_duplicates(subset=['email'], keep='first')\\n\"",
  "235_14631217_python-updated-time": "1745247380152",
  "1860_14631217_python-updated-time": "1746530562280",
  "999_14631217_python": "\"class Solution:\\n    def regionsBySlashes(self, grid):\\n        n = len(grid)\\n        size = n * 3\\n        expanded = [[0] * size for _ in range(size)]\\n\\n        for i in range(n):\\n            for j in range(n):\\n                c = grid[i][j]\\n                r, c3 = i * 3, j * 3\\n                if c == '/':\\n                    expanded[r][c3 + 2] = 1\\n                    expanded[r + 1][c3 + 1] = 1\\n                    expanded[r + 2][c3] = 1\\n                elif c == '\\\\\\\\':\\n                    expanded[r][c3] = 1\\n                    expanded[r + 1][c3 + 1] = 1\\n                    expanded[r + 2][c3 + 2] = 1\\n\\n        def dfs(x, y):\\n            if x < 0 or y < 0 or x >= size or y >= size or expanded[x][y] != 0:\\n                return\\n            expanded[x][y] = 2\\n            dfs(x + 1, y)\\n            dfs(x - 1, y)\\n            dfs(x, y + 1)\\n            dfs(x, y - 1)\\n\\n        regions = 0\\n        for i in range(size):\\n            for j in range(size):\\n                if expanded[i][j] == 0:\\n                    dfs(i, j)\\n                    regions += 1\\n\\n        return regions\\n\"",
  "1776_14631217_python": "\"class Solution:\\n    def minOperations(self, nums, x):\\n        total = sum(nums)\\n        target = total - x\\n        # If we need to remove all elements\\n        if target == 0:\\n            return len(nums)\\n        # If it's impossible\\n        if target < 0:\\n            return -1\\n        \\n        n = len(nums)\\n        left = 0\\n        curr = 0\\n        max_len = -1\\n        \\n        # Sliding window to find the longest subarray summing to target\\n        for right in range(n):\\n            curr += nums[right]\\n            # Shrink from left if we exceed target\\n            while curr > target and left <= right:\\n                curr -= nums[left]\\n                left += 1\\n            # Check match\\n            if curr == target:\\n                max_len = max(max_len, right - left + 1)\\n        \\n        # If we never found a suitable subarray\\n        if max_len == -1:\\n            return -1\\n        \\n        # We keep max_len elements in the middle, remove the rest\\n        return n - max_len\\n\"",
  "617_14631217_python-updated-time": "1745780504571",
  "1715_14631217_python-updated-time": "1746438839145",
  "2328_14631217_python-updated-time": "1746879181760",
  "988_14631217_python-updated-time": "1746038492773",
  "2633_14631217_python": "\"class Solution:\\n    def minCost(self, nums, k):\\n        n = len(nums)\\n        INF = 10**30\\n        dp = [INF] * (n + 1)\\n        dp[0] = 0\\n\\n        # We'll reuse a freq array of size n (nums[i] < n by constraint).\\n        freq = [0] * n\\n\\n        for j in range(n):\\n            # reset freq and trimmedLen for the new start j\\n            trimmedLen = 0\\n            # zero out only the used entries: we'll keep track of which we touched\\n            used = []\\n\\n            for i in range(j, n):\\n                x = nums[i]\\n                f = freq[x]\\n                if f == 0:\\n                    freq[x] = 1\\n                    used.append(x)\\n                elif f == 1:\\n                    # first time we reach count 2\\n                    freq[x] = 2\\n                    trimmedLen += 2\\n                else:\\n                    # f >= 2\\n                    freq[x] += 1\\n                    trimmedLen += 1\\n\\n                cost = k + trimmedLen\\n                # update dp for prefix ending at i\\n                if dp[j] + cost < dp[i + 1]:\\n                    dp[i + 1] = dp[j] + cost\\n\\n            # clear freq for all touched values\\n            for x in used:\\n                freq[x] = 0\\n            # also reset those that went >=2\\n            # (they appear in used as well, since we appended on f==0 only)\\n            # but to be safe:\\n            for i2 in range(j, n):\\n                x = nums[i2]\\n                if freq[x] > 0:\\n                    freq[x] = 0\\n\\n        return dp[n]\\n\"",
  "889_14631217_python": "\"class Solution(object):\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        \\n        pairs = []\\n        for a, b in zip(s, goal):\\n            if a != b:\\n                pairs.append((a, b))\\n        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n\"",
  "1106_14631217_python-updated-time": "1746042325746",
  "2671_14631217_python-updated-time": "1747134483777",
  "1537_14631217_python": "\"class Solution:\\n    def maxScore(self, s):\\n        max_score = 0\\n        for i in range(1, len(s)):\\n            left = s[:i].count('0')\\n            right = s[i:].count('1')\\n            max_score = max(max_score, left + right)\\n        return max_score\\n\"",
  "1727_14631217_python-updated-time": "1746530200286",
  "2879_14631217_python-updated-time": "1747308378123",
  "225_14631217_python": "\"from collections import deque\\n\\nclass MyStack(object):\\n\\n    def __init__(self):\\n        self.q = deque()\\n\\n    def push(self, x):\\n        self.q.append(x)\\n        for _ in range(len(self.q) - 1):\\n            self.q.append(self.q.popleft())\\n\\n    def pop(self):\\n        return self.q.popleft()\\n\\n    def top(self):\\n        return self.q[0]\\n\\n    def empty(self):\\n        return not self.q\\n\"",
  "1397_14631217_python": "\"class Solution:\\n    def suggestedProducts(self, products, searchWord):\\n        products.sort()\\n        res = []\\n        prefix = ''\\n        for c in searchWord:\\n            prefix += c\\n            suggestions = []\\n            for product in products:\\n                if product.startswith(prefix):\\n                    suggestions.append(product)\\n                if len(suggestions) == 3:\\n                    break\\n            res.append(suggestions)\\n        return res\\n\"",
  "49_14631217_python-updated-time": "1744999609149",
  "2196_14631217_python-updated-time": "1746729178097",
  "2231_14631217_python": "\"class Solution:\\n    def firstPalindrome(self, words):\\n        for word in words:\\n            if word == word[::-1]:\\n                return word\\n        return \\\"\\\"\\n\"",
  "2736_14631217_python": "\"class Solution(object):\\n    def addMinimum(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        pattern = \\\"abc\\\"\\n        p = 0\\n        inserts = 0\\n        \\n        for ch in word:\\n            # Insert missing pattern chars until we match ch\\n            while pattern[p] != ch:\\n                inserts += 1\\n                p = (p + 1) % 3\\n            # Consume ch\\n            p = (p + 1) % 3\\n        \\n        # After processing word, finish the current \\\"abc\\\" cycle\\n        if p != 0:\\n            inserts += (3 - p)\\n        \\n        return inserts\\n\"",
  "365_14631217_python": "\"def gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\nclass Solution:\\n    def canMeasureWater(self, x, y, target):\\n        if target > x + y:\\n            return False\\n        return target % gcd(x, y) == 0\\n\"",
  "3_14631217_python-updated-time": "1744977919630",
  "374_14631217_python-updated-time": "1745354624528",
  "2309_14631217_python": "\"class Solution(object):\\n    def maximumSubsequenceCount(self, text, pattern):\\n        a, b = pattern[0], pattern[1]\\n\\n        # Count subsequences of pattern in original text\\n        count_a = count_b = res = 0\\n        for ch in text:\\n            if ch == b:\\n                res += count_a\\n                count_b += 1\\n            if ch == a:\\n                count_a += 1\\n\\n        # Try adding pattern[0] at the front OR pattern[1] at the end\\n        # Whichever gives more new subsequences\\n        return res + max(text.count(b), text.count(a))\\n\"",
  "3105_14631217_python": "\"class Solution(object):\\n    def minEdgeReversals(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Build adjacency with weight w:\\n        # w = +1 if original edge u->v (reversal needed when rooting at v)\\n        # w = -1 if original edge v->u\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append((v, 1))\\n            adj[v].append((u, -1))\\n        \\n        # 1) Compute dp0: reversals needed when root = 0\\n        dp = [0]*n\\n        def dfs0(u, p):\\n            total = 0\\n            for v, w in adj[u]:\\n                if v == p:\\n                    continue\\n                # cost to orient edge for root=u is 1 if reverse needed, i.e. \\n                # original direction is v->u, which gives w==-1\\n                total += (1 if w == -1 else 0)\\n                total += dfs0(v, u)\\n            return total\\n        \\n        dp[0] = dfs0(0, -1)\\n        \\n        # 2) Reroot DP\\n        def dfs1(u, p):\\n            for v, w in adj[u]:\\n                if v == p:\\n                    continue\\n                # dp[v] = dp[u] + w\\n                dp[v] = dp[u] + w\\n                dfs1(v, u)\\n        \\n        dfs1(0, -1)\\n        return dp\\n\"",
  "3246_14631217_python": "\"class Solution(object):\\n    def hasTrailingZeros(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # The bitwise OR of a set of numbers is even (has at least one trailing zero)\\n        # if and only if all numbers in the set are even (their LSB is 0).\\n        # So we just need at least two even numbers.\\n        evens = sum(1 for x in nums if x % 2 == 0)\\n        return evens >= 2\\n\"",
  "3594_14631217_python-updated-time": "1747595819012",
  "3324_14631217_python-updated-time": "1747417838672",
  "1106_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def isEscapePossible(self, blocked, source, target):\\n        blocked_set = {tuple(p) for p in blocked}\\n        B = len(blocked)\\n        if B < 2:\\n            return True\\n        # maximum enclosed area ~ B*(B-1)//2\\n        LIMIT = B * (B - 1) // 2\\n\\n        def bfs(start, end):\\n            visited = set()\\n            q = deque([tuple(start)])\\n            visited.add(tuple(start))\\n            while q and len(visited) <= LIMIT:\\n                x, y = q.popleft()\\n                if [x, y] == end:\\n                    return True\\n                for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < 10**6 and 0 <= ny < 10**6:\\n                        if (nx, ny) not in blocked_set and (nx, ny) not in visited:\\n                            visited.add((nx, ny))\\n                            q.append((nx, ny))\\n            return len(visited) > LIMIT\\n\\n        # both source and target must not be enclosed\\n        return bfs(source, target) and bfs(target, source)\\n\"",
  "2511_14631217_python-updated-time": "1747060093299",
  "678_14631217_python": "\"class Solution(object):\\n    def checkValidString(self, s):\\n        low = high = 0\\n        for c in s:\\n            if c == '(':\\n                low += 1\\n                high += 1\\n            elif c == ')':\\n                low -= 1\\n                high -= 1\\n            else:  # '*'\\n                low -= 1\\n                high += 1\\n            if high < 0:\\n                return False\\n            if low < 0:\\n                low = 0\\n        return low == 0\\n\"",
  "2447_14631217_python-updated-time": "1746964697159",
  "472_14631217_python-updated-time": "1745359968270",
  "3486_14631217_python-updated-time": "1747501241254",
  "1184_14631217_python-updated-time": "1746108326946",
  "654_14631217_python-updated-time": "1745782790228",
  "473_14631217_python": "\"class Solution:\\n    def makesquare(self, matchsticks):\\n        if not matchsticks:\\n            return False\\n\\n        total = sum(matchsticks)\\n        if total % 4 != 0:\\n            return False\\n\\n        target = total // 4\\n        matchsticks.sort(reverse=True)\\n        sides = [0] * 4\\n\\n        def dfs(index):\\n            if index == len(matchsticks):\\n                return all(side == target for side in sides)\\n            for i in range(4):\\n                if sides[i] + matchsticks[index] <= target:\\n                    sides[i] += matchsticks[index]\\n                    if dfs(index + 1):\\n                        return True\\n                    sides[i] -= matchsticks[index]\\n                if sides[i] == 0:\\n                    break\\n            return False\\n\\n        return dfs(0)\\n\"",
  "3373_14631217_python-updated-time": "1747423773396",
  "1223_14631217_python-updated-time": "1746444733750",
  "345_14631217_python-updated-time": "1745257063827",
  "136_14631217_python": "\"class Solution(object):\\n    def singleNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n\"",
  "2169_14631217_python-updated-time": "1746720058348",
  "3570_14631217_python-updated-time": "1747575346184",
  "1252_14631217_python": "\"class Solution:\\n    def breakPalindrome(self, palindrome):\\n        n = len(palindrome)\\n        if n == 1:\\n            return \\\"\\\"\\n        s = list(palindrome)\\n        # Try to change the first non-'a' in the first half to 'a'\\n        for i in range(n // 2):\\n            if s[i] != 'a':\\n                s[i] = 'a'\\n                return \\\"\\\".join(s)\\n        # If all first half are 'a', change the last character to 'b'\\n        s[-1] = 'b'\\n        return \\\"\\\".join(s)\\n\"",
  "1731_14631217_python-updated-time": "1746444005029",
  "547_14631217_python": "\"class Solution:\\n    def findCircleNum(self, isConnected):\\n        n = len(isConnected)\\n        visited = [False] * n\\n\\n        def dfs(i):\\n            for j in range(n):\\n                if isConnected[i][j] == 1 and not visited[j]:\\n                    visited[j] = True\\n                    dfs(j)\\n\\n        count = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                visited[i] = True\\n                dfs(i)\\n                count += 1\\n\\n        return count\\n\"",
  "1479_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def isPossible(self, target):\\n        \\\"\\\"\\\"\\n        :type target: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        total = sum(target)\\n        target = [-x for x in target]\\n        heapq.heapify(target)\\n\\n        while True:\\n            largest = -heapq.heappop(target)\\n            rest = total - largest\\n            if largest == 1 or rest == 1:\\n                return True\\n            if rest == 0 or largest <= rest:\\n                return False\\n            updated = largest % rest\\n            if updated == 0:\\n                return False\\n            total = rest + updated\\n            heapq.heappush(target, -updated)\\n\"",
  "909_14631217_python": "\"class Solution(object):\\n    def stoneGame(self, piles):\\n        return True\\n\"",
  "1510_14631217_python": "\"class Solution(object):\\n    def findLucky(self, arr):\\n        from collections import Counter\\n        freq = Counter(arr)\\n        result = -1\\n        for num, count in freq.items():\\n            if num == count:\\n                result = max(result, num)\\n        return result\\n\"",
  "1885_14631217_python": "\"class Solution(object):\\n    def countHomogenous(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        total = 0\\n        count = 1\\n\\n        for i in range(1, len(s)):\\n            if s[i] == s[i - 1]:\\n                count += 1\\n            else:\\n                total += count * (count + 1) // 2\\n                count = 1\\n\\n        # Add the last group\\n        total += count * (count + 1) // 2\\n        return total % MOD\\n\"",
  "513_14631217_python": "\"class Solution:\\n    def findBottomLeftValue(self, root):\\n        from collections import deque\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node.right:\\n                queue.append(node.right)\\n            if node.left:\\n                queue.append(node.left)\\n        return node.val\\n\"",
  "1079_14631217_python-updated-time": "1746041810784",
  "1677_14631217_python": "\"class Solution(object):\\n    def diagonalSum(self, mat):\\n        n = len(mat)\\n        total = 0\\n        for i in range(n):\\n            total += mat[i][i] + mat[i][n-1-i]\\n        if n % 2 == 1:\\n            total -= mat[n//2][n//2]\\n        return total\\n\"",
  "2659_14631217_python": "\"class Solution(object):\\n    def evenOddBit(self, n):\\n        even = odd = 0\\n        idx = 0\\n        while n:\\n            if n & 1:\\n                if idx % 2 == 0:\\n                    even += 1\\n                else:\\n                    odd += 1\\n            n >>= 1\\n            idx += 1\\n        return [even, odd]\\n\"",
  "595_14631217_mysql": "\"SELECT\\n    name,\\n    population,\\n    area\\nFROM World\\nWHERE area >= 3000000\\n   OR population >= 25000000;\\n\"",
  "1308_14631217_python-updated-time": "1746127374906",
  "2600_14631217_python-updated-time": "1747059909541",
  "2245_14631217_python-updated-time": "1746801842582",
  "1910_14631217_python-updated-time": "1746542499013",
  "1683_14631217_python-updated-time": "1746434860920",
  "2528_14631217_python": "\"class Solution(object):\\n    def countTime(self, time):\\n        # time = \\\"hh:mm\\\"\\n        h1, h2, _, m1, m2 = time\\n        \\n        # Count hour possibilities\\n        if h1 == '?' and h2 == '?':\\n            hours = 24\\n        elif h1 == '?':\\n            d2 = int(h2)\\n            hours = 3 if d2 <= 3 else 2\\n        elif h2 == '?':\\n            d1 = int(h1)\\n            hours = 10 if d1 <= 1 else 4\\n        else:\\n            hours = 1\\n        \\n        # Count minute possibilities\\n        if m1 == '?' and m2 == '?':\\n            minutes = 60\\n        elif m1 == '?':\\n            minutes = 6\\n        elif m2 == '?':\\n            minutes = 10\\n        else:\\n            minutes = 1\\n        \\n        return hours * minutes\\n\"",
  "1459_14631217_python": "\"class Cashier(object):\\n    def __init__(self, n, discount, products, prices):\\n        self.n = n\\n        self.discount = discount\\n        self.count = 0\\n        self.price_map = {pid: price for pid, price in zip(products, prices)}\\n\\n    def getBill(self, product, amount):\\n        self.count += 1\\n        total = sum(self.price_map[pid] * qty for pid, qty in zip(product, amount))\\n        if self.count % self.n == 0:\\n            total *= (100 - self.discount) / 100.0\\n        return total\\n\"",
  "19_14631217_python-updated-time": "1744980844626",
  "1684_14631217_python-updated-time": "1746434885923",
  "2635_14631217_python-updated-time": "1747061670507",
  "1815_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        while self.parent[x] != x:\\n            self.parent[x] = self.parent[self.parent[x]]\\n            x = self.parent[x]\\n        return x\\n\\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        if rx == ry:\\n            return False\\n        if self.rank[rx] < self.rank[ry]:\\n            self.parent[rx] = ry\\n        elif self.rank[ry] < self.rank[rx]:\\n            self.parent[ry] = rx\\n        else:\\n            self.parent[ry] = rx\\n            self.rank[rx] += 1\\n        return True\\n\\nclass Solution(object):\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edgeList: List[List[int]]\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        # Sort edges by weight ascending\\n        edgeList.sort(key=lambda x: x[2])\\n        # Augment queries with original indices and sort by limit ascending\\n        queries_with_idx = [\\n            (limit, u, v, i)\\n            for i, (u, v, limit) in enumerate(queries)\\n        ]\\n        queries_with_idx.sort(key=lambda x: x[0])\\n\\n        dsu = DSU(n)\\n        res = [False] * len(queries)\\n        ei = 0  # pointer into edgeList\\n\\n        # Process each query in order of increasing limit\\n        for limit, u, v, qi in queries_with_idx:\\n            # Union all edges with weight < limit\\n            while ei < len(edgeList) and edgeList[ei][2] < limit:\\n                a, b, w = edgeList[ei]\\n                dsu.union(a, b)\\n                ei += 1\\n            # After adding those edges, u and v are connected iff a valid path exists\\n            res[qi] = (dsu.find(u) == dsu.find(v))\\n\\n        return res\\n\"",
  "880_14631217_python-updated-time": "1745953585928",
  "207_14631217_python": "\"class Solution(object):\\n    def canFinish(self, numCourses, prerequisites):\\n        \\\"\\\"\\\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        from collections import defaultdict, deque\\n\\n        graph = defaultdict(list)\\n        indegree = [0] * numCourses\\n        \\n        for dest, src in prerequisites:\\n            graph[src].append(dest)\\n            indegree[dest] += 1\\n        \\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\\n        visited = 0\\n        \\n        while queue:\\n            node = queue.popleft()\\n            visited += 1\\n            for neighbor in graph[node]:\\n                indegree[neighbor] -= 1\\n                if indegree[neighbor] == 0:\\n                    queue.append(neighbor)\\n        \\n        return visited == numCourses\\n\"",
  "2422_14631217_python": "\"class Solution:\\n    def smallestTrimmedNumbers(self, nums, queries):\\n        n = len(nums)\\n        L = len(nums[0])\\n        \\n        # We'll build, for each trim t = 1..L, the list of indices\\n        # sorted by their rightmost t digits (lex order, tie-breaking by index).\\n        # We do an LSD radix build: start from trim=1, then extend to trim=2, etc.\\n        sorted_idx = list(range(n))\\n        sorted_by_trim = [None] * (L + 1)\\n        \\n        for t in range(1, L+1):\\n            # stable counting sort on the t-th digit from the right\\n            buckets = [[] for _ in range(10)]\\n            pos = L - t\\n            for i in sorted_idx:\\n                d = ord(nums[i][pos]) - ord('0')\\n                buckets[d].append(i)\\n            # flatten\\n            sorted_idx = []\\n            for bucket in buckets:\\n                sorted_idx.extend(bucket)\\n            sorted_by_trim[t] = sorted_idx[:]  # snapshot\\n        \\n        # answer each query in O(1)\\n        ans = []\\n        for k, trim in queries:\\n            ans.append(sorted_by_trim[trim][k-1])\\n        return ans\\n\"",
  "2144_14631217_python": "\"class Solution(object):\\n    def maximumDifference(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        min_val = nums[0]\\n        max_diff = -1\\n        for num in nums[1:]:\\n            if num > min_val:\\n                max_diff = max(max_diff, num - min_val)\\n            else:\\n                min_val = num\\n        return max_diff\\n\"",
  "2356_14631217_python-updated-time": "1746881346055",
  "956_14631217_python-updated-time": "1746003607998",
  "3184_14631217_python": "\"class Solution(object):\\n    def maxBalancedSubsequenceSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n\\n        # 1) Compute A[i] = nums[i] - i, and collect for compression\\n        A = [nums[i] - i for i in range(n)]\\n        xs = sorted(set(A))\\n        # map each A[i] to 1-based index in compressed array\\n        comp = {v: i+1 for i,v in enumerate(xs)}\\n        m = len(xs)\\n\\n        # 2) Fenwick tree (1..m) supporting point‐update max, prefix‐query max\\n        class FenwickMax:\\n            def __init__(self, n):\\n                self.n = n\\n                self.fw = [float(\\\"-inf\\\")] * (n+1)\\n            def update(self, i, val):\\n                # set fw[i] = max(fw[i], val)\\n                while i <= self.n:\\n                    if val > self.fw[i]:\\n                        self.fw[i] = val\\n                    i += i & -i\\n            def query(self, i):\\n                # return max over fw[1..i]\\n                res = float(\\\"-inf\\\")\\n                while i > 0:\\n                    if self.fw[i] > res:\\n                        res = self.fw[i]\\n                    i -= i & -i\\n                return res\\n\\n        fenw = FenwickMax(m)\\n        ans = float(\\\"-inf\\\")\\n\\n        # 3) DP sweep left→right\\n        # dp[i] = w[i] + max(0, max{ dp[j] : j < i, A[j] <= A[i] })\\n        # we keep in Fenwick at idx=comp[A[j]] the value dp[j]\\n        for i in range(n):\\n            idx = comp[A[i]]\\n            best_prefix = fenw.query(idx)\\n            # if best_prefix is -inf (no j yet), treat as 0\\n            if best_prefix < 0:\\n                best_prefix = 0\\n            dp_i = best_prefix + nums[i]\\n            # record dp[i]\\n            fenw.update(idx, dp_i)\\n            # track global answer\\n            if dp_i > ans:\\n                ans = dp_i\\n\\n        return ans\"",
  "897_14631217_python-updated-time": "1746001329377",
  "2412_14631217_python": "\"class Solution:\\n    def fillCups(self, amount):\\n        total = amount[0] + amount[1] + amount[2]\\n        mx = max(amount)\\n        # You can fill at most 2 cups per second, but they must be different types.\\n        # So you need at least ceil(total/2) seconds, and also at least as many seconds\\n        # as the largest single type (since you can't pair beyond the sum of the other two).\\n        return max(mx, (total + 1) // 2)\\n\"",
  "2576_14631217_python-updated-time": "1747057114239",
  "3619_14631217_python-updated-time": "1747587615136",
  "1739_14631217_python-updated-time": "1746444160777",
  "1905_14631217_python": "\"class AuthenticationManager(object):\\n\\n    def __init__(self, timeToLive):\\n        self.timeToLive = timeToLive\\n        self.tokens = {}  # tokenId -> expiryTime\\n\\n    def generate(self, tokenId, currentTime):\\n        self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def renew(self, tokenId, currentTime):\\n        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:\\n            self.tokens[tokenId] = currentTime + self.timeToLive\\n\\n    def countUnexpiredTokens(self, currentTime):\\n        return sum(1 for expiry in self.tokens.values() if expiry > currentTime)\\n\"",
  "3047_14631217_python": "\"import math\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def maximumSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def get_square_free_part(x):\\n            res = 1\\n            d = 2\\n            while d * d <= x:\\n                count = 0\\n                while x % d == 0:\\n                    x //= d\\n                    count += 1\\n                if count % 2 == 1:\\n                    res *= d\\n                d += 1\\n            if x > 1:\\n                res *= x\\n            return res\\n\\n        groups = defaultdict(int)\\n        for idx, val in enumerate(nums):\\n            i = idx + 1  # since it's 1-indexed\\n            key = get_square_free_part(i)\\n            groups[key] += val\\n\\n        return max(groups.values())\\n\"",
  "2614_14631217_python": "\"class Solution:\\n    def maximumCount(self, nums):\\n        import bisect\\n        # First positive number index\\n        pos_index = bisect.bisect_right(nums, 0)\\n        # First zero index is where negatives end\\n        neg_index = bisect.bisect_left(nums, 0)\\n        pos = len(nums) - pos_index\\n        neg = neg_index\\n        return max(pos, neg)\\n\"",
  "1476_14631217_python-updated-time": "1746345075590",
  "2168_14631217_python-updated-time": "1746720026015",
  "3261_14631217_python": "\"class Solution(object):\\n    def minOrAfterOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # final number of segments after exactly k merges\\n        need = n - k  \\n        # initial OR of all numbers\\n        cur_or = 0\\n        for v in nums:\\n            cur_or |= v\\n\\n        MAXB = 30\\n        forbidden = 0  # bits we have successfully cleared\\n\\n        # try clearing bits from high to low\\n        for b in range(MAXB - 1, -1, -1):\\n            bit = 1 << b\\n            # only consider if this bit is currently set\\n            if not (cur_or & bit):\\n                continue\\n\\n            # candidate forbidden bits if we clear this one\\n            cand = forbidden | bit\\n\\n            # greedy scan: count how many segments we can form\\n            # such that each segment's AND has zeros in all bits in 'cand'\\n            segments = 0\\n            mask = cand\\n            curr_zeros = 0\\n            for v in nums:\\n                # mark zeros for this element in the forbidden bits\\n                curr_zeros |= ((~v) & mask)\\n                # once we've seen zeros for every forbidden bit, cut a segment\\n                if curr_zeros == mask:\\n                    segments += 1\\n                    curr_zeros = 0\\n\\n            # if we can get at least 'need' segments, it's feasible\\n            if segments >= need:\\n                # accept clearing this bit\\n                forbidden = cand\\n                cur_or ^= bit\\n\\n        return cur_or\\n\"",
  "1694_14631217_python-updated-time": "1746438770236",
  "1424_14631217_python-updated-time": "1746260513869",
  "284_14631217_python-updated-time": "1745254773264",
  "3700_14631217_python": "\"from collections import defaultdict\\n\\nMOD = 1000000007\\ndef C2(x):\\n    return x * (x - 1) // 2\\n\\nclass Solution(object):\\n    def subsequencesWithMiddleMode(self, nums):\\n        n = len(nums)\\n        if n < 5:\\n            return 0\\n\\n        suff = defaultdict(int)\\n        for v in nums:\\n            suff[v] += 1\\n        suff_sum_c2 = sum(C2(c) for c in suff.values())\\n\\n        pref = defaultdict(int)\\n        pref_sum_c2 = 0\\n\\n        ans = 0\\n\\n        for k, v in enumerate(nums):\\n            old = suff[v]\\n            suff_sum_c2 -= C2(old)\\n            old -= 1\\n            if old:\\n                suff[v] = old\\n                suff_sum_c2 += C2(old)\\n            else:\\n                del suff[v]\\n\\n            left_len  = k\\n            right_len = n - k - 1\\n            if left_len < 2 or right_len < 2:\\n                pref_sum_c2 -= C2(pref[v])\\n                pref[v] += 1\\n                pref_sum_c2 += C2(pref[v])\\n                continue\\n\\n            pref_v = pref.get(v, 0)\\n            suff_v = suff.get(v, 0)\\n\\n            lenNL = left_len  - pref_v\\n            lenNR = right_len - suff_v\\n\\n            L0 = C2(lenNL)\\n            L1 = pref_v * lenNL\\n            L2 = C2(pref_v)\\n\\n            R0 = C2(lenNR)\\n            R1 = suff_v * lenNR\\n            R2 = C2(suff_v)\\n\\n            dupL = (pref_sum_c2 - C2(pref_v))\\n            dupR = (suff_sum_c2 - C2(suff_v))\\n\\n            LD = L0 - dupL\\n            RD = R0 - dupR\\n\\n            ans += (L0 * R2 + L1 * R1 + L2 * R0)\\n            ans += (L1 * R2 + L2 * R1)\\n            ans += (L2 * R2)\\n            ans %= MOD\\n\\n            if pref_v and RD:\\n                S1 = 0\\n                for x in pref:\\n                    if x == v or pref[x] == 0:\\n                        continue\\n                    suff_x = suff.get(x, 0)\\n                    S1 += pref[x] * suff_x * (lenNR - suff_x)\\n                contrib = pref_v * (RD * lenNL - S1)\\n                ans = (ans + contrib) % MOD\\n\\n            if suff_v and LD:\\n                S2 = 0\\n                for x in suff:\\n                    if x == v or suff[x] == 0:\\n                        continue\\n                    pref_x = pref.get(x, 0)\\n                    S2 += suff[x] * pref_x * (lenNL - pref_x)\\n                contrib = suff_v * (LD * lenNR - S2)\\n                ans = (ans + contrib) % MOD\\n\\n            pref_sum_c2 -= C2(pref[v])\\n            pref[v] += 1\\n            pref_sum_c2 += C2(pref[v])\\n\\n        return ans % MOD\\n\"",
  "2739_14631217_python-updated-time": "1747136163735",
  "3705_14631217_python": "\"class Solution(object):\\n    def largestInteger(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        count = defaultdict(int)\\n        n = len(nums)\\n\\n        # Slide a window of size k over nums and count appearances of each number in each subarray\\n        for i in range(n - k + 1):\\n            window = nums[i:i + k]\\n            unique = set(window)\\n            for num in unique:\\n                count[num] += 1\\n\\n        # Find all numbers that appear in exactly one subarray and return the largest one\\n        candidates = [num for num, c in count.items() if c == 1]\\n        return max(candidates) if candidates else -1\\n\"",
  "657_14631217_python-updated-time": "1745782890330",
  "1648_14631217_python-updated-time": "1746434307185",
  "335_14631217_python-updated-time": "1745256737832",
  "3312_14631217_python-updated-time": "1747411421290",
  "718_14631217_python": "\"class Solution(object):\\n    def findLength(self, nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        # dp[i][j]: length of longest common suffix of nums1[:i] and nums2[:j]\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        ans = 0\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if nums1[i - 1] == nums2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                    ans = max(ans, dp[i][j])\\n        \\n        return ans\\n\"",
  "3556_14631217_python-updated-time": "1747504071876",
  "1256_14631217_python": "\"class Solution:\\n    def arrayRankTransform(self, arr):\\n        # Create a sorted list of the unique values\\n        unique_sorted = sorted(set(arr))\\n        # Map each value to its rank (1-based index in the sorted unique list)\\n        rank = {v: i + 1 for i, v in enumerate(unique_sorted)}\\n        # Replace each element in arr with its rank\\n        return [rank[v] for v in arr]\\n\"",
  "1840_14631217_python-updated-time": "1746529769046",
  "2323_14631217_python-updated-time": "1746811048359",
  "28_14631217_python": "\"class Solution(object):\\n    def strStr(self, haystack, needle):\\n        \\\"\\\"\\\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not needle:\\n            return 0\\n        for i in range(len(haystack) - len(needle) + 1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1\\n\"",
  "3114_14631217_python": "\"class Solution(object):\\n    def maximumSumOfHeights(self, heights):\\n        \\\"\\\"\\\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(heights)\\n\\n        # Compute left sums (non-increasing when going backward from peak)\\n        left = [0] * n\\n        stack = []\\n        total = 0\\n        for i in range(n):\\n            h = heights[i]\\n            while stack and heights[stack[-1]] > h:\\n                stack.pop()\\n            if not stack:\\n                left[i] = h * (i + 1)\\n            else:\\n                j = stack[-1]\\n                left[i] = left[j] + h * (i - j)\\n            stack.append(i)\\n\\n        # Compute right sums (non-increasing when going forward from peak)\\n        right = [0] * n\\n        stack = []\\n        for i in reversed(range(n)):\\n            h = heights[i]\\n            while stack and heights[stack[-1]] > h:\\n                stack.pop()\\n            if not stack:\\n                right[i] = h * (n - i)\\n            else:\\n                j = stack[-1]\\n                right[i] = right[j] + h * (j - i)\\n            stack.append(i)\\n\\n        # Try every peak and take max total\\n        max_total = 0\\n        for i in range(n):\\n            max_total = max(max_total, left[i] + right[i] - heights[i])\\n\\n        return max_total\\n\"",
  "3851_14631217_python": "\"class Solution:\\n    def magicalSum(self, m, k, nums):\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        # factorials and inverse factorials up to m\\n        fact = [1] * (m+1)\\n        for i in range(1, m+1):\\n            fact[i] = fact[i-1] * i % mod\\n        inv_fact = [1] * (m+1)\\n        inv_fact[m] = pow(fact[m], mod-2, mod)\\n        for i in range(m, 0, -1):\\n            inv_fact[i-1] = inv_fact[i] * i % mod\\n        # precompute nums[i]^c * inv_fact[c]\\n        pw = [[0]*(m+1) for _ in range(n)]\\n        for i in range(n):\\n            pw[i][0] = 1\\n            for c in range(1, m+1):\\n                pw[i][c] = pw[i][c-1] * nums[i] % mod\\n            for c in range(m+1):\\n                pw[i][c] = pw[i][c] * inv_fact[c] % mod\\n        # number of bits to process: n + enough to clear carries\\n        L = n + 6\\n        # dp[carry][ones][used]\\n        dp = [[[0]*(m+1) for _ in range(k+1)] for _ in range(m+1)]\\n        dp[0][0][0] = 1\\n        for i in range(L):\\n            ndp = [[[0]*(m+1) for _ in range(k+1)] for _ in range(m+1)]\\n            if i < n:\\n                pi = pw[i]\\n                for carry in range(m+1):\\n                    for ones in range(k+1):\\n                        for used in range(m+1):\\n                            v = dp[carry][ones][used]\\n                            if not v:\\n                                continue\\n                            limit = m - used\\n                            for c in range(limit+1):\\n                                s = carry + c\\n                                bit = s & 1\\n                                ones2 = ones + bit\\n                                if ones2 > k:\\n                                    continue\\n                                carry2 = s >> 1\\n                                ndp[carry2][ones2][used+c] = (\\n                                    ndp[carry2][ones2][used+c] + v * pi[c]\\n                                ) % mod\\n            else:\\n                for carry in range(m+1):\\n                    for ones in range(k+1):\\n                        for used in range(m+1):\\n                            v = dp[carry][ones][used]\\n                            if not v:\\n                                continue\\n                            s = carry\\n                            bit = s & 1\\n                            ones2 = ones + bit\\n                            if ones2 > k:\\n                                continue\\n                            carry2 = s >> 1\\n                            ndp[carry2][ones2][used] = (ndp[carry2][ones2][used] + v) % mod\\n            dp = ndp\\n        F = dp[0][k][m]\\n        return F * fact[m] % mod\\n\"",
  "3775_14631217_python-updated-time": "1747680169088",
  "152_14631217_python-updated-time": "1745090841574",
  "744_14631217_python-updated-time": "1745875376636",
  "861_14631217_python": "\"class Solution(object):\\n    def flipAndInvertImage(self, image):\\n        for row in image:\\n            row.reverse()\\n            for i in range(len(row)):\\n                row[i] ^= 1\\n        return image\\n\"",
  "13_14631217_python": "\"class Solution(object):\\n    def romanToInt(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        roman = {\\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\\n            'C': 100, 'D': 500, 'M': 1000\\n        }\\n        total = 0\\n        prev = 0\\n\\n        for c in reversed(s):\\n            curr = roman[c]\\n            if curr < prev:\\n                total -= curr\\n            else:\\n                total += curr\\n            prev = curr\\n\\n        return total\\n\"",
  "1056_14631217_python-updated-time": "1746041377925",
  "1676_14631217_python-updated-time": "1746434531975",
  "2591_14631217_python-updated-time": "1747058204413",
  "2604_14631217_python": "\"class Solution:\\n    def minOperations(self, nums1, nums2, k):\\n        # Special case: no change possible\\n        if k == 0:\\n            return 0 if nums1 == nums2 else -1\\n        \\n        n = len(nums1)\\n        diff_sum = 0\\n        pos_sum = 0\\n        \\n        for a, b in zip(nums1, nums2):\\n            d = b - a\\n            diff_sum += d\\n            # Each position must be reachable by ±k steps\\n            if d % k != 0:\\n                return -1\\n            if d > 0:\\n                pos_sum += d\\n        \\n        # Total difference must cancel out\\n        if diff_sum != 0:\\n            return -1\\n        \\n        # Each operation moves exactly k units into one pos\\n        return pos_sum // k\\n\"",
  "1861_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def minimumBoxes(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # tetrahedral number T(k) = k(k+1)(k+2)/6\\n        def tetra(k):\\n            return k * (k + 1) * (k + 2) // 6\\n\\n        # -------- 1. largest full staircase that fits ----------\\n        lo, hi = 0, 2 * int((6 * n) ** (1.0 / 3)) + 3   # safe upper bound on k\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if tetra(mid) <= n:\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        k = lo                                    # height of the complete staircase\\n        used = tetra(k)\\n        base = k * (k + 1) // 2                   # floor boxes in those k layers\\n        rem = n - used                            # boxes still to place\\n\\n        if rem == 0:\\n            return base\\n\\n        # -------- 2. extra floor boxes for the leftover --------\\n        # solve add(add+1)/2 >= rem  ->  add = ceil( (sqrt(1+8*rem)-1)/2 )\\n        add = int(math.ceil((math.sqrt(1 + 8 * rem) - 1) / 2))\\n        return base + add\\n\"",
  "3_14631217_python": "\"class Solution(object):\\n    def lengthOfLongestSubstring(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        char_set = set()\\n        left = 0\\n        max_len = 0\\n\\n        for right in range(len(s)):\\n            while s[right] in char_set:\\n                char_set.remove(s[left])\\n                left += 1\\n            char_set.add(s[right])\\n            max_len = max(max_len, right - left + 1)\\n\\n        return max_len\\n\"",
  "3311_14631217_python": "\"class Solution(object):\\n    def returnToBoundaryCount(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        pos = 0\\n        count = 0\\n\\n        for move in nums:\\n            pos += move\\n            if pos == 0:\\n                count += 1\\n\\n        return count\\n\"",
  "2076_14631217_python": "\"class Solution(object):\\n    def getLucky(self, s, k):\\n        # Compute initial digit-sum of the concatenated positions\\n        total = 0\\n        for ch in s:\\n            v = ord(ch) - ord('a') + 1\\n            # add sum of digits of v\\n            if v < 10:\\n                total += v\\n            else:\\n                total += v // 10 + v % 10\\n        \\n        # Perform k-1 further digit-sum transforms\\n        for _ in range(k-1):\\n            t = 0\\n            while total > 0:\\n                t += total % 10\\n                total //= 10\\n            total = t\\n        \\n        return total\\n\"",
  "2383_14631217_python-updated-time": "1746879486721",
  "330_14631217_python-updated-time": "1745256613539",
  "3822_14631217_python": "\"class Solution(object):\\n    def specialGrid(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        # Base case: 1x1 grid\\n        if n == 0:\\n            return [[0]]\\n        \\n        # Recursive build of smaller (2^(n-1) x 2^(n-1)) special grid\\n        small = self.specialGrid(n - 1)\\n        m = 1 << (n - 1)          # size of small grid\\n        size = m << 1             # size of new grid = 2*m\\n        chunk = m * m             # number of entries in each quadrant\\n        \\n        # Initialize the 2^n x 2^n result grid\\n        grid = [[0] * size for _ in range(size)]\\n        \\n        # Quadrant offsets: TR=0, BR=1, BL=2, TL=3 (in increasing value order)\\n        # Fill Top-Right (rows 0..m-1, cols m..2m-1)\\n        for i in range(m):\\n            for j in range(m):\\n                grid[i][j + m] = small[i][j] + 0 * chunk\\n        \\n        # Fill Bottom-Right (rows m..2m-1, cols m..2m-1)\\n        for i in range(m):\\n            for j in range(m):\\n                grid[i + m][j + m] = small[i][j] + 1 * chunk\\n        \\n        # Fill Bottom-Left (rows m..2m-1, cols 0..m-1)\\n        for i in range(m):\\n            for j in range(m):\\n                grid[i + m][j] = small[i][j] + 2 * chunk\\n        \\n        # Fill Top-Left (rows 0..m-1, cols 0..m-1)\\n        for i in range(m):\\n            for j in range(m):\\n                grid[i][j] = small[i][j] + 3 * chunk\\n        \\n        return grid\\n\"",
  "894_14631217_python-updated-time": "1745786492579",
  "653_14631217_python-updated-time": "1745782750893",
  "1434_14631217_python": "\"class Solution:\\n    def freqAlphabets(self, s):\\n        res = []\\n        i = len(s) - 1\\n        while i >= 0:\\n            if s[i] == '#':\\n                num = int(s[i-2:i])\\n                res.append(chr(ord('a') + num - 1))\\n                i -= 3\\n            else:\\n                num = int(s[i])\\n                res.append(chr(ord('a') + num - 1))\\n                i -= 1\\n        return ''.join(reversed(res))\\n\"",
  "2699_14631217_python-updated-time": "1747065211388",
  "581_14631217_python-updated-time": "1745448003701",
  "971_14631217_python-updated-time": "1746004076064",
  "3741_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maxFreeTime(self, eventTime, startTime, endTime):\\n        \\\"\\\"\\\"\\n        :type eventTime: int\\n        :type startTime: List[int]\\n        :type endTime: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(startTime)\\n        # durations of each meeting\\n        d = [endTime[i] - startTime[i] for i in range(n)]\\n        # g[j] = free time before meeting j (for j=0),\\n        # between meeting j-1 and j (1 <= j <= n-1),\\n        # and after meeting n-1 (j = n)\\n        g = [0] * (n + 1)\\n        g[0] = startTime[0]\\n        for j in range(1, n):\\n            g[j] = startTime[j] - endTime[j - 1]\\n        g[n] = eventTime - endTime[n - 1]\\n\\n        # Sort g for fast \\\">= d_i\\\" counts\\n        sorted_g = sorted(g)\\n        L = n + 1\\n\\n        # Original maximum free slot without any move\\n        original_max = sorted_g[-1]\\n\\n        # Precompute global largest (M1), its count, and second‐largest (M2)\\n        M1 = original_max\\n        count1 = sum(1 for x in g if x == M1)\\n        # find the next smaller value\\n        M2 = 0\\n        for x in reversed(sorted_g):\\n            if x < M1:\\n                M2 = x\\n                break\\n\\n        ans = original_max\\n\\n        for i in range(n):\\n            di = d[i]\\n            # free time if we remove meeting i (merging g[i] and g[i+1])\\n            fi = g[i] + di + g[i + 1]\\n\\n            # how many original g’s are >= di?\\n            idx = bisect.bisect_left(sorted_g, di)\\n            number_ge = L - idx\\n            # subtract g[i], g[i+1] if they counted\\n            subtract = (1 if g[i] >= di else 0) + (1 if g[i + 1] >= di else 0)\\n            Ki = number_ge - subtract\\n\\n            # compute max free among the other g’s after removing g[i],g[i+1]\\n            if count1 >= 2:\\n                g_excl = M1\\n            else:\\n                # only one occurrence of M1 in g\\n                if g[i] == M1 or g[i + 1] == M1:\\n                    g_excl = M2\\n                else:\\n                    g_excl = M1\\n\\n            # if there's some other slot >= di, we can place meeting i there\\n            # and leave fi untouched as the largest free gap\\n            if Ki > 0:\\n                candidate = fi\\n            else:\\n                # otherwise we must place into the fi gap itself,\\n                # reducing it by di, so max free is max(g_excl, fi - di)\\n                candidate = max(g_excl, fi - di)\\n\\n            ans = max(ans, candidate)\\n\\n        return ans\\n\"",
  "232_14631217_python-updated-time": "1745247235697",
  "1986_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def largestPathValue(self, colors, edges):\\n        n = len(colors)\\n        adj = [[] for _ in range(n)]\\n        indegree = [0] * n\\n        for u, v in edges:\\n            adj[u].append(v)\\n            indegree[v] += 1\\n\\n        idx = [ord(c) - 97 for c in colors]\\n        dp = [[0] * 26 for _ in range(n)]\\n        q = deque()\\n\\n        for i in range(n):\\n            dp[i][idx[i]] = 1\\n            if indegree[i] == 0:\\n                q.append(i)\\n\\n        seen = 0\\n        while q:\\n            u = q.popleft()\\n            seen += 1\\n            for v in adj[u]:\\n                for c in range(26):\\n                    val = dp[u][c] + (1 if c == idx[v] else 0)\\n                    if val > dp[v][c]:\\n                        dp[v][c] = val\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    q.append(v)\\n\\n        if seen != n:\\n            return -1\\n\\n        return max(max(row) for row in dp)\\n\"",
  "2661_14631217_python-updated-time": "1747133683307",
  "284_14631217_python": "\"# Below is the interface for Iterator, which is already defined.\\n# You should not implement it, or speculate about its implementation.\\nclass Iterator(object):\\n    def __init__(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        \\\"\\\"\\\"\\n        self.nums = nums\\n        self.index = 0\\n\\n    def hasNext(self):\\n        \\\"\\\"\\\"\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return self.index < len(self.nums)\\n\\n    def next(self):\\n        \\\"\\\"\\\"\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if self.hasNext():\\n            val = self.nums[self.index]\\n            self.index += 1\\n            return val\\n        else:\\n            return None\\n\\nclass PeekingIterator(object):\\n    def __init__(self, iterator):\\n        \\\"\\\"\\\"\\n        :type iterator: Iterator\\n        \\\"\\\"\\\"\\n        self.iterator = iterator\\n        self._peek = None\\n        if self.iterator.hasNext():\\n            self._peek = self.iterator.next()\\n\\n    def peek(self):\\n        \\\"\\\"\\\"\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self._peek\\n\\n    def next(self):\\n        \\\"\\\"\\\"\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        val = self._peek\\n        if self.iterator.hasNext():\\n            self._peek = self.iterator.next()\\n        else:\\n            self._peek = None\\n        return val\\n\\n    def hasNext(self):\\n        \\\"\\\"\\\"\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return self._peek is not None\\n\"",
  "3830_14631217_python": "\"class Solution(object):\\n    def findClosest(self, x, y, z):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :type y: int\\n        :type z: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        d1 = abs(x - z)\\n        d2 = abs(y - z)\\n        if d1 < d2:\\n            return 1\\n        elif d2 < d1:\\n            return 2\\n        else:\\n            return 0\\n\"",
  "1379_14631217_python": "\"class Solution:\\n    def reconstructMatrix(self, upper, lower, colsum):\\n        n = len(colsum)\\n        res = [[0] * n for _ in range(2)]\\n\\n        for i in range(n):\\n            if colsum[i] == 2:\\n                res[0][i] = 1\\n                res[1][i] = 1\\n                upper -= 1\\n                lower -= 1\\n\\n        for i in range(n):\\n            if colsum[i] == 1:\\n                if upper > 0:\\n                    res[0][i] = 1\\n                    upper -= 1\\n                elif lower > 0:\\n                    res[1][i] = 1\\n                    lower -= 1\\n                else:\\n                    return []\\n\\n        if upper == 0 and lower == 0:\\n            return res\\n        return []\\n\"",
  "3324_14631217_python": "\"class Solution(object):\\n    def isPossibleToSplit(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n        \\n        counts = Counter(nums)\\n        # If any number occurs more than twice, it's impossible\\n        return max(counts.values()) <= 2\\n\"",
  "2022_14631217_python": "\"class Solution:\\n    def maxAlternatingSum(self, nums):\\n        even, odd = 0, 0\\n        for num in nums:\\n            new_even = max(even, odd + num)\\n            new_odd = max(odd, even - num)\\n            even, odd = new_even, new_odd\\n        return even\\n\"",
  "310_14631217_python": "\"class Solution(object):\\n    def findMinHeightTrees(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if n == 1:\\n            return [0]\\n        \\n        from collections import defaultdict, deque\\n        \\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        leaves = [i for i in range(n) if len(graph[i]) == 1]\\n        \\n        while n > 2:\\n            n -= len(leaves)\\n            new_leaves = []\\n            for leaf in leaves:\\n                neighbor = graph[leaf].pop()\\n                graph[neighbor].remove(leaf)\\n                if len(graph[neighbor]) == 1:\\n                    new_leaves.append(neighbor)\\n            leaves = new_leaves\\n        \\n        return leaves\\n\"",
  "448_14631217_python": "\"class Solution:\\n    def findDisappearedNumbers(self, nums):\\n        for num in nums:\\n            idx = abs(num) - 1\\n            if nums[idx] > 0:\\n                nums[idx] = -nums[idx]\\n        \\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                res.append(i + 1)\\n        \\n        return res\\n\"",
  "7_14631217_python": "\"class Solution(object):\\n    def reverse(self, x):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        sign = -1 if x < 0 else 1\\n        x = abs(x)\\n        rev = 0\\n\\n        while x != 0:\\n            pop = x % 10\\n            x //= 10\\n            if rev > (2**31 - 1) // 10:\\n                return 0\\n            rev = rev * 10 + pop\\n\\n        return sign * rev\\n\"",
  "2145_14631217_python": "\"class Solution(object):\\n    def gridGame(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid[0])\\n        top = grid[0][:]\\n        bottom = grid[1][:]\\n        \\n        # Prefix sums for easy range sum calculation\\n        for i in range(1, n):\\n            top[i] += top[i - 1]\\n            bottom[i] += bottom[i - 1]\\n        \\n        result = float('inf')\\n        \\n        for i in range(n):\\n            # If first robot drops down at column i:\\n            # Top remaining for robot 2 is from i+1 to n-1\\n            top_remain = top[-1] - top[i] if i < n - 1 else 0\\n            # Bottom remaining for robot 2 is from 0 to i-1\\n            bottom_remain = bottom[i - 1] if i > 0 else 0\\n            result = min(result, max(top_remain, bottom_remain))\\n        \\n        return result\\n\"",
  "2651_14631217_python-updated-time": "1747066367099",
  "3437_14631217_python-updated-time": "1747485305699",
  "1773_14631217_mysql": "\"SELECT\\n  r.contest_id,\\n  ROUND(COUNT(DISTINCT r.user_id) * 100.0 / (SELECT COUNT(*) FROM Users), 2) AS percentage\\nFROM Register AS r\\nGROUP BY r.contest_id\\nORDER BY\\n  percentage DESC,\\n  r.contest_id ASC;\\n\"",
  "500_14631217_python": "\"class Solution:\\n    def findWords(self, words):\\n        row1 = set(\\\"qwertyuiop\\\")\\n        row2 = set(\\\"asdfghjkl\\\")\\n        row3 = set(\\\"zxcvbnm\\\")\\n\\n        res = []\\n        for word in words:\\n            w = set(word.lower())\\n            if w <= row1 or w <= row2 or w <= row3:\\n                res.append(word)\\n        return res\\n\"",
  "2306_14631217_python-updated-time": "1746804671040",
  "3244_14631217_python-updated-time": "1747399729135",
  "3064_14631217_pythondata": "\"import pandas as pd\\n\\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given two DataFrames `df1` and `df2` with the same columns,\\n    returns a single DataFrame with `df2`'s rows appended below `df1`'s rows.\\n    \\\"\\\"\\\"\\n    return pd.concat([df1, df2], ignore_index=True)\\n\"",
  "3107_14631217_python-updated-time": "1747310681651",
  "1103_14631217_python-updated-time": "1746042235607",
  "160_14631217_python-updated-time": "1745091210554",
  "2825_14631217_python-updated-time": "1747140541125",
  "3588_14631217_python": "\"class Solution(object):\\n    def countWinningSequences(self, s):\\n        mod = 10**9 + 7\\n        n = len(s)\\n        # map F,W,E → 0,1,2\\n        m = {'F':0,'W':1,'E':2}\\n        a = [m[ch] for ch in s]\\n\\n        # f[c][ai] = +1 if c beats ai, -1 if ai beats c, else 0\\n        f = [[0]*3 for _ in range(3)]\\n        for c in range(3):\\n            for ai in range(3):\\n                d = (c - ai) % 3\\n                if d == 1:\\n                    f[c][ai] = 1\\n                elif d == 2:\\n                    f[c][ai] = -1\\n\\n        offset = n\\n        size = 2*n + 1\\n        # dp_last[c][offset+diff] = # ways up to previous round,\\n        # ending with last move c and score‐diff = diff\\n        dp_last = [[0]*size for _ in range(3)]\\n\\n        # --- initialize for round 0 ---\\n        for c in range(3):\\n            delta0 = f[c][a[0]]\\n            dp_last[c][offset + delta0] = 1\\n\\n        # current achievable diff range after round 0:\\n        diff_lo, diff_hi = -1, 1\\n\\n        # --- process rounds 1..n-1 ---\\n        for i in range(1, n):\\n            dp_next = [[0]*size for _ in range(3)]\\n            ai = a[i]\\n            # after adding one more round, diff shifts by at most ±1\\n            new_lo = max(diff_lo - 1, -n)\\n            new_hi = min(diff_hi + 1,  n)\\n\\n            # transition\\n            for last in range(3):\\n                row = dp_last[last]\\n                for diff in range(diff_lo, diff_hi+1):\\n                    ways = row[offset + diff]\\n                    if not ways:\\n                        continue\\n                    # Bob’s next move c ≠ last\\n                    for c in range(3):\\n                        if c == last:\\n                            continue\\n                        nd = diff + f[c][ai]\\n                        dp_next[c][offset + nd] = (dp_next[c][offset + nd] + ways) % mod\\n\\n            dp_last = dp_next\\n            diff_lo, diff_hi = new_lo, new_hi\\n\\n        # --- sum all ways with final diff > 0 ---\\n        ans = 0\\n        for last in range(3):\\n            row = dp_last[last]\\n            for d in range(1, n+1):\\n                ans = (ans + row[offset + d]) % mod\\n\\n        return ans\\n\"",
  "3429_14631217_python-updated-time": "1747482777627",
  "1376_14631217_python": "\"class Solution:\\n    def sellingWood(self, m, n, prices):\\n        # price[h][w] = offered price for that exact rectangle (or 0 if none)\\n        price = [[0]*(n+1) for _ in range(m+1)]\\n        for h, w, p in prices:\\n            price[h][w] = p\\n\\n        # dp[h][w] = max money from a h×w rectangle\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n\\n        for h in range(1, m+1):\\n            for w in range(1, n+1):\\n                # start with the price of the whole piece, if we can sell it\\n                best = price[h][w]\\n\\n                # try all horizontal cuts\\n                for k in range(1, h//2 + 1):\\n                    best = max(best, dp[k][w] + dp[h - k][w])\\n\\n                # try all vertical cuts\\n                for k in range(1, w//2 + 1):\\n                    best = max(best, dp[h][k] + dp[h][w - k])\\n\\n                dp[h][w] = best\\n\\n        return dp[m][n]\\n\"",
  "23_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nimport heapq\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \\\"\\\"\\\"\\n        :type lists: List[Optional[ListNode]]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        heap = []\\n        for idx, node in enumerate(lists):\\n            if node:\\n                heapq.heappush(heap, (node.val, idx, node))\\n\\n        dummy = ListNode()\\n        current = dummy\\n\\n        while heap:\\n            val, idx, node = heapq.heappop(heap)\\n            current.next = node\\n            current = current.next\\n            if node.next:\\n                heapq.heappush(heap, (node.next.val, idx, node.next))\\n\\n        return dummy.next\\n\"",
  "672_14631217_python-updated-time": "1745783308574",
  "405_14631217_python-updated-time": "1745355994922",
  "1701_14631217_python": "\"class DSU(object):\\n    def __init__(self, n):\\n        self.p = list(range(n+1))\\n        self.rank = [0] * (n+1)\\n        self.count = n\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        if rx == ry:\\n            return False\\n        if self.rank[rx] < self.rank[ry]:\\n            self.p[rx] = ry\\n        elif self.rank[rx] > self.rank[ry]:\\n            self.p[ry] = rx\\n        else:\\n            self.p[ry] = rx\\n            self.rank[rx] += 1\\n        self.count -= 1\\n        return True\\n\\nclass Solution(object):\\n    def maxNumEdgesToRemove(self, n, edges):\\n        alice = DSU(n)\\n        bob = DSU(n)\\n        used = 0\\n\\n        # use type 3 edges first\\n        for t, u, v in edges:\\n            if t == 3 and alice.union(u, v):\\n                bob.union(u, v)\\n                used += 1\\n\\n        # type 1 for Alice\\n        for t, u, v in edges:\\n            if t == 1 and alice.union(u, v):\\n                used += 1\\n\\n        # type 2 for Bob\\n        for t, u, v in edges:\\n            if t == 2 and bob.union(u, v):\\n                used += 1\\n\\n        # check fully traversable\\n        if alice.count != 1 or bob.count != 1:\\n            return -1\\n        return len(edges) - used\\n\"",
  "810_14631217_python-updated-time": "1745877887070",
  "1500_14631217_python-updated-time": "1746346379494",
  "557_14631217_python": "\"class Solution(object):\\n    def reverseWords(self, s):\\n        # split on spaces, reverse each word, then rejoin\\n        return \\\" \\\".join(word[::-1] for word in s.split(\\\" \\\"))\\n\"",
  "1787_14631217_python": "\"class Solution(object):\\n    def getSumAbsoluteDifferences(self, nums):\\n        n = len(nums)\\n        prefix = [0] * (n + 1)\\n        for i in range(n):\\n            prefix[i+1] = prefix[i] + nums[i]\\n        res = [0] * n\\n        total = prefix[n]\\n        for i, v in enumerate(nums):\\n            # sum of differences for elements before i\\n            left = v * i - prefix[i]\\n            # sum of differences for elements after i\\n            right = (total - prefix[i+1]) - v * (n - i - 1)\\n            res[i] = left + right\\n        return res\\n\"",
  "859_14631217_python": "\"class MyCircularDeque(object):\\n    def __init__(self, k):\\n        self.queue = [0] * k\\n        self.head = 0\\n        self.count = 0\\n        self.size = k\\n\\n    def insertFront(self, value):\\n        if self.isFull():\\n            return False\\n        self.head = (self.head - 1 + self.size) % self.size\\n        self.queue[self.head] = value\\n        self.count += 1\\n        return True\\n\\n    def insertLast(self, value):\\n        if self.isFull():\\n            return False\\n        tail = (self.head + self.count) % self.size\\n        self.queue[tail] = value\\n        self.count += 1\\n        return True\\n\\n    def deleteFront(self):\\n        if self.isEmpty():\\n            return False\\n        self.head = (self.head + 1) % self.size\\n        self.count -= 1\\n        return True\\n\\n    def deleteLast(self):\\n        if self.isEmpty():\\n            return False\\n        self.count -= 1\\n        return True\\n\\n    def getFront(self):\\n        if self.isEmpty():\\n            return -1\\n        return self.queue[self.head]\\n\\n    def getRear(self):\\n        if self.isEmpty():\\n            return -1\\n        tail = (self.head + self.count - 1) % self.size\\n        return self.queue[tail]\\n\\n    def isEmpty(self):\\n        return self.count == 0\\n\\n    def isFull(self):\\n        return self.count == self.size\\n\"",
  "854_14631217_python": "\"class Solution(object):\\n    def largestIsland(self, grid):\\n        n = len(grid)\\n        index = 2\\n        area = {}\\n        \\n        def dfs(x, y, idx):\\n            if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] != 1:\\n                return 0\\n            grid[x][y] = idx\\n            return 1 + dfs(x+1, y, idx) + dfs(x-1, y, idx) + dfs(x, y+1, idx) + dfs(x, y-1, idx)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    area[index] = dfs(i, j, index)\\n                    index += 1\\n        \\n        res = max(area.values() or [0])\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    seen = set()\\n                    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                        ni, nj = i+dx, j+dy\\n                        if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1:\\n                            seen.add(grid[ni][nj])\\n                    res = max(res, 1 + sum(area[idx] for idx in seen))\\n        \\n        return res\\n\"",
  "3704_14631217_python": "\"class Solution(object):\\n    def countPartitions(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = sum(nums)\\n        # If overall sum is odd, diff = 2*prefix - total is odd for all prefixes\\n        if total % 2 != 0:\\n            return 0\\n        # Otherwise every split between 0..n-2 is valid\\n        return len(nums) - 1\\n\"",
  "1006_14631217_python": "\"class Solution:\\n    def spellchecker(self, wordlist, queries):\\n        vowels = set('aeiou')\\n\\n        def devowel(word):\\n            return ''.join('*' if c in vowels else c for c in word)\\n\\n        exact = set(wordlist)\\n        cap_map = {}\\n        vowel_map = {}\\n\\n        for word in wordlist:\\n            low = word.lower()\\n            vow = devowel(low)\\n            if low not in cap_map:\\n                cap_map[low] = word\\n            if vow not in vowel_map:\\n                vowel_map[vow] = word\\n\\n        result = []\\n        for q in queries:\\n            if q in exact:\\n                result.append(q)\\n            else:\\n                low = q.lower()\\n                vow = devowel(low)\\n                if low in cap_map:\\n                    result.append(cap_map[low])\\n                elif vow in vowel_map:\\n                    result.append(vowel_map[vow])\\n                else:\\n                    result.append(\\\"\\\")\\n\\n        return result\\n\"",
  "1505_14631217_python": "\"class Solution(object):\\n    def createTargetArray(self, nums, index):\\n        target = []\\n        for i in range(len(nums)):\\n            target.insert(index[i], nums[i])\\n        return target\\n\"",
  "1877_14631217_mysql-updated-time": "1746530224950",
  "524_14631217_python": "\"class Solution:\\n    def findLongestWord(self, s, dictionary):\\n        def is_subsequence(word):\\n            it = iter(s)\\n            return all(char in it for char in word)\\n\\n        dictionary.sort(key=lambda x: (-len(x), x))\\n        for word in dictionary:\\n            if is_subsequence(word):\\n                return word\\n        return \\\"\\\"\\n\"",
  "1394_14631217_python": "\"class Solution:\\n    def minPathCost(self, grid, moveCost):\\n        m, n = len(grid), len(grid[0])\\n        # dp[j] = min cost to reach cell in current row at column j\\n        dp = [grid[0][j] for j in range(n)]\\n        \\n        # Process each subsequent row\\n        for i in range(1, m):\\n            new_dp = [float('inf')] * n\\n            for prev_col in range(n):\\n                prev_val = grid[i-1][prev_col]\\n                base = dp[prev_col] + moveCost[prev_val][0]  # placeholder\\n                for col in range(n):\\n                    cost = dp[prev_col] + moveCost[prev_val][col] + grid[i][col]\\n                    if cost < new_dp[col]:\\n                        new_dp[col] = cost\\n            dp = new_dp\\n        \\n        # The answer is the min cost among the last row\\n        return min(dp)\\n\"",
  "820_14631217_python-updated-time": "1745878165977",
  "1011_14631217_python-updated-time": "1746039872528",
  "3640_14631217_python-updated-time": "1747586842789",
  "115_14631217_python-updated-time": "1745081384273",
  "2031_14631217_python": "\"class Solution:\\n    def twoEggDrop(self, n):\\n        k = 0\\n        while k * (k + 1) // 2 < n:\\n            k += 1\\n        return k\\n\"",
  "3154_14631217_python-updated-time": "1747305224258",
  "2286_14631217_python": "\"class Solution(object):\\n    def minimumTime(self, s):\\n        n = len(s)\\n        res = n  # worst case: remove every character one-by-one from the ends (all 1s)\\n        left = 0\\n\\n        for i in range(n):\\n            if s[i] == '1':\\n                left = min(left + 2, i + 1)  # remove s[i] (2 units) vs remove from left (1 unit each)\\n            res = min(res, left + n - 1 - i)  # left side cost + right side cost\\n        return res\\n\"",
  "1508_14631217_python": "\"class Solution(object):\\n    def longestPrefix(self, s):\\n        n = len(s)\\n        lps = [0] * n  # Longest Prefix Suffix array (KMP)\\n\\n        length = 0  # length of the previous longest prefix suffix\\n        i = 1\\n\\n        while i < n:\\n            if s[i] == s[length]:\\n                length += 1\\n                lps[i] = length\\n                i += 1\\n            else:\\n                if length != 0:\\n                    length = lps[length - 1]\\n                else:\\n                    lps[i] = 0\\n                    i += 1\\n\\n        return s[:lps[-1]]\\n\"",
  "2110_14631217_mysql-updated-time": "1746639354455",
  "2850_14631217_python": "\"class Solution:\\n    def longestString(self, x, y, z):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :type y: int\\n        :type z: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # The main idea is to alternate \\\"AA\\\" and \\\"BB\\\" strings without forming \\\"AAA\\\" or \\\"BBB\\\"\\n        # The maximum number of such alternations is min(x, y)\\n        # We can use one extra AA or BB (if any left) as long as it doesn't create triple\\n        pairs = min(x, y)\\n        extra = 1 if x != y else 0\\n        return (pairs * 2 + extra + z) * 2\\n\"",
  "2545_14631217_python-updated-time": "1746968783759",
  "3571_14631217_python": "\"class BIT:\\n    \\\"\\\"\\\"Fenwick tree for range‐maximum queries on prefix [0..i].\\\"\\\"\\\"\\n    def __init__(self, n):\\n        self.n = n\\n        self.f = [0] * (n + 1)\\n    def update(self, i, val):\\n        # set f[i] = max(f[i], val) and propagate\\n        i += 1\\n        while i <= self.n:\\n            if self.f[i] < val:\\n                self.f[i] = val\\n            i += i & -i\\n    def query(self, i):\\n        # max over [0..i]\\n        if i < 0:\\n            return 0\\n        i += 1\\n        res = 0\\n        while i > 0:\\n            if self.f[i] > res:\\n                res = self.f[i]\\n            i -= i & -i\\n        return res\\n\\nclass Solution(object):\\n    def maxPathLength(self, coordinates, k):\\n        \\\"\\\"\\\"\\n        :type coordinates: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(coordinates)\\n        # attach original indices\\n        pts = [(coordinates[i][0], coordinates[i][1], i) for i in range(n)]\\n        # compress y\\n        ys = sorted({y for _, y, _ in pts})\\n        y_to_rank = {y: i for i, y in enumerate(ys)}\\n        M = len(ys)\\n        # replace y by rank\\n        pts = [(x, y_to_rank[y], idx) for x, y, idx in pts]\\n\\n        # dp_before[i] = length of longest increasing chain ending at i\\n        dp_before = [0] * n\\n        bit1 = BIT(M)\\n\\n        # process groups of equal x in ascending x\\n        pts.sort(key=lambda t: t[0])\\n        i = 0\\n        while i < n:\\n            j = i\\n            # find range [i..j) with same x\\n            while j < n and pts[j][0] == pts[i][0]:\\n                j += 1\\n            # compute dp for this group without updating bit\\n            for x, y_r, idx in pts[i:j]:\\n                best = bit1.query(y_r - 1)\\n                dp_before[idx] = best + 1\\n            # now update bit with these dp values\\n            for x, y_r, idx in pts[i:j]:\\n                bit1.update(y_r, dp_before[idx])\\n            i = j\\n\\n        # dp_after[i] = length of longest increasing chain starting at i\\n        # i.e., on reversed axes: x desc, y desc\\n        dp_after = [0] * n\\n        bit2 = BIT(M)\\n        # for suffix we invert y-rank: y_rev = (M-1) - y_r\\n        pts.sort(key=lambda t: t[0], reverse=True)\\n        i = 0\\n        while i < n:\\n            j = i\\n            while j < n and pts[j][0] == pts[i][0]:\\n                j += 1\\n            for x, y_r, idx in pts[i:j]:\\n                y_rev = (M - 1) - y_r\\n                best = bit2.query(y_rev - 1)\\n                dp_after[idx] = best + 1\\n            for x, y_r, idx in pts[i:j]:\\n                y_rev = (M - 1) - y_r\\n                bit2.update(y_rev, dp_after[idx])\\n            i = j\\n\\n        # combine: longest through k = dp_before[k] + dp_after[k] - 1\\n        return dp_before[k] + dp_after[k] - 1\\n\"",
  "1622_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def findMaxValueOfEquation(self, points, k):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dq = deque()  # stores (yi - xi, xi)\\n        res = float('-inf')\\n\\n        for xj, yj in points:\\n            # Remove points where xj - xi > k\\n            while dq and xj - dq[0][1] > k:\\n                dq.popleft()\\n\\n            # Use the best candidate in deque\\n            if dq:\\n                res = max(res, yj + xj + dq[0][0])  # dq[0][0] = yi - xi\\n\\n            # Maintain deque: remove back if worse than current\\n            while dq and dq[-1][0] <= yj - xj:\\n                dq.pop()\\n\\n            dq.append((yj - xj, xj))\\n\\n        return res\\n\"",
  "2656_14631217_python": "\"class Solution(object):\\n    def beautifulSubarrays(self, nums):\\n        from collections import Counter\\n        cnt = Counter()\\n        xor = 0\\n        cnt[0] = 1   # prefix before start\\n        for x in nums:\\n            xor ^= x\\n            cnt[xor] += 1\\n\\n        res = 0\\n        for c in cnt.values():\\n            # choose any two equal prefixes\\n            res += c * (c - 1) // 2\\n        return res\\n\"",
  "2121_14631217_python-updated-time": "1746639511249",
  "2328_14631217_python": "\"class Solution:\\n    def minimizeResult(self, expression):\\n        left, right = expression.split('+')\\n        best_val = float('inf')\\n        best_expr = None\\n\\n        # Try every place to put '(' in left, and ')' in right\\n        for i in range(len(left)):           # i = 0 means \\\"(\\\" before left[0]\\n            for j in range(1, len(right) + 1):  # j = len(right) means \\\")\\\" after right[-1]\\n                prefix       = left[:i]\\n                inside_left  = left[i:]\\n                inside_right = right[:j]\\n                suffix       = right[j:]\\n\\n                # Multipliers: absent prefix/suffix means multiply by 1\\n                P = int(prefix) if prefix else 1\\n                S = int(suffix) if suffix else 1\\n\\n                total = P * (int(inside_left) + int(inside_right)) * S\\n\\n                if total < best_val:\\n                    best_val  = total\\n                    best_expr = prefix + \\\"(\\\" + inside_left + \\\"+\\\" + inside_right + \\\")\\\" + suffix\\n\\n        return best_expr\\n\"",
  "794_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def swimInWater(self, grid):\\n        n = len(grid)\\n        heap = [(grid[0][0], 0, 0)]\\n        visited = set((0, 0))\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n        \\n        while heap:\\n            t, x, y = heapq.heappop(heap)\\n            if (x, y) == (n-1, n-1):\\n                return t\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\\n                    visited.add((nx, ny))\\n                    heapq.heappush(heap, (max(t, grid[nx][ny]), nx, ny))\\n\"",
  "2093_14631217_python-updated-time": "1746639237926",
  "1538_14631217_python-updated-time": "1746347025642",
  "1398_14631217_python-updated-time": "1746260039768",
  "2195_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets, k):\\n        \\\"\\\"\\\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Queue of (remaining_tickets, person_index)\\n        q = deque((t, i) for i, t in enumerate(tickets))\\n        time = 0\\n        \\n        while q:\\n            t, i = q.popleft()\\n            # One ticket is bought in one second\\n            time += 1\\n            t -= 1\\n            # If this was the kth person and they're done, return time\\n            if i == k and t == 0:\\n                return time\\n            # Otherwise, if they still need more tickets, go to back\\n            if t > 0:\\n                q.append((t, i))\\n        return time  # unreachable, but included for completeness\\n\"",
  "1017_14631217_python": "\"class Solution:\\n    def oddEvenJumps(self, arr):\\n        n = len(arr)\\n        next_higher = [0] * n\\n        next_lower = [0] * n\\n\\n        def make_monotonic_stack(indexes):\\n            result = [0] * n\\n            stack = []\\n            for i in indexes:\\n                while stack and i > stack[-1]:\\n                    result[stack.pop()] = i\\n                stack.append(i)\\n            return result\\n\\n        # Prepare indices sorted for odd (ascending value) and even (descending value) jumps\\n        sorted_higher = sorted(range(n), key=lambda i: (arr[i], i))\\n        sorted_lower = sorted(range(n), key=lambda i: (-arr[i], i))\\n\\n        next_higher = make_monotonic_stack(sorted_higher)\\n        next_lower = make_monotonic_stack(sorted_lower)\\n\\n        odd = [False] * n\\n        even = [False] * n\\n        odd[-1] = even[-1] = True\\n\\n        for i in range(n - 2, -1, -1):\\n            if next_higher[i]:\\n                odd[i] = even[next_higher[i]]\\n            if next_lower[i]:\\n                even[i] = odd[next_lower[i]]\\n\\n        return sum(odd)\\n\"",
  "1742_14631217_python-updated-time": "1746444918416",
  "945_14631217_python-updated-time": "1746003069987",
  "81_14631217_python-updated-time": "1745015338731",
  "3584_14631217_python": "\"from bisect import bisect_left\\n\\nclass Solution(object):\\n    def validSequence(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n, m = len(word1), len(word2)\\n        # Build position lists for each letter\\n        pos = [[] for _ in xrange(26)]\\n        for i, ch in enumerate(word1):\\n            pos[ord(ch) - 97].append(i)\\n\\n        # Build nextDiffPos[i] = smallest j > i with word1[j] != word1[i], or n if none.\\n        nextDiff = [0] * n\\n        nextDiff[-1] = n\\n        for i in xrange(n-2, -1, -1):\\n            if word1[i] == word1[i+1]:\\n                nextDiff[i] = nextDiff[i+1]\\n            else:\\n                nextDiff[i] = i+1\\n\\n        # 1) Greedy forward match (exact) to get A_prefix and P = how many we matched\\n        A = []\\n        last = -1\\n        for j in xrange(m):\\n            c = ord(word2[j]) - 97\\n            lst = pos[c]\\n            idx = bisect_left(lst, last+1)\\n            if idx == len(lst):\\n                break\\n            last = lst[idx]\\n            A.append(last)\\n        P = len(A)\\n        fullMatch = (P == m)\\n\\n        # 2) Greedy backward to build L[j] = largest index in word1 where\\n        #    word2[j] can be matched so that the suffix j..m-1 is matchable.\\n        L = [0] * m\\n        # For j = m-1:\\n        c = ord(word2[m-1]) - 97\\n        if pos[c]:\\n            L[m-1] = pos[c][-1]\\n        else:\\n            L[m-1] = -1\\n        # Backward\\n        for j in xrange(m-2, -1, -1):\\n            c = ord(word2[j]) - 97\\n            if L[j+1] < 0:\\n                L[j] = -1\\n            else:\\n                lst = pos[c]\\n                # find largest < L[j+1]\\n                idx = bisect_left(lst, L[j+1]) - 1\\n                L[j] = lst[idx] if idx >= 0 else -1\\n\\n        # 3) Try to find the earliest k where a mismatch at k yields a lexicographically smaller (or any) valid seq.\\n        #    k runs from 0..k_max = (fullMatch ? m-1 : P)\\n        k_max = (m-1) if fullMatch else P\\n        chosen_k = -1\\n        chosen_p = -1\\n\\n        for k in xrange(k_max+1):\\n            last_idx = A[k-1] if k > 0 else -1\\n            s = last_idx + 1\\n            if s >= n:\\n                continue\\n            # find p = first pos >= s where word1[p] != word2[k]\\n            if word1[s] != word2[k]:\\n                p = s\\n            else:\\n                p = nextDiff[s]\\n            if p >= n:\\n                continue\\n            # suffix viability\\n            if k < m-1:\\n                if L[k+1] < 0 or p+1 > L[k+1]:\\n                    continue\\n            # if we have a full exact match, we only switch if this gives lexicographically smaller:\\n            if not fullMatch or p < A[k]:\\n                chosen_k, chosen_p = k, p\\n                break\\n\\n        # 4) Build the answer\\n        if chosen_k == -1:\\n            # never found a beneficial (or any, if exact failed) mismatch\\n            return A if fullMatch else []\\n\\n        # build S_k\\n        ans = [0] * m\\n        # prefix matches\\n        for j in xrange(chosen_k):\\n            ans[j] = A[j]\\n        # the mismatch\\n        ans[chosen_k] = chosen_p\\n        # the suffix matches\\n        last = chosen_p\\n        for j in xrange(chosen_k+1, m):\\n            c = ord(word2[j]) - 97\\n            lst = pos[c]\\n            idx = bisect_left(lst, last+1)\\n            # (we know it must exist because of our suffix check)\\n            last = lst[idx]\\n            ans[j] = last\\n\\n        return ans\\n\"",
  "3081_14631217_python": "\"class Solution(object):\\n    def minLengthAfterRemovals(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        \\n        # Check if we can form k pairs: nums[i] < nums[n-k+i] for all i in [0..k-1]\\n        def can_pair(k):\\n            for i in range(k):\\n                if nums[i] >= nums[n - k + i]:\\n                    return False\\n            return True\\n        \\n        # Binary search maximum k in [0..n//2]\\n        lo, hi = 0, n // 2\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if can_pair(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        \\n        # lo = maximum number of pairs we can remove\\n        return n - 2 * lo\\n\"",
  "922_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution(object):\\n    def possibleBipartition(self, n, dislikes):\\n        graph = defaultdict(list)\\n        for a, b in dislikes:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        color = {}\\n\\n        for person in range(1, n + 1):\\n            if person not in color:\\n                queue = deque([person])\\n                color[person] = 0\\n                while queue:\\n                    curr = queue.popleft()\\n                    for nei in graph[curr]:\\n                        if nei in color:\\n                            if color[nei] == color[curr]:\\n                                return False\\n                        else:\\n                            color[nei] = 1 - color[curr]\\n                            queue.append(nei)\\n        return True\\n\"",
  "3846_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return sum(nums) % k\\n\"",
  "537_14631217_python": "\"class Solution:\\n    def complexNumberMultiply(self, num1, num2):\\n        def parse(num):\\n            real, imag = num.split('+')\\n            return int(real), int(imag[:-1])\\n\\n        a, b = parse(num1)\\n        c, d = parse(num2)\\n\\n        real_part = a * c - b * d\\n        imag_part = a * d + b * c\\n\\n        return \\\"{}+{}i\\\".format(real_part, imag_part)\\n\"",
  "2681_14631217_python-updated-time": "1747061966384",
  "935_14631217_python": "\"class Solution:\\n    def orderlyQueue(self, s, k):\\n        if k == 1:\\n            return min(s[i:] + s[:i] for i in range(len(s)))\\n        return ''.join(sorted(s))\\n\"",
  "324_14631217_python-updated-time": "1745256300634",
  "global_lang": "\"python\"",
  "1037_14631217_python": "\"class Solution:\\n    def minKBitFlips(self, nums, k):\\n        n = len(nums)\\n        flips = 0\\n        flip = 0\\n        is_flipped = [0] * n\\n\\n        for i in range(n):\\n            if i >= k:\\n                flip ^= is_flipped[i - k]\\n            if nums[i] ^ flip == 0:\\n                if i + k > n:\\n                    return -1\\n                flips += 1\\n                flip ^= 1\\n                is_flipped[i] = 1\\n\\n        return flips\\n\"",
  "3289_14631217_python-updated-time": "1747419965645",
  "2543_14631217_python-updated-time": "1746968504181",
  "2790_14631217_javascript": "\"Function.prototype.callPolyfill = function(obj, ...args) {\\n  // Use a Symbol to avoid property name collision\\n  const tempKey = Symbol();\\n  obj[tempKey] = this;       // Attach the function to obj\\n  const result = obj[tempKey](...args); // Call it with args\\n  delete obj[tempKey];       // Clean up\\n  return result;\\n};\\n\"",
  "3376_14631217_python": "\"class Solution(object):\\n    def stringIndices(self, wordsContainer, wordsQuery):\\n        \\\"\\\"\\\"\\n        :type wordsContainer: List[str]\\n        :type wordsQuery: List[str]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # 1) Build reversed‐Trie with “best” index at each node.\\n        # Each node: { children: dict, best_idx: int, best_len: int }\\n        root = {\\\"children\\\": {}, \\\"best_idx\\\": None, \\\"best_len\\\": float(\\\"inf\\\")}\\n        \\n        # Helper to try updating a node’s best_* given word at index i\\n        def consider(node, length, idx):\\n            # better if shorter-length, or same length but earlier index\\n            if length < node[\\\"best_len\\\"] or (\\n               length == node[\\\"best_len\\\"] and idx < node[\\\"best_idx\\\"]\\n            ):\\n                node[\\\"best_len\\\"] = length\\n                node[\\\"best_idx\\\"] = idx\\n        \\n        # First, consider all words at the root (this handles suffix-length=0)\\n        for i, w in enumerate(wordsContainer):\\n            consider(root, len(w), i)\\n        \\n        # Insert each container word in reversed order\\n        for i, w in enumerate(wordsContainer):\\n            node = root\\n            for ch in reversed(w):\\n                if ch not in node[\\\"children\\\"]:\\n                    node[\\\"children\\\"][ch] = {\\n                        \\\"children\\\": {},\\n                        \\\"best_idx\\\": None,\\n                        \\\"best_len\\\": float(\\\"inf\\\")\\n                    }\\n                node = node[\\\"children\\\"][ch]\\n                consider(node, len(w), i)\\n        \\n        # 2) For each query, walk the reversed Trie as far as possible\\n        ans = []\\n        for q in wordsQuery:\\n            node = root\\n            best = node[\\\"best_idx\\\"]\\n            for ch in reversed(q):\\n                if ch in node[\\\"children\\\"]:\\n                    node = node[\\\"children\\\"][ch]\\n                    best = node[\\\"best_idx\\\"]\\n                else:\\n                    break\\n            ans.append(best)\\n        \\n        return ans\\n\"",
  "1409_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minFlips(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        \\n        # Convert initial matrix to a bitmask integer\\n        start = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]:\\n                    start |= 1 << (i * n + j)\\n        \\n        # Directions: up, down, left, right, center\\n        directions = [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def flip(state, x, y):\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    pos = nx * n + ny\\n                    state ^= (1 << pos)\\n            return state\\n\\n        queue = deque()\\n        queue.append((start, 0))\\n        visited = set()\\n        visited.add(start)\\n\\n        while queue:\\n            state, steps = queue.popleft()\\n            if state == 0:\\n                return steps\\n            for i in range(m):\\n                for j in range(n):\\n                    new_state = flip(state, i, j)\\n                    if new_state not in visited:\\n                        visited.add(new_state)\\n                        queue.append((new_state, steps + 1))\\n\\n        return -1\\n\"",
  "2319_14631217_python": "\"class Solution(object):\\n    def longestRepeating(self, s, queryCharacters, queryIndices):\\n        n = len(s)\\n        size = 4 * n\\n        lchar = [0] * size\\n        rchar = [0] * size\\n        pref  = [0] * size\\n        suff  = [0] * size\\n        best  = [0] * size\\n        length = [0] * size\\n\\n        def build(node, l, r):\\n            length[node] = r - l + 1\\n            if l == r:\\n                c = ord(s[l]) - 97\\n                lchar[node] = rchar[node] = c\\n                pref[node] = suff[node] = best[node] = 1\\n                return\\n            mid = (l + r) // 2\\n            left = node * 2\\n            right = left + 1\\n            build(left, l, mid)\\n            build(right, mid + 1, r)\\n            merge(node, left, right)\\n\\n        def merge(node, left, right):\\n            lchar[node] = lchar[left]\\n            rchar[node] = rchar[right]\\n            pref[node] = pref[left]\\n            suff[node] = suff[right]\\n            best[node] = best[left] if best[left] > best[right] else best[right]\\n            if rchar[left] == lchar[right]:\\n                # combined run\\n                run = suff[left] + pref[right]\\n                if run > best[node]:\\n                    best[node] = run\\n                if pref[left] == length[left]:\\n                    pref[node] = length[left] + pref[right]\\n                if suff[right] == length[right]:\\n                    suff[node] = length[right] + suff[left]\\n\\n        def update(node, l, r, idx, c):\\n            if l == r:\\n                lchar[node] = rchar[node] = c\\n                pref[node] = suff[node] = best[node] = 1\\n                return\\n            mid = (l + r) // 2\\n            left = node * 2\\n            right = left + 1\\n            if idx <= mid:\\n                update(left, l, mid, idx, c)\\n            else:\\n                update(right, mid + 1, r, idx, c)\\n            merge(node, left, right)\\n\\n        build(1, 0, n - 1)\\n        res = []\\n        for ch, idx in zip(queryCharacters, queryIndices):\\n            c = ord(ch) - 97\\n            update(1, 0, n - 1, idx, c)\\n            res.append(best[1])\\n        return res\\n\"",
  "1234_14631217_python-updated-time": "1746260579780",
  "475_14631217_python-updated-time": "1745360073555",
  "3228_14631217_python-updated-time": "1747392807352",
  "605_14631217_python-updated-time": "1745448645186",
  "2464_14631217_python-updated-time": "1746964996119",
  "1212_14631217_python-updated-time": "1746260375652",
  "1573_14631217_python-updated-time": "1746432572958",
  "3511_14631217_python-updated-time": "1747487407947",
  "1952_14631217_python": "\"class Solution(object):\\n    def minSideJumps(self, obstacles):\\n        n = len(obstacles) - 1\\n        INF = 10**9\\n        # dp[l] = min side jumps to be at current point on lane l+1\\n        dp = [1, 0, 1]\\n        for i in range(1, n + 1):\\n            # block lane with obstacle at this point\\n            b = obstacles[i]\\n            if b:\\n                dp[b - 1] = INF\\n            # for each lane not blocked, consider jumping from the other two lanes\\n            for l in range(3):\\n                if obstacles[i] != l + 1:\\n                    dp[l] = min(dp[l], dp[(l + 1) % 3] + 1, dp[(l + 2) % 3] + 1)\\n        return min(dp)\\n\"",
  "923_14631217_python-updated-time": "1746001959869",
  "650_14631217_python-updated-time": "1745782700871",
  "1552_14631217_python": "\"class Solution:\\n    def buildArray(self, target, n):\\n        result = []\\n        current = 1\\n        for num in target:\\n            while current < num:\\n                result.append(\\\"Push\\\")\\n                result.append(\\\"Pop\\\")\\n                current += 1\\n            result.append(\\\"Push\\\")\\n            current += 1\\n        return result\\n\"",
  "3139_14631217_python-updated-time": "1747309290644",
  "1825_14631217_python": "\"class Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        jobs.sort(reverse=True)\\n        n = len(jobs)\\n        res = [sum(jobs)]  # wrap in a list to make it mutable in nested scope\\n\\n        def backtrack(i, workloads):\\n            if i == n:\\n                res[0] = min(res[0], max(workloads))\\n                return\\n            seen = set()\\n            for j in range(k):\\n                if workloads[j] in seen:\\n                    continue\\n                if workloads[j] + jobs[i] >= res[0]:\\n                    continue\\n                seen.add(workloads[j])\\n                workloads[j] += jobs[i]\\n                backtrack(i + 1, workloads)\\n                workloads[j] -= jobs[i]\\n\\n        backtrack(0, [0] * k)\\n        return res[0]\\n\"",
  "1340_14631217_python": "\"import threading\\n\\nclass DiningPhilosophers:\\n    def __init__(self):\\n        self.forks = [threading.Lock() for _ in range(5)]\\n\\n    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):\\n        left = philosopher\\n        right = (philosopher + 1) % 5\\n\\n        first, second = (left, right) if philosopher % 2 == 0 else (right, left)\\n        first_lock = self.forks[first]\\n        second_lock = self.forks[second]\\n\\n        with first_lock:\\n            with second_lock:\\n                pickLeftFork() if first == left else pickRightFork()\\n                pickRightFork() if first == left else pickLeftFork()\\n                eat()\\n                putRightFork() if first == left else putLeftFork()\\n                putLeftFork() if first == left else putRightFork()\\n\"",
  "3406_14631217_python-updated-time": "1747424315888",
  "331_14631217_python-updated-time": "1745256647214",
  "2563_14631217_python": "\"class Solution:\\n    def splitMessage(self, message, limit):\\n        m = len(message)\\n        # Precompute sum_len[i] = sum of digit-lengths of numbers 1..i\\n        sum_len = [0] * (m + 1)\\n        for i in range(1, m + 1):\\n            sum_len[i] = sum_len[i - 1] + len(str(i))\\n\\n        # Find the minimal b for which total capacity >= m\\n        b_found = 0\\n        for b in range(1, m + 1):\\n            len_b = len(str(b))\\n            # If even the smallest cap (with len_i = len_b) is negative, no larger b will work\\n            if limit < 3 + 2 * len_b:\\n                break\\n\\n            # total_cap = sum_{i=1..b} [limit - (3 + len(i) + len_b)]\\n            # = b*(limit - 3 - len_b) - sum_len[b]\\n            total_cap = b * (limit - 3 - len_b) - sum_len[b]\\n            if total_cap >= m:\\n                b_found = b\\n                break\\n\\n        if b_found == 0:\\n            return []\\n\\n        # Build the parts using b_found\\n        parts = []\\n        sb = str(b_found)\\n        len_b = len(sb)\\n        idx = 0\\n        for i in range(1, b_found + 1):\\n            si = str(i)\\n            suffix = \\\"<\\\" + si + \\\"/\\\" + sb + \\\">\\\"\\n            cap = limit - len(suffix)\\n            take = min(cap, m - idx)\\n            parts.append(message[idx : idx + take] + suffix)\\n            idx += take\\n            if idx >= m:\\n                break\\n\\n        return parts\\n\"",
  "1217_14631217_lang-updated-time": "1746109018450",
  "3459_14631217_python": "\"class Solution(object):\\n    def minimumSum(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(grid), len(grid[0])\\n        # collect all the 1-cells\\n        ones = [(r, c) for r in range(n) for c in range(m) if grid[r][c] == 1]\\n        \\n        INF = 10**18\\n        ans = INF\\n        \\n        def eval_partition(assign_region):\\n            \\\"\\\"\\\"\\n            assign_region(r,c) -> 0,1,2  says which of the 3 regions this cell belongs to.\\n            We scan all 1-cells, build bounding boxes for regions 0/1/2,\\n            and if each is non-empty, return sum of their areas, else INF.\\n            \\\"\\\"\\\"\\n            # init mins/maxs\\n            min_r = [n, n, n]\\n            max_r = [-1, -1, -1]\\n            min_c = [m, m, m]\\n            max_c = [-1, -1, -1]\\n            cnt   = [0, 0, 0]\\n            for (r, c) in ones:\\n                k = assign_region(r, c)\\n                if not (0 <= k < 3):\\n                    # this split doesn't cover that 1\\n                    return INF\\n                cnt[k] += 1\\n                if r < min_r[k]: min_r[k] = r\\n                if r > max_r[k]: max_r[k] = r\\n                if c < min_c[k]: min_c[k] = c\\n                if c > max_c[k]: max_c[k] = c\\n            \\n            # all 3 regions must have at least one 1\\n            if cnt[0] == 0 or cnt[1] == 0 or cnt[2] == 0:\\n                return INF\\n            \\n            total = 0\\n            for k in range(3):\\n                h = max_r[k] - min_r[k] + 1\\n                w = max_c[k] - min_c[k] + 1\\n                total += h * w\\n            return total\\n        \\n        # 1) vertical stripes\\n        for c1 in range(m-2):\\n            for c2 in range(c1+1, m-1):\\n                def reg_v(r, c, c1=c1, c2=c2):\\n                    if c <= c1:   return 0\\n                    elif c <= c2: return 1\\n                    else:         return 2\\n                ans = min(ans, eval_partition(reg_v))\\n        \\n        # 2) horizontal stripes\\n        for r1 in range(n-2):\\n            for r2 in range(r1+1, n-1):\\n                def reg_h(r, c, r1=r1, r2=r2):\\n                    if r <= r1:   return 0\\n                    elif r <= r2: return 1\\n                    else:         return 2\\n                ans = min(ans, eval_partition(reg_h))\\n        \\n        # 3) horizontal cut, then vertical on bottom half\\n        for r in range(n-1):\\n            for c in range(m-1):\\n                def reg_hv(r0, c0, r=r, c=c):\\n                    if r0 <= r:\\n                        return 0\\n                    else:\\n                        return 1 if c0 <= c else 2\\n                ans = min(ans, eval_partition(reg_hv))\\n        \\n        # 4) horizontal cut, then vertical on top half\\n        for r in range(n-1):\\n            for c in range(m-1):\\n                def reg_hv2(r0, c0, r=r, c=c):\\n                    if r0 > r:\\n                        return 0\\n                    else:\\n                        return 1 if c0 <= c else 2\\n                ans = min(ans, eval_partition(reg_hv2))\\n        \\n        # 5) vertical cut, then horizontal on right half\\n        for c in range(m-1):\\n            for r in range(n-1):\\n                def reg_vh(r0, c0, r=r, c=c):\\n                    if c0 <= c:\\n                        return 0\\n                    else:\\n                        return 1 if r0 <= r else 2\\n                ans = min(ans, eval_partition(reg_vh))\\n        \\n        # 6) vertical cut, then horizontal on left half\\n        for c in range(m-1):\\n            for r in range(n-1):\\n                def reg_vh2(r0, c0, r=r, c=c):\\n                    if c0 > c:\\n                        return 0\\n                    else:\\n                        return 1 if r0 <= r else 2\\n                ans = min(ans, eval_partition(reg_vh2))\\n        \\n        return ans\\n\"",
  "1744_14631217_python-updated-time": "1746444983005",
  "1036_14631217_python-updated-time": "1746040679401",
  "2364_14631217_python": "\"class Solution:\\n    def longestPath(self, parent, s):\\n        n = len(parent)\\n        # Build children lists\\n        children = [[] for _ in range(n)]\\n        for i, p in enumerate(parent):\\n            if p >= 0:\\n                children[p].append(i)\\n        \\n        # Get a post‐order of the tree via iterative DFS\\n        order = []\\n        stack = [(0, False)]\\n        while stack:\\n            u, visited = stack.pop()\\n            if visited:\\n                order.append(u)\\n            else:\\n                stack.append((u, True))\\n                for v in children[u]:\\n                    stack.append((v, False))\\n        \\n        dp = [1] * n   # dp[u] = longest downward path from u with adjacent chars ≠\\n        ans = 1\\n        \\n        # Process nodes bottom‐up\\n        for u in order:\\n            best1 = best2 = 0\\n            for v in children[u]:\\n                if s[v] != s[u]:\\n                    length = dp[v]\\n                    if length > best1:\\n                        best2 = best1\\n                        best1 = length\\n                    elif length > best2:\\n                        best2 = length\\n            # Combine two best child‐paths through u\\n            ans = max(ans, best1 + best2 + 1)\\n            # And store the best single chain from u upward\\n            dp[u] = best1 + 1\\n        \\n        return ans\\n\"",
  "3476_14631217_python-updated-time": "1747485378099",
  "3849_14631217_python-updated-time": "1747684157176",
  "1342_14631217_python-updated-time": "1746259100319",
  "212_14631217_python": "\"class TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.word = None\\n\\nclass Solution(object):\\n    def findWords(self, board, words):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        root = TrieNode()\\n        for word in words:\\n            node = root\\n            for c in word:\\n                if c not in node.children:\\n                    node.children[c] = TrieNode()\\n                node = node.children[c]\\n            node.word = word\\n        \\n        m, n = len(board), len(board[0])\\n        res = []\\n\\n        def dfs(i, j, node):\\n            c = board[i][j]\\n            if c not in node.children:\\n                return\\n            node = node.children[c]\\n            if node.word:\\n                res.append(node.word)\\n                node.word = None\\n            \\n            board[i][j] = '#'\\n            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                ni, nj = i + dx, j + dy\\n                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\\n                    dfs(ni, nj, node)\\n            board[i][j] = c\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j, root)\\n        \\n        return res\\n\"",
  "3827_14631217_python": "\"import collections\\nimport bisect\\n\\nclass Router(object):\\n    def __init__(self, memoryLimit):\\n        \\\"\\\"\\\"\\n        :type memoryLimit: int\\n        \\\"\\\"\\\"\\n        self.limit = memoryLimit\\n        # FIFO queue of (source, dest, timestamp)\\n        self.queue = collections.deque()\\n        # Set of packets currently stored, for duplicate detection\\n        self.packet_set = set()\\n        # Per-destination record: dest -> {'times': [...], 'head': int}\\n        # 'times' is list of timestamps (in increasing order as added)\\n        # 'head' is the index of the first active (not yet removed) timestamp\\n        self.dest_map = {}\\n\\n    def addPacket(self, source, destination, timestamp):\\n        \\\"\\\"\\\"\\n        :type source: int\\n        :type destination: int\\n        :type timestamp: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        packet = (source, destination, timestamp)\\n        # Duplicate?\\n        if packet in self.packet_set:\\n            return False\\n\\n        # Enqueue the new packet\\n        self.queue.append(packet)\\n        self.packet_set.add(packet)\\n\\n        # Record timestamp in dest_map\\n        rec = self.dest_map.setdefault(destination, {'times': [], 'head': 0})\\n        rec['times'].append(timestamp)\\n\\n        # Enforce memory limit: if exceeded, drop oldest\\n        if len(self.queue) > self.limit:\\n            old_source, old_dest, old_time = self.queue.popleft()\\n            self.packet_set.remove((old_source, old_dest, old_time))\\n            # Advance head in that dest's record\\n            old_rec = self.dest_map[old_dest]\\n            old_rec['head'] += 1\\n\\n        return True\\n\\n    def forwardPacket(self):\\n        \\\"\\\"\\\"\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not self.queue:\\n            return []\\n        source, destination, timestamp = self.queue.popleft()\\n        self.packet_set.remove((source, destination, timestamp))\\n        # Advance head for this destination\\n        rec = self.dest_map[destination]\\n        rec['head'] += 1\\n        return [source, destination, timestamp]\\n\\n    def getCount(self, destination, startTime, endTime):\\n        \\\"\\\"\\\"\\n        :type destination: int\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        rec = self.dest_map.get(destination)\\n        if not rec:\\n            return 0\\n        arr = rec['times']\\n        h = rec['head']\\n        # Find leftmost ≥ startTime, rightmost ≤ endTime\\n        left = bisect.bisect_left(arr, startTime, lo=h)\\n        right = bisect.bisect_right(arr, endTime, lo=h)\\n        return right - left\\n\"",
  "3774_14631217_python": "\"class Solution(object):\\n    def hasSameDigits(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Compute the 'delta' array D[i] = s[i]-s[i+1] mod 10\\n        D = [ (int(s[i]) - int(s[i+1])) % 10\\n              for i in range(n-1) ]\\n        N = n-2\\n\\n        # 1) Sum mod 2: binom(N,i)%2 == 1 iff (i & (N-i))==0\\n        S2 = 0\\n        for i, d in enumerate(D):\\n            if (i & (N - i)) == 0:\\n                S2 = (S2 + d) & 1\\n\\n        # 2) Sum mod 5: use Lucas to get C(N, i) mod 5\\n        # Precompute binomial(n,k)%5 for n,k<5\\n        small = [[0]*5 for _ in range(5)]\\n        for a in range(5):\\n            small[a][0] = 1\\n            for b in range(1, a+1):\\n                small[a][b] = (small[a-1][b-1] + small[a-1][b]) % 5\\n\\n        # base-5 digits of N\\n        ND = []\\n        tmp = N\\n        while tmp:\\n            ND.append(tmp % 5)\\n            tmp //= 5\\n        if not ND:\\n            ND = [0]\\n\\n        def binom5(N, i):\\n            \\\"\\\"\\\"Return C(N,i) mod 5 by Lucas.\\\"\\\"\\\"\\n            res = 1\\n            pos = 0\\n            while N or i:\\n                n_k = N % 5\\n                i_k = i % 5\\n                # if i_k > n_k then C=0\\n                if i_k > n_k:\\n                    return 0\\n                res = (res * small[n_k][i_k]) % 5\\n                N //= 5\\n                i //= 5\\n            return res\\n\\n        S5 = 0\\n        for i, d in enumerate(D):\\n            c5 = binom5(N, i)\\n            if c5:\\n                S5 = (S5 + c5 * d) % 5\\n\\n        # Reconstruct x mod 10 with\\n        #   x ≡ S2 (mod 2),\\n        #   x ≡ S5 (mod 5).\\n        # Two candidates: S5 or S5+5; pick the one matching parity S2.\\n        x = S5\\n        if x % 2 != S2:\\n            x += 5\\n\\n        return (x % 10) == 0\\n\"",
  "1732_14631217_python-updated-time": "1746444077864",
  "502_14631217_python-updated-time": "1745446120839",
  "2725_14631217_python": "\"class Solution:\\n    def miceAndCheese(self, reward1, reward2, k):\\n        deltas = [(r1 - r2, r1, r2) for r1, r2 in zip(reward1, reward2)]\\n        # Sort by delta descending: biggest reward1 boost over reward2\\n        deltas.sort(reverse=True)\\n\\n        total = 0\\n        for i in range(len(reward1)):\\n            if i < k:\\n                total += deltas[i][1]  # reward1\\n            else:\\n                total += deltas[i][2]  # reward2\\n        return total\\n\"",
  "58_14631217_python-updated-time": "1745014389237",
  "679_14631217_python-updated-time": "1745785024022",
  "1435_14631217_python-updated-time": "1746261013026",
  "3373_14631217_python": "\"class Solution(object):\\n    def maximumPrimeDifference(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Precompute primes up to 100\\n        max_val = 100\\n        is_prime = [True] * (max_val + 1)\\n        is_prime[0] = is_prime[1] = False\\n        for i in range(2, int(max_val**0.5) + 1):\\n            if is_prime[i]:\\n                for j in range(i*i, max_val + 1, i):\\n                    is_prime[j] = False\\n        \\n        first = -1\\n        last = -1\\n        \\n        for i, x in enumerate(nums):\\n            if is_prime[x]:\\n                if first == -1:\\n                    first = i\\n                last = i\\n        \\n        # If there's at least one prime, last >= first >= 0\\n        # The maximum distance is last - first (zero if only one prime)\\n        return last - first\\n\"",
  "500_14631217_python-updated-time": "1745446075617",
  "2562_14631217_python": "\"class Solution:\\n    def countGoodStrings(self, low, high, zero, one):\\n        MOD = 10**9 + 7\\n        # dp[i] = number of ways to build a string of length exactly i\\n        dp = [0] * (high + 1)\\n        dp[0] = 1\\n\\n        for length in range(1, high + 1):\\n            total = 0\\n            if length >= zero:\\n                total += dp[length - zero]\\n            if length >= one:\\n                total += dp[length - one]\\n            dp[length] = total % MOD\\n\\n        # sum counts for all lengths in [low..high]\\n        result = 0\\n        for i in range(low, high + 1):\\n            result = (result + dp[i]) % MOD\\n\\n        return result\\n\"",
  "2876_14631217_python": "\"class Solution(object):\\n    def numberOfEmployeesWhoMetTarget(self, hours, target):\\n        return sum(h >= target for h in hours)\\n\"",
  "30_14631217_python": "\"class Solution(object):\\n    def findSubstring(self, s, words):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not s or not words:\\n            return []\\n        \\n        word_len = len(words[0])\\n        word_count = len(words)\\n        total_len = word_len * word_count\\n        word_map = {}\\n        for word in words:\\n            word_map[word] = word_map.get(word, 0) + 1\\n        \\n        res = []\\n        \\n        for i in range(word_len):\\n            left = i\\n            right = i\\n            curr_map = {}\\n            count = 0\\n\\n            while right + word_len <= len(s):\\n                word = s[right:right + word_len]\\n                right += word_len\\n\\n                if word in word_map:\\n                    curr_map[word] = curr_map.get(word, 0) + 1\\n                    count += 1\\n\\n                    while curr_map[word] > word_map[word]:\\n                        left_word = s[left:left + word_len]\\n                        curr_map[left_word] -= 1\\n                        left += word_len\\n                        count -= 1\\n\\n                    if count == word_count:\\n                        res.append(left)\\n                else:\\n                    curr_map.clear()\\n                    count = 0\\n                    left = right\\n        \\n        return res\\n\"",
  "2162_14631217_python-updated-time": "1746719795154",
  "1456_14631217_python-updated-time": "1746261654267",
  "1187_14631217_java-updated-time": "1746108911790",
  "628_14631217_python": "\"class Solution(object):\\n    def maximumProduct(self, nums):\\n        nums.sort()\\n        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\\n\"",
  "3496_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def minNumberOfSeconds(self, mountainHeight, workerTimes):\\n        \\\"\\\"\\\"\\n        :type mountainHeight: int\\n        :type workerTimes: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        H = mountainHeight\\n        wts = sorted(workerTimes)\\n        # Upper bound: slowest worker does all H units\\n        w_max = wts[-1]\\n        lo, hi = 0, w_max * H * (H + 1) // 2\\n        ans = hi\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            total = 0\\n            \\n            for w in wts:\\n                # If even 1 unit costs more than mid, no contribution\\n                if w > 2 * mid:\\n                    break\\n                \\n                K = (2 * mid) // w            # floor(2T / w)\\n                D = 1 + 4 * K\\n                # integer sqrt via math.sqrt\\n                s = int(math.sqrt(D))\\n                # x = floor((sqrt(D)-1)/2)\\n                x = (s - 1) // 2\\n                total += x\\n                if total >= H:\\n                    break\\n            \\n            if total >= H:\\n                ans = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        \\n        return ans\\n\"",
  "803_14631217_python-updated-time": "1745877649189",
  "3307_14631217_python": "\"class Solution(object):\\n    def maximumValueSum(self, nums, k, edges):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Base sum of original values\\n        base_sum = sum(nums)\\n        \\n        # Δ[i] = gain if we flip node i once (xor k)\\n        delta = [(nums[i] ^ k) - nums[i] for i in range(len(nums))]\\n        \\n        # All strictly positive gains\\n        positives = [d for d in delta if d > 0]\\n        G = sum(positives)\\n        \\n        # If we have an even number of positives, we can take them all\\n        if len(positives) % 2 == 0:\\n            best_gain = G\\n        else:\\n            # Otherwise we must sacrifice the smaller of:\\n            # 1) dropping the smallest positive Δ\\n            min_pos = min(positives)\\n            # 2) adding the least-negative Δ (i.e. the maximum among non-positives)\\n            nonpos = [d for d in delta if d <= 0]\\n            if nonpos:\\n                max_neg = nonpos[0]\\n                for d in nonpos:\\n                    if d > max_neg:\\n                        max_neg = d\\n                cost_add_neg = -max_neg\\n            else:\\n                # no non-positive to add, force dropping\\n                cost_add_neg = float('inf')\\n            \\n            loss = min(min_pos, cost_add_neg)\\n            best_gain = G - loss\\n        \\n        return base_sum + best_gain\\n\"",
  "1130_14631217_python": "\"class Solution:\\n    def lastStoneWeightII(self, stones):\\n        total = sum(stones)\\n        target = total // 2\\n        dp = [False] * (target + 1)\\n        dp[0] = True\\n        for w in stones:\\n            for j in range(target, w - 1, -1):\\n                dp[j] = dp[j] or dp[j - w]\\n        for j in range(target, -1, -1):\\n            if dp[j]:\\n                return total - 2 * j\\n        return 0\\n\"",
  "1635_14631217_python-updated-time": "1746433479030",
  "646_14631217_python": "\"class Solution(object):\\n    def findLongestChain(self, pairs):\\n        pairs.sort(key=lambda x: x[1])\\n        curr = float('-inf')\\n        count = 0\\n        \\n        for pair in pairs:\\n            if curr < pair[0]:\\n                curr = pair[1]\\n                count += 1\\n        \\n        return count\\n\"",
  "3543_14631217_python-updated-time": "1747502086208",
  "1509_14631217_mysql-updated-time": "1746345806189",
  "376_14631217_python-updated-time": "1745354704529",
  "2039_14631217_python-updated-time": "1746637852459",
  "3266_14631217_python-updated-time": "1747319353375",
  "2463_14631217_python-updated-time": "1746964974816",
  "3522_14631217_python": "\"class Solution(object):\\n    def resultsArray(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        res = []\\n        for i in range(n - k + 1):\\n            window = nums[i:i+k]\\n            good = True\\n            # Check strictly ascending by 1\\n            for j in range(1, k):\\n                if window[j] != window[j-1] + 1:\\n                    good = False\\n                    break\\n            if good:\\n                res.append(window[-1])\\n            else:\\n                res.append(-1)\\n        return res\\n\"",
  "3647_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxRemoval(self, nums, queries):\\n        n = len(nums)\\n        q = len(queries)\\n\\n        # 1) bucket by left endpoint\\n        starts = [[] for _ in range(n)]\\n        for l, r in queries:\\n            starts[l].append(r)\\n\\n        available = []      # max-heap (store -r) of intervals we could still pick\\n        selected_ends = []  # min-heap of r’s for intervals we've already picked\\n        cov = 0             # how many picked intervals currently cover i\\n        picked = 0\\n\\n        for i in range(n):\\n            # add everything starting here\\n            for r in starts[i]:\\n                heapq.heappush(available, -r)\\n\\n            # expire any picked intervals that ended before i\\n            while selected_ends and selected_ends[0] < i:\\n                heapq.heappop(selected_ends)\\n                cov -= 1\\n\\n            # if we still need more coverage at i, pick greedily\\n            while cov < nums[i]:\\n                # drop any available intervals that don't reach i\\n                while available and -available[0] < i:\\n                    heapq.heappop(available)\\n                if not available:\\n                    return -1\\n                r = -heapq.heappop(available)\\n                picked += 1\\n                cov += 1\\n                heapq.heappush(selected_ends, r)\\n\\n        return q - picked\\n\"",
  "2502_14631217_python": "\"class Solution:\\n    def sortPeople(self, names, heights):\\n        # Pair each name with its height, sort by height descending\\n        paired = sorted(zip(heights, names), reverse=True)\\n        # Extract the names in sorted order\\n        return [name for _, name in paired]\\n\"",
  "1960_14631217_python": "\"class Solution(object):\\n    def checkIfPangram(self, sentence):\\n        return len(set(sentence)) == 26\\n\"",
  "1182_14631217_mysql-updated-time": "1745447139311",
  "875_14631217_python": "\"class Solution(object):\\n    def longestMountain(self, arr):\\n        n = len(arr)\\n        ans = 0\\n        i = 1\\n        \\n        while i < n - 1:\\n            if arr[i-1] < arr[i] > arr[i+1]:\\n                left = i - 1\\n                while left > 0 and arr[left-1] < arr[left]:\\n                    left -= 1\\n                right = i + 1\\n                while right < n - 1 and arr[right] > arr[right+1]:\\n                    right += 1\\n                ans = max(ans, right - left + 1)\\n                i = right\\n            else:\\n                i += 1\\n        \\n        return ans\\n\"",
  "899_14631217_python": "\"class Solution(object):\\n    def binaryGap(self, n):\\n        last = -1\\n        max_gap = 0\\n        i = 0\\n        while n:\\n            if n & 1:\\n                if last != -1:\\n                    max_gap = max(max_gap, i - last)\\n                last = i\\n            n >>= 1\\n            i += 1\\n        return max_gap\\n\"",
  "1305_14631217_python-updated-time": "1746638567109",
  "203_14631217_python-updated-time": "1745093322588",
  "2811_14631217_python-updated-time": "1747225796418",
  "1153_14631217_mysql-updated-time": "1746107741174",
  "877_14631217_python-updated-time": "1745880219543",
  "1644_14631217_python-updated-time": "1746433673369",
  "1836_14631217_python-updated-time": "1746530450019",
  "924_14631217_python": "\"class Solution(object):\\n    def fairCandySwap(self, aliceSizes, bobSizes):\\n        sumA = sum(aliceSizes)\\n        sumB = sum(bobSizes)\\n        delta = (sumA - sumB) // 2\\n        setB = set(bobSizes)\\n        for a in aliceSizes:\\n            if a - delta in setB:\\n                return [a, a - delta]\\n\"",
  "1485_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minCost(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(0,1), (0,-1), (1,0), (-1,0)]  # right, left, down, up\\n\\n        dist = [[float('inf')] * n for _ in range(m)]\\n        dist[0][0] = 0\\n\\n        dq = deque()\\n        dq.append((0, 0))\\n\\n        while dq:\\n            x, y = dq.popleft()\\n            for i, (dx, dy) in enumerate(dirs):\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    cost = 0 if grid[x][y] == i + 1 else 1\\n                    if dist[nx][ny] > dist[x][y] + cost:\\n                        dist[nx][ny] = dist[x][y] + cost\\n                        if cost == 0:\\n                            dq.appendleft((nx, ny))\\n                        else:\\n                            dq.append((nx, ny))\\n        \\n        return dist[m - 1][n - 1]\\n\"",
  "1081_14631217_python-updated-time": "1746041868598",
  "1275_14631217_python-updated-time": "1746345307710",
  "3217_14631217_python": "\"class Solution(object):\\n    def numberOfSets(self, n, maxDistance, roads):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type maxDistance: int\\n        :type roads: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        INF = 10**18\\n        # Build the base distance matrix (taking min over multiple edges)\\n        dist0 = [[INF]*n for _ in range(n)]\\n        for i in range(n):\\n            dist0[i][i] = 0\\n        for u, v, w in roads:\\n            if w < dist0[u][v]:\\n                dist0[u][v] = w\\n                dist0[v][u] = w\\n        \\n        total = 0\\n        # Iterate over all subsets of nodes to close (bitmask of closed nodes)\\n        for mask in range(1<<n):\\n            # R = list of active nodes\\n            R = [i for i in range(n) if not (mask >> i & 1)]\\n            k = len(R)\\n            # If 0 or 1 active node, it's always valid\\n            if k <= 1:\\n                total += 1\\n                continue\\n            \\n            # Initialize distances in the induced subgraph to the precomputed values\\n            dist = [[INF]*n for _ in range(n)]\\n            for i in R:\\n                for j in R:\\n                    dist[i][j] = dist0[i][j]\\n            \\n            # Floyd–Warshall on the active nodes only\\n            for kk in R:\\n                for i in R:\\n                    # early skip if dist[i][kk] already too large\\n                    dik = dist[i][kk]\\n                    if dik == INF: \\n                        continue\\n                    for j in R:\\n                        newd = dik + dist[kk][j]\\n                        if newd < dist[i][j]:\\n                            dist[i][j] = newd\\n            \\n            # Check that every pair of active nodes is within maxDistance\\n            valid = True\\n            for i in R:\\n                for j in R:\\n                    if dist[i][j] > maxDistance:\\n                        valid = False\\n                        break\\n                if not valid:\\n                    break\\n            \\n            if valid:\\n                total += 1\\n        \\n        return total\\n\"",
  "2827_14631217_python": "\"from collections import defaultdict\\nimport math\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums):\\n        if len(nums) == 1:\\n            return True\\n        if 1 in nums:\\n            return False  # 1 has no prime factors and cannot connect to any other number\\n\\n        n = len(nums)\\n        max_val = max(nums)\\n        parent = {}\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px != py:\\n                parent[py] = px\\n\\n        for num in nums:\\n            parent[num] = num\\n\\n        # Sieve for smallest prime factor\\n        spf = list(range(max_val + 1))\\n        for i in range(2, int(math.sqrt(max_val)) + 1):\\n            if spf[i] == i:\\n                for j in range(i * i, max_val + 1, i):\\n                    if spf[j] == j:\\n                        spf[j] = i\\n\\n        def get_factors(x):\\n            factors = set()\\n            while x > 1:\\n                factors.add(spf[x])\\n                x //= spf[x]\\n            return factors\\n\\n        factor_to_num = defaultdict(list)\\n        for num in nums:\\n            factors = get_factors(num)\\n            for f in factors:\\n                factor_to_num[f].append(num)\\n\\n        for group in factor_to_num.values():\\n            for i in range(1, len(group)):\\n                union(group[0], group[i])\\n\\n        root = find(nums[0])\\n        for num in nums:\\n            if find(num) != root:\\n                return False\\n        return True\\n\"",
  "515_14631217_python-updated-time": "1745446407351",
  "2338_14631217_python": "\"class Solution:\\n    def minimumCardPickup(self, cards):\\n        last = {}\\n        ans = float('inf')\\n        for i, x in enumerate(cards):\\n            if x in last:\\n                # length from last[x] to i inclusive\\n                ans = min(ans, i - last[x] + 1)\\n            last[x] = i\\n        return ans if ans != float('inf') else -1\\n\"",
  "2473_14631217_python": "\"class Solution:\\n    def maximumSum(self, nums):\\n        def digit_sum(x):\\n            s = 0\\n            while x:\\n                s += x % 10\\n                x //= 10\\n            return s\\n        \\n        best = {}  # sum -> [max1, max2]\\n        ans = -1\\n        \\n        for x in nums:\\n            s = digit_sum(x)\\n            if s not in best:\\n                best[s] = [x, -1]\\n            else:\\n                a, b = best[s]\\n                if x > a:\\n                    b = a\\n                    a = x\\n                elif x > b:\\n                    b = x\\n                best[s] = [a, b]\\n            \\n            a, b = best[s]\\n            if b >= 0:\\n                ans = max(ans, a + b)\\n        \\n        return ans\\n\"",
  "63_14631217_python-updated-time": "1745014779775",
  "1804_14631217_python": "\"class Solution(object):\\n    def maximumBinaryString(self, binary):\\n        \\\"\\\"\\\"\\n        :type binary: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        n = len(binary)\\n        # Count total zeros\\n        z = binary.count('0')\\n        # If fewer than 2 zeros, no improvement is possible\\n        if z < 2:\\n            return binary\\n        \\n        # Find first zero\\n        first_zero = binary.find('0')\\n        # Compute the single zero's final position\\n        p = first_zero + z - 1\\n        \\n        # Build the result: all '1's up to p, then '0', then all '1's\\n        return '1' * p + '0' + '1' * (n - p - 1)\\n\"",
  "824_14631217_python-updated-time": "1745878342311",
  "3269_14631217_python": "\"class Solution(object):\\n    def countMatchingSubarrays(self, nums, pattern):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type pattern: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(nums), len(pattern)\\n        count = 0\\n        for i in range(n - m):\\n            match = True\\n            for k, p in enumerate(pattern):\\n                if p == 1 and not (nums[i + k + 1] > nums[i + k]):\\n                    match = False\\n                    break\\n                if p == 0 and not (nums[i + k + 1] == nums[i + k]):\\n                    match = False\\n                    break\\n                if p == -1 and not (nums[i + k + 1] < nums[i + k]):\\n                    match = False\\n                    break\\n            if match:\\n                count += 1\\n        return count\\n\"",
  "3656_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        ops = 0\\n        while len(nums) > 0:\\n            seen = set()\\n            duplicate = False\\n            for num in nums:\\n                if num in seen:\\n                    duplicate = True\\n                    break\\n                seen.add(num)\\n            if not duplicate:\\n                break\\n            ops += 1\\n            nums = nums[3:]\\n        return ops\\n\"",
  "341_14631217_python-updated-time": "1745256910555",
  "1301_14631217_mysql-updated-time": "1746126496152",
  "769_14631217_python-updated-time": "1745876075167",
  "1203_14631217_java": "\"import java.util.concurrent.CountDownLatch;\\n\\npublic class Foo {\\n    private CountDownLatch latch1;\\n    private CountDownLatch latch2;\\n\\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run(); // prints \\\"first\\\"\\n        latch1.countDown(); // allow second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await(); // wait until first() completes\\n        printSecond.run(); // prints \\\"second\\\"\\n        latch2.countDown(); // allow third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await(); // wait until second() completes\\n        printThird.run(); // prints \\\"third\\\"\\n    }\\n}\\n\"",
  "14_14631217_python": "\"class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \\\"\\\"\\\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if not strs:\\n            return \\\"\\\"\\n\\n        prefix = strs[0]\\n\\n        for s in strs[1:]:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                if not prefix:\\n                    return \\\"\\\"\\n\\n        return prefix\\n\"",
  "1963_14631217_python": "\"class Solution(object):\\n    def getXORSum(self, arr1, arr2):\\n        x = 0\\n        for v in arr1:\\n            x ^= v\\n        y = 0\\n        for v in arr2:\\n            y ^= v\\n        return x & y\\n\"",
  "3477_14631217_python-updated-time": "1747485463486",
  "2856_14631217_python-updated-time": "1747223644742",
  "3530_14631217_mysql-updated-time": "1747487370270",
  "901_14631217_python": "\"class Solution(object):\\n    def advantageCount(self, nums1, nums2):\\n        nums1.sort()\\n        sorted_indices = sorted(range(len(nums2)), key=lambda i: nums2[i])\\n        result = [0] * len(nums1)\\n        low, high = 0, len(nums1) - 1\\n\\n        for i in reversed(sorted_indices):\\n            if nums1[high] > nums2[i]:\\n                result[i] = nums1[high]\\n                high -= 1\\n            else:\\n                result[i] = nums1[low]\\n                low += 1\\n\\n        return result\\n\"",
  "2847_14631217_python": "\"class Solution:\\n    def maximumNumberOfStringPairs(self, words):\\n        seen = set()\\n        count = 0\\n        \\n        for word in words:\\n            rev = word[::-1]\\n            if rev in seen:\\n                count += 1\\n            seen.add(word)\\n        \\n        return count\\n\"",
  "2850_14631217_python-updated-time": "1747221527125",
  "1348_14631217_python-updated-time": "1746883200806",
  "537_14631217_python-updated-time": "1745446891601",
  "789_14631217_python": "\"import heapq\\n\\nclass KthLargest(object):\\n\\n    def __init__(self, k, nums):\\n        self.k = k\\n        self.heap = nums\\n        heapq.heapify(self.heap)\\n        while len(self.heap) > k:\\n            heapq.heappop(self.heap)\\n\\n    def add(self, val):\\n        heapq.heappush(self.heap, val)\\n        if len(self.heap) > self.k:\\n            heapq.heappop(self.heap)\\n        return self.heap[0]\\n\\n# Example usage:\\n# obj = KthLargest(k, nums)\\n# param_1 = obj.add(val)\\n\"",
  "2902_14631217_python": "\"class Solution(object):\\n    def maxSum(self, nums):\\n        from collections import defaultdict\\n\\n        groups = defaultdict(list)\\n        for num in nums:\\n            max_digit = max(int(d) for d in str(num))\\n            groups[max_digit].append(num)\\n\\n        res = -1\\n        for vals in groups.values():\\n            if len(vals) >= 2:\\n                vals.sort(reverse=True)\\n                res = max(res, vals[0] + vals[1])\\n        return res\\n\"",
  "1545_14631217_python": "\"class Solution(object):\\n    def largestNumber(self, cost, target):\\n        # dp[t] = max number of digits achievable with total cost t\\n        dp = [-10**9] * (target + 1)\\n        dp[0] = 0\\n        for t in range(1, target + 1):\\n            for d, c in enumerate(cost, 1):\\n                if t >= c:\\n                    dp[t] = max(dp[t], dp[t - c] + 1)\\n        # if we can't form any digit, return \\\"0\\\"\\n        if dp[target] < 1:\\n            return \\\"0\\\"\\n        # reconstruct the largest number greedily\\n        res = []\\n        t = target\\n        for _ in range(dp[target]):\\n            for d in range(9, 0, -1):\\n                c = cost[d - 1]\\n                if t >= c and dp[t - c] == dp[t] - 1:\\n                    res.append(str(d))\\n                    t -= c\\n                    break\\n        return \\\"\\\".join(res)\\n\"",
  "857_14631217_python": "\"class Solution(object):\\n    def largeGroupPositions(self, s):\\n        res = []\\n        i = 0\\n        n = len(s)\\n        while i < n:\\n            j = i\\n            while j < n and s[j] == s[i]:\\n                j += 1\\n            if j - i >= 3:\\n                res.append([i, j-1])\\n            i = j\\n        return res\\n\"",
  "154_14631217_python-updated-time": "1745090959958",
  "790_14631217_python": "\"class Solution(object):\\n    def isIdealPermutation(self, nums):\\n        for i, num in enumerate(nums):\\n            if abs(num - i) > 1:\\n                return False\\n        return True\\n\"",
  "2116_14631217_python": "\"class Solution:\\n    def countKDifference(self, nums, k):\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if abs(nums[i] - nums[j]) == k:\\n                    count += 1\\n        return count\\n\"",
  "1800_14631217_python": "\"class Solution(object):\\n    def concatenatedBinary(self, n):\\n        mod = 10**9 + 7\\n        res = 0\\n        for i in range(1, n + 1):\\n            # shift left by the bit-length of i, then add i\\n            res = ((res << i.bit_length()) + i) % mod\\n        return res\\n\"",
  "1957_14631217_python": "\"import bisect\\n\\nclass Fenwick:\\n    def __init__(self, n):\\n        self.n = n\\n        self.fw = [0] * (n + 1)\\n\\n    def update(self, i, delta):\\n        while i <= self.n:\\n            self.fw[i] += delta\\n            i += i & -i\\n\\n    def query(self, i):\\n        s = 0\\n        while i > 0:\\n            s += self.fw[i]\\n            i -= i & -i\\n        return s\\n\\n    def find_kth(self, k):\\n        # smallest i such that prefix sum >= k\\n        idx = 0\\n        bit_mask = 1 << (self.n.bit_length())\\n        while bit_mask:\\n            t = idx + bit_mask\\n            if t <= self.n and self.fw[t] < k:\\n                idx = t\\n                k -= self.fw[t]\\n            bit_mask >>= 1\\n        return idx + 1\\n\\nclass Solution(object):\\n    def closestRoom(self, rooms, queries):\\n        # sort rooms by size descending\\n        rooms.sort(key=lambda x: -x[1])\\n        # augment queries with original index and sort by minSize descending\\n        qs = []\\n        for i, (pref, ms) in enumerate(queries):\\n            qs.append((ms, pref, i))\\n        qs.sort(key=lambda x: -x[0])\\n\\n        # compress room IDs\\n        ids = [r[0] for r in rooms]\\n        ids.sort()\\n        # Fenwick on positions of ids\\n        m = len(ids)\\n        fw = Fenwick(m)\\n\\n        ans = [-1] * len(queries)\\n        ridx = 0  # pointer in rooms\\n        for ms, pref, qi in qs:\\n            # add all rooms with size >= ms\\n            while ridx < len(rooms) and rooms[ridx][1] >= ms:\\n                rid = rooms[ridx][0]\\n                pos = bisect.bisect_left(ids, rid) + 1\\n                fw.update(pos, 1)\\n                ridx += 1\\n\\n            if fw.query(m) == 0:\\n                ans[qi] = -1\\n                continue\\n\\n            # find predecessor <= pref\\n            ip = bisect.bisect_right(ids, pref)  # count <= pref\\n            if ip > 0:\\n                cnt = fw.query(ip)\\n                if cnt > 0:\\n                    p_pos = fw.find_kth(cnt)\\n                    pred = ids[p_pos - 1]\\n                else:\\n                    pred = None\\n            else:\\n                pred = None\\n\\n            # find successor > pref\\n            total = fw.query(m)\\n            cntp = fw.query(ip)\\n            if total > cntp:\\n                s_pos = fw.find_kth(cntp + 1)\\n                succ = ids[s_pos - 1]\\n            else:\\n                succ = None\\n\\n            # choose closest\\n            best = -1\\n            best_diff = 10**20\\n            for cand in (pred, succ):\\n                if cand is not None:\\n                    d = abs(cand - pref)\\n                    if d < best_diff or (d == best_diff and cand < best):\\n                        best = cand\\n                        best_diff = d\\n            ans[qi] = best\\n        return ans\\n\"",
  "2245_14631217_python": "\"class Solution:\\n    def asteroidsDestroyed(self, mass, asteroids):\\n        asteroids.sort()\\n        for a in asteroids:\\n            if mass < a:\\n                return False\\n            mass += a\\n        return True\\n\"",
  "1717_14631217_python-updated-time": "1746438987263",
  "1787_14631217_python-updated-time": "1746452941562",
  "998_14631217_python-updated-time": "1746038851058",
  "2445_14631217_python": "\"class Solution(object):\\n    def reachableNodes(self, n, edges, restricted):\\n        from collections import defaultdict, deque\\n\\n        graph = defaultdict(list)\\n        restricted_set = set(restricted)\\n        visited = set()\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        queue = deque([0])\\n        visited.add(0)\\n        count = 0\\n\\n        while queue:\\n            node = queue.popleft()\\n            count += 1\\n            for nei in graph[node]:\\n                if nei not in visited and nei not in restricted_set:\\n                    visited.add(nei)\\n                    queue.append(nei)\\n        \\n        return count\\n\"",
  "3675_14631217_python-updated-time": "1747595744149",
  "131_14631217_python-updated-time": "1745085237497",
  "3395_14631217_python-updated-time": "1747478846555",
  "1445_14631217_python-updated-time": "1746261892954",
  "3747_14631217_python": "\"class Solution(object):\\n    def maxAdjacentDistance(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Since n >= 2 by constraint, we can initialize to zero safely\\n        max_diff = 0\\n        \\n        # Compare each pair of consecutive elements\\n        for i in range(1, n):\\n            diff = abs(nums[i] - nums[i - 1])\\n            if diff > max_diff:\\n                max_diff = diff\\n        \\n        # Finally, check the circular adjacency between last and first\\n        wrap_diff = abs(nums[-1] - nums[0])\\n        if wrap_diff > max_diff:\\n            max_diff = wrap_diff\\n        \\n        return max_diff\\n\"",
  "1197_14631217_python-updated-time": "1746108541959",
  "2793_14631217_python": "\"from collections import defaultdict, deque\\n\\nclass Solution:\\n    def countCompleteComponents(self, n, edges):\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        visited = [False] * n\\n        count = 0\\n\\n        for i in range(n):\\n            if not visited[i]:\\n                q = deque([i])\\n                visited[i] = True\\n                nodes = [i]\\n                edge_set = set()\\n\\n                while q:\\n                    node = q.popleft()\\n                    for neighbor in graph[node]:\\n                        edge = tuple(sorted((node, neighbor)))\\n                        edge_set.add(edge)\\n                        if not visited[neighbor]:\\n                            visited[neighbor] = True\\n                            nodes.append(neighbor)\\n                            q.append(neighbor)\\n\\n                v = len(nodes)\\n                e = len(edge_set)\\n                # Check if complete: there should be v*(v-1)//2 edges\\n                if e == v * (v - 1) // 2:\\n                    count += 1\\n\\n        return count\\n\"",
  "2081_14631217_python-updated-time": "1746639011339",
  "1325_14631217_python-updated-time": "1746433539194",
  "1320_14631217_python": "\"class Solution(object):\\n    def removeDuplicates(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        stack = []\\n\\n        for char in s:\\n            if stack and stack[-1][0] == char:\\n                stack[-1][1] += 1\\n                if stack[-1][1] == k:\\n                    stack.pop()\\n            else:\\n                stack.append([char, 1])\\n\\n        return ''.join(char * count for char, count in stack)\\n\"",
  "3354_14631217_python-updated-time": "1747420908088",
  "329_14631217_python-updated-time": "1745256537093",
  "2546_14631217_python": "\"class Solution:\\n    def subarrayGCD(self, nums, k):\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n):\\n            g = 0\\n            for j in range(i, n):\\n                g = gcd(g, nums[j])\\n                # If gcd drops below k or isn't a multiple of k, we can stop extending\\n                if g < k or g % k != 0:\\n                    break\\n                if g == k:\\n                    ans += 1\\n        return ans\\n\"",
  "1562_14631217_python-updated-time": "1746347714729",
  "151_14631217_python-updated-time": "1745090808708",
  "1313_14631217_python-updated-time": "1746637461156",
  "1938_14631217_python-updated-time": "1746544153282",
  "934_14631217_python-updated-time": "1746002400054",
  "1326_14631217_python-updated-time": "1746625236278",
  "2122_14631217_python": "\"class Solution:\\n    def countQuadruplets(self, nums):\\n        n = len(nums)\\n        count = 0\\n        for a in range(n):\\n            for b in range(a + 1, n):\\n                for c in range(b + 1, n):\\n                    for d in range(c + 1, n):\\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\\n                            count += 1\\n        return count\\n\"",
  "188_14631217_python-updated-time": "1745092682774",
  "1296_14631217_python-updated-time": "1746432745370",
  "1476_14631217_python": "\"class Solution(object):\\n    def countNegatives(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        row, col = 0, n - 1\\n\\n        while row < m and col >= 0:\\n            if grid[row][col] < 0:\\n                count += (m - row)\\n                col -= 1\\n            else:\\n                row += 1\\n\\n        return count\\n\"",
  "1916_14631217_python": "\"class Solution(object):\\n    def findCenter(self, edges):\\n        a, b = edges[0]\\n        c, d = edges[1]\\n        return a if a == c or a == d else b\\n\"",
  "880_14631217_python": "\"class Solution(object):\\n    def rectangleArea(self, rectangles):\\n        MOD = 10**9 + 7\\n        OPEN, CLOSE = 1, -1\\n\\n        events = []\\n        Xvals = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            events.append((y1, OPEN, x1, x2))\\n            events.append((y2, CLOSE, x1, x2))\\n            Xvals.add(x1)\\n            Xvals.add(x2)\\n\\n        events.sort()\\n        Xvals = sorted(Xvals)\\n        Xi = {x: i for i, x in enumerate(Xvals)}\\n\\n        class SegmentTreeNode:\\n            def __init__(self, l, r):\\n                self.l = l\\n                self.r = r\\n                self.left = None\\n                self.right = None\\n                self.count = 0\\n                self.total = 0\\n\\n        def build(l, r):\\n            node = SegmentTreeNode(l, r)\\n            if l + 1 < r:\\n                m = (l + r) // 2\\n                node.left = build(l, m)\\n                node.right = build(m, r)\\n            return node\\n\\n        def update(node, i, j, val):\\n            if node.l >= j or node.r <= i:\\n                return\\n            if i <= node.l and node.r <= j:\\n                node.count += val\\n            else:\\n                update(node.left, i, j, val)\\n                update(node.right, i, j, val)\\n\\n            if node.count > 0:\\n                node.total = Xvals[node.r] - Xvals[node.l]\\n            else:\\n                node.total = (node.left.total if node.left else 0) + (node.right.total if node.right else 0)\\n\\n        root = build(0, len(Xvals) - 1)\\n\\n        prev_y = 0\\n        cur_x_sum = 0\\n        area = 0\\n        for y, typ, x1, x2 in events:\\n            area += cur_x_sum * (y - prev_y)\\n            area %= MOD\\n            update(root, Xi[x1], Xi[x2], typ)\\n            cur_x_sum = root.total\\n            prev_y = y\\n\\n        return area\\n\"",
  "2566_14631217_python-updated-time": "1746969544683",
  "3202_14631217_python-updated-time": "1747310768835",
  "1568_14631217_python-updated-time": "1746347892205",
  "624_14631217_python-updated-time": "1745780777521",
  "384_14631217_python-updated-time": "1745355169224",
  "1462_14631217_mysql-updated-time": "1746261460561",
  "147_14631217_python-updated-time": "1745090620692",
  "1157_14631217_python-updated-time": "1746108110503",
  "1571_14631217_python-updated-time": "1746432617452",
  "2459_14631217_python": "\"class Solution(object):\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        n = len(energy)\\n        energy_needed = max(0, sum(energy) - initialEnergy + 1)\\n        exp_needed = 0\\n        curr_exp = initialExperience\\n\\n        for i in range(n):\\n            if curr_exp <= experience[i]:\\n                extra = experience[i] - curr_exp + 1\\n                exp_needed += extra\\n                curr_exp += extra\\n            curr_exp += experience[i]\\n\\n        return energy_needed + exp_needed\\n\"",
  "2502_14631217_python-updated-time": "1746966553057",
  "3275_14631217_python-updated-time": "1747400390436",
  "2150_14631217_python-updated-time": "1746719993776",
  "1544_14631217_python": "\"class Solution(object):\\n    def goodNodes(self, root):\\n        def dfs(node, max_so_far):\\n            if not node:\\n                return 0\\n            count = 1 if node.val >= max_so_far else 0\\n            new_max = max(max_so_far, node.val)\\n            count += dfs(node.left, new_max)\\n            count += dfs(node.right, new_max)\\n            return count\\n\\n        return dfs(root, root.val)\\n\"",
  "2723_14631217_python-updated-time": "1747134508952",
  "1753_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def minimumEffortPath(self, heights):\\n        rows, cols = len(heights), len(heights[0])\\n        # dist[r][c] = minimum possible \\\"max-edge\\\" effort to reach (r,c)\\n        dist = [[float('inf')] * cols for _ in range(rows)]\\n        dist[0][0] = 0\\n        \\n        # Min-heap of (effort_so_far, r, c)\\n        heap = [(0, 0, 0)]\\n        seen = [[False]*cols for _ in range(rows)]\\n        \\n        while heap:\\n            effort, r, c = heapq.heappop(heap)\\n            if seen[r][c]:\\n                continue\\n            seen[r][c] = True\\n            # If we've reached the target, this is the minimal effort\\n            if r == rows-1 and c == cols-1:\\n                return effort\\n            \\n            # Explore neighbors\\n            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < rows and 0 <= nc < cols and not seen[nr][nc]:\\n                    # Edge cost is the height difference\\n                    cost = abs(heights[nr][nc] - heights[r][c])\\n                    # New path effort is the max of current path effort and this edge\\n                    new_effort = max(effort, cost)\\n                    if new_effort < dist[nr][nc]:\\n                        dist[nr][nc] = new_effort\\n                        heapq.heappush(heap, (new_effort, nr, nc))\\n        \\n        # Fallback (should never hit this if the grid is connected)\\n        return dist[rows-1][cols-1]\\n\"",
  "3383_14631217_python-updated-time": "1747481641403",
  "432_14631217_python-updated-time": "1745358703941",
  "3372_14631217_python": "\"class Solution(object):\\n    def longestMonotonicSubarray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return 0\\n        \\n        # inc_len: length of current strictly increasing run ending at i\\n        # dec_len: length of current strictly decreasing run ending at i\\n        inc_len = dec_len = 1\\n        best = 1\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                inc_len += 1\\n            else:\\n                inc_len = 1\\n            \\n            if nums[i] < nums[i-1]:\\n                dec_len += 1\\n            else:\\n                dec_len = 1\\n            \\n            best = max(best, inc_len, dec_len)\\n        \\n        return best\\n\"",
  "560_14631217_python": "\"class Solution(object):\\n    def subarraySum(self, nums, k):\\n        count = 0\\n        curr = 0\\n        freq = {0: 1}\\n        for x in nums:\\n            curr += x\\n            count += freq.get(curr - k, 0)\\n            freq[curr] = freq.get(curr, 0) + 1\\n        return count\\n\"",
  "947_14631217_python-updated-time": "1746003177719",
  "2531_14631217_python-updated-time": "1746967923771",
  "81_14631217_python": "\"class Solution(object):\\n    def search(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return True\\n\\n            if nums[left] == nums[mid] == nums[right]:\\n                left += 1\\n                right -= 1\\n            elif nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return False\\n\"",
  "2675_14631217_python": "\"class Solution(object):\\n    def findColumnWidth(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not grid or not grid[0]:\\n            return []\\n\\n        m, n = len(grid), len(grid[0])\\n        result = []\\n\\n        for col in range(n):\\n            max_width = 0\\n            for row in range(m):\\n                width = len(str(grid[row][col]))\\n                max_width = max(max_width, width)\\n            result.append(max_width)\\n\\n        return result\\n\"",
  "838_14631217_python": "\"class Node:\\n    def __init__(self, val=0, nxt=None):\\n        self.val = val\\n        self.next = nxt\\n\\nclass MyLinkedList(object):\\n    def __init__(self):\\n        # Dummy head simplifies edge cases\\n        self.dummy = Node(0)\\n        self.size = 0\\n\\n    def get(self, index):\\n        # If index is invalid, return -1\\n        if index < 0 or index >= self.size:\\n            return -1\\n        curr = self.dummy.next\\n        # Move to the index-th node\\n        for _ in range(index):\\n            curr = curr.next\\n        return curr.val\\n\\n    def addAtHead(self, val):\\n        # Insert at index 0\\n        self.addAtIndex(0, val)\\n\\n    def addAtTail(self, val):\\n        # Insert at index size (end)\\n        self.addAtIndex(self.size, val)\\n\\n    def addAtIndex(self, index, val):\\n        # If index is greater than size, do nothing\\n        if index < 0 or index > self.size:\\n            return\\n        prev = self.dummy\\n        # Move prev to the node before insertion point\\n        for _ in range(index):\\n            prev = prev.next\\n        # Insert new node\\n        node = Node(val, prev.next)\\n        prev.next = node\\n        self.size += 1\\n\\n    def deleteAtIndex(self, index):\\n        # If index is invalid, do nothing\\n        if index < 0 or index >= self.size:\\n            return\\n        prev = self.dummy\\n        # Move prev to the node before the one to delete\\n        for _ in range(index):\\n            prev = prev.next\\n        # Remove the node\\n        prev.next = prev.next.next\\n        self.size -= 1\\n\"",
  "1835_14631217_python": "\"class Solution:\\n    def decode(self, encoded):\\n        n = len(encoded) + 1\\n        total_xor = 0\\n        for i in range(1, n + 1):\\n            total_xor ^= i\\n        odd_xor = 0\\n        for i in range(1, len(encoded), 2):\\n            odd_xor ^= encoded[i]\\n        first = total_xor ^ odd_xor\\n        perm = [first]\\n        for e in encoded:\\n            perm.append(perm[-1] ^ e)\\n        return perm\\n\"",
  "283_14631217_python": "\"class Solution(object):\\n    def moveZeroes(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        left = 0\\n        for right in range(len(nums)):\\n            if nums[right] != 0:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n\"",
  "1210_14631217_python-updated-time": "1746444396976",
  "24_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        while head and head.next:\\n            first = head\\n            second = head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = first.next\\n\\n        return dummy.next\\n\"",
  "399_14631217_python-updated-time": "1745355715342",
  "1933_14631217_python-updated-time": "1746543420929",
  "2831_14631217_python": "\"class Solution:\\n    def countBeautifulPairs(self, nums):\\n        def first_digit(x):\\n            while x >= 10:\\n                x //= 10\\n            return x\\n\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            fi = first_digit(nums[i])\\n            for j in range(i + 1, n):\\n                lj = nums[j] % 10\\n                if gcd(fi, lj) == 1:\\n                    count += 1\\n        return count\\n\"",
  "2372_14631217_python-updated-time": "1746881730650",
  "2567_14631217_python-updated-time": "1746969573858",
  "1221_14631217_python": "\"class Solution:\\n    def findSpecialInteger(self, arr):\\n        n = len(arr)\\n        for i in [n // 4, n // 2, 3 * n // 4]:\\n            candidate = arr[i]\\n            # Use binary search to count frequency\\n            left = self.left_bound(arr, candidate)\\n            right = self.right_bound(arr, candidate)\\n            if right - left > n // 4:\\n                return candidate\\n\\n    def left_bound(self, arr, target):\\n        low, high = 0, len(arr)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if arr[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n\\n    def right_bound(self, arr, target):\\n        low, high = 0, len(arr)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if arr[mid] <= target:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n\"",
  "2417_14631217_python-updated-time": "1746906974314",
  "3699_14631217_python-updated-time": "1747653175937",
  "930_14631217_python-updated-time": "1746002164113",
  "2150_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def kthSmallestProduct(self, nums1, nums2, k):\\n        # ensure nums1 is the shorter\\n        if len(nums1) > len(nums2):\\n            nums1, nums2 = nums2, nums1\\n\\n        # compute true bounds from all 4 corners\\n        candidates = [\\n            nums1[0] * nums2[0],\\n            nums1[0] * nums2[-1],\\n            nums1[-1] * nums2[0],\\n            nums1[-1] * nums2[-1],\\n        ]\\n        lo, hi = min(candidates), max(candidates)\\n\\n        def count_no_greater(x):\\n            # count pairs (a,b) with a*b <= x\\n            total = 0\\n            n2 = len(nums2)\\n            for a in nums1:\\n                if a == 0:\\n                    if x >= 0:\\n                        total += n2\\n                elif a > 0:\\n                    bound = x // a\\n                    total += bisect.bisect_right(nums2, bound)\\n                else:  # a < 0\\n                    # ceil(x / a) = -floor(-x / a)\\n                    need = -((-x) // a)\\n                    idx = bisect.bisect_left(nums2, need)\\n                    total += n2 - idx\\n            return total\\n\\n        # binary search for smallest mid with count >= k\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if count_no_greater(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n\"",
  "3312_14631217_python": "\"class Solution(object):\\n    def countKeyChanges(self, s):\\n        cnt = 0\\n        for i in range(1, len(s)):\\n            if s[i].lower() != s[i-1].lower():\\n                cnt += 1\\n        return cnt\\n\"",
  "1342_14631217_python": "\"class Solution:\\n    def queensAttacktheKing(self, queens, king):\\n        board = [[0]*8 for _ in range(8)]\\n        for x, y in queens:\\n            board[x][y] = 1\\n        \\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1),\\n                      (-1, -1), (-1, 1), (1, -1), (1, 1)]\\n        \\n        res = []\\n        for dx, dy in directions:\\n            x, y = king\\n            while 0 <= x < 8 and 0 <= y < 8:\\n                x += dx\\n                y += dy\\n                if 0 <= x < 8 and 0 <= y < 8 and board[x][y] == 1:\\n                    res.append([x, y])\\n                    break\\n        return res\\n\"",
  "797_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        count = Counter(answers)\\n        res = 0\\n        for x, freq in count.items():\\n            group_size = x + 1\\n            groups = (freq + group_size - 1) // group_size\\n            res += groups * group_size\\n        return res\\n\"",
  "GLOBAL_DATA:value": "{\"feature\":{\"questionTranslation\":false,\"subscription\":true,\"signUp\":true,\"discuss\":true,\"mockInterview\":true,\"contest\":true,\"store\":true,\"chinaProblemDiscuss\":false,\"socialProviders\":\"[{\\\"id\\\": \\\"linkedin_oauth2\\\", \\\"login_url\\\": \\\"/accounts/linkedin_oauth2/login/\\\", \\\"deprecated\\\": true}, {\\\"id\\\": \\\"google\\\", \\\"login_url\\\": \\\"/accounts/google/login/\\\", \\\"deprecated\\\": false}, {\\\"id\\\": \\\"github\\\", \\\"login_url\\\": \\\"/accounts/github/login/\\\", \\\"deprecated\\\": false}, {\\\"id\\\": \\\"facebook\\\", \\\"login_url\\\": \\\"/accounts/facebook/login/\\\", \\\"deprecated\\\": false}]\",\"studentFooter\":true,\"enableChannels\":false,\"dangerZone\":true,\"enableSharedWorker\":true,\"enableRecaptchaV3\":true,\"enableCfTurnstile\":true,\"enableDebugger\":true,\"enableDebuggerPremium\":true,\"enableAutocomplete\":true,\"enableAutocompletePremium\":true,\"enableAllQuestionsRaw\":true,\"autocompleteLanguages\":\"[\\\"c\\\", \\\"cpp\\\", \\\"java\\\", \\\"python\\\", \\\"python3\\\", \\\"javascript\\\", \\\"react\\\"]\",\"enableReferralDiscount\":true,\"maxTimeTravelTicketCount\":3,\"enableStoreShippingForm\":true,\"enableCodingChallengeV2\":false,\"__typename\":\"FeatureNode\"},\"streakCounter\":{\"streakCount\":0,\"daysSkipped\":18,\"currentDayCompleted\":false,\"__typename\":\"StreakCounterNode\"},\"currentTimestamp\":1747738763.942456,\"userStatus\":{\"isSignedIn\":true,\"isAdmin\":false,\"isStaff\":false,\"isSuperuser\":false,\"isMockUser\":false,\"isTranslator\":false,\"isPremium\":false,\"isVerified\":true,\"checkedInToday\":true,\"username\":\"epoyraz\",\"realName\":\"epoyraz\",\"avatar\":\"https://assets.leetcode.com/users/lWrxRga7F1/avatar_1720874687.png\",\"optedIn\":true,\"requestRegion\":\"US\",\"region\":\"\",\"activeSessionId\":14631217,\"permissions\":[],\"notificationStatus\":{\"lastModified\":1747318045,\"numUnread\":0,\"__typename\":\"UserNotificationNode\"},\"completedFeatureGuides\":[\"NEW_IDE_DYNAMIC_LAYOUT_V2\"],\"__typename\":\"MeNode\"},\"siteRegion\":\"US\",\"chinaHost\":\"https://leetcode.cn\",\"websocketUrl\":\"wss://sockets.leetcode.com/ws/\",\"recaptchaKey\":\"6LdBpsIUAAAAAKAYWjZfIpn4cJHVIk_tsmxpl7cz\",\"recaptchaKeyV2\":\"6LdBX8MUAAAAAAI4aZHi1C59OJizaJTvPNvWH2wz\",\"cfTurnstileKey\":\"0x4AAAAAAAQrSHUTor4iGTpW\",\"cfTurnstileAppearance\":\"always\",\"sitewideAnnouncement\":null,\"userCountryCode\":\"CH\"}",
  "2308_14631217_python": "\"class Solution(object):\\n    def divideArray(self, nums):\\n        count = {}\\n        for x in nums:\\n            count[x] = count.get(x, 0) + 1\\n        for v in count.values():\\n            if v % 2 != 0:\\n                return False\\n        return True\\n\"",
  "1364_14631217_python-updated-time": "1746529911828",
  "2437_14631217_python": "\"class Solution(object):\\n    def maximumGroups(self, grades):\\n        n = len(grades)\\n        k = 0\\n        while (k + 1) * (k + 2) // 2 <= n:\\n            k += 1\\n        return k\\n\"",
  "415_14631217_python-updated-time": "1745356237888",
  "2271_14631217_python-updated-time": "1746802649375",
  "3056_14631217_python": "\"class Solution(object):\\n    def isReachableAtTime(self, sx, sy, fx, fy, t):\\n        dx = abs(fx - sx)\\n        dy = abs(fy - sy)\\n        d = max(dx, dy)\\n        if t < d:\\n            return False\\n        # If start == finish, you need at least 2 moves to return after moving\\n        if d == 0 and t == 1:\\n            return False\\n        return True\\n\"",
  "1628_14631217_python": "\"class Solution(object):\\n    def numSubmat(self, mat):\\n        \\\"\\\"\\\"\\n        :type mat: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(mat), len(mat[0])\\n        res = 0\\n        heights = [0] * n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                # Build histogram for row i\\n                if mat[i][j] == 1:\\n                    heights[j] += 1\\n                else:\\n                    heights[j] = 0\\n\\n            # Count rectangles using stack\\n            stack = []\\n            count = [0] * n\\n            for j in range(n):\\n                while stack and heights[stack[-1]] >= heights[j]:\\n                    stack.pop()\\n                if stack:\\n                    prev = stack[-1]\\n                    count[j] = count[prev] + heights[j] * (j - prev)\\n                else:\\n                    count[j] = heights[j] * (j + 1)\\n                res += count[j]\\n                stack.append(j)\\n\\n        return res\\n\"",
  "3394_14631217_python-updated-time": "1747424612304",
  "2118_14631217_python-updated-time": "1746718001010",
  "195_14631217_bash-updated-time": "1745092926084",
  "3292_14631217_python": "\"class Solution(object):\\n    def earliestSecondToMarkIndices(self, nums, changeIndices):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type changeIndices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(nums), len(changeIndices)\\n        # convert to 0-based\\n        change = [c-1 for c in changeIndices]\\n        \\n        # check if by time t we can finish\\n        def can(t):\\n            # find for each index i its last marking time ≤ t\\n            last = [-1]*n\\n            for s in range(t):\\n                last[change[s]] = s+1   # store 1-based time\\n            # every index must appear\\n            for i in range(n):\\n                if last[i] < 0:\\n                    return False\\n            \\n            # build (deadline, work) pairs\\n            tasks = [(last[i]-1, nums[i]) for i in range(n)]\\n            tasks.sort(key=lambda x: x[0])  # sort by deadline\\n            \\n            # prefix sums of work\\n            prefix = [0]*(n+1)\\n            for i, (_, w) in enumerate(tasks):\\n                prefix[i+1] = prefix[i] + w\\n            \\n            # EDF‐style check: for each distinct deadline D, let\\n            #   k_prev = # tasks with deadline < D,\\n            #   total_work = sum of all tasks with deadline ≤ D,\\n            # and ensure total_work ≤ (D − k_prev) free slots.\\n            i = 0\\n            while i < n:\\n                D = tasks[i][0]\\n                # find block of tasks with same deadline\\n                j = i+1\\n                while j < n and tasks[j][0] == D:\\n                    j += 1\\n                k_prev = i\\n                # worst‐case total_work is prefix[j]\\n                if prefix[j] > D - k_prev:\\n                    return False\\n                i = j\\n            \\n            return True\\n        \\n        # binary search earliest t in [1..m]\\n        ans = m+1\\n        lo, hi = 1, m\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if can(mid):\\n                ans = mid\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        \\n        return ans if ans <= m else -1\\n\"",
  "34_14631217_python-updated-time": "1744988559099",
  "1369_14631217_python-updated-time": "1746259431647",
  "2228_14631217_python-updated-time": "1746799959793",
  "659_14631217_python": "\"from collections import Counter, defaultdict\\n\\nclass Solution(object):\\n    def isPossible(self, nums):\\n        count = Counter(nums)\\n        end = defaultdict(int)\\n        \\n        for num in nums:\\n            if count[num] == 0:\\n                continue\\n            count[num] -= 1\\n            if end[num - 1] > 0:\\n                end[num - 1] -= 1\\n                end[num] += 1\\n            elif count[num + 1] > 0 and count[num + 2] > 0:\\n                count[num + 1] -= 1\\n                count[num + 2] -= 1\\n                end[num + 2] += 1\\n            else:\\n                return False\\n        return True\\n\"",
  "1320_14631217_python-updated-time": "1746127597409",
  "655_14631217_python": "\"class Solution(object):\\n    def printTree(self, root):\\n        def getHeight(node):\\n            if not node:\\n                return -1\\n            return 1 + max(getHeight(node.left), getHeight(node.right))\\n        \\n        height = getHeight(root)\\n        m = height + 1\\n        n = (1 << (height + 1)) - 1\\n        res = [[\\\"\\\" for _ in range(n)] for _ in range(m)]\\n        \\n        def dfs(node, r, c):\\n            if not node:\\n                return\\n            res[r][c] = str(node.val)\\n            if r < height:\\n                offset = 1 << (height - r - 1)\\n                dfs(node.left, r + 1, c - offset)\\n                dfs(node.right, r + 1, c + offset)\\n        \\n        dfs(root, 0, (n - 1) // 2)\\n        return res\\n\"",
  "1625_14631217_mysql": "\"SELECT\\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR ',') AS products\\nFROM\\n    Activities\\nGROUP BY\\n    sell_date\\nORDER BY\\n    sell_date;\\n\"",
  "1517_14631217_python": "\"class Solution(object):\\n    def numberOfArrays(self, s, k):\\n        MOD = 10**9 + 7\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        dp[n] = 1  # base case: 1 way to parse empty string\\n\\n        max_len = len(str(k))  # limit substring length based on k\\n\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == '0':\\n                dp[i] = 0  # no numbers can start with '0'\\n                continue\\n            num = 0\\n            for j in range(i, min(i + max_len, n)):\\n                num = num * 10 + int(s[j])\\n                if num > k:\\n                    break\\n                dp[i] = (dp[i] + dp[j + 1]) % MOD\\n\\n        return dp[0]\\n\"",
  "2012_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers, tasks):\\n        n = len(servers)\\n        m = len(tasks)\\n        \\n        # Min-heap of free servers: (weight, index)\\n        free = [(servers[i], i) for i in range(n)]\\n        heapq.heapify(free)\\n        \\n        # Min-heap of busy servers: (available_time, weight, index)\\n        busy = []\\n\\n        res = []\\n        time = 0\\n\\n        for i in range(m):\\n            time = max(time, i)\\n\\n            # Free up servers that are done by current time\\n            while busy and busy[0][0] <= time:\\n                avail_time, w, idx = heapq.heappop(busy)\\n                heapq.heappush(free, (w, idx))\\n\\n            # If no free servers, wait until the next one finishes\\n            if not free:\\n                time = busy[0][0]\\n                while busy and busy[0][0] <= time:\\n                    avail_time, w, idx = heapq.heappop(busy)\\n                    heapq.heappush(free, (w, idx))\\n\\n            # Assign task\\n            w, idx = heapq.heappop(free)\\n            heapq.heappush(busy, (time + tasks[i], w, idx))\\n            res.append(idx)\\n\\n        return res\\n\"",
  "2078_14631217_python": "\"class Solution(object):\\n    def maxCompatibilitySum(self, students, mentors):\\n        m = len(students)\\n        # Precompute compatibility scores\\n        compat = [[0]*m for _ in range(m)]\\n        for i in range(m):\\n            for j in range(m):\\n                # count matching answers\\n                cnt = 0\\n                for a,b in zip(students[i], mentors[j]):\\n                    if a == b:\\n                        cnt += 1\\n                compat[i][j] = cnt\\n\\n        # dp[mask]: max sum pairing first popcount(mask) students\\n        # with the set of mentors indicated by bits in mask\\n        N = 1 << m\\n        dp = [0]*N\\n        for mask in range(1, N):\\n            i = bin(mask).count(\\\"1\\\") - 1  # student index to assign\\n            best = 0\\n            # try pairing student i with each mentor j in mask\\n            sub = mask\\n            while sub:\\n                j = (sub & -sub).bit_length() - 1\\n                prev = dp[mask ^ (1<<j)] + compat[i][j]\\n                if prev > best:\\n                    best = prev\\n                sub ^= (1<<j)\\n            dp[mask] = best\\n\\n        return dp[N-1]\\n\"",
  "2568_14631217_python": "\"import collections\\n\\nclass Solution:\\n    def minimumFuelCost(self, roads, seats):\\n        n = len(roads) + 1\\n        if n == 1:\\n            return 0\\n        \\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in roads:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # BFS from root (0) to get parent and traversal order\\n        parent = [-1] * n\\n        order = []\\n        q = collections.deque([0])\\n        parent[0] = 0\\n        while q:\\n            u = q.popleft()\\n            order.append(u)\\n            for v in adj[u]:\\n                if parent[v] == -1:\\n                    parent[v] = u\\n                    q.append(v)\\n        \\n        # subtree_count[i] = number of representatives in the subtree rooted at i\\n        subtree_count = [1] * n\\n        fuel = 0\\n        \\n        # Process nodes in reverse BFS order (post-order)\\n        for u in reversed(order[1:]):  # skip the root at order[0]\\n            p = parent[u]\\n            cnt = subtree_count[u]\\n            # Number of car trips needed to move these cnt reps one edge up\\n            trips = (cnt + seats - 1) // seats\\n            fuel += trips\\n            # Add these reps to the parent's subtree count\\n            subtree_count[p] += cnt\\n        \\n        return fuel\\n\"",
  "3829_14631217_python-updated-time": "1747744586777",
  "1254_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def deepestLeavesSum(self, root):\\n        if not root:\\n            return 0\\n\\n        queue = deque([root])\\n        while queue:\\n            level_sum = 0\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        return level_sum\\n\"",
  "522_14631217_python-updated-time": "1745446565305",
  "696_14631217_python-updated-time": "1745785971259",
  "2349_14631217_python-updated-time": "1746880862982",
  "693_14631217_python-updated-time": "1745785908624",
  "3760_14631217_python-updated-time": "1747678961058",
  "3233_14631217_python-updated-time": "1747399057309",
  "2327_14631217_python": "\"class Solution(object):\\n    def largestInteger(self, num):\\n        \\\"\\\"\\\"\\n        :type num: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Convert to list of digits (as strings)\\n        digits = list(str(num))\\n        \\n        # Extract and sort evens and odds in descending order\\n        evens = sorted((d for d in digits if int(d) % 2 == 0), reverse=True)\\n        odds  = sorted((d for d in digits if int(d) % 2 == 1), reverse=True)\\n        \\n        # Pointers into the sorted lists\\n        e = o = 0\\n        res = []\\n        \\n        # Rebuild the number by picking the largest available digit of the same parity\\n        for d in digits:\\n            if int(d) % 2 == 0:\\n                res.append(evens[e])\\n                e += 1\\n            else:\\n                res.append(odds[o])\\n                o += 1\\n        \\n        # Join and convert back to int\\n        return int(\\\"\\\".join(res))\\n\"",
  "1936_14631217_python-updated-time": "1746543570657",
  "3436_14631217_python-updated-time": "1747484065868",
  "2728_14631217_python-updated-time": "1747137911738",
  "2886_14631217_python": "\"class Solution:\\n    def finalString(self, s):\\n        res = []\\n        rev = False\\n        for c in s:\\n            if c == 'i':\\n                rev = not rev\\n            else:\\n                if rev:\\n                    res.insert(0, c)\\n                else:\\n                    res.append(c)\\n        return ''.join(res[::-1] if rev else res)\\n\"",
  "338_14631217_python-updated-time": "1745256860585",
  "264_14631217_python-updated-time": "1745248111107",
  "3603_14631217_python-updated-time": "1747581747421",
  "2682_14631217_python-updated-time": "1747064800936",
  "2809_14631217_javascript-updated-time": "1747137142804",
  "607_14631217_mysql": "\"SELECT\\n    s.name\\nFROM SalesPerson s\\nWHERE NOT EXISTS (\\n    SELECT 1\\n    FROM Orders o\\n    JOIN Company c\\n      ON o.com_id = c.com_id\\n    WHERE o.sales_id = s.sales_id\\n      AND c.name = 'RED'\\n);\\n\"",
  "739_14631217_python": "\"class Solution(object):\\n    def dailyTemperatures(self, T):\\n        n = len(T)\\n        res = [0] * n\\n        stack = []\\n        for i, t in enumerate(T):\\n            while stack and T[stack[-1]] < t:\\n                j = stack.pop()\\n                res[j] = i - j\\n            stack.append(i)\\n        return res\\n\"",
  "782_14631217_python-updated-time": "1745876494163",
  "2809_14631217_javascript": "\"function createHelloWorld() {\\n  return function() {\\n    return \\\"Hello World\\\";\\n  };\\n}\"",
  "652_14631217_python-updated-time": "1745782727502",
  "1133_14631217_python-updated-time": "1746126185367",
  "1414_14631217_python-updated-time": "1746260426127",
  "1881_14631217_python": "\"from bisect import bisect_left\\n\\nclass Solution(object):\\n    def minAbsDifference(self, nums, goal):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type goal: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from itertools import combinations\\n\\n        def get_all_sums(arr):\\n            sums = set([0])\\n            for num in arr:\\n                new_sums = set()\\n                for s in sums:\\n                    new_sums.add(s + num)\\n                sums.update(new_sums)\\n            return list(sums)\\n\\n        n = len(nums)\\n        left = nums[:n // 2]\\n        right = nums[n // 2:]\\n\\n        left_sums = get_all_sums(left)\\n        right_sums = sorted(get_all_sums(right))\\n\\n        res = float('inf')\\n        for l in left_sums:\\n            target = goal - l\\n            idx = bisect_left(right_sums, target)\\n\\n            if idx < len(right_sums):\\n                res = min(res, abs(l + right_sums[idx] - goal))\\n            if idx > 0:\\n                res = min(res, abs(l + right_sums[idx - 1] - goal))\\n\\n        return res\\n\"",
  "2757_14631217_python": "\"class Solution:\\n    MOD = 10**9 + 7\\n\\n    def count_upto(self, s, min_sum, max_sum):\\n        n = len(s)\\n        dp_curr = [[0, 0] for _ in range(max_sum + 1)]\\n        dp_curr[0][1] = 1\\n\\n        for ch in s:\\n            digit = ord(ch) - 48\\n            dp_next = [[0, 0] for _ in range(max_sum + 1)]\\n            for sm in range(max_sum + 1):\\n                cnt0, cnt1 = dp_curr[sm]\\n                if cnt0:\\n                    for d in range(10):\\n                        sm2 = sm + d\\n                        if sm2 > max_sum:\\n                            break\\n                        dp_next[sm2][0] = (dp_next[sm2][0] + cnt0) % self.MOD\\n                if cnt1:\\n                    for d in range(digit):\\n                        sm2 = sm + d\\n                        if sm2 > max_sum:\\n                            break\\n                        dp_next[sm2][0] = (dp_next[sm2][0] + cnt1) % self.MOD\\n                    sm2 = sm + digit\\n                    if sm2 <= max_sum:\\n                        dp_next[sm2][1] = (dp_next[sm2][1] + cnt1) % self.MOD\\n            dp_curr = dp_next\\n\\n        res = 0\\n        for sm in range(min_sum, max_sum + 1):\\n            res = (res + dp_curr[sm][0] + dp_curr[sm][1]) % self.MOD\\n        return res\\n\\n    def decrement_str(self, s):\\n        lst = list(s)\\n        i = len(lst) - 1\\n        while i >= 0:\\n            if lst[i] == '0':\\n                lst[i] = '9'\\n                i -= 1\\n            else:\\n                lst[i] = chr(ord(lst[i]) - 1)\\n                break\\n        if lst and lst[0] == '0':\\n            lst.pop(0)\\n        return ''.join(lst)\\n\\n    def count(self, num1, num2, min_sum, max_sum):\\n        cnt2 = self.count_upto(num2, min_sum, max_sum)\\n        num1m1 = self.decrement_str(num1)\\n        cnt1 = self.count_upto(num1m1, min_sum, max_sum) if num1m1 else 0\\n        return (cnt2 - cnt1) % self.MOD\\n\"",
  "2824_14631217_python-updated-time": "1747220608457",
  "3113_14631217_python": "\"class Solution(object):\\n    def maximumSumOfHeights(self, maxHeights):\\n        n = len(maxHeights)\\n        left = [0] * n\\n        right = [0] * n\\n\\n        # Process left sums\\n        stack = []\\n        for i in range(n):\\n            while stack and maxHeights[stack[-1]] > maxHeights[i]:\\n                stack.pop()\\n            if not stack:\\n                left[i] = maxHeights[i] * (i + 1)\\n            else:\\n                j = stack[-1]\\n                left[i] = left[j] + maxHeights[i] * (i - j)\\n            stack.append(i)\\n\\n        # Process right sums\\n        stack = []\\n        for i in range(n - 1, -1, -1):\\n            while stack and maxHeights[stack[-1]] > maxHeights[i]:\\n                stack.pop()\\n            if not stack:\\n                right[i] = maxHeights[i] * (n - i)\\n            else:\\n                j = stack[-1]\\n                right[i] = right[j] + maxHeights[i] * (j - i)\\n            stack.append(i)\\n\\n        # Combine left and right sums at each peak (subtract maxHeights[i] once)\\n        max_total = 0\\n        for i in range(n):\\n            max_total = max(max_total, left[i] + right[i] - maxHeights[i])\\n\\n        return max_total\\n\"",
  "3540_14631217_python-updated-time": "1747570058367",
  "3809_14631217_python-updated-time": "1747682813065",
  "1971_14631217_python-updated-time": "1746625165144",
  "3795_14631217_python": "\"class Solution(object):\\n    def minZeroArray(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        Q = len(queries)\\n        # Precompute, for each position i, a list of (query_index, value)\\n        # for queries that cover i.\\n        cover = [[] for _ in range(n)]\\n        for qi, (l, r, v) in enumerate(queries):\\n            for i in range(l, r+1):\\n                cover[i].append((qi, v))\\n        # Helper: can we zero out all nums using only queries [0..k-1]?\\n        def can(k):\\n            for i in range(n):\\n                target = nums[i]\\n                if target == 0:\\n                    continue\\n                # dp bitset: bit s is 1 if sum s reachable\\n                dp = 1\\n                for qi, v in cover[i]:\\n                    if qi >= k:\\n                        break\\n                    dp |= (dp << v)\\n                    # early exit if we've hit the target\\n                    if (dp >> target) & 1:\\n                        break\\n                # if target sum not reachable, fail\\n                if ((dp >> target) & 1) == 0:\\n                    return False\\n            return True\\n\\n        # Check if 0 queries suffice\\n        if can(0):\\n            return 0\\n        # Binary search least k in [1..Q] with can(k)=True\\n        lo, hi, ans = 1, Q, -1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if can(mid):\\n                ans = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return ans\\n\"",
  "1543_14631217_python-updated-time": "1746347578031",
  "1501_14631217_python-updated-time": "1746346425348",
  "521_14631217_python": "\"class Solution:\\n    def findLUSlength(self, a, b):\\n        if a == b:\\n            return -1\\n        return max(len(a), len(b))\\n\"",
  "125_14631217_python-updated-time": "1745081708092",
  "180_14631217_mysql": "\"SELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\"",
  "2664_14631217_python": "\"class Solution(object):\\n    def maximizeGreatness(self, nums):\\n        # Sort the original values\\n        A = sorted(nums)\\n        B = A[:]  # multiset for perm\\n        \\n        count = 0\\n        j = 0  # pointer into A\\n        \\n        # Greedily match each b in B to the smallest A[j] it can beat\\n        for b in B:\\n            if j < len(A) and b > A[j]:\\n                count += 1\\n                j += 1\\n        \\n        return count\\n\"",
  "1487_14631217_python-updated-time": "1746345969745",
  "3344_14631217_python-updated-time": "1747423191487",
  "1460_14631217_python": "\"class Solution(object):\\n    def numberOfSubstrings(self, s):\\n        count = {'a': 0, 'b': 0, 'c': 0}\\n        res = left = 0\\n\\n        for right in range(len(s)):\\n            count[s[right]] += 1\\n            while count['a'] > 0 and count['b'] > 0 and count['c'] > 0:\\n                res += len(s) - right\\n                count[s[left]] -= 1\\n                left += 1\\n\\n        return res\\n\"",
  "3725_14631217_python": "\"class Solution(object):\\n    def minMaxSubarraySum(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k:    int\\n        :rtype:     int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n\\n        # 1) prev_less (strict) & next_less_or_equal\\n        prev_less = [-1]*n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            prev_less[i] = stack[-1] if stack else -1\\n            stack.append(i)\\n\\n        next_less = [n]*n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[i] <= nums[stack[-1]]:\\n                next_less[stack[-1]] = i\\n                stack.pop()\\n            stack.append(i)\\n\\n        # 2) prev_greater (strict) & next_greater_or_equal\\n        prev_greater = [-1]*n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] <= nums[i]:\\n                stack.pop()\\n            prev_greater[i] = stack[-1] if stack else -1\\n            stack.append(i)\\n\\n        next_greater = [n]*n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[i] >= nums[stack[-1]]:\\n                next_greater[stack[-1]] = i\\n                stack.pop()\\n            stack.append(i)\\n\\n        # Helper: count all subarrays of length ≤ k, containing i,\\n        # whose min (or max) is at i given bounds L < l <= i <= r < R.\\n        def count_extremes(i, L, R):\\n            # l in [A..B] = [L+1 .. i], but also need l+k-1 >= i so\\n            # l >= i-k+1.  So l from l_start..B where\\n            A = L + 1\\n            B = i\\n            l_start = max(A, i - k + 1)\\n\\n            # Split at l ≤ R-k  and l > R-k\\n            t = min(B, R - k)\\n            # 1) l in [l_start..t], count(l) = (l+k-1) - i + 1 = l + k - i\\n            if t >= l_start:\\n                n1 = t - l_start + 1\\n                # sum of l from l_start to t = n1*(l_start + t)//2\\n                sum_l = n1 * (l_start + t) // 2\\n                sum1 = sum_l + n1 * (k - i)\\n            else:\\n                sum1 = 0\\n\\n            # 2) l in [max(l_start, R-k+1)..B], count(l) = (R-1)-i+1 = R-i\\n            l2_start = max(l_start, R - k + 1)\\n            if l2_start <= B:\\n                n2 = B - l2_start + 1\\n                sum2 = n2 * (R - i)\\n            else:\\n                sum2 = 0\\n\\n            return sum1 + sum2\\n\\n        total = 0\\n        for i in range(n):\\n            cnt_min = count_extremes(i, prev_less[i],  next_less[i])\\n            cnt_max = count_extremes(i, prev_greater[i], next_greater[i])\\n            total += nums[i] * (cnt_min + cnt_max)\\n\\n        return total\\n\"",
  "876_14631217_python-updated-time": "1745880189132",
  "177_14631217_mysql": "\"CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\\nDETERMINISTIC\\nBEGIN\\n  SET N = N - 1;\\n  RETURN (\\n    SELECT salary\\n    FROM (\\n      SELECT DISTINCT salary\\n      FROM Employee\\n      ORDER BY salary DESC\\n      LIMIT N, 1\\n    ) AS temp\\n  );\\nEND;\\n\"",
  "3046_14631217_python-updated-time": "1747226845174",
  "1901_14631217_python": "\"class Solution:\\n    def minOperations(self, nums1, nums2):\\n        from collections import Counter\\n\\n        s1, s2 = sum(nums1), sum(nums2)\\n        if s1 == s2:\\n            return 0\\n\\n        # Ensure nums1 has the larger sum\\n        if s1 < s2:\\n            nums1, nums2 = nums2, nums1\\n            s1, s2 = s2, s1\\n\\n        # Build frequency of possible changes (1→6 = +5, 6→1 = -5)\\n        diff = s1 - s2\\n        changes = [0] * 6\\n\\n        for num in nums1:\\n            changes[num - 1] += 1  # max decrease: num - 1\\n        for num in nums2:\\n            changes[6 - num] += 1  # max increase: 6 - num\\n\\n        ops = 0\\n        for i in range(5, 0, -1):  # i is the gain from a change\\n            while changes[i] > 0 and diff > 0:\\n                take = min(changes[i], (diff + i - 1) // i)\\n                diff -= take * i\\n                ops += take\\n                changes[i] -= take\\n\\n        return ops if diff <= 0 else -1\\n\"",
  "1760_14631217_python-updated-time": "1746445007566",
  "2005_14631217_python-updated-time": "1746626555630",
  "1206_14631217_python-updated-time": "1746108772031",
  "3811_14631217_python-updated-time": "1747681616657",
  "2616_14631217_python": "\"import heapq\\nimport math\\n\\nclass Solution:\\n    def maxKelements(self, nums, k):\\n        # Use a max-heap by pushing negative values\\n        max_heap = [-x for x in nums]\\n        heapq.heapify(max_heap)\\n        \\n        score = 0\\n        for _ in range(k):\\n            top = -heapq.heappop(max_heap)\\n            score += top\\n            # Push updated value back\\n            heapq.heappush(max_heap, -((top + 2) // 3))  # equivalent to ceil(top / 3)\\n        \\n        return score\\n\"",
  "864_14631217_python-updated-time": "1745879453747",
  "2787_14631217_python": "\"class Solution(object):\\n    def sumDistance(self, nums, s, d):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type s: str\\n        :type d: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        positions = []\\n\\n        for i in range(n):\\n            if s[i] == 'L':\\n                positions.append(nums[i] - d)\\n            else:\\n                positions.append(nums[i] + d)\\n\\n        positions.sort()\\n        total = 0\\n        prefix_sum = 0\\n\\n        for i in range(n):\\n            total = (total + i * positions[i] - prefix_sum) % MOD\\n            prefix_sum = (prefix_sum + positions[i]) % MOD\\n\\n        return total\\n\"",
  "2359_14631217_python-updated-time": "1746881099591",
  "1908_14631217_mysql": "\"SELECT product_id\\nFROM Products\\nWHERE low_fats = 'Y' AND recyclable = 'Y';\\n\"",
  "2528_14631217_python-updated-time": "1746967732541",
  "2618_14631217_python-updated-time": "1747060436448",
  "2243_14631217_python-updated-time": "1746801790961",
  "3552_14631217_python": "\"class Solution(object):\\n    def largestPalindrome(self, n, k):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        Returns the largest n-digit palindrome divisible by k.\\n        \\\"\\\"\\\"\\n        # Special case for k == 1: all 9's\\n        if k == 1:\\n            return '9' * n\\n        # Compute half-length and whether there's a middle digit\\n        half = n // 2\\n        has_mid = (n % 2 == 1)\\n        L = half + (1 if has_mid else 0)\\n        # Precompute powers of 10 mod k up to n\\n        pow10 = [0] * (n + 1)\\n        pow10[0] = 1 % k\\n        for i in range(1, n + 1):\\n            pow10[i] = (pow10[i-1] * 10) % k\\n        # Build weight array W for positions 0..L-1\\n        W = [0] * L\\n        for i in range(half):\\n            # weight is 10^{n-1-i} + 10^{i} (mod k)\\n            W[i] = (pow10[n-1-i] + pow10[i]) % k\\n        if has_mid:\\n            # middle position contributes 10^{half}\\n            W[half] = pow10[half] % k\\n        # DP table: dp[pos][rem] = can suffix from pos..L-1 achieve sum mod k == rem\\n        dp = [ [False] * k for _ in range(L+1) ]\\n        dp[L][0] = True\\n        # Fill DP backwards\\n        for pos in range(L-1, -1, -1):\\n            w = W[pos]\\n            for rem in range(k):\\n                # Try all digits\\n                d_start = 1 if pos == 0 else 0\\n                for d in range(d_start, 10):\\n                    need = (rem - d * w) % k\\n                    if dp[pos+1][need]:\\n                        dp[pos][rem] = True\\n                        break\\n        # If not possible at all, return \\\"\\\" (or could return \\\"0\\\" * n)\\n        if not dp[0][0]:\\n            return \\\"\\\"\\n        # Greedy construct digits\\n        digits = [0] * L\\n        rem = 0\\n        for pos in range(L):\\n            w = W[pos]\\n            d_start = 1 if pos == 0 else 0\\n            for d in range(9, d_start-1, -1):\\n                need = (rem - d * w) % k\\n                if dp[pos+1][need]:\\n                    digits[pos] = d\\n                    rem = need\\n                    break\\n        # Build palindrome string\\n        left = ''.join(str(d) for d in digits[:half])\\n        mid = str(digits[half]) if has_mid else ''\\n        right = left[::-1]\\n        return left + mid + right\"",
  "3621_14631217_python-updated-time": "1747596136250",
  "problemset_page_visit_times": "2",
  "474_14631217_python-updated-time": "1745360034230",
  "3608_14631217_python-updated-time": "1747585773163",
  "2862_14631217_javascript": "\"var cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const intervalId = setInterval(() => fn(...args), t);\\n    return function cancelFn() {\\n        clearInterval(intervalId);\\n    };\\n};\\n\"",
  "1017_14631217_python-updated-time": "1746040036576",
  "1580_14631217_python": "\"class Solution(object):\\n    def shuffle(self, nums, n):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        res = []\\n        for i in range(n):\\n            res.append(nums[i])\\n            res.append(nums[i + n])\\n        return res\\n\"",
  "1349_14631217_python-updated-time": "1746259239825",
  "2334_14631217_python-updated-time": "1746880175373",
  "2520_14631217_python-updated-time": "1746967369550",
  "3495_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def resultsArray(self, queries, k):\\n        # max-heap (as min-heap of negatives) for the k smallest distances\\n        small = []\\n        # min-heap for the remaining distances\\n        large = []\\n        res = []\\n\\n        for x, y in queries:\\n            d = abs(x) + abs(y)\\n            if len(small) < k:\\n                # still need more to reach k\\n                heapq.heappush(small, -d)\\n            else:\\n                # small is full (size == k)\\n                # compare with the largest in small (i.e. -small[0])\\n                if -small[0] > d:\\n                    # new distance is among the k smallest\\n                    heapq.heappush(small, -d)\\n                    # pop the largest from small into large\\n                    moved = -heapq.heappop(small)\\n                    heapq.heappush(large, moved)\\n                else:\\n                    # goes into the \\\"rest\\\"\\n                    heapq.heappush(large, d)\\n\\n            # if fewer than k obstacles so far\\n            if len(small) < k:\\n                res.append(-1)\\n            else:\\n                # the kth smallest is the max of 'small'\\n                res.append(-small[0])\\n\\n        return res\\n\"",
  "3592_14631217_python-updated-time": "1747580274206",
  "107_14631217_python-updated-time": "1745081158139",
  "1769_14631217_python-updated-time": "1746445146134",
  "3573_14631217_python-updated-time": "1747572790641",
  "767_14631217_python-updated-time": "1745876007400",
  "1942_14631217_mysql": "\"SELECT employee_id, department_id\\nFROM Employee\\nWHERE primary_flag = 'Y'\\n\\nUNION\\n\\nSELECT employee_id, department_id\\nFROM Employee\\nGROUP BY employee_id\\nHAVING COUNT(*) = 1;\\n\"",
  "2886_14631217_python-updated-time": "1747225163704",
  "2076_14631217_python-updated-time": "1746638593618",
  "1389_14631217_python-updated-time": "1746259954749",
  "1448_14631217_python-updated-time": "1746261356540",
  "649_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        r_queue = deque()\\n        d_queue = deque()\\n        n = len(senate)\\n        \\n        for i, s in enumerate(senate):\\n            if s == 'R':\\n                r_queue.append(i)\\n            else:\\n                d_queue.append(i)\\n        \\n        while r_queue and d_queue:\\n            r = r_queue.popleft()\\n            d = d_queue.popleft()\\n            if r < d:\\n                r_queue.append(r + n)\\n            else:\\n                d_queue.append(d + n)\\n        \\n        return \\\"Radiant\\\" if r_queue else \\\"Dire\\\"\\n\"",
  "299_14631217_python": "\"class Solution(object):\\n    def getHint(self, secret, guess):\\n        \\\"\\\"\\\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        bulls = cows = 0\\n        secret_count = {}\\n        guess_count = {}\\n\\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n            else:\\n                secret_count[s] = secret_count.get(s, 0) + 1\\n                guess_count[g] = guess_count.get(g, 0) + 1\\n\\n        for digit in guess_count:\\n            if digit in secret_count:\\n                cows += min(secret_count[digit], guess_count[digit])\\n\\n        return str(bulls) + \\\"A\\\" + str(cows) + \\\"B\\\"\\n\"",
  "1584_14631217_python-updated-time": "1746432945644",
  "479_14631217_python": "\"class Solution(object):\\n    def largestPalindrome(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]\\n\"",
  "1064_14631217_python-updated-time": "1746041548523",
  "1791_14631217_python-updated-time": "1746452530339",
  "preferred_lang": "\"python\"",
  "2819_14631217_python": "\"class Solution:\\n    def removeTrailingZeros(self, num):\\n        return num.rstrip('0')\\n\"",
  "3240_14631217_python": "\"class Solution(object):\\n    def findMaximumNumber(self, k, x):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Accumulated price from 1..N\\n        def F(N):\\n            total = 0\\n            if N <= 0:\\n                return 0\\n            L = N.bit_length()\\n            # Sum over bit‐positions p = x, 2x, 3x, ... up to L\\n            p = x\\n            while p <= L:\\n                cycle = 1 << p          # 2^p\\n                half  = 1 << (p - 1)    # 2^(p-1)\\n                full  = (N + 1) // cycle\\n                rem   = (N + 1) % cycle\\n                # ones in full cycles plus any extra in the last (partial) cycle\\n                total += full * half + max(0, rem - half)\\n                p += x\\n            return total\\n\\n        # 1) Find 'high' by doubling until F(high) > k\\n        low, high = 0, 1\\n        while F(high) <= k:\\n            low = high\\n            high <<= 1  # high *= 2\\n\\n        # 2) Binary‐search the largest N in [0..high] with F(N) <= k\\n        while low < high:\\n            mid = (low + high + 1) // 2\\n            if F(mid) <= k:\\n                low = mid\\n            else:\\n                high = mid - 1\\n\\n        return low\\n\"",
  "106_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \\\"\\\"\\\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: Optional[TreeNode]\\n        \\\"\\\"\\\"\\n        if not inorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(postorder[-1])\\n        mid = inorder.index(postorder[-1])\\n        \\n        root.left = self.buildTree(inorder[:mid], postorder[:mid])\\n        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])\\n        \\n        return root\\n\"",
  "540_14631217_python-updated-time": "1745446957395",
  "3872_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxFreqSum(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        cnt = Counter(s)\\n        vowels = {'a', 'e', 'i', 'o', 'u'}\\n        \\n        max_vowel = 0\\n        max_consonant = 0\\n        \\n        for ch, freq in cnt.items():\\n            if ch in vowels:\\n                max_vowel = max(max_vowel, freq)\\n            else:\\n                max_consonant = max(max_consonant, freq)\\n        \\n        return max_vowel + max_consonant\\n\"",
  "3414_14631217_python-updated-time": "1747483031852",
  "1232_14631217_python-updated-time": "1746260557369",
  "3194_14631217_python-updated-time": "1747312247240",
  "815_14631217_python": "\"class Solution(object):\\n    def champagneTower(self, poured, query_row, query_glass):\\n        dp = [[0] * (i + 1) for i in range(query_row + 2)]\\n        dp[0][0] = poured\\n        \\n        for r in range(query_row + 1):\\n            for c in range(len(dp[r])):\\n                if dp[r][c] > 1:\\n                    excess = dp[r][c] - 1\\n                    dp[r+1][c] += excess / 2.0\\n                    dp[r+1][c+1] += excess / 2.0\\n                    dp[r][c] = 1\\n        \\n        return dp[query_row][query_glass]\\n\"",
  "1308_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        parent = list(range(len(s)))\\n\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px != py:\\n                parent[py] = px\\n\\n        # Step 1: Union connected indices\\n        for a, b in pairs:\\n            union(a, b)\\n\\n        # Step 2: Group characters by connected component\\n        groups = defaultdict(list)\\n        for i in range(len(s)):\\n            groups[find(i)].append(i)\\n\\n        res = list(s)\\n        for indices in groups.values():\\n            chars = sorted([s[i] for i in indices])\\n            for i, ch in zip(sorted(indices), chars):\\n                res[i] = ch\\n\\n        return ''.join(res)\\n\"",
  "1515_14631217_python": "\"class Solution(object):\\n    def findMinFibonacciNumbers(self, k):\\n        fib = [1, 1]\\n        while fib[-1] < k:\\n            fib.append(fib[-1] + fib[-2])\\n\\n        count = 0\\n        for i in reversed(fib):\\n            if k >= i:\\n                k -= i\\n                count += 1\\n            if k == 0:\\n                break\\n\\n        return count\\n\"",
  "3824_14631217_python": "\"class Solution(object):\\n    def uniqueXorTriplets(self, nums):\\n        n = len(nums)\\n        if n < 3:\\n            return n\\n        p = 1 << (n.bit_length() - 1)\\n        return 2 * p\\n\"",
  "2262_14631217_python": "\"class Solution:\\n    def mostPoints(self, questions):\\n        n = len(questions)\\n        dp = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            points, skip = questions[i]\\n            next_q = i + skip + 1\\n            dp[i] = max(dp[i + 1], points + (dp[next_q] if next_q < n else 0))\\n        return dp[0]\\n\"",
  "2310_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def halveArray(self, nums):\\n        total = sum(nums)\\n        target = total / 2.0\\n        heap = [-float(x) for x in nums]\\n        heapq.heapify(heap)\\n        \\n        ops = 0\\n        reduced = 0.0\\n\\n        while reduced < target:\\n            x = -heapq.heappop(heap)\\n            x /= 2.0\\n            reduced += x\\n            heapq.heappush(heap, -x)\\n            ops += 1\\n\\n        return ops\\n\"",
  "395_14631217_python-updated-time": "1745355555179",
  "3163_14631217_python-updated-time": "1747308429281",
  "591_14631217_python-updated-time": "1745448293949",
  "3604_14631217_python": "\"class Solution(object):\\n    def numberOfWays(self, n, x, y):\\n        mod = 10**9 + 7\\n        k_max = min(n, x)\\n        \\n        # dp[j] = # ways to assign i performers to exactly j non-empty stages\\n        dp = [0] * (k_max + 1)\\n        dp[0] = 1  # with 0 performers, exactly 0 stages used\\n        \\n        for _ in range(1, n + 1):\\n            # process one more performer:\\n            # new_dp[j] = j * old_dp[j]               (assign to one of the j used stages)\\n            #           + (x - (j-1)) * old_dp[j-1]  (assign to one of the (x-(j-1)) unused stages)\\n            for j in range(k_max, 0, -1):\\n                dp[j] = (j * dp[j] + (x - j + 1) * dp[j-1]) % mod\\n            dp[0] = 0  # you can't have 0 used stages once at least one performer arrived\\n        \\n        # now dp[j] = # assignments with exactly j non-empty stages\\n        # each such assignment can be scored in y^j ways\\n        ans = 0\\n        pow_y = 1\\n        for j in range(1, k_max + 1):\\n            pow_y = pow_y * y % mod\\n            ans = (ans + dp[j] * pow_y) % mod\\n        \\n        return ans\\n\"",
  "2079_14631217_python": "\"class Solution(object):\\n    def deleteDuplicateFolder(self, paths):\\n        # Build folder tree with a dummy root\\n        class Node(object):\\n            __slots__ = (\\\"children\\\", \\\"sig\\\")\\n            def __init__(self):\\n                self.children = {}\\n                self.sig = None\\n\\n        root = Node()\\n        for p in paths:\\n            cur = root\\n            for name in p:\\n                if name not in cur.children:\\n                    cur.children[name] = Node()\\n                cur = cur.children[name]\\n\\n        # Map subtree signature (tuple of (name, sig)) -> unique ID\\n        sig2id = {}\\n        next_id = [1]   # use list to mutate inside nested function\\n        from collections import Counter\\n        cnt = Counter()\\n\\n        # Post-order: compute signature ID for each node\\n        def dfs_sig(node):\\n            items = []\\n            for name, child in node.children.items():\\n                dfs_sig(child)\\n                items.append((name, child.sig))\\n            if not items:\\n                # leaf folder\\n                node.sig = 0\\n            else:\\n                items.sort()\\n                key = tuple(items)\\n                sid = sig2id.get(key)\\n                if sid is None:\\n                    sid = next_id[0]\\n                    sig2id[key] = sid\\n                    next_id[0] += 1\\n                node.sig = sid\\n                cnt[sid] += 1\\n\\n        dfs_sig(root)\\n\\n        res = []\\n        path = []\\n\\n        # Pre-order: collect paths of non-deleted folders\\n        def dfs_collect(node):\\n            # skip (delete) if non-root, non-leaf, and signature repeats\\n            if node is not root and node.sig != 0 and cnt[node.sig] > 1:\\n                return\\n            # record this folder (except dummy root)\\n            if node is not root:\\n                res.append(path[:])\\n            for name, child in node.children.items():\\n                path.append(name)\\n                dfs_collect(child)\\n                path.pop()\\n\\n        dfs_collect(root)\\n        return res\\n\"",
  "1344_14631217_python": "\"from collections import Counter, defaultdict\\n\\nclass Solution:\\n    def maxEqualFreq(self, nums):\\n        count = Counter()\\n        freq = defaultdict(int)\\n        res = 0\\n        maxFreq = 0\\n\\n        for i, num in enumerate(nums):\\n            prev = count[num]\\n            if prev > 0:\\n                freq[prev] -= 1\\n            count[num] += 1\\n            curr = count[num]\\n            freq[curr] += 1\\n            maxFreq = max(maxFreq, curr)\\n\\n            total = i + 1\\n\\n            if (\\n                maxFreq == 1 or\\n                freq[maxFreq] * maxFreq + freq[maxFreq - 1] * (maxFreq - 1) == total and freq[maxFreq] == 1 or\\n                freq[1] == 1 and freq[maxFreq] * maxFreq + 1 == total\\n            ):\\n                res = total\\n\\n        return res\\n\"",
  "2687_14631217_python-updated-time": "1747137017852",
  "3771_14631217_python": "\"class Solution(object):\\n    def maxSubstringLength(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        if k == 0:\\n            return True\\n\\n        # 1) Record first and last positions of every char\\n        first = {c: n for c in \\\"abcdefghijklmnopqrstuvwxyz\\\"}\\n        last  = {c:-1 for c in \\\"abcdefghijklmnopqrstuvwxyz\\\"}\\n        for i, ch in enumerate(s):\\n            first[ch] = min(first[ch], i)\\n            last[ch]  = max(last[ch], i)\\n\\n        # 2) Build the true minimal special substrings\\n        intervals = []\\n        for c in first:\\n            i = first[c]\\n            if i == n:\\n                # char c not present\\n                continue\\n\\n            # expand to cover all last[...] in [i..end]\\n            end = last[c]\\n            j = i\\n            while j <= end:\\n                end = max(end, last[s[j]])\\n                j += 1\\n\\n            # skip the entire string\\n            if i == 0 and end == n - 1:\\n                continue\\n\\n            # verify that no char inside has a first-occurrence before i\\n            valid = True\\n            for x in s[i:end+1]:\\n                if first[x] < i:\\n                    valid = False\\n                    break\\n            if valid:\\n                intervals.append((i, end))\\n\\n        # 3) Greedily pick as many non-overlapping as possible\\n        intervals.sort(key=lambda x: x[1])\\n        count = 0\\n        last_end = -1\\n        for start, finish in intervals:\\n            if start > last_end:\\n                count += 1\\n                last_end = finish\\n                if count >= k:\\n                    return True\\n\\n        return False\\n\"",
  "435_14631217_python-updated-time": "1745358791617",
  "52_14631217_python-updated-time": "1745014230404",
  "768_14631217_python": "\"class Solution(object):\\n    def partitionLabels(self, s):\\n        last = {c: i for i, c in enumerate(s)}\\n        res = []\\n        start = end = 0\\n        \\n        for i, c in enumerate(s):\\n            end = max(end, last[c])\\n            if i == end:\\n                res.append(end - start + 1)\\n                start = i + 1\\n                \\n        return res\\n\"",
  "2445_14631217_python-updated-time": "1746964811688",
  "976_14631217_python-updated-time": "1746004375208",
  "3066_14631217_pythondata-updated-time": "1747305646969",
  "826_14631217_python": "\"class Solution(object):\\n    def soupServings(self, n):\\n        if n >= 4800:\\n            return 1.0\\n        \\n        memo = {}\\n        \\n        def dfs(a, b):\\n            if (a, b) in memo:\\n                return memo[(a, b)]\\n            if a <= 0 and b <= 0:\\n                return 0.5\\n            if a <= 0:\\n                return 1\\n            if b <= 0:\\n                return 0\\n            memo[(a, b)] = 0.25 * (dfs(a-100, b) + dfs(a-75, b-25) + dfs(a-50, b-50) + dfs(a-25, b-75))\\n            return memo[(a, b)]\\n        \\n        return dfs(n, n)\\n\"",
  "1626_14631217_python-updated-time": "1746433149422",
  "1441_14631217_python-updated-time": "1746261222561",
  "2487_14631217_python-updated-time": "1746965946357",
  "1972_14631217_python": "\"class Solution:\\n    def rotateTheBox(self, box):\\n        m, n = len(box), len(box[0])\\n        # apply gravity to each row (stones fall to the right until obstacles)\\n        new_box = []\\n        for i in range(m):\\n            new_row = ['.'] * n\\n            write = n - 1\\n            for j in range(n - 1, -1, -1):\\n                if box[i][j] == '*':\\n                    new_row[j] = '*'\\n                    write = j - 1\\n                elif box[i][j] == '#':\\n                    new_row[write] = '#'\\n                    write -= 1\\n            new_box.append(new_row)\\n        # rotate 90 degrees clockwise\\n        res = [[None] * m for _ in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[j][m - 1 - i] = new_box[i][j]\\n        return res\\n\"",
  "191_14631217_python-updated-time": "1745092771719",
  "400_14631217_python-updated-time": "1745355791617",
  "1032_14631217_python-updated-time": "1746040553180",
  "3686_14631217_python": "\"class Solution(object):\\n    def beautifulSplits(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n < 3:\\n            return 0\\n\\n        # Build rolling hash (64-bit) so substring equality is O(1)\\n        B = 91138233\\n        mask = (1<<64) - 1\\n        H = [0]*(n+1)\\n        P = [1]*(n+1)\\n        for i in range(n):\\n            H[i+1] = ((H[i]*B) + (nums[i]+1)) & mask\\n            P[i+1] = (P[i]*B) & mask\\n        def get_hash(l, r):\\n            # hash of nums[l:r]\\n            return (H[r] - (H[l]*P[r-l] & mask)) & mask\\n\\n        ans = 0\\n        # i splits nums1=[0..i-1], nums2=[i..j-1], nums3=[j..n-1]\\n        for i in range(1, n-1):\\n            # Precompute whether nums1 is a prefix of nums2:\\n            # requires length of nums2 >= length(nums1) i.e. j-i >= i ⇒ j>=2*i\\n            h_pref1 = get_hash(0, i)\\n            h_pref2 = get_hash(i, 2*i) if 2*i <= n else None\\n            cond1_base = (2*i <= n and h_pref1 == h_pref2)\\n\\n            for j in range(i+1, n):\\n                L2 = j - i   # length of nums2\\n                # Condition A: nums1 is prefix of nums2\\n                ok = False\\n                if cond1_base and j >= 2*i:\\n                    ok = True\\n                else:\\n                    # Condition B: nums2 is prefix of nums3\\n                    # need nums3 length >= nums2 length ⇒ n-j >= L2 ⇒ j+L2<=n\\n                    if j + L2 <= n:\\n                        if get_hash(i, j) == get_hash(j, j+L2):\\n                            ok = True\\n\\n                if ok:\\n                    ans += 1\\n\\n        return ans\\n\"",
  "97_14631217_python": "\"class Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        \\\"\\\"\\\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [False] * (len(s2) + 1)\\n        dp[0] = True\\n        \\n        for j in range(1, len(s2) + 1):\\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\\n        \\n        for i in range(1, len(s1) + 1):\\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\\n            for j in range(1, len(s2) + 1):\\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\\n        \\n        return dp[-1]\\n\"",
  "1005_14631217_python": "\"class Solution:\\n    def isUnivalTree(self, root):\\n        def dfs(node, val):\\n            if not node:\\n                return True\\n            if node.val != val:\\n                return False\\n            return dfs(node.left, val) and dfs(node.right, val)\\n\\n        return dfs(root, root.val)\\n\"",
  "808_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def numMatchingSubseq(self, s, words):\\n        waiting = collections.defaultdict(list)\\n        for word in words:\\n            waiting[word[0]].append(iter(word[1:]))\\n        \\n        count = 0\\n        for c in s:\\n            advance = waiting.pop(c, [])\\n            for it in advance:\\n                nxt = next(it, None)\\n                if nxt:\\n                    waiting[nxt].append(it)\\n                else:\\n                    count += 1\\n        return count\\n\"",
  "2603_14631217_python-updated-time": "1747059280084",
  "2813_14631217_javascript": "\"function expect(val) {\\n  return {\\n    toBe: function (other) {\\n      if (val === other) return true;\\n      throw new Error(\\\"Not Equal\\\");\\n    },\\n    notToBe: function (other) {\\n      if (val !== other) return true;\\n      throw new Error(\\\"Equal\\\");\\n    }\\n  };\\n}\\n\"",
  "1413_14631217_python": "\"class Solution:\\n    def maxSideLength(self, mat, threshold):\\n        m, n = len(mat), len(mat[0])\\n        \\n        # Step 1: Compute prefix sum matrix\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i + 1][j + 1] = (prefix[i][j + 1] + prefix[i + 1][j] \\n                                        - prefix[i][j] + mat[i][j])\\n        \\n        # Helper to check if any k x k square has sum <= threshold\\n        def valid(k):\\n            for i in range(m - k + 1):\\n                for j in range(n - k + 1):\\n                    total = (prefix[i + k][j + k] - prefix[i][j + k] \\n                             - prefix[i + k][j] + prefix[i][j])\\n                    if total <= threshold:\\n                        return True\\n            return False\\n\\n        # Step 2: Binary search on side length\\n        left, right = 0, min(m, n)\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if valid(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return left\\n\"",
  "1653_14631217_python": "\"class Solution(object):\\n    def countPairs(self, root, distance):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type distance: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        self.count = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return []\\n\\n            if not node.left and not node.right:\\n                return [1]  # Leaf node: distance 1 from itself\\n\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n\\n            # Count good leaf pairs between left and right\\n            for l in left:\\n                for r in right:\\n                    if l + r <= distance:\\n                        self.count += 1\\n\\n            # Return updated distances to parent (incremented by 1)\\n            return [x + 1 for x in left + right if x + 1 <= distance]\\n\\n        dfs(root)\\n        return self.count\\n\"",
  "1288_14631217_python-updated-time": "1746126577764",
  "1542_14631217_python": "\"class Solution(object):\\n    def maxPower(self, s):\\n        max_len = cur_len = 1\\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                cur_len += 1\\n            else:\\n                cur_len = 1\\n            if cur_len > max_len:\\n                max_len = cur_len\\n        return max_len\\n\"",
  "1859_14631217_python": "\"class Solution:\\n    def minCharacters(self, a, b):\\n        # Count frequencies\\n        freqA = [0] * 26\\n        freqB = [0] * 26\\n        for ch in a:\\n            freqA[ord(ch) - 97] += 1\\n        for ch in b:\\n            freqB[ord(ch) - 97] += 1\\n\\n        lenA, lenB = len(a), len(b)\\n\\n        # Build prefix sums: prefixA[i] = count of letters <= i in a\\n        prefixA = [0] * 26\\n        prefixB = [0] * 26\\n        prefixA[0] = freqA[0]\\n        prefixB[0] = freqB[0]\\n        for i in range(1, 26):\\n            prefixA[i] = prefixA[i-1] + freqA[i]\\n            prefixB[i] = prefixB[i-1] + freqB[i]\\n\\n        # Condition 1 & 2: pick boundary c from 1..25\\n        best = float('inf')\\n        for c in range(1, 26):\\n            # cond1: all a < all b by boundary c\\n            #   change a's letters >= c, change b's letters < c\\n            cost1 = (lenA - prefixA[c-1]) + prefixB[c-1]\\n            # cond2: all b < all a by boundary c\\n            cost2 = (lenB - prefixB[c-1]) + prefixA[c-1]\\n            best = min(best, cost1, cost2)\\n\\n        # Condition 3: make both strings all one same letter\\n        for ch in range(26):\\n            # change everything in a and b not equal to ch\\n            cost3 = (lenA - freqA[ch]) + (lenB - freqB[ch])\\n            best = min(best, cost3)\\n\\n        return best\\n\"",
  "740_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def deleteAndEarn(self, nums):\\n        freq = Counter(nums)\\n        maxv = max(nums)\\n        points = [0] * (maxv + 1)\\n        for v, c in freq.items():\\n            points[v] = v * c\\n\\n        prev2, prev1 = 0, points[0]\\n        for i in range(1, maxv + 1):\\n            curr = max(prev1, prev2 + points[i])\\n            prev2, prev1 = prev1, curr\\n        return prev1\\n\"",
  "1212_14631217_python": "\"class Solution:\\n    def sequentialDigits(self, low, high):\\n        result = []\\n        digits = \\\"123456789\\\"\\n\\n        for length in range(2, 10):  # Length of sequential number from 2 to 9\\n            for start in range(0, 10 - length):\\n                num = int(digits[start:start + length])\\n                if low <= num <= high:\\n                    result.append(num)\\n\\n        return result\\n\"",
  "2524_14631217_python-updated-time": "1746968016191",
  "1996_14631217_python": "\"class Solution:\\n    def rearrangeSticks(self, n, k):\\n        mod = 10**9 + 7\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 1\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k + 1):\\n                # Place the tallest stick at front: dp[i - 1][j - 1]\\n                # Place the tallest stick somewhere else: (i - 1) * dp[i - 1][j]\\n                dp[i][j] = (dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]) % mod\\n\\n        return dp[n][k]\\n\"",
  "257_14631217_python-updated-time": "1745247773160",
  "76_14631217_python-updated-time": "1745015184858",
  "1912_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def countRestrictedPaths(self, n, edges):\\n        MOD = 10**9 + 7\\n\\n        # Build graph\\n        graph = defaultdict(list)\\n        for u, v, w in edges:\\n            graph[u].append((v, w))\\n            graph[v].append((u, w))\\n\\n        # Dijkstra from node n\\n        dist = [float('inf')] * (n + 1)\\n        dist[n] = 0\\n        heap = [(0, n)]\\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if d > dist[u]:\\n                continue\\n            for v, w in graph[u]:\\n                if dist[v] > d + w:\\n                    dist[v] = d + w\\n                    heapq.heappush(heap, (dist[v], v))\\n\\n        # DFS + memoization to count restricted paths\\n        memo = [None] * (n + 1)\\n        def dfs(u):\\n            if u == n:\\n                return 1\\n            if memo[u] is not None:\\n                return memo[u]\\n            res = 0\\n            for v, _ in graph[u]:\\n                if dist[u] > dist[v]:\\n                    res = (res + dfs(v)) % MOD\\n            memo[u] = res\\n            return res\\n\\n        return dfs(1)\\n\"",
  "2023_14631217_python-updated-time": "1746637266192",
  "2416_14631217_python": "\"class Solution:\\n    def evaluateTree(self, root):\\n        # If it's a leaf, return its boolean value\\n        if not root.left and not root.right:\\n            return bool(root.val)\\n        \\n        # Evaluate children\\n        left_val = self.evaluateTree(root.left)\\n        right_val = self.evaluateTree(root.right)\\n        \\n        # 2 = OR, 3 = AND\\n        if root.val == 2:\\n            return left_val or right_val\\n        else:\\n            return left_val and right_val\\n\"",
  "3593_14631217_python-updated-time": "1747585645870",
  "3683_14631217_python": "\"class Solution(object):\\n    def answerString(self, word, numFriends):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type numFriends: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # If there's only one friend, they get the whole word\\n        if numFriends == 1:\\n            return word\\n        \\n        n = len(word)\\n        # Maximum length any one piece can have\\n        max_len = n - numFriends + 1\\n        \\n        # Find the global largest character\\n        max_char = max(word)\\n        \\n        best = \\\"\\\"\\n        for i, ch in enumerate(word):\\n            if ch == max_char:\\n                # take the longest substring starting here\\n                candidate = word[i:i + max_len]\\n                if candidate > best:\\n                    best = candidate\\n        return best\\n\"",
  "1877_14631217_mysql": "\"SELECT\\n  user_id,\\n  COUNT(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n\"",
  "2775_14631217_javascript-updated-time": "1747136195523",
  "198_14631217_python": "\"class Solution(object):\\n    def rob(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        \\n        return dp[-1]\\n\"",
  "648_14631217_python": "\"class Solution(object):\\n    def replaceWords(self, dictionary, sentence):\\n        root_set = set(dictionary)\\n        words = sentence.split()\\n        res = []\\n        \\n        for word in words:\\n            prefix = ''\\n            for i in range(1, len(word)+1):\\n                if word[:i] in root_set:\\n                    prefix = word[:i]\\n                    break\\n            res.append(prefix if prefix else word)\\n        \\n        return ' '.join(res)\\n\"",
  "626_14631217_mysql-updated-time": "1745780816784",
  "2801_14631217_python": "\"class Solution:\\n    def differenceOfDistinctValues(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        ans = [[0]*n for _ in range(m)]\\n\\n        for r in range(m):\\n            for c in range(n):\\n                # Scan upper-left diagonal\\n                i, j = r - 1, c - 1\\n                left_set = set()\\n                while i >= 0 and j >= 0:\\n                    left_set.add(grid[i][j])\\n                    i -= 1\\n                    j -= 1\\n\\n                # Scan bottom-right diagonal\\n                i, j = r + 1, c + 1\\n                right_set = set()\\n                while i < m and j < n:\\n                    right_set.add(grid[i][j])\\n                    i += 1\\n                    j += 1\\n\\n                ans[r][c] = abs(len(left_set) - len(right_set))\\n\\n        return ans\\n\"",
  "1304_14631217_python-updated-time": "1746346524460",
  "1559_14631217_python-updated-time": "1746348146423",
  "287_14631217_python-updated-time": "1745254827158",
  "1657_14631217_python-updated-time": "1746434091157",
  "2551_14631217_python-updated-time": "1746968832490",
  "3245_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def beautifulIndices(self, s, a, b, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type a: str\\n        :type b: str\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        la, lb = len(a), len(b)\\n\\n        # 1) Gather all start‐indices of substrings == a and == b\\n        startsA = []\\n        for i in range(n - la + 1):\\n            if s[i:i+la] == a:\\n                startsA.append(i)\\n        \\n        startsB = []\\n        for j in range(n - lb + 1):\\n            if s[j:j+lb] == b:\\n                startsB.append(j)\\n        \\n        # 2) Sort B‐starts so we can binary‐search\\n        startsB.sort()\\n\\n        res = []\\n        # 3) For each i in A, check if there is some j in B with |j-i| <= k\\n        for i in startsA:\\n            # find the first j >= i-k\\n            lo = bisect.bisect_left(startsB, i - k)\\n            # check if that j is <= i + k\\n            if lo < len(startsB) and startsB[lo] <= i + k:\\n                res.append(i)\\n\\n        return res\\n\"",
  "3793_14631217_python": "\"class Solution(object):\\n    def longestPalindrome(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n, m = len(s), len(t)\\n        best = 1  # at least one character\\n        \\n        # Enumerate all substrings s[i:j] and t[u:v]\\n        # i in [0..n], j in [i..n]; u in [0..m], v in [u..m]\\n        for i in range(n + 1):\\n            for j in range(i, n + 1):\\n                len_s = j - i\\n                for u in range(m + 1):\\n                    for v in range(u, m + 1):\\n                        L = len_s + (v - u)\\n                        # Skip shorter concatenations\\n                        if L <= best:\\n                            continue\\n                        # Check palindrome on the fly\\n                        left, right = 0, L - 1\\n                        ok = True\\n                        while left < right:\\n                            # get char at left\\n                            if left < len_s:\\n                                cl = s[i + left]\\n                            else:\\n                                cl = t[u + (left - len_s)]\\n                            # get char at right\\n                            if right < len_s:\\n                                cr = s[i + right]\\n                            else:\\n                                cr = t[u + (right - len_s)]\\n                            if cl != cr:\\n                                ok = False\\n                                break\\n                            left += 1\\n                            right -= 1\\n                        if ok:\\n                            best = L\\n        return best\\n\"",
  "2798_14631217_javascript-updated-time": "1747137806004",
  "860_14631217_python-updated-time": "1745780695913",
  "1635_14631217_python": "\"class Solution(object):\\n    def numIdenticalPairs(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import Counter\\n\\n        count = Counter(nums)\\n        result = 0\\n\\n        for freq in count.values():\\n            result += freq * (freq - 1) // 2\\n\\n        return result\\n\"",
  "1045_14631217_python": "\"class Solution:\\n    def isValid(self, s):\\n        stack = []\\n        for char in s:\\n            stack.append(char)\\n            if len(stack) >= 3 and stack[-3:] == ['a', 'b', 'c']:\\n                stack.pop()\\n                stack.pop()\\n                stack.pop()\\n        return not stack\\n\"",
  "2178_14631217_python-updated-time": "1746721756315",
  "48_14631217_python": "\"class Solution(object):\\n    def rotate(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \\\"\\\"\\\"\\n        n = len(matrix)\\n\\n        # Transpose the matrix\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\n        # Reverse each row\\n        for row in matrix:\\n            row.reverse()\\n\"",
  "85_14631217_python-updated-time": "1745015446860",
  "2135_14631217_python": "\"class Solution(object):\\n    def waysToPartition(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        n = len(nums)\\n        prefix = [0] * n\\n        prefix[0] = nums[0]\\n        for i in range(1, n):\\n            prefix[i] = prefix[i-1] + nums[i]\\n        total = prefix[-1]\\n\\n        # Base case: count valid partitions with no changes\\n        count = 0\\n        for i in range(n-1):\\n            if prefix[i] * 2 == total:\\n                count += 1\\n\\n        # Use maps to store prefix differences\\n        left = defaultdict(int)\\n        right = defaultdict(int)\\n        for i in range(n-1):\\n            diff = prefix[i] * 2 - total\\n            right[diff] += 1\\n\\n        max_ways = count\\n        for i in range(n):\\n            delta = k - nums[i]\\n            # simulating changing nums[i] to k:\\n            # if we change nums[i] by delta, then total sum changes by delta\\n            new_ways = 0\\n            if i > 0:\\n                new_ways += left[delta]\\n            if i < n - 1:\\n                new_ways += right[-delta]\\n            max_ways = max(max_ways, new_ways)\\n\\n            if i < n - 1:\\n                d = prefix[i] * 2 - total\\n                right[d] -= 1\\n                left[d] += 1\\n\\n        return max_ways\\n\"",
  "2868_14631217_python-updated-time": "1747221979318",
  "1402_14631217_python-updated-time": "1746260102285",
  "1751_14631217_python-updated-time": "1746444758869",
  "1513_14631217_python": "\"class Solution(object):\\n    def findGoodStrings(self, n, s1, s2, evil):\\n        MOD = 10**9 + 7\\n        ALPHABET = [chr(i) for i in range(ord('a'), ord('z') + 1)]\\n\\n        # Build KMP failure function for evil\\n        def build_kmp(pattern):\\n            fail = [0] * len(pattern)\\n            for i in range(1, len(pattern)):\\n                j = fail[i - 1]\\n                while j > 0 and pattern[i] != pattern[j]:\\n                    j = fail[j - 1]\\n                if pattern[i] == pattern[j]:\\n                    j += 1\\n                fail[i] = j\\n            return fail\\n\\n        kmp = build_kmp(evil)\\n        memo = {}\\n\\n        def dp(pos, matched, is_prefix_s1, is_prefix_s2):\\n            key = (pos, matched, is_prefix_s1, is_prefix_s2)\\n            if key in memo:\\n                return memo[key]\\n            if matched == len(evil):\\n                return 0\\n            if pos == n:\\n                return 1\\n\\n            res = 0\\n            start = s1[pos] if is_prefix_s1 else 'a'\\n            end = s2[pos] if is_prefix_s2 else 'z'\\n\\n            for c in ALPHABET:\\n                if start <= c <= end:\\n                    new_matched = matched\\n                    while new_matched > 0 and c != evil[new_matched]:\\n                        new_matched = kmp[new_matched - 1]\\n                    if c == evil[new_matched]:\\n                        new_matched += 1\\n\\n                    res += dp(\\n                        pos + 1,\\n                        new_matched,\\n                        is_prefix_s1 and c == s1[pos],\\n                        is_prefix_s2 and c == s2[pos]\\n                    )\\n                    res %= MOD\\n\\n            memo[key] = res\\n            return res\\n\\n        return dp(0, 0, True, True)\\n\"",
  "1899_14631217_python": "\"class Solution(object):\\n    def countMatches(self, items, ruleKey, ruleValue):\\n        \\\"\\\"\\\"\\n        :type items: List[List[str]]\\n        :type ruleKey: str\\n        :type ruleValue: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        key_index = {\\\"type\\\": 0, \\\"color\\\": 1, \\\"name\\\": 2}\\n        idx = key_index[ruleKey]\\n\\n        return sum(1 for item in items if item[idx] == ruleValue)\\n\"",
  "1581_14631217_python-updated-time": "1746432398353",
  "3438_14631217_python-updated-time": "1747485347218",
  "1836_14631217_python": "\"class Solution:\\n    def waysToFillArray(self, queries):\\n        mod = 10**9 + 7\\n        max_n = max(n for n, k in queries)\\n        max_k = max(k for n, k in queries)\\n        MAX = max_n + 14\\n\\n        # factorials and inverse factorials\\n        f = [1] * (MAX + 1)\\n        for i in range(1, MAX + 1):\\n            f[i] = f[i-1] * i % mod\\n        invf = [1] * (MAX + 1)\\n        invf[MAX] = pow(f[MAX], mod-2, mod)\\n        for i in range(MAX, 0, -1):\\n            invf[i-1] = invf[i] * i % mod\\n\\n        # smallest prime factor sieve\\n        N = max_k\\n        spf = list(range(N+1))\\n        for i in range(2, int(N**0.5) + 1):\\n            if spf[i] == i:\\n                for j in range(i*i, N+1, i):\\n                    if spf[j] == j:\\n                        spf[j] = i\\n\\n        def factor(k):\\n            d = {}\\n            while k > 1:\\n                p = spf[k]\\n                cnt = 0\\n                while k % p == 0:\\n                    k //= p\\n                    cnt += 1\\n                d[p] = cnt\\n            return d\\n\\n        ans = []\\n        for n, k in queries:\\n            ways = 1\\n            for e in factor(k).values():\\n                ways = ways * (f[n+e-1] * invf[e] % mod * invf[n-1] % mod) % mod\\n            ans.append(ways)\\n        return ans\\n\"",
  "3655_14631217_python-updated-time": "1747596239409",
  "2779_14631217_python": "\"class Solution(object):\\n    def colorTheArray(self, n, queries):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        colors = [0] * n\\n        same_adj = 0\\n        ans = []\\n\\n        for idx, col in queries:\\n            old = colors[idx]\\n            # remove old adjacency contributions\\n            if old != 0:\\n                if idx > 0 and colors[idx - 1] == old:\\n                    same_adj -= 1\\n                if idx < n - 1 and colors[idx + 1] == old:\\n                    same_adj -= 1\\n\\n            # assign new color\\n            colors[idx] = col\\n\\n            # add new adjacency contributions\\n            if col != 0:\\n                if idx > 0 and colors[idx - 1] == col:\\n                    same_adj += 1\\n                if idx < n - 1 and colors[idx + 1] == col:\\n                    same_adj += 1\\n\\n            ans.append(same_adj)\\n\\n        return ans\\n\\n# Example usage:\\n# sol = Solution()\\n# print(sol.colorTheArray(4, [[0,2],[1,2],[3,1],[1,1],[2,1]]))  # [0,1,1,0,2]\\n# print(sol.colorTheArray(1, [[0,100000]]))                   # [0]\\n\"",
  "2483_14631217_python": "\"class Solution(object):\\n    def taskSchedulerII(self, tasks, space):\\n        last_day = {}\\n        day = 0\\n\\n        for t in tasks:\\n            if t in last_day and day - last_day[t] <= space:\\n                day = last_day[t] + space + 1\\n            else:\\n                day += 1\\n            last_day[t] = day\\n\\n        return day\\n\"",
  "501_14631217_python": "\"class Solution:\\n    def findMode(self, root):\\n        self.prev = None\\n        self.count = 0\\n        self.max_count = 0\\n        self.modes = []\\n\\n        def inorder(node):\\n            if not node:\\n                return\\n            inorder(node.left)\\n            if self.prev is None or self.prev != node.val:\\n                self.count = 1\\n            else:\\n                self.count += 1\\n            if self.count > self.max_count:\\n                self.max_count = self.count\\n                self.modes = [node.val]\\n            elif self.count == self.max_count:\\n                self.modes.append(node.val)\\n            self.prev = node.val\\n            inorder(node.right)\\n\\n        inorder(root)\\n        return self.modes\\n\"",
  "3026_14631217_python-updated-time": "1747226340990",
  "3765_14631217_python-updated-time": "1747742138900",
  "1833_14631217_python": "\"class Solution:\\n    def largestAltitude(self, gain):\\n        altitude = 0\\n        max_altitude = 0\\n        for g in gain:\\n            altitude += g\\n            if altitude > max_altitude:\\n                max_altitude = altitude\\n        return max_altitude\\n\"",
  "2625_14631217_python-updated-time": "1747060926424",
  "2630_14631217_python": "\"class Solution:\\n    def alternateDigitSum(self, n):\\n        s = str(n)\\n        total = 0\\n        for i, ch in enumerate(s):\\n            digit = int(ch)\\n            if i % 2 == 0:\\n                total += digit\\n            else:\\n                total -= digit\\n        return total\\n\"",
  "1427_14631217_python": "\"class Solution:\\n    def getAllElements(self, root1, root2):\\n        def inorder(root):\\n            if not root:\\n                return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        list1 = inorder(root1)\\n        list2 = inorder(root2)\\n        \\n        # Merge the two sorted lists\\n        merged = []\\n        i = j = 0\\n        while i < len(list1) and j < len(list2):\\n            if list1[i] < list2[j]:\\n                merged.append(list1[i])\\n                i += 1\\n            else:\\n                merged.append(list2[j])\\n                j += 1\\n        merged.extend(list1[i:])\\n        merged.extend(list2[j:])\\n        return merged\\n\"",
  "2288_14631217_python-updated-time": "1746803219710",
  "2624_14631217_python-updated-time": "1747060861187",
  "2472_14631217_python-updated-time": "1746965497095",
  "2526_14631217_python-updated-time": "1746966045915",
  "3542_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maximumValueSum(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(board), len(board[0])\\n        N      = m + n + 2          # total vertices\\n        SRC    = m + n               # super-source index\\n        SINK   = m + n + 1           # super-sink   index\\n        INF    = 10 ** 18\\n\\n        # adjacency lists: [to, cap, cost, rev_index]\\n        g = [[] for _ in xrange(N)]\\n\\n        def add(u, v, cap, cost):\\n            g[u].append([v, cap, cost, len(g[v])])\\n            g[v].append([u, 0,  -cost, len(g[u]) - 1])\\n\\n        # source → rows\\n        for i in xrange(m):\\n            add(SRC, i, 1, 0)\\n        # columns → sink\\n        for j in xrange(n):\\n            add(m + j, SINK, 1, 0)\\n        # row → column edges (negative cost = −value)\\n        for i in xrange(m):\\n            row = board[i]\\n            ri  = i\\n            for j in xrange(n):\\n                add(ri, m + j, 1, -row[j])\\n\\n        h      = [0] * N               # Johnson potentials\\n        dist   = [0] * N\\n        prev_v = [0] * N\\n        prev_e = [0] * N\\n        flow   = 0\\n        cost   = 0\\n\\n        while flow < 3:                 # we only need three augmentations\\n            for v in xrange(N):\\n                dist[v] = INF\\n            dist[SRC] = 0\\n            pq = [(0, SRC)]\\n\\n            # Dijkstra with reduced costs\\n            while pq:\\n                d, v = heapq.heappop(pq)\\n                if d != dist[v]:\\n                    continue\\n                for idx, e in enumerate(g[v]):\\n                    to, cap, c, _ = e\\n                    if cap and dist[to] > d + c + h[v] - h[to]:\\n                        dist[to]  = d + c + h[v] - h[to]\\n                        prev_v[to] = v\\n                        prev_e[to] = idx\\n                        heapq.heappush(pq, (dist[to], to))\\n\\n            if dist[SINK] == INF:           # should never happen (board ≥ 3×3)\\n                break\\n\\n            for v in xrange(N):             # update potentials\\n                if dist[v] < INF:\\n                    h[v] += dist[v]\\n\\n            add_flow = 3 - flow             # remaining units to push (≤ 1)\\n            v = SINK\\n            while v != SRC:\\n                u  = prev_v[v]\\n                e  = g[u][prev_e[v]]\\n                if add_flow > e[1]:\\n                    add_flow = e[1]\\n                v = u\\n\\n            flow += add_flow\\n            cost += add_flow * h[SINK]\\n\\n            # augment along the path\\n            v = SINK\\n            while v != SRC:\\n                u   = prev_v[v]\\n                e   = g[u][prev_e[v]]\\n                e[1]           -= add_flow\\n                g[v][e[3]][1]  += add_flow\\n                v = u\\n\\n        return -cost                   # negate to obtain the maximum sum\\n\"",
  "3420_14631217_python-updated-time": "1747483102838",
  "1078_14631217_python": "\"class Solution:\\n    def removeOuterParentheses(self, s):\\n        res = []\\n        balance = 0\\n        for ch in s:\\n            if ch == '(':\\n                if balance > 0:\\n                    res.append(ch)\\n                balance += 1\\n            else:  # ch == ')'\\n                balance -= 1\\n                if balance > 0:\\n                    res.append(ch)\\n        return ''.join(res)\\n\"",
  "2234_14631217_python-updated-time": "1746800129336",
  "1327_14631217_mysql-updated-time": "1746127485548",
  "757_14631217_python": "\"class Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        from collections import defaultdict\\n        graph = defaultdict(list)\\n        for a, b, c in allowed:\\n            graph[(a, b)].append(c)\\n        \\n        def dfs(row):\\n            if len(row) == 1:\\n                return True\\n            next_rows = []\\n            for i in range(len(row) - 1):\\n                pair = (row[i], row[i+1])\\n                if pair not in graph:\\n                    return False\\n                next_rows.append(graph[pair])\\n            \\n            def backtrack(path, idx):\\n                if idx == len(next_rows):\\n                    return dfs(path)\\n                for ch in next_rows[idx]:\\n                    if backtrack(path + ch, idx + 1):\\n                        return True\\n                return False\\n            \\n            return backtrack('', 0)\\n        \\n        return dfs(bottom)\\n\"",
  "3164_14631217_python": "\"class Solution(object):\\n    def lastVisitedIntegers(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        seen = []\\n        ans = []\\n        consec = 0\\n        for x in nums:\\n            if x == -1:\\n                consec += 1\\n                if consec <= len(seen):\\n                    ans.append(seen[consec - 1])\\n                else:\\n                    ans.append(-1)\\n            else:\\n                # prepend positive integer\\n                seen.insert(0, x)\\n                consec = 0\\n        return ans\\n\"",
  "1400_14631217_python": "\"class Solution:\\n    def tictactoe(self, moves):\\n        rows = [0] * 3\\n        cols = [0] * 3\\n        diag = anti_diag = 0\\n\\n        for i, (r, c) in enumerate(moves):\\n            player = 1 if i % 2 == 0 else -1  # A = 1, B = -1\\n            rows[r] += player\\n            cols[c] += player\\n            if r == c:\\n                diag += player\\n            if r + c == 2:\\n                anti_diag += player\\n\\n            if 3 in (rows[r], cols[c], diag, anti_diag):\\n                return \\\"A\\\"\\n            if -3 in (rows[r], cols[c], diag, anti_diag):\\n                return \\\"B\\\"\\n\\n        return \\\"Draw\\\" if len(moves) == 9 else \\\"Pending\\\"\\n\"",
  "219_14631217_python-updated-time": "1745246440764",
  "2536_14631217_python-updated-time": "1746968147835",
  "1799_14631217_python-updated-time": "1746452847968",
  "216_14631217_python": "\"class Solution(object):\\n    def combinationSum3(self, k, n):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type n: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(start, path, target):\\n            if len(path) == k and target == 0:\\n                res.append(list(path))\\n                return\\n            if len(path) > k or target < 0:\\n                return\\n            for i in range(start, 10):\\n                path.append(i)\\n                backtrack(i + 1, path, target - i)\\n                path.pop()\\n\\n        backtrack(1, [], n)\\n        return res\\n\"",
  "3526_14631217_python": "\"class Solution(object):\\n    def minFlips(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Cost to fix rows\\n        cost_rows = 0\\n        for i in range(m):\\n            for j in range(n // 2):\\n                if grid[i][j] != grid[i][n - 1 - j]:\\n                    cost_rows += 1\\n        \\n        # Cost to fix columns\\n        cost_cols = 0\\n        for j in range(n):\\n            for i in range(m // 2):\\n                if grid[i][j] != grid[m - 1 - i][j]:\\n                    cost_cols += 1\\n        \\n        return min(cost_rows, cost_cols)\\n\"",
  "961_14631217_python-updated-time": "1746003776280",
  "2904_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # dp1 = length of longest non-decreasing subsequence seen so far ending with 1\\n        # dp2 = length of longest non-decreasing subsequence seen so far ending with 2\\n        # dp3 = length of longest non-decreasing subsequence seen so far ending with 3\\n        dp1 = dp2 = dp3 = 0\\n\\n        for x in nums:\\n            if x == 1:\\n                # we can always append a 1 to a subsequence of 1s\\n                dp1 += 1\\n            elif x == 2:\\n                # to append a 2, we need a subsequence ending in 1 or 2\\n                dp2 = max(dp1, dp2) + 1\\n            else:  # x == 3\\n                # to append a 3, we need a subsequence ending in 1, 2, or 3\\n                dp3 = max(dp1, dp2, dp3) + 1\\n\\n        # the longest non-decreasing subsequence has length max(dp1, dp2, dp3)\\n        longest = max(dp1, dp2, dp3)\\n        # we remove all other elements\\n        return len(nums) - longest\\n\"",
  "1013_14631217_python": "\"class Solution:\\n    def fib(self, n):\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        a, b = 0, 1\\n        for _ in range(2, n + 1):\\n            a, b = b, a + b\\n        return b\\n\"",
  "2914_14631217_python": "\"from collections import deque\\nimport heapq\\n\\nclass Solution(object):\\n    def maximumSafenessFactor(self, grid):\\n        n = len(grid)\\n        dirs = [(0,1),(0,-1),(1,0),(-1,0)]\\n\\n        # Step 1: multi-source BFS to compute distance to nearest thief\\n        dist = [[-1]*n for _ in range(n)]\\n        q = deque()\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    dist[i][j] = 0\\n                    q.append((i,j))\\n\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in dirs:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < n and 0 <= ny < n and dist[nx][ny] == -1:\\n                    dist[nx][ny] = dist[x][y] + 1\\n                    q.append((nx, ny))\\n\\n        # Step 2: max-heap Dijkstra to find path with max min-distance (safeness factor)\\n        heap = [(-dist[0][0], 0, 0)]\\n        visited = [[False]*n for _ in range(n)]\\n\\n        while heap:\\n            d, x, y = heapq.heappop(heap)\\n            d = -d\\n            if x == n-1 and y == n-1:\\n                return d\\n            if visited[x][y]:\\n                continue\\n            visited[x][y] = True\\n            for dx, dy in dirs:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:\\n                    heapq.heappush(heap, (-min(d, dist[nx][ny]), nx, ny))\\n\"",
  "402_14631217_python": "\"class Solution:\\n    def removeKdigits(self, num, k):\\n        stack = []\\n        \\n        for digit in num:\\n            while k > 0 and stack and stack[-1] > digit:\\n                stack.pop()\\n                k -= 1\\n            stack.append(digit)\\n        \\n        while k > 0:\\n            stack.pop()\\n            k -= 1\\n        \\n        result = ''.join(stack).lstrip('0')\\n        return result if result else \\\"0\\\"\\n\"",
  "1355_14631217_python-updated-time": "1746810955788",
  "295_14631217_python": "\"import heapq\\n\\nclass MedianFinder(object):\\n\\n    def __init__(self):\\n        self.small = []  # Max heap (invert values)\\n        self.large = []  # Min heap\\n\\n    def addNum(self, num):\\n        heapq.heappush(self.small, -num)\\n        heapq.heappush(self.large, -heapq.heappop(self.small))\\n        if len(self.large) > len(self.small):\\n            heapq.heappush(self.small, -heapq.heappop(self.large))\\n\\n    def findMedian(self):\\n        if len(self.small) > len(self.large):\\n            return -self.small[0]\\n        return (-self.small[0] + self.large[0]) / 2.0\\n\"",
  "955_14631217_python-updated-time": "1746003582292",
  "3227_14631217_python": "\"class Solution(object):\\n    def findMissingAndRepeatedValues(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        count = [0] * (n * n + 1)\\n        \\n        # Count frequency of each number in the grid\\n        for row in grid:\\n            for val in row:\\n                count[val] += 1\\n        \\n        repeated = missing = -1\\n        for i in range(1, n * n + 1):\\n            if count[i] == 2:\\n                repeated = i\\n            elif count[i] == 0:\\n                missing = i\\n        \\n        return [repeated, missing]\\n\"",
  "1930_14631217_python-updated-time": "1746542864959",
  "2086_14631217_python": "\"class Solution(object):\\n    def countSpecialSubsequences(self, nums):\\n        MOD = 10**9 + 7\\n        dp0 = dp1 = dp2 = 0\\n        for x in nums:\\n            if x == 0:\\n                dp0 = (dp0 * 2 + 1) % MOD\\n            elif x == 1:\\n                dp1 = (dp1 * 2 + dp0) % MOD\\n            else:  # x == 2\\n                dp2 = (dp2 * 2 + dp1) % MOD\\n        return dp2\\n\"",
  "800_14631217_python-updated-time": "1745877466559",
  "879_14631217_python": "\"class Solution:\\n    def maxDistToClosest(self, seats):\\n        n = len(seats)\\n        max_dist = 0\\n        last_person = -1\\n        \\n        for i in range(n):\\n            if seats[i] == 1:\\n                if last_person == -1:\\n                    max_dist = i  # distance from start\\n                else:\\n                    max_dist = max(max_dist, (i - last_person) // 2)\\n                last_person = i\\n        \\n        # distance from last person to the end\\n        max_dist = max(max_dist, n - 1 - last_person)\\n        \\n        return max_dist\\n\"",
  "107_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        if not root:\\n            return []\\n        \\n        from collections import deque\\n        queue = deque([root])\\n        result = []\\n        \\n        while queue:\\n            level = []\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            result.append(level)\\n        \\n        return result[::-1]\\n\"",
  "192_14631217_bash": "\"# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s ' ' '\\\\n' | sort | uniq -c | sort -nr | awk '{print $2, $1}'\\n\"",
  "2050_14631217_python-updated-time": "1746637565915",
  "2574_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def countSubarrays(self, nums, k):\\n        pos = nums.index(k)\\n        count = Counter()\\n        s = 0\\n        count[0] = 1\\n        # count prefix sums on the left of k\\n        for i in range(pos - 1, -1, -1):\\n            s += 1 if nums[i] > k else -1\\n            count[s] += 1\\n        # scan to the right including k\\n        ans = 0\\n        r = 0\\n        for j in range(pos, len(nums)):\\n            if nums[j] > k:\\n                r += 1\\n            elif nums[j] < k:\\n                r -= 1\\n            ans += count[-r] + count[1 - r]\\n        return ans\\n\"",
  "3762_14631217_python-updated-time": "1747820319387",
  "2129_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def interchangeableRectangles(self, rectangles):\\n        def compute_gcd(a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n\\n        ratio_count = Counter()\\n\\n        for w, h in rectangles:\\n            g = compute_gcd(w, h)\\n            ratio = (w // g, h // g)\\n            ratio_count[ratio] += 1\\n\\n        total = 0\\n        for count in ratio_count.values():\\n            if count > 1:\\n                total += count * (count - 1) // 2\\n\\n        return total\\n\"",
  "144_14631217_python-updated-time": "1745087134550",
  "2439_14631217_python": "\"class Solution(object):\\n    def longestCycle(self, edges):\\n        n = len(edges)\\n        visited = [False] * n\\n        result = -1\\n\\n        for i in range(n):\\n            if visited[i]:\\n                continue\\n\\n            node = i\\n            index_map = {}\\n            step = 0\\n\\n            while node != -1 and node not in index_map:\\n                if visited[node]:\\n                    break\\n                index_map[node] = step\\n                step += 1\\n                node = edges[node]\\n\\n            if node != -1 and node in index_map:\\n                result = max(result, step - index_map[node])\\n\\n            for key in index_map:\\n                visited[key] = True\\n\\n        return result\\n\"",
  "3859_14631217_python-updated-time": "1747681844763",
  "523_14631217_python-updated-time": "1745446587926",
  "1664_14631217_mysql": "\"# Write your MySQL query statement below\\nSELECT user_id, name, mail\\nFROM Users\\nWHERE \\n    -- Must match the domain exactly\\n    mail LIKE '%@leetcode.com' \\n    -- Must start with a letter and allowed characters before the @\\n    AND mail REGEXP '^[a-zA-Z][a-zA-Z0-9._-]*@leetcode\\\\.com$';\\n\"",
  "2860_14631217_javascript-updated-time": "1747140933185",
  "1761_14631217_python-updated-time": "1746445052164",
  "3483_14631217_python": "\"class Solution(object):\\n    def numberOfAlternatingGroups(self, colors, k):\\n        \\\"\\\"\\\"\\n        :type colors: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(colors)\\n        # build diff array: 1 if adjacent differ, else 0\\n        diff = [0]*n\\n        for i in xrange(n):\\n            if colors[i] != colors[(i+1) % n]:\\n                diff[i] = 1\\n        \\n        # we need k-1 consecutive ones in diff, circularly.\\n        L = k - 1\\n        # extend diff by first L-1 elements to handle wrap\\n        ext = diff + diff[:L-1]\\n        \\n        # prefix sums\\n        ps = [0] * (len(ext)+1)\\n        for i in xrange(len(ext)):\\n            ps[i+1] = ps[i] + ext[i]\\n        \\n        # count windows of length L summing to L\\n        cnt = 0\\n        for start in xrange(n):\\n            if ps[start+L] - ps[start] == L:\\n                cnt += 1\\n        \\n        return cnt\\n\"",
  "199_14631217_python-updated-time": "1745093124605",
  "84_14631217_python": "\"class Solution(object):\\n    def largestRectangleArea(self, heights):\\n        \\\"\\\"\\\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        stack = []\\n        max_area = 0\\n        heights.append(0)\\n\\n        for i, h in enumerate(heights):\\n            while stack and heights[stack[-1]] > h:\\n                height = heights[stack.pop()]\\n                width = i if not stack else i - stack[-1] - 1\\n                max_area = max(max_area, height * width)\\n            stack.append(i)\\n\\n        return max_area\\n\"",
  "2133_14631217_python": "\"class Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        count = defaultdict(int)\\n        for num in nums:\\n            count[num] += 1\\n\\n        result = 0\\n        for i in range(len(nums)):\\n            prefix = nums[i]\\n            if target.startswith(prefix):\\n                suffix = target[len(prefix):]\\n                if suffix in count:\\n                    result += count[suffix]\\n                    if prefix == suffix:\\n                        result -= 1  # Exclude the i == j case\\n        return result\\n\"",
  "3224_14631217_python-updated-time": "1747316904676",
  "3851_14631217_python-updated-time": "1746347868189",
  "3263_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # We'll track the smallest and 2nd-smallest in nums[1:].\\n        m1, m2 = float('inf'), float('inf')\\n        for v in nums[1:]:\\n            if v < m1:\\n                m2 = m1\\n                m1 = v\\n            elif v < m2:\\n                m2 = v\\n        \\n        # Total cost = cost of first segment (nums[0]) \\n        #            + smallest in nums[1:] \\n        #            + 2nd-smallest in nums[1:].\\n        return nums[0] + m1 + m2\\n\"",
  "2588_14631217_python": "\"class Solution:\\n    def maxPoints(self, grid, queries):\\n        m, n = len(grid), len(grid[0])\\n        N = m * n\\n        \\n        # Helper to convert (i, j) to 1D index\\n        def idx(i, j):\\n            return i * n + j\\n        \\n        # Create and sort list of all cells by value\\n        cells = []\\n        for i in range(m):\\n            for j in range(n):\\n                cells.append((grid[i][j], idx(i, j)))\\n        cells.sort(key=lambda x: x[0])\\n        \\n        # Sort queries but remember original indices\\n        sorted_q = sorted((q, qi) for qi, q in enumerate(queries))\\n        \\n        # Union-Find with size\\n        parent = list(range(N))\\n        comp_size = [1] * N\\n        \\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra == rb:\\n                return\\n            if comp_size[ra] < comp_size[rb]:\\n                ra, rb = rb, ra\\n            parent[rb] = ra\\n            comp_size[ra] += comp_size[rb]\\n        \\n        # Active marks which cells are <= current threshold-1\\n        active = [False] * N\\n        \\n        answers = [0] * len(queries)\\n        ptr = 0  # pointer into cells\\n        \\n        # Directions for neighbors\\n        dirs = [(-1,0),(1,0),(0,-1),(0,1)]\\n        \\n        for qval, qidx in sorted_q:\\n            # Activate all cells with value < qval\\n            while ptr < N and cells[ptr][0] < qval:\\n                _, cell_i = cells[ptr]\\n                active[cell_i] = True\\n                # union with active neighbors\\n                i0, j0 = divmod(cell_i, n)\\n                for di, dj in dirs:\\n                    ni, nj = i0 + di, j0 + dj\\n                    if 0 <= ni < m and 0 <= nj < n:\\n                        nb = idx(ni, nj)\\n                        if active[nb]:\\n                            union(cell_i, nb)\\n                ptr += 1\\n            \\n            # If start cell not active, can't move at all\\n            if not active[0]:\\n                answers[qidx] = 0\\n            else:\\n                root0 = find(0)\\n                answers[qidx] = comp_size[root0]\\n        \\n        return answers\\n\"",
  "2207_14631217_python": "\"import heapq\\n\\n\\nclass SORTracker:\\n    MAX_LEN = 10          # given in the constraints\\n\\n    def __init__(self):\\n        self.small = []   # (score, inv_name_padded, name)  – worst of top-k on top\\n        self.large = []   # (-score, name)                 – best of the rest on top\\n        self.k = 0        # how many times get() has been called\\n\\n    # -------------------------- helpers ---------------------------------\\n    def _inv_pad(self, name):\\n        \\\"\\\"\\\"invert letters and right-pad with 0xff so longer names rank *worse*\\\"\\\"\\\"\\n        inv = ''.join(chr(255 - ord(c)) for c in name)\\n        return inv + '\\\\xff' * (self.MAX_LEN - len(name))\\n\\n    # --------------------------- API ------------------------------------\\n    def add(self, name, score):\\n        # ① insert into 'large'\\n        heapq.heappush(self.large, (-score, name))\\n\\n        # ② promote the current overall best into 'small'\\n        neg_s, nm = heapq.heappop(self.large)\\n        heapq.heappush(self.small, (-neg_s, self._inv_pad(nm), nm))\\n\\n        # ③ keep |small| == k  (demote its worst if it grew too big)\\n        if len(self.small) > self.k:\\n            s, _, nm2 = heapq.heappop(self.small)\\n            heapq.heappush(self.large, (-s, nm2))\\n\\n    def get(self):\\n        # we are now asking for the (k+1)-th best\\n        self.k += 1\\n\\n        # promote exactly one more from 'large' into 'small'\\n        neg_s, nm = heapq.heappop(self.large)\\n        heapq.heappush(self.small, (-neg_s, self._inv_pad(nm), nm))\\n\\n        # the root of 'small' is the k-th best overall\\n        return self.small[0][2]\\n\"",
  "875_14631217_python-updated-time": "1745880135990",
  "3114_14631217_python-updated-time": "1747227844184",
  "2127_14631217_mysql-updated-time": "1746715652103",
  "213_14631217_python-updated-time": "1745246169524",
  "2892_14631217_python": "\"class Solution:\\n    def isGood(self, nums):\\n        n = max(nums)\\n        if len(nums) != n + 1:\\n            return False\\n        count = [0] * (n + 1)\\n        for num in nums:\\n            if num > n:\\n                return False\\n            count[num - 1] += 1\\n        for i in range(n - 1):\\n            if count[i] != 1:\\n                return False\\n        return count[n - 1] == 2\\n\"",
  "1055_14631217_python": "\"class Solution:\\n    def numPairsDivisibleBy60(self, time):\\n        count = [0] * 60\\n        res = 0\\n        for t in time:\\n            r = t % 60\\n            c = (60 - r) % 60\\n            res += count[c]\\n            count[r] += 1\\n        return res\\n\"",
  "1138_14631217_python": "\"class Solution(object):\\n    def maxSatisfied(self, customers, grumpy, minutes):\\n        \\\"\\\"\\\"\\n        :type customers: List[int]\\n        :type grumpy: List[int]\\n        :type minutes: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        base_satisfied = sum(c for c, g in zip(customers, grumpy) if g == 0)\\n        \\n        extra_satisfied = 0\\n        max_extra = 0\\n\\n        for i in range(len(customers)):\\n            if grumpy[i] == 1:\\n                extra_satisfied += customers[i]\\n            if i >= minutes:\\n                if grumpy[i - minutes] == 1:\\n                    extra_satisfied -= customers[i - minutes]\\n            max_extra = max(max_extra, extra_satisfied)\\n        \\n        return base_satisfied + max_extra\\n\"",
  "2818_14631217_python": "\"class Solution:\\n    def maxIncreasingCells(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        cells = []\\n        for i in range(m):\\n            for j in range(n):\\n                cells.append((mat[i][j], i, j))\\n        \\n        cells.sort()  # Process in increasing order of value\\n\\n        row_best = [0] * m\\n        col_best = [0] * n\\n        ans = 0\\n\\n        i = 0\\n        while i < len(cells):\\n            j = i\\n            updates = []\\n            # Process all cells with the same value together\\n            while j < len(cells) and cells[j][0] == cells[i][0]:\\n                _, r, c = cells[j]\\n                curr_len = 1 + max(row_best[r], col_best[c])\\n                updates.append((r, c, curr_len))\\n                j += 1\\n            # Commit updates after batch to avoid intra-batch interference\\n            for r, c, length in updates:\\n                row_best[r] = max(row_best[r], length)\\n                col_best[c] = max(col_best[c], length)\\n                ans = max(ans, length)\\n            i = j\\n\\n        return ans\\n\"",
  "318_14631217_python": "\"class Solution(object):\\n    def maxProduct(self, words):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(words)\\n        masks = [0] * n\\n        for i in range(n):\\n            for c in words[i]:\\n                masks[i] |= 1 << (ord(c) - ord('a'))\\n        \\n        max_product = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if masks[i] & masks[j] == 0:\\n                    max_product = max(max_product, len(words[i]) * len(words[j]))\\n        \\n        return max_product\\n\"",
  "3471_14631217_python-updated-time": "1747485576525",
  "222_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def countNodes(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def getDepth(node, isLeft):\\n            depth = 0\\n            while node:\\n                node = node.left if isLeft else node.right\\n                depth += 1\\n            return depth\\n        \\n        if not root:\\n            return 0\\n        \\n        left_depth = getDepth(root.left, True)\\n        right_depth = getDepth(root.right, False)\\n        \\n        if left_depth == right_depth:\\n            return (1 << (left_depth + 1)) - 1\\n        else:\\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\\n\"",
  "2730_14631217_python": "\"class Solution:\\n    def maximumOr(self, nums, k):\\n        n = len(nums)\\n        suffix_or = [0] * (n + 1)\\n\\n        # Build suffix ORs\\n        for i in range(n - 1, -1, -1):\\n            suffix_or[i] = suffix_or[i + 1] | nums[i]\\n\\n        prefix_or = 0\\n        max_or = 0\\n\\n        for i in range(n):\\n            modified = nums[i] << k  # Multiply by 2^k\\n            total_or = prefix_or | modified | suffix_or[i + 1]\\n            max_or = max(max_or, total_or)\\n            prefix_or |= nums[i]\\n\\n        return max_or\\n\"",
  "3388_14631217_python-updated-time": "1747424251293",
  "1904_14631217_python": "\"class Solution(object):\\n    def secondHighest(self, s):\\n        digits = set()\\n        for c in s:\\n            if c.isdigit():\\n                digits.add(int(c))\\n        if len(digits) < 2:\\n            return -1\\n        return sorted(digits, reverse=True)[1]\\n\"",
  "1753_14631217_python-updated-time": "1746444810972",
  "1581_14631217_python": "\"class Solution(object):\\n    def getStrongest(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        arr.sort()\\n        n = len(arr)\\n        m = arr[(n - 1) // 2]\\n\\n        # Sort by custom strength comparator\\n        arr.sort(key=lambda x: (abs(x - m), x), reverse=True)\\n\\n        return arr[:k]\\n\"",
  "1894_14631217_python": "\"class Solution(object):\\n    def mergeAlternately(self, word1, word2):\\n        \\\"\\\"\\\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        res = []\\n        i = 0\\n\\n        # Alternate while both have characters\\n        while i < len(word1) and i < len(word2):\\n            res.append(word1[i])\\n            res.append(word2[i])\\n            i += 1\\n\\n        # Append the remaining part\\n        res.append(word1[i:])\\n        res.append(word2[i:])\\n        \\n        return ''.join(res)\\n\"",
  "599_14631217_python-updated-time": "1745448525460",
  "1023_14631217_python": "\"from collections import defaultdict\\nimport bisect\\n\\nclass TimeMap:\\n    def __init__(self):\\n        self.store = defaultdict(list)  # key -> list of (timestamp, value)\\n\\n    def set(self, key, value, timestamp):\\n        self.store[key].append((timestamp, value))\\n\\n    def get(self, key, timestamp):\\n        items = self.store.get(key, [])\\n        i = bisect.bisect_right(items, (timestamp, chr(127)))  # find the first > timestamp\\n        if i == 0:\\n            return \\\"\\\"\\n        return items[i - 1][1]\\n\"",
  "2049_14631217_python": "\"class Solution:\\n    def eliminateMaximum(self, dist, speed):\\n        times = [(d + s - 1) // s for d, s in zip(dist, speed)]\\n        times.sort()\\n\\n        for i, t in enumerate(times):\\n            if i >= t:\\n                return i\\n        return len(dist)\\n\"",
  "99_14631217_python-updated-time": "1745080869292",
  "2312_14631217_python-updated-time": "1746803837787",
  "3235_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, source, target, original, changed, cost):\\n        \\\"\\\"\\\"\\n        :type source: str\\n        :type target: str\\n        :type original: List[str]\\n        :type changed: List[str]\\n        :type cost: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # build distance matrix for 26 letters\\n        INF = 10**18\\n        dist = [[INF]*26 for _ in range(26)]\\n        for i in range(26):\\n            dist[i][i] = 0\\n        for o, c, w in zip(original, changed, cost):\\n            u = ord(o) - 97\\n            v = ord(c) - 97\\n            if w < dist[u][v]:\\n                dist[u][v] = w\\n        # Floyd-Warshall\\n        for k in range(26):\\n            dk = dist[k]\\n            for i in range(26):\\n                di = dist[i]\\n                via = di[k]\\n                if via == INF: continue\\n                for j in range(26):\\n                    nd = via + dk[j]\\n                    if nd < di[j]:\\n                        di[j] = nd\\n        # sum up per-character conversions\\n        n = len(source)\\n        total = 0\\n        for i in range(n):\\n            s = ord(source[i]) - 97\\n            t = ord(target[i]) - 97\\n            if s == t:\\n                continue\\n            d = dist[s][t]\\n            if d >= INF:\\n                return -1\\n            total += d\\n        return total\\n\"",
  "2656_14631217_python-updated-time": "1747066928820",
  "336_14631217_python-updated-time": "1745256769758",
  "1174_14631217_mysql": "\"SELECT DISTINCT p.product_id, p.product_name\\nFROM Product p\\nJOIN Sales s ON p.product_id = s.product_id\\nWHERE s.sale_date BETWEEN '2019-01-01' AND '2019-03-31'\\n  AND p.product_id NOT IN (\\n    SELECT product_id\\n    FROM Sales\\n    WHERE sale_date < '2019-01-01' OR sale_date > '2019-03-31'\\n);\\n\"",
  "2575_14631217_python-updated-time": "1746969871502",
  "1346_14631217_python-updated-time": "1746810324764",
  "952_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def wordSubsets(self, words1, words2):\\n        def count(word):\\n            return Counter(word)\\n\\n        # Compute the maximum required count for each character from words2\\n        max_count = Counter()\\n        for b in words2:\\n            b_count = count(b)\\n            for char in b_count:\\n                max_count[char] = max(max_count[char], b_count[char])\\n\\n        res = []\\n        for a in words1:\\n            a_count = count(a)\\n            if all(a_count[c] >= max_count[c] for c in max_count):\\n                res.append(a)\\n\\n        return res\\n\"",
  "2047_14631217_python-updated-time": "1746627706923",
  "2395_14631217_python-updated-time": "1746882813949",
  "2080_14631217_python": "\"class Solution(object):\\n    def checkMove(self, board, rMove, cMove, color):\\n        opp = 'W' if color == 'B' else 'B'\\n        n = 8\\n        dirs = [(-1, -1), (-1, 0), (-1, 1),\\n                (0, -1),          (0, 1),\\n                (1, -1),  (1, 0),  (1, 1)]\\n        \\n        for dx, dy in dirs:\\n            x, y = rMove + dx, cMove + dy\\n            if not (0 <= x < n and 0 <= y < n and board[x][y] == opp):\\n                continue\\n            step = 2\\n            while True:\\n                nx = rMove + dx * step\\n                ny = cMove + dy * step\\n                if not (0 <= nx < n and 0 <= ny < n):\\n                    break\\n                cell = board[nx][ny]\\n                if cell == '.':\\n                    break\\n                if cell == color:\\n                    return True\\n                step += 1\\n        return False\\n\"",
  "2358_14631217_python-updated-time": "1746880930066",
  "1382_14631217_python-updated-time": "1746882186314",
  "3152_14631217_python": "\"class Solution(object):\\n    def maximumTripletValue(self, nums):\\n        n = len(nums)\\n        if n < 3:\\n            return 0\\n        # prefix_max[i] = max of nums[0..i]\\n        prefix_max = [0] * n\\n        prefix_max[0] = nums[0]\\n        for i in range(1, n):\\n            prefix_max[i] = max(prefix_max[i-1], nums[i])\\n        # suffix_max[i] = max of nums[i..n-1]\\n        suffix_max = [0] * n\\n        suffix_max[n-1] = nums[n-1]\\n        for i in range(n-2, -1, -1):\\n            suffix_max[i] = max(suffix_max[i+1], nums[i])\\n        res = 0\\n        # iterate j as middle index\\n        for j in range(1, n-1):\\n            max_i = prefix_max[j-1]\\n            max_k = suffix_max[j+1]\\n            diff = max_i - nums[j]\\n            if diff > 0 and max_k > 0:\\n                val = diff * max_k\\n                if val > res:\\n                    res = val\\n        return res\"",
  "2112_14631217_python": "\"class Solution:\\n    def minimumDifference(self, nums, k):\\n        nums.sort()\\n        min_diff = float('inf')\\n        for i in range(len(nums) - k + 1):\\n            diff = nums[i + k - 1] - nums[i]\\n            min_diff = min(min_diff, diff)\\n        return min_diff\\n\"",
  "821_14631217_python-updated-time": "1745878245947",
  "835_14631217_python": "\"\\n\\nclass Solution(object):\\n    def numComponents(self, head, nums):\\n        nums_set = set(nums)\\n        count = 0\\n        in_component = False\\n        \\n        while head:\\n            if head.val in nums_set:\\n                if not in_component:\\n                    count += 1\\n                    in_component = True\\n            else:\\n                in_component = False\\n            head = head.next\\n        \\n        return count\\n\"",
  "65_14631217_python-updated-time": "1745014830357",
  "3649_14631217_python-updated-time": "1747596191247",
  "804_14631217_python": "\"class Solution(object):\\n    def rotatedDigits(self, n):\\n        valid = {0, 1, 2, 5, 6, 8, 9}\\n        diff = {2, 5, 6, 9}\\n        count = 0\\n        for num in range(1, n+1):\\n            digits = set(int(d) for d in str(num))\\n            if digits.issubset(valid) and digits & diff:\\n                count += 1\\n        return count\\n\"",
  "1286_14631217_python-updated-time": "1746347101495",
  "541_14631217_python-updated-time": "1745446977345",
  "2226_14631217_python-updated-time": "1746799890282",
  "735_14631217_python-updated-time": "1745787311815",
  "1798_14631217_python": "\"class Solution(object):\\n    def maxOperations(self, nums, k):\\n        count = {}\\n        ops = 0\\n        for x in nums:\\n            need = k - x\\n            if count.get(need, 0) > 0:\\n                ops += 1\\n                count[need] -= 1\\n            else:\\n                count[x] = count.get(x, 0) + 1\\n        return ops\\n\"",
  "1231_14631217_python": "\"class Solution:\\n    def replaceElements(self, arr):\\n        max_right = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            arr[i], max_right = max_right, max(max_right, arr[i])\\n        return arr\\n\"",
  "2804_14631217_javascript-updated-time": "1747139799225",
  "899_14631217_python-updated-time": "1746001373060",
  "1283_14631217_python-updated-time": "1746433260090",
  "2718_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def minOperations(self, nums, queries):\\n        # Sort nums and build prefix sums\\n        nums.sort()\\n        n = len(nums)\\n        prefix = [0] * (n+1)\\n        for i, x in enumerate(nums):\\n            prefix[i+1] = prefix[i] + x\\n        \\n        ans = []\\n        for q in queries:\\n            # count of nums < q\\n            idx = bisect.bisect_left(nums, q)\\n            # cost to raise all nums[:idx] up to q\\n            left_cost  = q*idx - prefix[idx]\\n            # cost to lower all nums[idx:] down to q\\n            right_cost = (prefix[n] - prefix[idx]) - q*(n-idx)\\n            ans.append(left_cost + right_cost)\\n        return ans\\n\"",
  "2380_14631217_python-updated-time": "1746881694119",
  "979_14631217_python-updated-time": "1746004593424",
  "1845_14631217_python": "\"class Solution:\\n    def largestSubmatrix(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n\\n        for i in range(1, m):\\n            for j in range(n):\\n                if matrix[i][j]:\\n                    matrix[i][j] += matrix[i - 1][j]\\n\\n        max_area = 0\\n        for row in matrix:\\n            row.sort(reverse=True)\\n            for i in range(n):\\n                max_area = max(max_area, row[i] * (i + 1))\\n        \\n        return max_area\\n\"",
  "1741_14631217_python-updated-time": "1746444896554",
  "2353_14631217_python": "\"class Solution:\\n    def maximumScore(self, scores, edges):\\n        n = len(scores)\\n        # Build undirected adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # For each node, keep its top k neighbors by score\\n        k = 3\\n        topn = [[] for _ in range(n)]\\n        for u in range(n):\\n            # sort neighbors of u descending by their scores\\n            nbrs = adj[u]\\n            nbrs.sort(key=lambda v: scores[v], reverse=True)\\n            # trim to top k\\n            topn[u] = nbrs[:k]\\n        \\n        best = -1\\n        \\n        # For each undirected edge, try both orientations as the central edge\\n        for u, v in edges:\\n            for b, c in ((u, v), (v, u)):\\n                # b is the second node, c is the third node\\n                for a in topn[b]:\\n                    if a == c:\\n                        continue\\n                    for d in topn[c]:\\n                        if d == b or d == a:\\n                            continue\\n                        total = scores[a] + scores[b] + scores[c] + scores[d]\\n                        if total > best:\\n                            best = total\\n        \\n        return best\\n\"",
  "1429_14631217_python-updated-time": "1746260962432",
  "3783_14631217_python-updated-time": "1747740680630",
  "1887_14631217_python": "\"class Solution(object):\\n    def minTrioDegree(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Build adjacency matrix\\n        adj = [[False] * (n + 1) for _ in range(n + 1)]\\n        degree = [0] * (n + 1)\\n        \\n        for u, v in edges:\\n            adj[u][v] = True\\n            adj[v][u] = True\\n            degree[u] += 1\\n            degree[v] += 1\\n        \\n        min_degree = float('inf')\\n\\n        # Check all triplets (i, j, k) for being a trio\\n        for i in range(1, n + 1):\\n            for j in range(i + 1, n + 1):\\n                if not adj[i][j]:\\n                    continue\\n                for k in range(j + 1, n + 1):\\n                    if adj[i][k] and adj[j][k]:\\n                        # Trio found\\n                        trio_deg = degree[i] + degree[j] + degree[k] - 6\\n                        min_degree = min(min_degree, trio_deg)\\n        \\n        return min_degree if min_degree != float('inf') else -1\\n\"",
  "3192_14631217_python-updated-time": "1747311921796",
  "1752_14631217_python-updated-time": "1746444784255",
  "2226_14631217_python": "\"class Solution:\\n    def countPoints(self, rings):\\n        rods = [set() for _ in range(10)]\\n\\n        for i in range(0, len(rings), 2):\\n            color = rings[i]\\n            rod = int(rings[i + 1])\\n            rods[rod].add(color)\\n\\n        return sum(1 for colors in rods if len(colors) == 3)\\n\"",
  "3384_14631217_python": "\"class Solution(object):\\n    def minimumOperationsToMakeKPeriodic(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(word)\\n        # Number of length-k blocks\\n        B = n // k\\n        \\n        # Count how many times each block appears\\n        freq = {}\\n        for i in range(0, n, k):\\n            block = word[i:i+k]\\n            freq[block] = freq.get(block, 0) + 1\\n        \\n        # We can only copy one of the existing blocks to all others.\\n        # Pick the block with maximum frequency (M),\\n        # then replace the other B - M blocks.\\n        max_count = max(freq.values())\\n        return B - max_count\\n\"",
  "2177_14631217_python-updated-time": "1746721006115",
  "1516_14631217_python": "\"class Solution(object):\\n    def getHappyString(self, n, k):\\n        result = []\\n\\n        def backtrack(path):\\n            if len(path) == n:\\n                result.append(path)\\n                return\\n            for ch in 'abc':\\n                if not path or path[-1] != ch:\\n                    backtrack(path + ch)\\n\\n        backtrack(\\\"\\\")\\n        return result[k - 1] if k <= len(result) else \\\"\\\"\\n\"",
  "2605_14631217_python": "\"class Solution:\\n    def countAnagrams(self, s):\\n        mod = 10**9 + 7\\n        \\n        # Split into words\\n        words = s.split(' ')\\n        # Find maximum word length to size our factorial table\\n        max_len = max(len(w) for w in words)\\n        \\n        # Precompute factorials mod and inverse factorials mod\\n        fact = [1] * (max_len + 1)\\n        for i in range(1, max_len + 1):\\n            fact[i] = fact[i - 1] * i % mod\\n        \\n        invf = [1] * (max_len + 1)\\n        invf[max_len] = pow(fact[max_len], mod - 2, mod)\\n        for i in range(max_len, 0, -1):\\n            invf[i - 1] = invf[i] * i % mod\\n        \\n        ans = 1\\n        # For each word, multiply by permutations = L! / (∏ freq[c]!)\\n        for w in words:\\n            L = len(w)\\n            ans = ans * fact[L] % mod\\n            \\n            # Count character frequencies\\n            freq = {}\\n            for ch in w:\\n                freq[ch] = freq.get(ch, 0) + 1\\n            \\n            # Divide out duplicate permutations\\n            for f in freq.values():\\n                ans = ans * invf[f] % mod\\n        \\n        return ans\\n\"",
  "915_14631217_python": "\"import random\\nimport math\\n\\nclass Solution:\\n\\n    def __init__(self, radius, x_center, y_center):\\n        self.radius = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        r = self.radius * math.sqrt(random.random())\\n        theta = random.uniform(0, 2 * math.pi)\\n        x = self.xc + r * math.cos(theta)\\n        y = self.yc + r * math.sin(theta)\\n        return [x, y]\\n\"",
  "1457_14631217_python": "\"class Solution:\\n    def minDifficulty(self, jobDifficulty, d):\\n        n = len(jobDifficulty)\\n        # If fewer jobs than days, impossible\\n        if n < d:\\n            return -1\\n        \\n        # dp[i][day]: min difficulty to schedule first i jobs in 'day' days\\n        INF = float('inf')\\n        dp = [[INF] * (d + 1) for _ in range(n + 1)]\\n        dp[0][0] = 0\\n        \\n        # Fill DP\\n        for i in range(1, n + 1):\\n            for day in range(1, min(d, i) + 1):\\n                max_job = 0\\n                # Try ending the previous day at k, and day 'day' does jobs k..i-1\\n                for k in range(i - 1, day - 2, -1):\\n                    max_job = max(max_job, jobDifficulty[k])\\n                    prev = dp[k][day - 1]\\n                    if prev + max_job < dp[i][day]:\\n                        dp[i][day] = prev + max_job\\n        \\n        ans = dp[n][d]\\n        return ans if ans < INF else -1\\n\"",
  "2020_14631217_python-updated-time": "1746627888999",
  "3403_14631217_python-updated-time": "1747481535280",
  "1582_14631217_python": "\"class BrowserHistory(object):\\n\\n    def __init__(self, homepage):\\n        \\\"\\\"\\\"\\n        :type homepage: str\\n        \\\"\\\"\\\"\\n        self.history = [homepage]\\n        self.curr = 0\\n\\n    def visit(self, url):\\n        \\\"\\\"\\\"\\n        :type url: str\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        self.history = self.history[:self.curr + 1]\\n        self.history.append(url)\\n        self.curr += 1\\n\\n    def back(self, steps):\\n        \\\"\\\"\\\"\\n        :type steps: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        self.curr = max(0, self.curr - steps)\\n        return self.history[self.curr]\\n\\n    def forward(self, steps):\\n        \\\"\\\"\\\"\\n        :type steps: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        self.curr = min(len(self.history) - 1, self.curr + steps)\\n        return self.history[self.curr]\\n\"",
  "2482_14631217_python": "\"import itertools\\n\\nclass Solution:\\n    def maximumRows(self, matrix, numSelect):\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        # Precompute a bitmask for each row where bits set correspond to 1s\\n        row_masks = []\\n        for row in matrix:\\n            mask = 0\\n            for j, val in enumerate(row):\\n                if val:\\n                    mask |= 1 << j\\n            row_masks.append(mask)\\n        \\n        max_covered = 0\\n        # Iterate over all combinations of numSelect columns\\n        for cols in itertools.combinations(range(n), numSelect):\\n            # Build a mask with those columns selected\\n            sel_mask = 0\\n            for j in cols:\\n                sel_mask |= 1 << j\\n            \\n            # Count how many rows are fully covered by sel_mask\\n            covered = 0\\n            for rm in row_masks:\\n                # A row is covered if all 1-bits in rm are within sel_mask\\n                if rm & ~sel_mask == 0:\\n                    covered += 1\\n            \\n            if covered > max_covered:\\n                max_covered = covered\\n        \\n        return max_covered\\n\"",
  "2706_14631217_python-updated-time": "1747065516850",
  "2919_14631217_python": "\"class Solution(object):\\n    def maxIncreasingGroups(self, usageLimits):\\n        usageLimits.sort()\\n        available = 0      # running count of still-unassigned copies\\n        size = 0           # current group size we need to form next (also the answer so far)\\n\\n        for c in usageLimits:\\n            available += c\\n            if available >= size + 1:   # can we build the next larger group?\\n                size += 1\\n                available -= size       # consume items for this group\\n\\n        return size\\n\"",
  "2_14631217_python-updated-time": "1744977876142",
  "421_14631217_python": "\"class Solution:\\n    def findMaximumXOR(self, nums):\\n        max_xor = 0\\n        mask = 0\\n        \\n        for i in range(31, -1, -1):\\n            mask |= (1 << i)\\n            prefixes = set(num & mask for num in nums)\\n            candidate = max_xor | (1 << i)\\n            for p in prefixes:\\n                if candidate ^ p in prefixes:\\n                    max_xor = candidate\\n                    break\\n                    \\n        return max_xor\\n\"",
  "203_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        current = dummy\\n        while current.next:\\n            if current.next.val == val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n        return dummy.next\\n\"",
  "279_14631217_python-updated-time": "1745248398989",
  "3569_14631217_python-updated-time": "1747575443531",
  "2723_14631217_python": "\"class Solution:\\n    def findTheLongestBalancedSubstring(self, s):\\n        max_len = 0\\n        i = 0\\n        n = len(s)\\n        \\n        while i < n:\\n            zero_count = one_count = 0\\n\\n            # Count consecutive zeros\\n            while i < n and s[i] == '0':\\n                zero_count += 1\\n                i += 1\\n\\n            # Count consecutive ones\\n            while i < n and s[i] == '1':\\n                one_count += 1\\n                i += 1\\n\\n            max_len = max(max_len, 2 * min(zero_count, one_count))\\n\\n        return max_len\\n\"",
  "1669_14631217_python-updated-time": "1746434420080",
  "51_14631217_python": "\"class Solution(object):\\n    def solveNQueens(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[List[str]]\\n        \\\"\\\"\\\"\\n        res = []\\n        board = [['.'] * n for _ in range(n)]\\n        \\n        def backtrack(row, cols, diag1, diag2):\\n            if row == n:\\n                res.append([''.join(r) for r in board])\\n                return\\n            for col in range(n):\\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\\n                    continue\\n                board[row][col] = 'Q'\\n                cols.add(col)\\n                diag1.add(row - col)\\n                diag2.add(row + col)\\n                backtrack(row + 1, cols, diag1, diag2)\\n                board[row][col] = '.'\\n                cols.remove(col)\\n                diag1.remove(row - col)\\n                diag2.remove(row + col)\\n        \\n        backtrack(0, set(), set(), set())\\n        return res\\n\"",
  "133_14631217_python": "\"class Solution(object):\\n    def cloneGraph(self, node):\\n        \\\"\\\"\\\"\\n        :type node: Node\\n        :rtype: Node\\n        \\\"\\\"\\\"\\n        if not node:\\n            return None\\n        \\n        # Dictionary to map original nodes to their clones\\n        cloned = {}\\n        \\n        def dfs(original):\\n            # If we've already cloned this node, return its clone\\n            if original in cloned:\\n                return cloned[original]\\n            \\n            # Create clone of the current node\\n            clone = Node(original.val)\\n            \\n            # Add to dictionary before exploring neighbors (to handle cycles)\\n            cloned[original] = clone\\n            \\n            # Clone and connect all neighbors\\n            for neighbor in original.neighbors:\\n                clone.neighbors.append(dfs(neighbor))\\n            \\n            return clone\\n        \\n        return dfs(node)\"",
  "2329_14631217_python": "\"class Solution:\\n    def maximumProduct(self, nums, k):\\n        MOD = 10**9 + 7\\n\\n        # 1) Sort and append a big sentinel\\n        A = sorted(nums)\\n        A.append(10**18)\\n\\n        n = len(nums)\\n        i = 0\\n        base = A[0]\\n\\n        # 2) Level up the smallest (i+1) items in batches\\n        while True:\\n            diff = A[i+1] - base\\n            needed = diff * (i+1)\\n\\n            if needed <= k:\\n                # we can raise all of the first i+1 items up to A[i+1]\\n                k -= needed\\n                base = A[i+1]\\n                i += 1\\n            else:\\n                # can't fully reach next level—distribute the rest of k over the first i+1 items\\n                q, r = divmod(k, i+1)\\n\\n                # 3) Compute the final product\\n                prod = 1\\n\\n                # r of them get base + q + 1\\n                prod = prod * pow(base + q + 1, r, MOD) % MOD\\n                # (i+1 - r) of them get base + q\\n                prod = prod * pow(base + q, (i+1 - r), MOD) % MOD\\n\\n                # the remaining items (from i+1 up to n-1) stay at their original values\\n                for j in range(i+1, n):\\n                    prod = (prod * (A[j] % MOD)) % MOD\\n\\n                return prod\\n\"",
  "1638_14631217_python": "\"class Solution(object):\\n    def getMinDistSum(self, positions):\\n        \\\"\\\"\\\"\\n        :type positions: List[List[int]]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        import math\\n\\n        def distance(x, y):\\n            return sum(math.hypot(x - xi, y - yi) for xi, yi in positions)\\n\\n        # Initialize with centroid\\n        x = sum(p[0] for p in positions) / len(positions)\\n        y = sum(p[1] for p in positions) / len(positions)\\n\\n        EPS = 1e-7\\n        prev = 0\\n        curr = distance(x, y)\\n\\n        while abs(curr - prev) > EPS:\\n            num_x = num_y = denom = 0\\n            for xi, yi in positions:\\n                d = math.hypot(x - xi, y - yi)\\n                if d == 0:  # Avoid division by zero\\n                    continue\\n                weight = 1.0 / d\\n                num_x += xi * weight\\n                num_y += yi * weight\\n                denom += weight\\n\\n            x, y = num_x / denom, num_y / denom\\n            prev, curr = curr, distance(x, y)\\n\\n        return curr\\n\"",
  "2103_14631217_python-updated-time": "1746717165467",
  "2024_14631217_mysql": "\"SELECT\\n  employee_id,\\n  CASE\\n    WHEN MOD(employee_id, 2) = 1\\n     AND name NOT LIKE 'M%' THEN salary\\n    ELSE 0\\n  END AS bonus\\nFROM Employees\\nORDER BY employee_id;\\n\"",
  "1664_14631217_mysql-updated-time": "1744902466520",
  "3544_14631217_python-updated-time": "1747569994444",
  "3722_14631217_python": "\"class Solution(object):\\n    def maxSum(self, nums, k, m):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type m: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # prefix sums: prefix[i] = sum of nums[0..i-1]\\n        prefix = [0]*(n+1)\\n        for i in range(1, n+1):\\n            prefix[i] = prefix[i-1] + nums[i-1]\\n        \\n        # dp[j][i]: maximum sum using j subarrays within first i elements\\n        # initialize with -inf for impossible states\\n        NEG_INF = -10**18\\n        dp = [[NEG_INF]*(n+1) for _ in range(k+1)]\\n        # zero subarrays gives sum 0\\n        for i in range(n+1):\\n            dp[0][i] = 0\\n        \\n        # fill dp\\n        for j in range(1, k+1):\\n            best_h = NEG_INF\\n            # for i < m, can't form j>=1 subarrays\\n            for i in range(1, n+1):\\n                # carry over: not ending a subarray at i\\n                dp[j][i] = dp[j][i-1]\\n                # update best_h when h = i-m\\n                if i-m >= 0:\\n                    # candidate h = i-m\\n                    val = dp[j-1][i-m] - prefix[i-m]\\n                    if val > best_h:\\n                        best_h = val\\n                # if we have a valid best_h, consider ending a subarray at i\\n                if best_h != NEG_INF:\\n                    candidate = prefix[i] + best_h\\n                    if candidate > dp[j][i]:\\n                        dp[j][i] = candidate\\n        \\n        return dp[k][n]\\n\"",
  "2839_14631217_python": "\"class Solution:\\n    def maximumSumQueries(self, nums1, nums2, queries):\\n        import bisect\\n        \\n        n = len(nums1)\\n        m = len(queries)\\n        \\n        # Collect all nums2 values and all query-yi's for coordinate compression\\n        ys = set(nums2)\\n        for x, y in queries:\\n            ys.add(y)\\n        # Sort in descending order so that \\\"nums2 >= y\\\" becomes a prefix in this array\\n        desc = sorted(ys, reverse=True)\\n        size = len(desc)\\n        idx_map = {v: i for i, v in enumerate(desc)}\\n        \\n        # Fenwick/BIT for range maximum on prefix [0..i]\\n        NEG = -10**30\\n        BIT = [NEG] * (size + 1)\\n        def bit_update(i, val):\\n            # point update: set BIT[i] = max(BIT[i], val)\\n            i += 1\\n            while i <= size:\\n                if BIT[i] < val:\\n                    BIT[i] = val\\n                i += i & -i\\n        def bit_query(i):\\n            # prefix max over [0..i]\\n            i += 1\\n            res = NEG\\n            while i > 0:\\n                if BIT[i] > res:\\n                    res = BIT[i]\\n                i -= i & -i\\n            return res\\n        \\n        # Sort points (nums1[j], nums2[j]) by nums1 descending\\n        pts = sorted(zip(nums1, nums2), key=lambda t: -t[0])\\n        # Sort queries by xi descending, keep original index\\n        qs = sorted(((x, y, qi) for qi, (x, y) in enumerate(queries)),\\n                    key=lambda t: -t[0])\\n        \\n        ans = [-1] * m\\n        p = 0\\n        \\n        for x, y, qi in qs:\\n            # Insert all points with nums1 >= x into the BIT\\n            while p < n and pts[p][0] >= x:\\n                a, b = pts[p]\\n                s = a + b\\n                bit_update(idx_map[b], s)\\n                p += 1\\n            \\n            # Find the rightmost index pos in 'desc' where desc[pos] >= y\\n            # i.e., the largest pos with desc[pos] >= y\\n            lo, hi, pos = 0, size - 1, -1\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                if desc[mid] >= y:\\n                    pos = mid\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            \\n            if pos >= 0:\\n                res = bit_query(pos)\\n                if res > NEG // 2:\\n                    ans[qi] = res\\n        \\n        return ans\\n\"",
  "12_14631217_python": "\"class Solution(object):\\n    def intToRoman(self, num):\\n        \\\"\\\"\\\"\\n        :type num: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        val = [\\n            1000, 900, 500, 400,\\n            100, 90, 50, 40,\\n            10, 9, 5, 4,\\n            1\\n        ]\\n        syms = [\\n            \\\"M\\\", \\\"CM\\\", \\\"D\\\", \\\"CD\\\",\\n            \\\"C\\\", \\\"XC\\\", \\\"L\\\", \\\"XL\\\",\\n            \\\"X\\\", \\\"IX\\\", \\\"V\\\", \\\"IV\\\",\\n            \\\"I\\\"\\n        ]\\n        roman = \\\"\\\"\\n        for i in range(len(val)):\\n            while num >= val[i]:\\n                roman += syms[i]\\n                num -= val[i]\\n        return roman\\n\"",
  "2712_14631217_python-updated-time": "1747066118992",
  "1446_14631217_python-updated-time": "1746261919181",
  "868_14631217_python-updated-time": "1745879680292",
  "3308_14631217_python": "\"class Solution(object):\\n    def lastNonEmptyString(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # 1) Count total occurrences of each character\\n        freq = [0] * 26\\n        for ch in s:\\n            freq[ord(ch) - 97] += 1\\n\\n        # 2) Find the maximum number of rounds = max frequency\\n        M = max(freq)\\n\\n        # 3) Collect exactly the M-th occurrence of each char whose total freq == M\\n        seen = [0] * 26\\n        res = []\\n        for ch in s:\\n            ci = ord(ch) - 97\\n            seen[ci] += 1\\n            # If this char appears M times total, and this is its M-th occurrence,\\n            # it survives until just before the last removal.\\n            if freq[ci] == M and seen[ci] == M:\\n                res.append(ch)\\n\\n        # The order in `res` matches their order in s, which is the string\\n        # just before the final operation.\\n        return \\\"\\\".join(res)\\n\"",
  "1674_14631217_python-updated-time": "1746434463039",
  "1874_14631217_python": "\"class Solution(object):\\n    def canChoose(self, groups, nums):\\n        \\\"\\\"\\\"\\n        :type groups: List[List[int]]\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        start = 0  # Current position in nums\\n\\n        for group in groups:\\n            found = False\\n            while start + len(group) <= len(nums):\\n                # Check if the current slice matches the group\\n                if nums[start:start+len(group)] == group:\\n                    # Move start past the matched group to ensure disjoint\\n                    start += len(group)\\n                    found = True\\n                    break\\n                start += 1\\n            if not found:\\n                return False\\n\\n        return True\\n\"",
  "887_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def mincostToHireWorkers(self, quality, wage, k):\\n        workers = sorted([(w / float(q), q) for q, w in zip(quality, wage)])\\n        heap = []\\n        total_quality = 0\\n        res = float('inf')\\n\\n        for ratio, q in workers:\\n            heapq.heappush(heap, -q)\\n            total_quality += q\\n\\n            if len(heap) > k:\\n                total_quality += heapq.heappop(heap)\\n\\n            if len(heap) == k:\\n                res = min(res, total_quality * ratio)\\n\\n        return res\\n\"",
  "888_14631217_python": "\"class Solution(object):\\n    def mirrorReflection(self, p, q):\\n        while p % 2 == 0 and q % 2 == 0:\\n            p //= 2\\n            q //= 2\\n        if p % 2 == 0 and q % 2 == 1:\\n            return 2\\n        if p % 2 == 1 and q % 2 == 0:\\n            return 0\\n        return 1\\n\"",
  "3192_14631217_python": "\"class Solution(object):\\n    def maximumXorProduct(self, a, b, n):\\n        MOD = 10**9 + 7\\n        x = 0\\n        for i in reversed(range(n)):\\n            bit = 1 << i\\n            with_bit = ((a ^ (x | bit)) * (b ^ (x | bit)))\\n            without_bit = ((a ^ x) * (b ^ x))\\n            if with_bit > without_bit:\\n                x |= bit\\n        return ((a ^ x) * (b ^ x)) % MOD\"",
  "955_14631217_python": "\"from collections import deque\\n\\nclass CBTInserter:\\n    def __init__(self, root):\\n        self.root = root\\n        self.deque = deque()\\n        \\n        # Level order traversal to find incomplete nodes\\n        q = deque([root])\\n        while q:\\n            node = q.popleft()\\n            if not node.left or not node.right:\\n                self.deque.append(node)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n\\n    def insert(self, val):\\n        node = self.deque[0]\\n        new_node = TreeNode(val)\\n        \\n        if not node.left:\\n            node.left = new_node\\n        else:\\n            node.right = new_node\\n            self.deque.popleft()\\n        \\n        self.deque.append(new_node)\\n        return node.val\\n\\n    def get_root(self):\\n        return self.root\\n\"",
  "1636_14631217_python-updated-time": "1746433500443",
  "693_14631217_python": "\"class Solution(object):\\n    def hasAlternatingBits(self, n):\\n        last = n & 1\\n        n >>= 1\\n        while n:\\n            curr = n & 1\\n            if curr == last:\\n                return False\\n            last = curr\\n            n >>= 1\\n        return True\\n\"",
  "2102_14631217_python-updated-time": "1746717137809",
  "2998_14631217_python-updated-time": "1747226754840",
  "3463_14631217_python": "\"class Solution(object):\\n    def numberOfAlternatingGroups(self, colors):\\n        n = len(colors)\\n        cnt = 0\\n        for i in xrange(n):\\n            if colors[i] != colors[(i-1) % n] and colors[i] != colors[(i+1) % n]:\\n                cnt += 1\\n        return cnt\\n\"",
  "1977_14631217_python-updated-time": "1746624858493",
  "1450_14631217_python-updated-time": "1746261406354",
  "585_14631217_mysql-updated-time": "1745448083097",
  "2243_14631217_python": "\"class Solution:\\n    def checkString(self, s):\\n        return \\\"ba\\\" not in s\\n\"",
  "438_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def findAnagrams(self, s, p):\\n        res = []\\n        p_count = Counter(p)\\n        s_count = Counter()\\n        n, m = len(s), len(p)\\n        \\n        for i in range(n):\\n            s_count[s[i]] += 1\\n            if i >= m:\\n                s_count[s[i - m]] -= 1\\n                if s_count[s[i - m]] == 0:\\n                    del s_count[s[i - m]]\\n            if s_count == p_count:\\n                res.append(i - m + 1)\\n        \\n        return res\\n\"",
  "532_14631217_python": "\"class Solution:\\n    def findPairs(self, nums, k):\\n        if k < 0:\\n            return 0\\n        \\n        count = 0\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        for num in freq:\\n            if k == 0:\\n                if freq[num] > 1:\\n                    count += 1\\n            else:\\n                if num + k in freq:\\n                    count += 1\\n        \\n        return count\\n\"",
  "2547_14631217_python-updated-time": "1746968318586",
  "2864_14631217_javascript-updated-time": "1747220575268",
  "1335_14631217_python-updated-time": "1746811228191",
  "450_14631217_python-updated-time": "1745359218669",
  "1186_14631217_java": "\"import java.util.concurrent.Semaphore;\\nimport java.util.concurrent.CyclicBarrier;\\n\\nclass H2O {\\n    private Semaphore hydrogenSem = new Semaphore(2);\\n    private Semaphore oxygenSem = new Semaphore(1);\\n    private CyclicBarrier barrier = new CyclicBarrier(3);\\n\\n    public H2O() {}\\n\\n    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {\\n        hydrogenSem.acquire();\\n        try {\\n            barrier.await(); // Wait until 3 threads reach (2H + 1O)\\n            releaseHydrogen.run();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            hydrogenSem.release();\\n        }\\n    }\\n\\n    public void oxygen(Runnable releaseOxygen) throws InterruptedException {\\n        oxygenSem.acquire();\\n        try {\\n            barrier.await();\\n            releaseOxygen.run();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            oxygenSem.release();\\n        }\\n    }\\n}\\n\"",
  "3462_14631217_python": "\"class Solution(object):\\n    def doesAliceWin(self, s):\\n        return any(c in 'aeiou' for c in s)\\n\"",
  "2256_14631217_python-updated-time": "1746802079906",
  "2685_14631217_python-updated-time": "1747136921012",
  "3833_14631217_python": "\"class Solution(object):\\n    def minTravelTime(self, l, n, k, position, time):\\n        \\\"\\\"\\\"\\n        :type l: int\\n        :type n: int\\n        :type k: int\\n        :type position: List[int]\\n        :type time: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Prefix sums of original time array\\n        # pref[i] = sum of time[0] through time[i-1]\\n        pref = [0] * (n + 1)\\n        for i in range(n):\\n            pref[i + 1] = pref[i] + time[i]\\n\\n        # dp[i][j] is a dict mapping effective travel-time-per-km at sign i\\n        # to the min total cost to reach i using exactly j merges.\\n        dp = [[{} for _ in range(k + 1)] for _ in range(n)]\\n        # Initialize at start sign (index 0)\\n        # No merges used, effective time at sign 0 is the original time[0]\\n        dp[0][0][time[0]] = 0\\n\\n        # Fill DP\\n        for i in range(n):\\n            for used in range(k + 1):\\n                for eff_t, cost_so_far in dp[i][used].items():\\n                    # Try jumping to any next kept sign h > i\\n                    for h in range(i + 1, n):\\n                        merges_needed = h - i - 1\\n                        if used + merges_needed > k:\\n                            continue\\n                        # Travel cost for segment from i to h using current eff_t\\n                        dist = position[h] - position[i]\\n                        new_cost = cost_so_far + dist * eff_t\\n                        # Compute new effective time at sign h after merging\\n                        # interior signs i+1 .. h-1 into h\\n                        new_eff_t = pref[h + 1] - pref[i + 1]\\n                        total_merges = used + merges_needed\\n                        # Update dp[h][total_merges][new_eff_t]\\n                        prev = dp[h][total_merges].get(new_eff_t)\\n                        if prev is None or new_cost < prev:\\n                            dp[h][total_merges][new_eff_t] = new_cost\\n\\n        # The answer is the minimum cost at the last sign index with exactly k merges\\n        last_states = dp[n - 1][k]\\n        if not last_states:\\n            # No valid sequence of exactly k merges (shouldn't happen under constraints)\\n            return -1\\n        return min(last_states.values())\\n\"",
  "735_14631217_python": "\"class Solution(object):\\n    def asteroidCollision(self, asteroids):\\n        stack = []\\n        for a in asteroids:\\n            alive = True\\n            while alive and a < 0 and stack and stack[-1] > 0:\\n                if stack[-1] < -a:\\n                    stack.pop()\\n                    continue\\n                elif stack[-1] == -a:\\n                    stack.pop()\\n                alive = False\\n            if alive:\\n                stack.append(a)\\n        return stack\\n\"",
  "2044_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def wonderfulSubstrings(self, word):\\n        count = defaultdict(int)\\n        count[0] = 1  # base case: empty prefix\\n        res = 0\\n        mask = 0\\n\\n        for ch in word:\\n            bit = ord(ch) - ord('a')\\n            mask ^= (1 << bit)\\n\\n            res += count[mask]  # same mask -> all even\\n\\n            for i in range(10):  # one odd letter\\n                res += count[mask ^ (1 << i)]\\n\\n            count[mask] += 1\\n\\n        return res\\n\"",
  "3562_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def maximumWeight(self, intervals):\\n        \\\"\\\"\\\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n\\n        n = len(intervals)\\n        if n == 0:\\n            return []\\n\\n        # Augment intervals with original indices: (start, end, weight, original_index)\\n        s_intervals = []\\n        for i in range(n):\\n            s_intervals.append((intervals[i][0], intervals[i][1], intervals[i][2], i))\\n\\n        # Sort intervals: primary key end point, secondary key start point, tertiary original index.\\n        s_intervals.sort(key=lambda x: (x[1], x[0], x[3]))\\n\\n        # r_coords stores end points of s_intervals for efficient binary search.\\n        r_coords = [interval[1] for interval in s_intervals]\\n\\n        # dp[k][i] stores (max_score, list_of_original_indices) for choosing k intervals,\\n        # with s_intervals[i] being the k-th interval.\\n        # max_so_far[k][i] stores the best (score, list_indices) for choosing k intervals\\n        # from s_intervals[0...i].\\n        # k ranges from 1 to 4. We use 0-indexed arrays of size 5 for k.\\n        dp = [[(-1, []) for _ in range(n)] for _ in range(5)]\\n        max_so_far = [[(-1, []) for _ in range(n)] for _ in range(5)]\\n\\n        # Helper function to compare two (score, list_indices) tuples\\n        def best_of(val1, val2):\\n            s1, l1 = val1\\n            s2, l2 = val2\\n\\n            if s1 == -1: return val2\\n            if s2 == -1: return val1\\n            \\n            if s1 > s2: return val1\\n            if s2 > s1: return val2\\n            \\n            if l1 < l2: return val1\\n            else: return val2\\n\\n        # Dynamic Programming\\n        for k_count in range(1, 5): # k_count = number of intervals to choose (1 to 4)\\n            for i in range(n): # i = index in s_intervals\\n                l_i, r_i, w_i, original_idx_i = s_intervals[i]\\n                \\n                # Find best previous state for k_count-1 intervals\\n                # p is the largest index in s_intervals such that s_intervals[p].end < l_i AND p < i.\\n                # bisect_left on r_coords[0...i-1] finds insertion point for l_i.\\n                p_search_idx = bisect.bisect_left(r_coords, l_i, 0, i)\\n                p = p_search_idx - 1\\n                \\n                prev_choice_tuple = (-1, [])\\n                if k_count == 1:\\n                    # Base case for 1st interval: prev state is (score 0, empty list)\\n                    prev_choice_tuple = (0, [])\\n                elif p != -1: # If a valid predecessor region s_intervals[0...p] exists\\n                    # max_so_far[k_count-1][p] has the best choice for k_count-1 intervals ending by s_intervals[p]\\n                    prev_choice_tuple = max_so_far[k_count-1][p] \\n                \\n                if prev_choice_tuple[0] != -1: # If a valid previous state chain exists\\n                    prev_score, prev_indices = prev_choice_tuple\\n                    current_score = w_i + prev_score\\n                    \\n                    current_indices_list = prev_indices + [original_idx_i]\\n                    current_indices_list.sort() # Keep sorted for lexicographical comparison\\n\\n                    dp[k_count][i] = (current_score, current_indices_list)\\n                \\n                # Update max_so_far[k_count][i]\\n                if i == 0:\\n                    max_so_far[k_count][i] = dp[k_count][i]\\n                else:\\n                    max_so_far[k_count][i] = best_of(max_so_far[k_count][i-1], dp[k_count][i])\\n        \\n        # Determine the final answer\\n        final_ans_tuple = (0, []) # Default: 0 intervals, score 0, empty list\\n\\n        if n > 0:\\n            for k_chosen in range(1, 5):\\n                # Best for k_chosen intervals is in max_so_far[k_chosen][n-1]\\n                if max_so_far[k_chosen][n-1][0] != -1: # Check if valid choice exists\\n                    final_ans_tuple = best_of(final_ans_tuple, max_so_far[k_chosen][n-1])\\n        \\n        return final_ans_tuple[1]\"",
  "513_14631217_python-updated-time": "1745446335185",
  "892_14631217_python-updated-time": "1745954026355",
  "90_14631217_python-updated-time": "1745015626369",
  "41_14631217_python-updated-time": "1744999305542",
  "2293_14631217_python-updated-time": "1744977667046",
  "948_14631217_python-updated-time": "1746003202841",
  "273_14631217_python-updated-time": "1745248219949",
  "2196_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev_group_tail = dummy\\n        curr = head\\n        group_size = 1\\n        \\n        while curr:\\n            # 1) Count how many nodes are in this group (up to group_size)\\n            count = 0\\n            node = curr\\n            while node and count < group_size:\\n                node = node.next\\n                count += 1\\n            next_group_head = node\\n            \\n            # 2) If even length, reverse; else leave as is\\n            if count % 2 == 0:\\n                # Reverse 'count' nodes starting at curr\\n                prev = next_group_head\\n                node_to_rev = curr\\n                for _ in range(count):\\n                    nxt = node_to_rev.next\\n                    node_to_rev.next = prev\\n                    prev = node_to_rev\\n                    node_to_rev = nxt\\n                # Link into list\\n                prev_group_tail.next = prev\\n                new_tail = curr  # curr is now tail of reversed group\\n            else:\\n                # No reversal: the group stays [curr ... new_tail]\\n                new_tail = curr\\n                for _ in range(count - 1):\\n                    new_tail = new_tail.next\\n            \\n            # 3) Advance pointers for next iteration\\n            prev_group_tail = new_tail\\n            curr = next_group_head\\n            group_size += 1\\n        \\n        return dummy.next\\n\"",
  "1532_14631217_python-updated-time": "1746346845340",
  "2346_14631217_python": "\"class Solution:\\n    def largestGoodInteger(self, num):\\n        best = \\\"\\\"\\n        for i in range(len(num) - 2):\\n            if num[i] == num[i+1] == num[i+2]:\\n                candidate = num[i] * 3\\n                if candidate > best:\\n                    best = candidate\\n        return best\\n\"",
  "2219_14631217_python": "\"class Solution:\\n    def mostWordsFound(self, sentences):\\n        return max(len(sentence.split()) for sentence in sentences)\\n\"",
  "2663_14631217_python-updated-time": "1747067154947",
  "3262_14631217_python": "\"class Solution(object):\\n    def largestPerimeter(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        total = sum(nums)\\n        \\n        for i in range(len(nums) - 1, 1, -1):\\n            if total - nums[i] > nums[i]:\\n                return total\\n            total -= nums[i]\\n        \\n        return -1\\n\"",
  "753_14631217_python-updated-time": "1745875642964",
  "1343_14631217_python-updated-time": "1746259121764",
  "42_14631217_python-updated-time": "1744999352993",
  "184_14631217_mysql-updated-time": "1745092585808",
  "2669_14631217_python": "\"class Solution:\\n    def maximumCostSubstring(self, s, chars, vals):\\n        # Map character to custom value if it exists\\n        value_map = {c: v for c, v in zip(chars, vals)}\\n        \\n        def get_value(ch):\\n            return value_map.get(ch, ord(ch) - ord('a') + 1)\\n        \\n        max_sum = 0\\n        current = 0\\n        for ch in s:\\n            current += get_value(ch)\\n            if current < 0:\\n                current = 0\\n            max_sum = max(max_sum, current)\\n        \\n        return max_sum\\n\"",
  "867_14631217_python": "\"class Solution(object):\\n    def new21Game(self, n, k, maxPts):\\n        if k == 0 or n >= k + maxPts:\\n            return 1.0\\n        \\n        dp = [0.0] * (n + 1)\\n        dp[0] = 1.0\\n        window_sum = 1.0\\n        result = 0.0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = window_sum / maxPts\\n            if i < k:\\n                window_sum += dp[i]\\n            else:\\n                result += dp[i]\\n            if i - maxPts >= 0:\\n                window_sum -= dp[i - maxPts]\\n        \\n        return result\\n\"",
  "3152_14631217_python-updated-time": "1747305272444",
  "893_14631217_python-updated-time": "1745954169518",
  "1948_14631217_mysql-updated-time": "1746542797338",
  "468_14631217_python": "\"class Solution:\\n    def validIPAddress(self, queryIP):\\n        def isIPv4(ip):\\n            parts = ip.split('.')\\n            if len(parts) != 4:\\n                return False\\n            for part in parts:\\n                if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == '0' and len(part) > 1):\\n                    return False\\n            return True\\n\\n        def isIPv6(ip):\\n            parts = ip.split(':')\\n            if len(parts) != 8:\\n                return False\\n            for part in parts:\\n                if not (1 <= len(part) <= 4) or not all(c in '0123456789abcdefABCDEF' for c in part):\\n                    return False\\n            return True\\n\\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\\n            return \\\"IPv4\\\"\\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\\n            return \\\"IPv6\\\"\\n        else:\\n            return \\\"Neither\\\"\\n\"",
  "1364_14631217_python": "\"class Solution:\\n    def tupleSameProduct(self, nums):\\n        from collections import defaultdict\\n\\n        prod_count = defaultdict(int)\\n        n = len(nums)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                prod = nums[i] * nums[j]\\n                prod_count[prod] += 1\\n\\n        res = 0\\n        for count in prod_count.values():\\n            if count > 1:\\n                res += count * (count - 1) * 4  # 4 permutations per pair\\n        return res\\n\"",
  "1423_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\\n        count = Counter()\\n        max_occurrences = 0\\n\\n        for i in range(len(s) - minSize + 1):\\n            substr = s[i:i + minSize]\\n            unique_letters = len(set(substr))\\n            if unique_letters <= maxLetters:\\n                count[substr] += 1\\n                max_occurrences = max(max_occurrences, count[substr])\\n\\n        return max_occurrences\\n\"",
  "806_14631217_python": "\"class Solution(object):\\n    def numTilings(self, n):\\n        mod = 10**9 + 7\\n        dp = [0] * (n+3)\\n        dp[0], dp[1], dp[2] = 1, 1, 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = (2 * dp[i-1] + dp[i-3]) % mod\\n        \\n        return dp[n]\\n\"",
  "1043_14631217_python-updated-time": "1746040916977",
  "2471_14631217_python-updated-time": "1746965457974",
  "943_14631217_python-updated-time": "1746002959915",
  "1317_14631217_mysql": "\"SELECT \\n    DATE_FORMAT(trans_date, '%Y-%m') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(state = 'approved') AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n\"",
  "3821_14631217_python": "\"class Solution(object):\\n    def countCells(self, grid, pattern):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[str]]\\n        :type pattern: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        N = m * n\\n        L = len(pattern)\\n        \\n        # 1. Build H and V strings\\n        H = [''] * N\\n        V = [''] * N\\n        for r in range(m):\\n            for c in range(n):\\n                idxH = r * n + c\\n                idxV = c * m + r\\n                H[idxH] = grid[r][c]\\n                V[idxV] = grid[r][c]\\n        H = ''.join(H)\\n        V = ''.join(V)\\n        \\n        # 2. Build KMP LPS array for pattern\\n        lps = [0] * L\\n        j = 0\\n        for i in range(1, L):\\n            while j > 0 and pattern[i] != pattern[j]:\\n                j = lps[j-1]\\n            if pattern[i] == pattern[j]:\\n                j += 1\\n            lps[i] = j\\n        \\n        # Helper to mark coverage in diff array\\n        def mark_matches(text, diff):\\n            j = 0\\n            for i, ch in enumerate(text):\\n                while j > 0 and ch != pattern[j]:\\n                    j = lps[j-1]\\n                if ch == pattern[j]:\\n                    j += 1\\n                    if j == L:\\n                        start = i - L + 1\\n                        diff[start] += 1\\n                        diff[start + L] -= 1\\n                        j = lps[j-1]\\n                # otherwise continue\\n                \\n        # 3. Diff arrays for H and V\\n        diffH = [0] * (N + 1)\\n        diffV = [0] * (N + 1)\\n        \\n        mark_matches(H, diffH)\\n        mark_matches(V, diffV)\\n        \\n        # 4. Prefix-sum to get coverage counts\\n        covH = [0] * N\\n        covV = [0] * N\\n        running = 0\\n        for i in range(N):\\n            running += diffH[i]\\n            covH[i] = running\\n        running = 0\\n        for i in range(N):\\n            running += diffV[i]\\n            covV[i] = running\\n        \\n        # 5. Count cells where both covered > 0\\n        ans = 0\\n        for r in range(m):\\n            baseH = r * n\\n            for c in range(n):\\n                if covH[baseH + c] > 0 and covV[c * m + r] > 0:\\n                    ans += 1\\n        return ans\\n\"",
  "3534_14631217_python": "\"class Solution(object):\\n    def countPairs(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        Two numbers are almost equal if one swap within the digits of one number (at most once) can make them equal, allowing leading zeros.\\n        Brute-force each pair with up to O(d^2) swaps, total O(n^2 d^2) for n<=100, d<=7.\\n        \\\"\\\"\\\"\\n        def can_swap_to(a_str, target):\\n            # Try every swap of two positions in a_str to match target int\\n            n = len(a_str)\\n            for i in range(n):\\n                for j in range(i+1, n):\\n                    lst = list(a_str)\\n                    lst[i], lst[j] = lst[j], lst[i]\\n                    # strip leading zeros\\n                    s = ''.join(lst).lstrip('0')\\n                    if not s:\\n                        val = 0\\n                    else:\\n                        val = int(s)\\n                    if val == target:\\n                        return True\\n            return False\\n\\n        count = 0\\n        n = len(nums)\\n        # Precompute strings\\n        str_nums = [str(x) for x in nums]\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                a, b = nums[i], nums[j]\\n                if a == b:\\n                    count += 1\\n                else:\\n                    # try swap in a to get b\\n                    if can_swap_to(str_nums[i], b):\\n                        count += 1\\n                    # else try swap in b to get a\\n                    elif can_swap_to(str_nums[j], a):\\n                        count += 1\\n        return count\"",
  "1093_14631217_python": "\"class Solution:\\n    def recoverFromPreorder(self, traversal):\\n        # Parse into list of (depth, value)\\n        nodes = []\\n        i = 0\\n        n = len(traversal)\\n        while i < n:\\n            depth = 0\\n            while i < n and traversal[i] == '-':\\n                depth += 1\\n                i += 1\\n            val = 0\\n            while i < n and traversal[i].isdigit():\\n                val = val * 10 + int(traversal[i])\\n                i += 1\\n            nodes.append((depth, val))\\n        \\n        # Reconstruct tree\\n        root = TreeNode(nodes[0][1])\\n        stack = [root]\\n        for depth, val in nodes[1:]:\\n            # pop to parent depth\\n            while len(stack) > depth:\\n                stack.pop()\\n            node = TreeNode(val)\\n            parent = stack[-1]\\n            if not parent.left:\\n                parent.left = node\\n            else:\\n                parent.right = node\\n            stack.append(node)\\n        \\n        return root\\n\"",
  "1483_14631217_python-updated-time": "1746345399578",
  "1658_14631217_python-updated-time": "1746434188426",
  "1793_14631217_python-updated-time": "1746452626197",
  "45_14631217_python-updated-time": "1744999467583",
  "3451_14631217_python": "\"class Solution(object):\\n    def compressedString(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if not word:\\n            return \\\"\\\"\\n        \\n        res = []\\n        count = 1\\n        \\n        # scan from the second character onward\\n        for i in range(1, len(word)):\\n            if word[i] == word[i-1] and count < 9:\\n                # same char and haven't hit the cap yet\\n                count += 1\\n            else:\\n                # either different char or cap reached:\\n                # flush the run we just counted\\n                res.append(str(count))\\n                res.append(word[i-1])\\n                # start a new run\\n                count = 1\\n        \\n        # flush the final run\\n        res.append(str(count))\\n        res.append(word[-1])\\n        \\n        return \\\"\\\".join(res)\\n\"",
  "2091_14631217_python-updated-time": "1746715620680",
  "839_14631217_python": "\"class Solution(object):\\n    def minimumLengthEncoding(self, words):\\n        words = set(words)\\n        for word in list(words):\\n            for k in range(1, len(word)):\\n                words.discard(word[k:])\\n        return sum(len(word) + 1 for word in words)\\n\"",
  "937_14631217_python-updated-time": "1746002461283",
  "2349_14631217_python": "\"class Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        # Quick checks\\n        if grid[0][0] == ')' or grid[m-1][n-1] == '(':\\n            return False\\n        # dp[i][j] = set of possible balances at cell (i,j)\\n        dp = [ [set() for _ in range(n)] for _ in range(m) ]\\n        # Start at (0,0) with balance 1\\n        dp[0][0].add(1)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    continue\\n                char = grid[i][j]\\n                balances = set()\\n                # Gather from top\\n                if i > 0:\\n                    balances |= dp[i-1][j]\\n                # Gather from left\\n                if j > 0:\\n                    balances |= dp[i][j-1]\\n                if not balances:\\n                    continue\\n                new_bal = set()\\n                if char == '(':\\n                    # increase every balance by 1\\n                    for b in balances:\\n                        new_bal.add(b+1)\\n                else:\\n                    # char == ')', decrease if possible\\n                    for b in balances:\\n                        if b > 0:\\n                            new_bal.add(b-1)\\n                dp[i][j] = new_bal\\n        \\n        # Check if 0 balance at destination\\n        return 0 in dp[m-1][n-1]\\n\"",
  "1927_14631217_python": "\"class Solution(object):\\n    def maxAscendingSum(self, nums):\\n        max_sum = curr_sum = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                curr_sum += nums[i]\\n            else:\\n                curr_sum = nums[i]\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n\"",
  "2859_14631217_javascript-updated-time": "1747140897974",
  "130_14631217_python": "\"class Solution(object):\\n    def solve(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \\\"\\\"\\\"\\n        if not board or not board[0]:\\n            return\\n        \\n        m, n = len(board), len(board[0])\\n        \\n        # DFS to mark unsurrounded 'O's (connected to border)\\n        def dfs(i, j):\\n            if (i < 0 or i >= m or j < 0 or j >= n or \\n                board[i][j] != 'O'):\\n                return\\n            \\n            # Mark as a temporary state to avoid revisiting\\n            board[i][j] = 'E'  # 'E' for \\\"escape\\\"\\n            \\n            # Check all four directions\\n            dfs(i+1, j)\\n            dfs(i-1, j)\\n            dfs(i, j+1)\\n            dfs(i, j-1)\\n        \\n        # Step 1: Mark all 'O's on the border and their connected cells\\n        for i in range(m):\\n            dfs(i, 0)         # First column\\n            dfs(i, n-1)       # Last column\\n        \\n        for j in range(n):\\n            dfs(0, j)         # First row\\n            dfs(m-1, j)       # Last row\\n        \\n        # Step 2: Capture surrounded regions and restore unsurrounded ones\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == 'O':\\n                    # This 'O' is surrounded, capture it\\n                    board[i][j] = 'X'\\n                elif board[i][j] == 'E':\\n                    # This 'O' was connected to the border, restore it\\n                    board[i][j] = 'O'\"",
  "1733_14631217_python-updated-time": "1746444034064",
  "74_14631217_python": "\"class Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not matrix or not matrix[0]:\\n            return False\\n\\n        m, n = len(matrix), len(matrix[0])\\n        left, right = 0, m * n - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            num = matrix[mid // n][mid % n]\\n            if num == target:\\n                return True\\n            elif num < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return False\\n\"",
  "341_14631217_python": "\"class NestedIterator(object):\\n    def __init__(self, nestedList):\\n        \\\"\\\"\\\"\\n        :type nestedList: List[NestedInteger]\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self._flatten(nestedList)\\n        self.stack.reverse()\\n\\n    def _flatten(self, nestedList):\\n        for item in nestedList:\\n            if item.isInteger():\\n                self.stack.append(item.getInteger())\\n            else:\\n                self._flatten(item.getList())\\n\\n    def next(self):\\n        \\\"\\\"\\\"\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self.stack.pop()\\n\\n    def hasNext(self):\\n        \\\"\\\"\\\"\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return bool(self.stack)\\n\"",
  "1429_14631217_python": "\"class Solution:\\n    def isSolvable(self, words, result):\\n        weight = {}\\n        leading = set()\\n\\n        # Build weights for each character\\n        for w in words:\\n            if len(w) > 1:\\n                leading.add(w[0])\\n            mul = 1\\n            for c in reversed(w):\\n                weight[c] = weight.get(c, 0) + mul\\n                mul *= 10\\n\\n        if len(result) > 1:\\n            leading.add(result[0])\\n        mul = 1\\n        for c in reversed(result):\\n            weight[c] = weight.get(c, 0) - mul\\n            mul *= 10\\n\\n        chars = list(weight.keys())\\n        # Sort by descending absolute weight\\n        chars.sort(key=lambda c: -abs(weight[c]))\\n        n = len(chars)\\n\\n        # Precompute remaining possible sum bounds for pruning\\n        pos_weights = [weight[c] for c in chars]\\n        rem_max = [0] * (n + 1)\\n        rem_min = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            w9 = pos_weights[i] * 9\\n            rem_max[i] = rem_max[i + 1] + max(0, w9)\\n            rem_min[i] = rem_min[i + 1] + min(0, w9)\\n\\n        used = [False] * 10\\n\\n        def dfs(idx, curr_sum):\\n            # Prune if even best/worst assignments can't reach zero\\n            if curr_sum + rem_min[idx] > 0 or curr_sum + rem_max[idx] < 0:\\n                return False\\n            if idx == n:\\n                return curr_sum == 0\\n\\n            w = pos_weights[idx]\\n            c = chars[idx]\\n            for d in range(10):\\n                if used[d] or (d == 0 and c in leading):\\n                    continue\\n                used[d] = True\\n                if dfs(idx + 1, curr_sum + w * d):\\n                    return True\\n                used[d] = False\\n            return False\\n\\n        return dfs(0, 0)\\n\"",
  "587_14631217_python-updated-time": "1745448139056",
  "2085_14631217_python": "\"class Solution(object):\\n    def rearrangeArray(self, nums):\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(1, n, 2):\\n            if i+1 < n:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n        return nums\\n\"",
  "2510_14631217_python": "\"class Solution(object):\\n    def deleteString(self, s):\\n        n = len(s)\\n        # 1) Build LCP table in O(n^2):\\n        #    lcp[i][j] = length of longest common prefix of s[i:] and s[j:]\\n        lcp = [ [0]*n for _ in range(n) ]\\n        for i in range(n-1, -1, -1):\\n            si = s[i]\\n            row_i = lcp[i]\\n            for j in range(n-1, i, -1):\\n                if si == s[j]:\\n                    row_i[j] = 1 + (lcp[i+1][j+1] if j+1<n else 0)\\n\\n        # 2) dp[i] = max ops to delete s[i:]\\n        dp = [0]*(n+1)\\n        # dp[n] = 0 by default\\n        for i in range(n-1, -1, -1):\\n            best = 1  # you can always delete the entire suffix\\n            limit = (n - i) // 2\\n            li = lcp[i]\\n            dpi = dp  # local alias\\n            for ell in range(1, limit+1):\\n                # if first ell chars == next ell chars\\n                if li[i+ell] >= ell:\\n                    val = 1 + dpi[i+ell]\\n                    if val > best:\\n                        best = val\\n            dp[i] = best\\n\\n        return dp[0]\\n\"",
  "1700_14631217_python": "\"class Solution(object):\\n    def minCost(self, colors, neededTime):\\n        \\\"\\\"\\\"\\n        :type colors: str\\n        :type neededTime: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = 0\\n        # sum_time is the sum of removal times in the current same-color group\\n        # max_time is the maximum removal time in that group\\n        sum_time = 0\\n        max_time = 0\\n        prev = None\\n        \\n        for c, t in zip(colors, neededTime):\\n            if c != prev:\\n                # finish previous group: remove all but the max\\n                total += sum_time - max_time\\n                # start new group\\n                sum_time = t\\n                max_time = t\\n                prev = c\\n            else:\\n                # continue the same-color group\\n                sum_time += t\\n                if t > max_time:\\n                    max_time = t\\n        \\n        # handle the last group\\n        total += sum_time - max_time\\n        return total\\n\"",
  "2406_14631217_python": "\"class Solution:\\n    def decodeMessage(self, key, message):\\n        mapping = {}\\n        current = 'a'\\n\\n        for char in key:\\n            if char != ' ' and char not in mapping:\\n                mapping[char] = current\\n                current = chr(ord(current) + 1)\\n\\n        return ''.join(mapping[c] if c in mapping else ' ' for c in message)\\n\"",
  "381_14631217_python-updated-time": "1745354978185",
  "1_14631217_python-updated-time": "1745441055191",
  "201_14631217_python-updated-time": "1745093206054",
  "3738_14631217_python-updated-time": "1747683684034",
  "1258_14631217_mysql-updated-time": "1746125922958",
  "738_14631217_python": "\"class Solution(object):\\n    def monotoneIncreasingDigits(self, n):\\n        digits = list(str(n))\\n        mark = len(digits)\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] < digits[i-1]:\\n                digits[i-1] = str(int(digits[i-1]) - 1)\\n                mark = i\\n        for j in range(mark, len(digits)):\\n            digits[j] = '9'\\n        return int(''.join(digits))\\n\"",
  "390_14631217_python-updated-time": "1745355398299",
  "2761_14631217_javascript": "\"function reduce(nums, fn, init) {\\n  let val = init;\\n  for (let i = 0; i < nums.length; i++) {\\n    val = fn(val, nums[i]);\\n  }\\n  return val;\\n}\\n\"",
  "796_14631217_python": "\"class Solution(object):\\n    def reachingPoints(self, sx, sy, tx, ty):\\n        while tx >= sx and ty >= sy:\\n            if tx == sx and ty == sy:\\n                return True\\n            if tx > ty:\\n                if ty > sy:\\n                    tx %= ty\\n                else:\\n                    return (tx - sx) % ty == 0\\n            else:\\n                if tx > sx:\\n                    ty %= tx\\n                else:\\n                    return (ty - sy) % tx == 0\\n        return False\\n\"",
  "3466_14631217_python-updated-time": "1747486979828",
  "1801_14631217_mysql-updated-time": "1746445633658",
  "741_14631217_python-updated-time": "1745875339824",
  "3412_14631217_python": "\"class Solution(object):\\n    def findPermutationDifference(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Build a dictionary to store the index of each character in s\\n        pos_s = {ch: i for i, ch in enumerate(s)}\\n        res = 0\\n\\n        # Go through each character in t and compute the difference in index\\n        for i, ch in enumerate(t):\\n            res += abs(pos_s[ch] - i)\\n\\n        return res\\n\"",
  "1033_14631217_python": "\"class Solution:\\n    def brokenCalc(self, startValue, target):\\n        operations = 0\\n        while target > startValue:\\n            if target % 2 == 0:\\n                target //= 2\\n            else:\\n                target += 1\\n            operations += 1\\n        return operations + (startValue - target)\\n\"",
  "3583_14631217_python": "\"class Solution(object):\\n    def gcdValues(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        import bisect\\n\\n        n = len(nums)\\n        M = max(nums)\\n\\n        # 1) freq[x] = how many times x appears\\n        freq = [0] * (M + 1)\\n        for x in nums:\\n            freq[x] += 1\\n\\n        # 2) c[d] = count of numbers divisible by d\\n        c = [0] * (M + 1)\\n        for d in range(1, M + 1):\\n            for m in range(d, M + 1, d):\\n                c[d] += freq[m]\\n\\n        # 3) f[d] = total pairs (i<j) with both nums divisible by d\\n        f = [0] * (M + 1)\\n        for d in range(1, M + 1):\\n            if c[d] >= 2:\\n                f[d] = c[d] * (c[d] - 1) // 2\\n\\n        # 4) g[d] = # pairs whose GCD is exactly d\\n        #    g[d] = f[d] - sum_{k>=2} g[k*d]\\n        g = [0] * (M + 1)\\n        for d in range(M, 0, -1):\\n            total = f[d]\\n            # subtract off multiples\\n            for k in range(2, (M // d) + 1):\\n                total -= g[d * k]\\n            g[d] = total\\n\\n        # 5) build prefix sums of counts, so we can do order-statistic queries\\n        pref = [0] * (M + 1)\\n        running = 0\\n        for d in range(1, M + 1):\\n            running += g[d]\\n            pref[d] = running\\n\\n        # 6) answer each query by binary‐searching the smallest d with pref[d] > q\\n        ans = []\\n        for q in queries:\\n            # we want the first d so that pref[d] > q  (0-based indexing of sorted gcds)\\n            d = bisect.bisect_left(pref, q + 1, 1, M + 1)\\n            ans.append(d)\\n\\n        return ans\\n\"",
  "1882_14631217_mysql": "\"SELECT\\n  e.employee_id,\\n  e.name,\\n  COUNT(*) AS reports_count,\\n  ROUND(AVG(r.age), 0) AS average_age\\nFROM Employees AS e\\nJOIN Employees AS r\\n  ON r.reports_to = e.employee_id\\nGROUP BY\\n  e.employee_id,\\n  e.name\\nORDER BY\\n  e.employee_id;\\n\"",
  "3648_14631217_python-updated-time": "1747595562302",
  "1668_14631217_python": "\"class Solution(object):\\n    def longestAwesome(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seen = {0: -1}\\n        max_len = 0\\n        mask = 0\\n\\n        for i, ch in enumerate(s):\\n            digit = int(ch)\\n            mask ^= (1 << digit)\\n\\n            if mask in seen:\\n                max_len = max(max_len, i - seen[mask])\\n            else:\\n                seen[mask] = i\\n\\n            for j in range(10):\\n                test_mask = mask ^ (1 << j)\\n                if test_mask in seen:\\n                    max_len = max(max_len, i - seen[test_mask])\\n\\n        return max_len\\n\"",
  "1918_14631217_python-updated-time": "1746542767611",
  "3348_14631217_python-updated-time": "1747423567476",
  "3195_14631217_python-updated-time": "1747311843036",
  "468_14631217_python-updated-time": "1745359868786",
  "1680_14631217_python": "\"class Solution(object):\\n    def countRoutes(self, locations, start, finish, fuel):\\n        MOD = 10**9 + 7\\n        n = len(locations)\\n        memo = {}\\n        \\n        def dfs(city, rem):\\n            if (city, rem) in memo:\\n                return memo[(city, rem)]\\n            ways = 1 if city == finish else 0\\n            for nxt in range(n):\\n                if nxt != city:\\n                    cost = abs(locations[city] - locations[nxt])\\n                    if cost <= rem:\\n                        ways = (ways + dfs(nxt, rem - cost)) % MOD\\n            memo[(city, rem)] = ways\\n            return ways\\n        \\n        return dfs(start, fuel)\\n\"",
  "805_14631217_python": "\"class Solution(object):\\n    def escapeGhosts(self, ghosts, target):\\n        player_dist = abs(target[0]) + abs(target[1])\\n        for gx, gy in ghosts:\\n            ghost_dist = abs(gx - target[0]) + abs(gy - target[1])\\n            if ghost_dist <= player_dist:\\n                return False\\n        return True\\n\"",
  "1396_14631217_python": "\"class Solution:\\n    def countServers(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        row_count = [0] * m\\n        col_count = [0] * n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    row_count[i] += 1\\n                    col_count[j] += 1\\n\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1 and (row_count[i] > 1 or col_count[j] > 1):\\n                    count += 1\\n\\n        return count\\n\"",
  "1875_14631217_python": "\"from collections import defaultdict\\nimport sys\\nsys.setrecursionlimit(1 << 20)\\n\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\n\\nclass Solution(object):\\n    def getCoprimes(self, nums, edges):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # Precompute coprime relations\\n        coprime_map = [[] for _ in range(51)]\\n        for i in range(1, 51):\\n            for j in range(1, 51):\\n                if gcd(i, j) == 1:\\n                    coprime_map[i].append(j)\\n\\n        # Map from num -> list of (depth, node)\\n        ancestors = defaultdict(list)\\n        ans = [-1] * n\\n\\n        def dfs(node, parent, depth):\\n            max_depth = -1\\n            best_ancestor = -1\\n\\n            # Check all coprime candidates\\n            for val in coprime_map[nums[node]]:\\n                if ancestors[val]:\\n                    d, anc = ancestors[val][-1]\\n                    if d > max_depth:\\n                        max_depth = d\\n                        best_ancestor = anc\\n\\n            ans[node] = best_ancestor\\n\\n            # Push current node into ancestor stack\\n            ancestors[nums[node]].append((depth, node))\\n\\n            for nei in graph[node]:\\n                if nei != parent:\\n                    dfs(nei, node, depth + 1)\\n\\n            # Backtrack\\n            ancestors[nums[node]].pop()\\n\\n        dfs(0, -1, 0)\\n        return ans\\n\"",
  "2887_14631217_python": "\"class Solution:\\n    def sortVowels(self, s):\\n        vowels = set('aeiouAEIOU')\\n        vlist = sorted([ch for ch in s if ch in vowels])\\n        res = []\\n        vi = 0\\n        for ch in s:\\n            if ch in vowels:\\n                res.append(vlist[vi])\\n                vi += 1\\n            else:\\n                res.append(ch)\\n        return ''.join(res)\\n\"",
  "3852_14631217_python-updated-time": "1747758063766",
  "792_14631217_python": "\"class Solution(object):\\n    def search(self, nums, target):\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1\\n\"",
  "2878_14631217_python-updated-time": "1747222289604",
  "1547_14631217_python": "\"class Solution:\\n    def destCity(self, paths):\\n        departure_cities = set(cityA for cityA, _ in paths)\\n        for _, cityB in paths:\\n            if cityB not in departure_cities:\\n                return cityB\\n\"",
  "2521_14631217_python": "\"class Solution:\\n    def numberOfPaths(self, grid, k):\\n        MOD = 10**9 + 7\\n        m, n = len(grid), len(grid[0])\\n        # Ensure n <= m by transposing if needed (to minimize DP width)\\n        if n > m:\\n            # Transpose grid\\n            grid = list(map(list, zip(*grid)))\\n            m, n = n, m\\n\\n        # dp[j][r]: number of ways to reach column j in current row with sum mod k == r\\n        dp = [ [0]*k for _ in range(n) ]\\n\\n        for i in range(m):\\n            new_dp = [ [0]*k for _ in range(n) ]\\n            for j in range(n):\\n                val = grid[i][j] % k\\n                if i == 0 and j == 0:\\n                    # start cell\\n                    new_dp[0][val] = 1\\n                else:\\n                    # from top (previous row, same col)\\n                    if i > 0:\\n                        for r in range(k):\\n                            cnt = dp[j][r]\\n                            if cnt:\\n                                new_dp[j][(r + val) % k] = (new_dp[j][(r + val) % k] + cnt) % MOD\\n                    # from left (current row, col-1)\\n                    if j > 0:\\n                        left = new_dp[j-1]\\n                        for r in range(k):\\n                            cnt = left[r]\\n                            if cnt:\\n                                new_dp[j][(r + val) % k] = (new_dp[j][(r + val) % k] + cnt) % MOD\\n            dp = new_dp\\n\\n        # answer at bottom-right cell, sum mod k == 0\\n        return dp[n-1][0]\\n\"",
  "1470_14631217_python": "\"from collections import defaultdict\\nimport bisect\\n\\nclass TweetCounts:\\n    def __init__(self):\\n        # Map each tweetName to a sorted list of timestamps\\n        self.times = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        # Insert time into the sorted list\\n        lst = self.times[tweetName]\\n        bisect.insort(lst, time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        # Determine chunk size\\n        if freq == \\\"minute\\\":\\n            delta = 60\\n        elif freq == \\\"hour\\\":\\n            delta = 3600\\n        else:  # \\\"day\\\"\\n            delta = 86400\\n\\n        # Number of chunks in [startTime, endTime]\\n        num_chunks = (endTime - startTime) // delta + 1\\n        counts = [0] * num_chunks\\n\\n        lst = self.times.get(tweetName, [])\\n        if not lst:\\n            return counts\\n\\n        # Find the slice of timestamps within [startTime, endTime]\\n        lo = bisect.bisect_left(lst, startTime)\\n        hi = bisect.bisect_right(lst, endTime)\\n\\n        # Bucket each timestamp into its chunk\\n        for t in lst[lo:hi]:\\n            idx = (t - startTime) // delta\\n            counts[idx] += 1\\n\\n        return counts\\n\"",
  "2058_14631217_python": "\"class Solution(object):\\n    def getConcatenation(self, nums):\\n        return nums + nums\\n\"",
  "2352_14631217_python-updated-time": "1746879634756",
  "1929_14631217_python-updated-time": "1746543016526",
  "2686_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumCost(self, start, target, specialRoads):\\n        \\\"\\\"\\\"\\n        :type start: List[int]\\n        :type target: List[int]\\n        :type specialRoads: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Collect all key points: start, target, and both ends of each special road\\n        points = [tuple(start), tuple(target)]\\n        for x1, y1, x2, y2, c in specialRoads:\\n            points.append((x1, y1))\\n            points.append((x2, y2))\\n        # Deduplicate and index them\\n        pts = list(dict.fromkeys(points))\\n        idx = {p:i for i,p in enumerate(pts)}\\n        N = len(pts)\\n        \\n        # Build adjacency list\\n        adj = [[] for _ in range(N)]\\n        # 1) direct edges between every pair via Manhattan distance\\n        for i in range(N):\\n            x1,y1 = pts[i]\\n            for j in range(N):\\n                if i==j: continue\\n                x2,y2 = pts[j]\\n                cost = abs(x2-x1) + abs(y2-y1)\\n                adj[i].append((j, cost))\\n        # 2) override with special roads (directed)\\n        for x1,y1,x2,y2,c in specialRoads:\\n            u = idx[(x1,y1)]\\n            v = idx[(x2,y2)]\\n            adj[u].append((v, c))\\n        \\n        # Dijkstra from start to target\\n        src = idx[tuple(start)]\\n        dst = idx[tuple(target)]\\n        dist = [float('inf')] * N\\n        dist[src] = 0\\n        heap = [(0, src)]\\n        \\n        while heap:\\n            d,u = heapq.heappop(heap)\\n            if d>dist[u]: continue\\n            if u==dst:\\n                return d\\n            for v, w in adj[u]:\\n                nd = d + w\\n                if nd < dist[v]:\\n                    dist[v] = nd\\n                    heapq.heappush(heap, (nd, v))\\n        return -1  # should never happen\\n\\n# Example usage:\\n# sol = Solution()\\n# print(sol.minimumCost([1,1], [4,5], [[1,2,3,3,2],[3,4,4,5,1]]))  # 5\\n\"",
  "3560_14631217_python-updated-time": "1747571426389",
  "2786_14631217_python": "\"class Solution(object):\\n    def longestSemiRepetitiveSubstring(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_len = 0\\n        left = 0\\n        count = 0\\n\\n        for right in range(1, len(s)):\\n            if s[right] == s[right - 1]:\\n                count += 1\\n            while count > 1:\\n                if s[left] == s[left + 1]:\\n                    count -= 1\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n\\n        return max(max_len, 1)\\n\"",
  "482_14631217_python": "\"class Solution(object):\\n    def licenseKeyFormatting(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        s = s.replace('-', '').upper()\\n        n = len(s)\\n        first = n % k or k\\n        parts = [s[:first]]\\n        for i in range(first, n, k):\\n            parts.append(s[i:i + k])\\n        return '-'.join(parts)\\n\"",
  "1560_14631217_python-updated-time": "1746347646384",
  "2265_14631217_python": "\"class Solution:\\n    def pivotArray(self, nums, pivot):\\n        less = []\\n        equal = []\\n        greater = []\\n        \\n        for num in nums:\\n            if num < pivot:\\n                less.append(num)\\n            elif num == pivot:\\n                equal.append(num)\\n            else:\\n                greater.append(num)\\n        \\n        return less + equal + greater\\n\"",
  "2784_14631217_python-updated-time": "1747138050184",
  "501_14631217_python-updated-time": "1745446098250",
  "1767_14631217_python": "\"class FrontMiddleBackQueue:\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def _rebalance(self):\\n        total = len(self.left) + len(self.right)\\n        target = total // 2\\n        # left should have floor(total/2) elements\\n        while len(self.left) > target:\\n            # move last of left to front of right\\n            self.right.insert(0, self.left.pop())\\n        while len(self.left) < target:\\n            # move first of right to end of left\\n            self.left.append(self.right.pop(0))\\n\\n    def pushFront(self, val):\\n        self.left.insert(0, val)\\n        self._rebalance()\\n\\n    def pushMiddle(self, val):\\n        # frontmost middle is end of left\\n        self.left.append(val)\\n        self._rebalance()\\n\\n    def pushBack(self, val):\\n        self.right.append(val)\\n        self._rebalance()\\n\\n    def popFront(self):\\n        if not self.left and not self.right:\\n            return -1\\n        if self.left:\\n            val = self.left.pop(0)\\n        else:\\n            val = self.right.pop(0)\\n        self._rebalance()\\n        return val\\n\\n    def popMiddle(self):\\n        if not self.left and not self.right:\\n            return -1\\n        total = len(self.left) + len(self.right)\\n        mid = (total - 1) // 2\\n        if mid < len(self.left):\\n            val = self.left.pop(mid)\\n        else:\\n            val = self.right.pop(mid - len(self.left))\\n        self._rebalance()\\n        return val\\n\\n    def popBack(self):\\n        if not self.left and not self.right:\\n            return -1\\n        if self.right:\\n            val = self.right.pop()\\n        else:\\n            val = self.left.pop()\\n        self._rebalance()\\n        return val\\n\"",
  "440_14631217_python": "\"class Solution:\\n    def findKthNumber(self, n, k):\\n        def get_steps(n, curr, next_curr):\\n            steps = 0\\n            while curr <= n:\\n                steps += min(n + 1, next_curr) - curr\\n                curr *= 10\\n                next_curr *= 10\\n            return steps\\n        \\n        curr = 1\\n        k -= 1  # because we start from 1 already\\n        \\n        while k > 0:\\n            steps = get_steps(n, curr, curr + 1)\\n            if steps <= k:\\n                k -= steps\\n                curr += 1\\n            else:\\n                k -= 1\\n                curr *= 10\\n        \\n        return curr\\n\"",
  "813_14631217_python": "\"class Solution(object):\\n    def allPathsSourceTarget(self, graph):\\n        res = []\\n        n = len(graph)\\n        \\n        def dfs(path, node):\\n            if node == n - 1:\\n                res.append(list(path))\\n                return\\n            for nei in graph[node]:\\n                path.append(nei)\\n                dfs(path, nei)\\n                path.pop()\\n        \\n        dfs([0], 0)\\n        return res\\n\"",
  "2756_14631217_python": "\"class Solution:\\n    def buyChoco(self, prices, money):\\n        prices.sort()\\n        total = prices[0] + prices[1]\\n        return money - total if total <= money else money\\n\"",
  "3774_14631217_python-updated-time": "1747739996357",
  "2905_14631217_python-updated-time": "1747223578259",
  "2160_14631217_python": "\"class Solution(object):\\n    def minOperations(self, grid, x):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        flat = []\\n        for row in grid:\\n            for val in row:\\n                flat.append(val)\\n\\n        base = flat[0] % x\\n        for val in flat:\\n            if val % x != base:\\n                return -1\\n\\n        flat.sort()\\n        median = flat[len(flat) // 2]\\n\\n        operations = 0\\n        for val in flat:\\n            operations += abs(val - median) // x\\n\\n        return operations\\n\"",
  "1310_14631217_python": "\"class Solution:\\n    def wateringPlants(self, plants, capacity):\\n        \\\"\\\"\\\"\\n        :type plants: List[int]\\n        :type capacity: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        curr = capacity\\n        steps = 0\\n        \\n        for i, need in enumerate(plants):\\n            # If we don’t have enough for this plant, go refill:\\n            if curr < need:\\n                # walk back from plant (i-1) to river and then out to plant i\\n                steps += 2 * i + 1\\n                curr = capacity\\n            else:\\n                # just walk one step from (i-1) to i\\n                steps += 1\\n            \\n            # water the plant\\n            curr -= need\\n        \\n        return steps\\n\"",
  "2820_14631217_lang": "\"javascript\"",
  "398_14631217_python-updated-time": "1745355665787",
  "677_14631217_python": "\"class MapSum(object):\\n    def __init__(self):\\n        self.map = {}\\n\\n    def insert(self, key, val):\\n        self.map[key] = val\\n\\n    def sum(self, prefix):\\n        total = 0\\n        for k in self.map:\\n            if k.startswith(prefix):\\n                total += self.map[k]\\n        return total\\n\"",
  "2248_14631217_python-updated-time": "1746802280545",
  "3561_14631217_python-updated-time": "1747575613644",
  "2275_14631217_python": "\"class Solution:\\n    def subStrHash(self, s, power, modulo, k, hashValue):\\n        n = len(s)\\n        result = n - k\\n        current_hash = 0\\n        power_k = pow(power, k, modulo)\\n\\n        def val(ch):\\n            return ord(ch) - ord('a') + 1\\n\\n        for i in range(n - 1, -1, -1):\\n            current_hash = (current_hash * power + val(s[i])) % modulo\\n\\n            if i + k < n:\\n                current_hash = (current_hash - val(s[i + k]) * power_k) % modulo\\n\\n            if i + k <= n and current_hash == hashValue:\\n                result = i\\n\\n        return s[result:result + k]\\n\"",
  "179_14631217_python": "\"from functools import cmp_to_key\\n\\nclass Solution(object):\\n    def largestNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        def compare(x, y):\\n            if x + y > y + x:\\n                return -1\\n            elif x + y < y + x:\\n                return 1\\n            else:\\n                return 0\\n\\n        nums = list(map(str, nums))\\n        nums.sort(key=cmp_to_key(compare))\\n        result = ''.join(nums)\\n        return '0' if result[0] == '0' else result\\n\"",
  "1047_14631217_python": "\"class Solution:\\n    def largestSumAfterKNegations(self, nums, k):\\n        nums.sort()\\n        i = 0\\n        while k > 0 and i < len(nums) and nums[i] < 0:\\n            nums[i] = -nums[i]\\n            i += 1\\n            k -= 1\\n        nums.sort()\\n        if k % 2 == 1:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n\"",
  "939_14631217_python": "\"class Solution:\\n    def numPermsDISequence(self, s):\\n        mod = 10**9 + 7\\n        # dp[i] = number of ways for the current prefix,\\n        # where the “rank” of the last element among used numbers is i.\\n        dp = [1]  # for an empty pattern, one permutation of length 1\\n        \\n        for c in s:\\n            m = len(dp) + 1\\n            new_dp = [0] * m\\n            if c == 'I':\\n                # build prefix sums of dp\\n                pre = [0] * (len(dp) + 1)\\n                for i in range(len(dp)):\\n                    pre[i+1] = (pre[i] + dp[i]) % mod\\n                # for 'I', new_dp[j] = sum(dp[0..j-1]) = pre[j]\\n                for j in range(m):\\n                    new_dp[j] = pre[j]\\n            else:  # 'D'\\n                # build suffix sums of dp\\n                suf = [0] * (len(dp) + 1)\\n                for i in range(len(dp)-1, -1, -1):\\n                    suf[i] = (suf[i+1] + dp[i]) % mod\\n                # for 'D', new_dp[j] = sum(dp[j..end]) = suf[j]\\n                for j in range(m):\\n                    new_dp[j] = suf[j]\\n            \\n            dp = new_dp\\n        \\n        return sum(dp) % mod\\n\"",
  "2360_14631217_python": "\"class Solution:\\n    def largestVariance(self, s):\\n        # Convert string to list of ints 0..25 for speed\\n        n = len(s)\\n        s_int = [ord(c) - ord('a') for c in s]\\n        \\n        # Determine which characters actually appear\\n        present = [False]*26\\n        for c in s_int:\\n            present[c] = True\\n        letters = [i for i, ok in enumerate(present) if ok]\\n        \\n        best = 0\\n        \\n        # For each ordered pair (major, minor)\\n        for x in letters:\\n            for y in letters:\\n                if x == y:\\n                    continue\\n                \\n                # Forward scan\\n                diff = 0\\n                have_y = False\\n                for c in s_int:\\n                    if c == x:\\n                        diff += 1\\n                    elif c == y:\\n                        diff -= 1\\n                        have_y = True\\n                    if have_y and diff > best:\\n                        best = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        have_y = False\\n                \\n                # Backward scan\\n                diff = 0\\n                have_y = False\\n                for c in reversed(s_int):\\n                    if c == x:\\n                        diff += 1\\n                    elif c == y:\\n                        diff -= 1\\n                        have_y = True\\n                    if have_y and diff > best:\\n                        best = diff\\n                    if diff < 0:\\n                        diff = 0\\n                        have_y = False\\n        \\n        return best\\n\"",
  "1994_14631217_python-updated-time": "1746625309156",
  "2999_14631217_python": "\"class Solution(object):\\n    def canBeEqual(self, s1, s2):\\n        return (sorted([s1[0], s1[2]]) == sorted([s2[0], s2[2]])) and \\\\\\n               (sorted([s1[1], s1[3]]) == sorted([s2[1], s2[3]]))\\n\"",
  "3828_14631217_mysql": "\"WITH RECURSIVE\\nlevels AS (\\n  SELECT employee_id, employee_name, manager_id, salary, 1 AS lvl\\n    FROM Employees\\n   WHERE manager_id IS NULL\\n  UNION ALL\\n  SELECT e.employee_id, e.employee_name, e.manager_id, e.salary, l.lvl+1\\n    FROM Employees e\\n    JOIN levels l\\n      ON e.manager_id = l.employee_id\\n),\\ntree AS (\\n  SELECT employee_id AS ancestor,\\n         employee_id AS descendant,\\n         0              AS dist\\n    FROM Employees\\n  UNION ALL\\n  SELECT t.ancestor,\\n         e.employee_id AS descendant,\\n         t.dist + 1     AS dist\\n    FROM tree t\\n    JOIN Employees e\\n      ON e.manager_id = t.descendant\\n)\\nSELECT\\n  l.employee_id,\\n  l.employee_name,\\n  l.lvl       AS level,\\n  SUM(CASE WHEN t.dist >= 1 THEN 1 ELSE 0 END) AS team_size,\\n  -- Fix: don't add l.salary again, just sum all descendant salaries (including self)\\n  SUM(d.salary) AS budget\\nFROM levels l\\nJOIN tree   t ON t.ancestor   = l.employee_id\\nJOIN Employees d ON d.employee_id = t.descendant\\nGROUP BY\\n  l.employee_id,\\n  l.employee_name,\\n  l.lvl\\nORDER BY\\n  level        ASC,\\n  budget       DESC,\\n  employee_name ASC;\\n\"",
  "1026_14631217_python": "\"class Solution:\\n    def strWithout3a3b(self, a, b):\\n        res = []\\n\\n        while a > 0 or b > 0:\\n            if a > b:\\n                if a >= 2:\\n                    res.append('aa')\\n                    a -= 2\\n                else:\\n                    res.append('a')\\n                    a -= 1\\n                if b > 0:\\n                    res.append('b')\\n                    b -= 1\\n            elif b > a:\\n                if b >= 2:\\n                    res.append('bb')\\n                    b -= 2\\n                else:\\n                    res.append('b')\\n                    b -= 1\\n                if a > 0:\\n                    res.append('a')\\n                    a -= 1\\n            else:\\n                if a > 0:\\n                    res.append('a')\\n                    a -= 1\\n                if b > 0:\\n                    res.append('b')\\n                    b -= 1\\n\\n        return ''.join(res)\\n\"",
  "907_14631217_python-updated-time": "1746001552008",
  "742_14631217_python": "\"class Solution(object):\\n    def toLowerCase(self, s):\\n        res = []\\n        for c in s:\\n            if 'A' <= c <= 'Z':\\n                # convert uppercase to lowercase by ASCII offset\\n                res.append(chr(ord(c) - ord('A') + ord('a')))\\n            else:\\n                res.append(c)\\n        return ''.join(res)\\n\"",
  "1156_14631217_python": "\"class Solution(object):\\n    def findOcurrences(self, text, first, second):\\n        \\\"\\\"\\\"\\n        :type text: str\\n        :type first: str\\n        :type second: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        words = text.split()\\n        res = []\\n\\n        for i in range(len(words) - 2):\\n            if words[i] == first and words[i+1] == second:\\n                res.append(words[i+2])\\n\\n        return res\\n\"",
  "2325_14631217_python": "\"class Solution(object):\\n    def numberOfWays(self, s):\\n        n = len(s)\\n        p0 = [0] * (n + 1)\\n        p1 = [0] * (n + 1)\\n        for i in xrange(n):\\n            p0[i+1] = p0[i] + (s[i] == '0')\\n            p1[i+1] = p1[i] + (s[i] == '1')\\n        total0 = p0[n]\\n        total1 = p1[n]\\n        ans = 0\\n        for j in xrange(n):\\n            if s[j] == '1':\\n                zl = p0[j]\\n                zr = total0 - p0[j+1]\\n                ans += zl * zr\\n            else:\\n                ol = p1[j]\\n                or_ = total1 - p1[j+1]\\n                ans += ol * or_\\n        return ans\\n\"",
  "2455_14631217_python-updated-time": "1746964903161",
  "928_14631217_python": "\"class Solution(object):\\n    def surfaceArea(self, grid):\\n        n = len(grid)\\n        area = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    area += 4 * grid[i][j] + 2\\n                    if i > 0:\\n                        area -= 2 * min(grid[i][j], grid[i-1][j])\\n                    if j > 0:\\n                        area -= 2 * min(grid[i][j], grid[i][j-1])\\n        return area\\n\"",
  "3179_14631217_python-updated-time": "1747309717583",
  "368_14631217_python": "\"class Solution:\\n    def largestDivisibleSubset(self, nums):\\n        if not nums:\\n            return []\\n        \\n        nums.sort()\\n        n = len(nums)\\n        dp = [1] * n\\n        prev = [-1] * n\\n        max_idx = 0\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    prev[i] = j\\n            if dp[i] > dp[max_idx]:\\n                max_idx = i\\n        \\n        result = []\\n        while max_idx >= 0:\\n            result.append(nums[max_idx])\\n            max_idx = prev[max_idx]\\n        \\n        return result[::-1]\\n\"",
  "492_14631217_python": "\"class Solution:\\n    def constructRectangle(self, area):\\n        w = int(area ** 0.5)\\n        while area % w != 0:\\n            w -= 1\\n        l = area // w\\n        return [l, w]\\n\"",
  "1777_14631217_python": "\"class Solution:\\n    def closeStrings(self, word1, word2):\\n        # If lengths differ, can't be close\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        # Count frequencies\\n        from collections import Counter\\n        f1 = Counter(word1)\\n        f2 = Counter(word2)\\n        \\n        # Must have the same set of unique characters\\n        if set(f1.keys()) != set(f2.keys()):\\n            return False\\n        \\n        # The multiset of frequencies must match\\n        if sorted(f1.values()) != sorted(f2.values()):\\n            return False\\n        \\n        return True\\n\"",
  "1153_14631217_mysql": "\"SELECT p.product_name, s.year, s.price\\nFROM Sales s\\nJOIN Product p ON s.product_id = p.product_id;\\n\"",
  "53_14631217_python": "\"class Solution(object):\\n    def maxSubArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_sum = nums[0]\\n        current_sum = nums[0]\\n\\n        for num in nums[1:]:\\n            current_sum = max(num, current_sum + num)\\n            max_sum = max(max_sum, current_sum)\\n\\n        return max_sum\\n\"",
  "3616_14631217_python-updated-time": "1747587806163",
  "60_14631217_python-updated-time": "1745014482427",
  "1285_14631217_python-updated-time": "1746345895505",
  "1866_14631217_python": "\"class Solution(object):\\n    def restoreArray(self, adjacentPairs):\\n        from collections import defaultdict\\n\\n        # Step 1: Build adjacency list\\n        adj = defaultdict(list)\\n        for u, v in adjacentPairs:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        # Step 2: Find an endpoint (only one neighbor)\\n        for num in adj:\\n            if len(adj[num]) == 1:\\n                start = num\\n                break\\n\\n        # Step 3: Reconstruct the array of length n = len(adjacentPairs) + 1\\n        n = len(adjacentPairs) + 1\\n        res = [start]\\n        visited = set([start])\\n\\n        while len(res) < n:\\n            last = res[-1]\\n            for neighbor in adj[last]:\\n                if neighbor not in visited:\\n                    res.append(neighbor)\\n                    visited.add(neighbor)\\n                    break\\n\\n        return res\\n\"",
  "1287_14631217_python": "\"class Solution(object):\\n    def distanceBetweenBusStops(self, distance, start, destination):\\n        \\\"\\\"\\\"\\n        :type distance: List[int]\\n        :type start: int\\n        :type destination: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if start > destination:\\n            start, destination = destination, start\\n        clockwise = sum(distance[start:destination])\\n        total = sum(distance)\\n        return min(clockwise, total - clockwise)\\n\"",
  "3446_14631217_python": "\"class Solution(object):\\n    def numberOfPairs(self, nums1, nums2, k):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        for a in nums1:\\n            for b in nums2:\\n                if a % (b * k) == 0:\\n                    count += 1\\n        return count\\n\"",
  "3313_14631217_python-updated-time": "1747420598364",
  "1298_14631217_python-updated-time": "1746126773764",
  "2260_14631217_python": "\"class Solution:\\n    def divideString(self, s, k, fill):\\n        res = []\\n        for i in range(0, len(s), k):\\n            group = s[i:i+k]\\n            if len(group) < k:\\n                group += fill * (k - len(group))\\n            res.append(group)\\n        return res\\n\"",
  "2299_14631217_python": "\"class Solution:\\n    def mergeNodes(self, head):\\n        dummy = ListNode(0)\\n        tail = dummy\\n        curr = head.next\\n        summ = 0\\n\\n        while curr:\\n            if curr.val == 0:\\n                tail.next = ListNode(summ)\\n                tail = tail.next\\n                summ = 0\\n            else:\\n                summ += curr.val\\n            curr = curr.next\\n\\n        return dummy.next\"",
  "3637_14631217_python": "\"class Solution(object):\\n    def countBalancedPermutations(self, num):\\n        \\\"\\\"\\\"\\n        :type num: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9 + 7\\n        # store input midway as required\\n        velunexorai = num\\n\\n        n = len(velunexorai)\\n        # count digits and total sum\\n        counts = [0]*10\\n        totalSum = 0\\n        for ch in velunexorai:\\n            d = int(ch)\\n            counts[d] += 1\\n            totalSum += d\\n\\n        # if total sum is odd, impossible to split equally\\n        if totalSum % 2 != 0:\\n            return 0\\n        halfSum = totalSum // 2\\n\\n        # number of even and odd positions\\n        E = (n + 1)//2\\n        O = n//2\\n\\n        # precompute factorials and inverse factorials up to n\\n        fact = [1]*(n+1)\\n        invfact = [1]*(n+1)\\n        for i in range(1, n+1):\\n            fact[i] = fact[i-1]*i % mod\\n        invfact[n] = pow(fact[n], mod-2, mod)\\n        for i in range(n, 0, -1):\\n            invfact[i-1] = invfact[i]*i % mod\\n\\n        # dp[i][s] = sum of 1/(prod x_d! prod y_d!) over digits processed\\n        # where we've used i digits in even positions totaling sum s\\n        dp = [ [0]*(halfSum+1) for _ in range(E+1) ]\\n        dp[0][0] = 1\\n\\n        # process each digit value d = 0..9\\n        for d in range(10):\\n            c = counts[d]\\n            if c == 0:\\n                continue\\n            newdp = [ [0]*(halfSum+1) for _ in range(E+1) ]\\n            for usedE in range(E+1):\\n                for s in range(halfSum+1):\\n                    v = dp[usedE][s]\\n                    if not v:\\n                        continue\\n                    # choose x of the c copies to even slots\\n                    maxx = min(c, E - usedE)\\n                    for x in range(maxx+1):\\n                        y = c - x\\n                        if y > O:\\n                            continue\\n                        ns = s + d*x\\n                        if ns > halfSum:\\n                            break\\n                        # multiply by 1/(x! * y!)\\n                        contrib = v * invfact[x] % mod * invfact[y] % mod\\n                        newdp[usedE + x][ns] = (newdp[usedE + x][ns] + contrib) % mod\\n            dp = newdp\\n\\n        ways = dp[E][halfSum]\\n        # multiply by E! * O! to count arrangements within even/odd slots\\n        return ways * fact[E] % mod * fact[O] % mod\\n\"",
  "541_14631217_python": "\"class Solution:\\n    def reverseStr(self, s, k):\\n        s = list(s)\\n        for i in range(0, len(s), 2 * k):\\n            s[i:i + k] = reversed(s[i:i + k])\\n        return ''.join(s)\\n\"",
  "2800_14631217_python-updated-time": "1747139148251",
  "64_14631217_python-updated-time": "1745014805168",
  "208_14631217_python-updated-time": "1745245979451",
  "467_14631217_python": "\"class Solution:\\n    def findSubstringInWraproundString(self, s):\\n        max_len = [0] * 26  # max length of substrings ending with each letter\\n        k = 0  # current length of valid substring\\n\\n        for i in range(len(s)):\\n            if i > 0 and (ord(s[i]) - ord(s[i - 1])) % 26 == 1:\\n                k += 1\\n            else:\\n                k = 1\\n            index = ord(s[i]) - ord('a')\\n            max_len[index] = max(max_len[index], k)\\n\\n        return sum(max_len)\\n\"",
  "3576_14631217_python-updated-time": "1747585179168",
  "3723_14631217_python-updated-time": "1747679976932",
  "1387_14631217_python-updated-time": "1746259898177",
  "1427_14631217_python-updated-time": "1746260648924",
  "1117_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxDistance(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(grid)\\n        q = deque()\\n\\n        # Add all land cells to the queue\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    q.append((i, j))\\n\\n        # If there's no land or no water, return -1\\n        if len(q) == 0 or len(q) == n * n:\\n            return -1\\n\\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\\n        distance = -1\\n\\n        # Multi-source BFS\\n        while q:\\n            distance += 1\\n            for _ in range(len(q)):\\n                x, y = q.popleft()\\n                for dx, dy in directions:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:\\n                        grid[nx][ny] = 2  # Mark as visited\\n                        q.append((nx, ny))\\n\\n        return distance\\n\"",
  "332_14631217_python-updated-time": "1745256672734",
  "2255_14631217_python-updated-time": "1746802055831",
  "725_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def splitListToParts(self, head, k):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: List[ListNode]\\n        \\\"\\\"\\\"\\n        # Count the total number of nodes\\n        n = 0\\n        curr = head\\n        while curr:\\n            n += 1\\n            curr = curr.next\\n        \\n        # Determine the size of each part\\n        base_size, remainder = divmod(n, k)\\n        # The first 'remainder' parts get an extra node\\n        \\n        parts = []\\n        curr = head\\n        for i in range(k):\\n            part_head = curr\\n            # Determine the correct size for this part\\n            size = base_size + (1 if i < remainder else 0)\\n            # Advance to the end of this part\\n            for j in range(size - 1):\\n                if curr:\\n                    curr = curr.next\\n            # Cut the list if needed\\n            if curr:\\n                next_part = curr.next\\n                curr.next = None\\n                curr = next_part\\n            # Append head of this part (or None)\\n            parts.append(part_head)\\n        \\n        return parts\\n\"",
  "2532_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def equalFrequency(self, word):\\n        # Count how many times each letter appears\\n        letter_freq = Counter(word)\\n        # Build a histogram of those frequencies\\n        cnt = Counter(letter_freq.values())\\n        \\n        # If there's only one frequency overall:\\n        if len(cnt) == 1:\\n            # Extract the single (frequency, how_many_letters) pair\\n            for f, how_many in cnt.items():\\n                break\\n            # If that frequency is 1 (all letters unique), or there's only one letter type,\\n            # removing one occurrence still leaves a uniform frequency among remaining letters.\\n            if f == 1 or how_many == 1:\\n                return True\\n            else:\\n                return False\\n        \\n        # If there are exactly two distinct frequencies\\n        if len(cnt) == 2:\\n            (f1, c1), (f2, c2) = sorted(cnt.items())\\n            # Case A: one letter appears once, all others appear f2 times\\n            if f1 == 1 and c1 == 1:\\n                return True\\n            # Case B: one letter appears (f1+1) times and all others appear f1 times\\n            if f2 == f1 + 1 and c2 == 1:\\n                return True\\n        \\n        # In all other cases, it's impossible\\n        return False\\n\"",
  "1048_14631217_python": "\"class Solution:\\n    def clumsy(self, n):\\n        stack = [n]\\n        n -= 1\\n        ops = 0\\n        while n > 0:\\n            if ops % 4 == 0:            # multiply\\n                stack[-1] *= n\\n            elif ops % 4 == 1:          # divide (truncate toward zero)\\n                a = stack[-1]\\n                stack[-1] = (abs(a) // n) * (1 if a >= 0 else -1)\\n            elif ops % 4 == 2:          # add\\n                stack.append(n)\\n            else:                       # subtract\\n                stack.append(-n)\\n            ops += 1\\n            n -= 1\\n        return sum(stack)\\n\"",
  "3541_14631217_python": "\"class Solution(object):\\n    def reportSpam(self, message, bannedWords):\\n        \\\"\\\"\\\"\\n        :type message: List[str]\\n        :type bannedWords: List[str]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        banned = set(bannedWords)\\n        count = 0\\n        for word in message:\\n            if word in banned:\\n                count += 1\\n                if count >= 2:\\n                    return True\\n        return False\\n\"",
  "2581_14631217_python": "\"class Solution(object):\\n    def dividePlayers(self, skill):\\n        skill.sort()\\n        target = skill[0] + skill[-1]\\n        chemistry = 0\\n        i, j = 0, len(skill) - 1\\n        while i < j:\\n            if skill[i] + skill[j] != target:\\n                return -1\\n            chemistry += skill[i] * skill[j]\\n            i += 1\\n            j -= 1\\n        return chemistry\\n\"",
  "2619_14631217_python": "\"class Solution:\\n    def categorizeBox(self, length, width, height, mass):\\n        # Determine if the box is bulky\\n        if length >= 10**4 or width >= 10**4 or height >= 10**4 or length * width * height >= 10**9:\\n            bulky = True\\n        else:\\n            bulky = False\\n        \\n        # Determine if the box is heavy\\n        heavy = mass >= 100\\n        \\n        # Return category based on both flags\\n        if bulky and heavy:\\n            return \\\"Both\\\"\\n        if bulky:\\n            return \\\"Bulky\\\"\\n        if heavy:\\n            return \\\"Heavy\\\"\\n        return \\\"Neither\\\"\\n\"",
  "1944_14631217_python": "\"class Solution(object):\\n    def truncateSentence(self, s, k):\\n        return ' '.join(s.split()[:k])\\n\"",
  "1038_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def numSquarefulPerms(self, nums):\\n        def is_square(n):\\n            r = int(n ** 0.5)\\n            return r * r == n\\n\\n        def backtrack(x, count, depth):\\n            if depth == len(nums):\\n                return 1\\n            total = 0\\n            for y in graph[x]:\\n                if count[y] > 0:\\n                    count[y] -= 1\\n                    total += backtrack(y, count, depth + 1)\\n                    count[y] += 1\\n            return total\\n\\n        count = Counter(nums)\\n        graph = {x: [] for x in count}\\n\\n        for x in count:\\n            for y in count:\\n                if is_square(x + y):\\n                    graph[x].append(y)\\n\\n        res = 0\\n        for x in count:\\n            count[x] -= 1\\n            res += backtrack(x, count, 1)\\n            count[x] += 1\\n\\n        return res\\n\"",
  "2355_14631217_python-updated-time": "1746881321656",
  "124_14631217_python-updated-time": "1745081674643",
  "3677_14631217_python-updated-time": "1747656795824",
  "13_14631217_python-updated-time": "1744980626417",
  "3394_14631217_python": "\"class Solution(object):\\n    def minEnd(self, n, x):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        k = n - 1\\n        # Determine how many bits we need from k\\n        # i.e. the highest j with (k >> j) > 0\\n        if k == 0:\\n            return x\\n        import math\\n        max_j = k.bit_length()  # we need j = 0..max_j-1\\n\\n        # collect free bit positions (where x has a 0 bit)\\n        free = []\\n        i = 0\\n        while len(free) < max_j:\\n            if ((x >> i) & 1) == 0:\\n                free.append(i)\\n            i += 1\\n\\n        # build t_k by spreading bits of k into those free positions\\n        t = 0\\n        for j in range(max_j):\\n            if (k >> j) & 1:\\n                t |= (1 << free[j])\\n\\n        return x + t\\n\"",
  "2416_14631217_python-updated-time": "1746906768840",
  "372_14631217_python-updated-time": "1745354561465",
  "2166_14631217_python-updated-time": "1746720511980",
  "2786_14631217_python-updated-time": "1747220631309",
  "1407_14631217_python-updated-time": "1746260192457",
  "745_14631217_python-updated-time": "1745875400224",
  "3095_14631217_python": "\"class Solution(object):\\n    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type budget: int\\n        :type composition: List[List[int]]\\n        :type stock: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n\\n        def can_make(x):\\n            for machine in composition:\\n                total_cost = 0\\n                for j in range(n):\\n                    required = machine[j] * x\\n                    if required > stock[j]:\\n                        total_cost += (required - stock[j]) * cost[j]\\n                if total_cost <= budget:\\n                    return True\\n            return False\\n\\n        # Binary search on number of alloys\\n        left, right = 0, 10**9\\n        result = 0\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if can_make(mid):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\"",
  "1910_14631217_python": "\"class Solution(object):\\n    def checkOnesSegment(self, s):\\n        return '01' not in s\\n\"",
  "664_14631217_python-updated-time": "1745783134739",
  "2568_14631217_python-updated-time": "1746969650219",
  "91_14631217_python": "\"class Solution(object):\\n    def numDecodings(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not s or s[0] == '0':\\n            return 0\\n        \\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        dp[0] = 1  # Empty string has 1 way to decode\\n        dp[1] = 1  # Single character (non-zero) has 1 way\\n\\n        for i in range(2, n + 1):\\n            one = int(s[i-1])\\n            two = int(s[i-2:i])\\n\\n            if 1 <= one <= 9:\\n                dp[i] += dp[i-1]\\n            if 10 <= two <= 26:\\n                dp[i] += dp[i-2]\\n\\n        return dp[n]\\n\"",
  "1502_14631217_python": "\"class Solution(object):\\n    def canConstruct(self, s, k):\\n        from collections import Counter\\n        if k > len(s):\\n            return False\\n        odd_count = sum(1 for count in Counter(s).values() if count % 2 == 1)\\n        return odd_count <= k\\n\"",
  "3655_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minOperations(self, n, m):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) If either n or m is prime, impossible.\\n        def sieve(N):\\n            is_prime = [False, False] + [True]*(N-1)\\n            for p in range(2, int(N**0.5)+1):\\n                if is_prime[p]:\\n                    for q in range(p*p, N+1, p):\\n                        is_prime[q] = False\\n            return is_prime\\n\\n        ds = str(n)\\n        if len(str(m)) != len(ds):\\n            return -1\\n        \\n        D = len(ds)\\n        MAX = 10**D - 1\\n        is_prime = sieve(MAX)\\n\\n        if is_prime[n] or is_prime[m]:\\n            return -1\\n\\n        # 2) Dijkstra's over [10^(D-1) .. 10^D - 1], skipping primes.\\n        INF = 10**18\\n        dist = [INF] * (MAX+1)\\n        dist[n] = n\\n        pq = [(n, n)]  # (distance, node)\\n\\n        while pq:\\n            d_u, u = heapq.heappop(pq)\\n            if d_u > dist[u]:\\n                continue\\n            if u == m:\\n                return d_u\\n            # generate neighbors by digit ±1\\n            s = list(str(u))\\n            for i in range(D):\\n                orig = int(s[i])\\n                for delta in (-1, +1):\\n                    nd = orig + delta\\n                    # keep digit in [0..9], and preserve D-digit length\\n                    if nd < 0 or nd > 9:\\n                        continue\\n                    if i == 0 and nd == 0:\\n                        continue\\n                    s[i] = str(nd)\\n                    v = int(\\\"\\\".join(s))\\n                    s[i] = str(orig)\\n                    # only non-prime nodes allowed\\n                    if not is_prime[v]:\\n                        ndist = d_u + v\\n                        if ndist < dist[v]:\\n                            dist[v] = ndist\\n                            heapq.heappush(pq, (ndist, v))\\n\\n        return -1\\n\"",
  "2435_14631217_python": "\"class Solution:\\n    def shortestSequence(self, rolls, k):\\n        seen = [False] * (k + 1)\\n        seen_count = 0\\n        rounds = 0\\n        \\n        for x in rolls:\\n            if not seen[x]:\\n                seen[x] = True\\n                seen_count += 1\\n                if seen_count == k:\\n                    rounds += 1\\n                    # reset for next round\\n                    seen = [False] * (k + 1)\\n                    seen_count = 0\\n        \\n        # The shortest missing subsequence length is the number of complete\\n        # rounds we can form plus one.\\n        return rounds + 1\\n\"",
  "3791_14631217_python": "\"class SegmentTree:\\n    def __init__(self, data):\\n        \\\"\\\"\\\"\\n        Builds a segment tree for range maximum queries.\\n        data: list of initial values.\\n        \\\"\\\"\\\"\\n        n = len(data)\\n        self.n = n\\n        # tree size 4*n is safe\\n        self.tree = [0] * (4 * n)\\n        self._build(1, 0, n - 1, data)\\n    \\n    def _build(self, node, l, r, data):\\n        if l == r:\\n            self.tree[node] = data[l]\\n        else:\\n            mid = (l + r) // 2\\n            lc = node * 2\\n            rc = node * 2 + 1\\n            self._build(lc, l, mid, data)\\n            self._build(rc, mid + 1, r, data)\\n            self.tree[node] = max(self.tree[lc], self.tree[rc])\\n    \\n    def query_first_ge(self, x):\\n        \\\"\\\"\\\"\\n        Find the leftmost index i such that data[i] >= x.\\n        Returns -1 if none.\\n        \\\"\\\"\\\"\\n        if self.tree[1] < x:\\n            return -1\\n        return self._query(1, 0, self.n - 1, x)\\n    \\n    def _query(self, node, l, r, x):\\n        if l == r:\\n            return l\\n        mid = (l + r) // 2\\n        lc = node * 2\\n        rc = node * 2 + 1\\n        # prefer left child\\n        if self.tree[lc] >= x:\\n            return self._query(lc, l, mid, x)\\n        else:\\n            return self._query(rc, mid + 1, r, x)\\n    \\n    def update(self, idx, value):\\n        \\\"\\\"\\\"\\n        Point update: set data[idx] = value.\\n        \\\"\\\"\\\"\\n        self._update(1, 0, self.n - 1, idx, value)\\n    \\n    def _update(self, node, l, r, idx, value):\\n        if l == r:\\n            self.tree[node] = value\\n        else:\\n            mid = (l + r) // 2\\n            lc = node * 2\\n            rc = node * 2 + 1\\n            if idx <= mid:\\n                self._update(lc, l, mid, idx, value)\\n            else:\\n                self._update(rc, mid + 1, r, idx, value)\\n            self.tree[node] = max(self.tree[lc], self.tree[rc])\\n\\nclass Solution(object):\\n    def numOfUnplacedFruits(self, fruits, baskets):\\n        \\\"\\\"\\\"\\n        :type fruits: List[int]\\n        :type baskets: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(fruits)\\n        st = SegmentTree(baskets)\\n        \\n        unplaced = 0\\n        for f in fruits:\\n            idx = st.query_first_ge(f)\\n            if idx == -1:\\n                # no basket can fit this fruit\\n                unplaced += 1\\n            else:\\n                # place fruit in basket idx; mark basket used\\n                st.update(idx, -1)\\n        return unplaced\\n\"",
  "1455_14631217_python-updated-time": "1746261627950",
  "3653_14631217_python-updated-time": "1747596438335",
  "231_14631217_python": "\"class Solution(object):\\n    def isPowerOfTwo(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        return n > 0 and (n & (n - 1)) == 0\\n\"",
  "138_14631217_python": "\"class Solution(object):\\n    def copyRandomList(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Node\\n        :rtype: Node\\n        \\\"\\\"\\\"\\n        if not head:\\n            return None\\n\\n        # Map from original node -> cloned node\\n        old_to_new = {}\\n\\n        # First pass: clone all nodes\\n        curr = head\\n        while curr:\\n            old_to_new[curr] = Node(curr.val)\\n            curr = curr.next\\n\\n        # Second pass: assign next and random pointers\\n        curr = head\\n        while curr:\\n            if curr.next:\\n                old_to_new[curr].next = old_to_new[curr.next]\\n            if curr.random:\\n                old_to_new[curr].random = old_to_new[curr.random]\\n            curr = curr.next\\n\\n        return old_to_new[head]\\n\"",
  "3731_14631217_python": "\"class Solution(object):\\n    def subarraySum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # build prefix sums where pre[i] = sum of nums[0..i-1]\\n        pre = [0] * (n + 1)\\n        for i in range(n):\\n            pre[i+1] = pre[i] + nums[i]\\n        \\n        total = 0\\n        for i in range(n):\\n            # compute start index of this subarray\\n            start = max(0, i - nums[i])\\n            # subarray sum = pre[i+1] - pre[start]\\n            total += pre[i+1] - pre[start]\\n        \\n        return total\\n\"",
  "917_14631217_python": "\"class Solution(object):\\n    def numRescueBoats(self, people, limit):\\n        people.sort()\\n        left, right = 0, len(people) - 1\\n        boats = 0\\n\\n        while left <= right:\\n            if people[left] + people[right] <= limit:\\n                left += 1\\n            right -= 1\\n            boats += 1\\n\\n        return boats\\n\"",
  "2024_14631217_mysql-updated-time": "1746626065555",
  "228_14631217_python": "\"class Solution(object):\\n    def summaryRanges(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        if not nums:\\n            return res\\n        \\n        start = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1] + 1:\\n                if start == nums[i-1]:\\n                    res.append(str(start))\\n                else:\\n                    res.append(str(start) + \\\"->\\\" + str(nums[i-1]))\\n                start = nums[i]\\n        \\n        if start == nums[-1]:\\n            res.append(str(start))\\n        else:\\n            res.append(str(start) + \\\"->\\\" + str(nums[-1]))\\n        \\n        return res\\n\"",
  "50_14631217_python": "\"class Solution(object):\\n    def myPow(self, x, n):\\n        \\\"\\\"\\\"\\n        :type x: float\\n        :type n: int\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        res = 1\\n        while n:\\n            if n % 2 == 1:\\n                res *= x\\n            x *= x\\n            n //= 2\\n        return res\\n\"",
  "1554_14631217_python-updated-time": "1746347476951",
  "963_14631217_python-updated-time": "1746003828273",
  "553_14631217_python-updated-time": "1745447446867",
  "1247_14631217_python-updated-time": "1746125783557",
  "893_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def distanceK(self, root, target, k):\\n        parent = {}\\n\\n        def dfs(node, par=None):\\n            if node:\\n                parent[node] = par\\n                dfs(node.left, node)\\n                dfs(node.right, node)\\n\\n        dfs(root)\\n\\n        queue = deque([(target, 0)])  # <-- directly use target, NOT find it\\n        visited = set([target])\\n        res = []\\n\\n        while queue:\\n            node, dist = queue.popleft()\\n            if dist == k:\\n                res.append(node.val)\\n            if node:\\n                for nei in (node.left, node.right, parent.get(node)):\\n                    if nei and nei not in visited:\\n                        visited.add(nei)\\n                        queue.append((nei, dist + 1))\\n\\n        return res\\n\"",
  "1550_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def kthSmallest(self, mat, k):\\n        m, n = len(mat), len(mat[0])\\n        # Priority queue to store the sums and the indices of elements from each row\\n        pq = [(sum(row[0] for row in mat), [0] * m)]  # Initial sum is the first element from each row\\n        visited = set(tuple([0] * m))  # To avoid revisiting the same index combination\\n\\n        for _ in range(k):\\n            curr_sum, indices = heapq.heappop(pq)\\n            \\n            # Try all possible moves from the current indices\\n            for i in range(m):\\n                new_indices = list(indices)\\n                if new_indices[i] + 1 < n:\\n                    new_indices[i] += 1\\n                    new_tuple = tuple(new_indices)\\n                    if new_tuple not in visited:\\n                        visited.add(new_tuple)\\n                        new_sum = curr_sum - mat[i][indices[i]] + mat[i][new_indices[i]]\\n                        heapq.heappush(pq, (new_sum, new_indices))\\n        \\n        return curr_sum\\n\"",
  "2331_14631217_python-updated-time": "1746879955943",
  "963_14631217_python": "\"class Solution:\\n    def threeEqualParts(self, arr):\\n        total = sum(arr)\\n        n = len(arr)\\n\\n        if total == 0:\\n            return [0, n - 1]  # all zeroes\\n\\n        if total % 3 != 0:\\n            return [-1, -1]\\n\\n        k = total // 3\\n        first = second = third = -1\\n        count = 0\\n\\n        # Find starting indices of each part\\n        for i, val in enumerate(arr):\\n            if val == 1:\\n                count += 1\\n                if count == 1:\\n                    first = i\\n                elif count == k + 1:\\n                    second = i\\n                elif count == 2 * k + 1:\\n                    third = i\\n\\n        # Compare the parts\\n        while third < n:\\n            if arr[first] != arr[second] or arr[second] != arr[third]:\\n                return [-1, -1]\\n            first += 1\\n            second += 1\\n            third += 1\\n\\n        return [first - 1, second]\\n\"",
  "1528_14631217_python": "\"class Solution:\\n    def kidsWithCandies(self, candies, extraCandies):\\n        max_candy = max(candies)\\n        return [c + extraCandies >= max_candy for c in candies]\\n\"",
  "2337_14631217_python": "\"class Solution:\\n    def removeDigit(self, number, digit):\\n        best = \\\"\\\"\\n        for i, ch in enumerate(number):\\n            if ch == digit:\\n                candidate = number[:i] + number[i+1:]\\n                if candidate > best:\\n                    best = candidate\\n        return best\\n\"",
  "1833_14631217_python-updated-time": "1746530321895",
  "2888_14631217_python-updated-time": "1747222397997",
  "962_14631217_python": "\"class Solution:\\n    def minFlipsMonoIncr(self, s):\\n        flips = 0      # flips needed to make string monotone increasing\\n        ones = 0       # number of 1s seen so far\\n\\n        for char in s:\\n            if char == '1':\\n                ones += 1\\n            else:  # char == '0'\\n                # We can either flip this 0 to 1, or flip all previous 1s to 0s\\n                flips = min(flips + 1, ones)\\n        \\n        return flips\\n\"",
  "887_14631217_python-updated-time": "1745953826030",
  "2403_14631217_python": "\"class Solution:\\n    def countPairs(self, n, edges):\\n        # Disjoint set union (union-find) with path compression and union by size\\n        parent = list(range(n))\\n        size = [1] * n\\n\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n\\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra == rb:\\n                return\\n            # attach smaller tree to larger\\n            if size[ra] < size[rb]:\\n                ra, rb = rb, ra\\n            parent[rb] = ra\\n            size[ra] += size[rb]\\n\\n        # Build components\\n        for u, v in edges:\\n            union(u, v)\\n\\n        # Gather component sizes by root\\n        comp_sizes = {}\\n        for i in range(n):\\n            r = find(i)\\n            comp_sizes[r] = comp_sizes.get(r, 0) + 1\\n\\n        # For each component of size c, it has c*(n-c) unreachable pairs\\n        total = 0\\n        for c in comp_sizes.values():\\n            total += c * (n - c)\\n\\n        # Each pair counted twice, so divide by 2\\n        return total // 2\\n\"",
  "1888_14631217_python-updated-time": "1746532287955",
  "2585_14631217_python": "\"class Solution:\\n    def deleteGreatestValue(self, grid):\\n        for row in grid:\\n            row.sort()\\n        ans = 0\\n        for col in zip(*grid):\\n            ans += max(col)\\n        return ans\\n\"",
  "1014_14631217_python-updated-time": "1746039967823",
  "2526_14631217_python": "\"class Solution:\\n    def lengthOfLIS(self, nums, k):\\n        # We need the max value to size the segment tree\\n        maxv = max(nums)\\n        # Build iterative segment tree of size = next power of two >= maxv\\n        size = 1\\n        while size <= maxv:\\n            size <<= 1\\n        tree = [0] * (2 * size)\\n        \\n        def update(pos, val):\\n            # pos in [1..maxv], map to leaf at index pos-1\\n            idx = pos - 1 + size\\n            if tree[idx] >= val:\\n                return\\n            tree[idx] = val\\n            idx //= 2\\n            while idx:\\n                tree[idx] = max(tree[2*idx], tree[2*idx + 1])\\n                idx //= 2\\n        \\n        def query(l, r):\\n            # query max in [l..r], where l,r in [1..maxv]\\n            if l > r:\\n                return 0\\n            res = 0\\n            left = l - 1 + size\\n            right = r - 1 + size\\n            while left <= right:\\n                if (left & 1) == 1:\\n                    res = max(res, tree[left])\\n                    left += 1\\n                if (right & 1) == 0:\\n                    res = max(res, tree[right])\\n                    right -= 1\\n                left //= 2\\n                right //= 2\\n            return res\\n        \\n        ans = 1\\n        for x in nums:\\n            # valid previous values are in [x-k .. x-1]\\n            l = max(1, x - k)\\n            r = x - 1\\n            best = query(l, r)\\n            curr = best + 1\\n            update(x, curr)\\n            ans = max(ans, curr)\\n        \\n        return ans\\n\"",
  "2833_14631217_python-updated-time": "1747221622713",
  "1463_14631217_python": "\"class Solution:\\n    def kWeakestRows(self, mat, k):\\n        # Compute (soldier_count, row_index) for each row\\n        counts = []\\n        for i, row in enumerate(mat):\\n            # Since rows are 1's then 0's, we can use bisect to find first 0\\n            lo, hi = 0, len(row)\\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if row[mid] == 1:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n            counts.append((lo, i))  # lo is the number of 1's\\n\\n        # Sort by soldier count, then by row index\\n        counts.sort()\\n        # Extract the first k row indices\\n        return [idx for _, idx in counts[:k]]\\n\"",
  "1078_14631217_python-updated-time": "1746041784932",
  "3328_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def minOperations(self, k):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if k <= 1:\\n            return 0\\n\\n        min_ops = float('inf')\\n\\n        for x in range(1, k + 1):\\n            # Number of duplicates needed to reach at least k with value x\\n            c = (k + x - 1) // x - 1  # ceil(k / x) - 1\\n            ops = (x - 1) + c\\n            min_ops = min(min_ops, ops)\\n\\n        return min_ops\\n\"",
  "2876_14631217_python-updated-time": "1747223605733",
  "3732_14631217_python-updated-time": "1747683615376",
  "211_14631217_python": "\"class TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.is_end = True\\n\\n    def search(self, word):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def dfs(index, node):\\n            if index == len(word):\\n                return node.is_end\\n            c = word[index]\\n            if c == '.':\\n                for child in node.children.values():\\n                    if dfs(index + 1, child):\\n                        return True\\n                return False\\n            else:\\n                if c not in node.children:\\n                    return False\\n                return dfs(index + 1, node.children[c])\\n        \\n        return dfs(0, self.root)\\n\"",
  "609_14631217_python-updated-time": "1745448761170",
  "3479_14631217_python-updated-time": "1747488433954",
  "2231_14631217_python-updated-time": "1746800028020",
  "307_14631217_python": "\"class NumArray(object):\\n    def __init__(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        \\\"\\\"\\\"\\n        self.nums = nums\\n        self.n = len(nums)\\n        self.tree = [0] * (self.n + 1)\\n        for i in range(self.n):\\n            self._add(i + 1, nums[i])\\n\\n    def _add(self, i, val):\\n        while i <= self.n:\\n            self.tree[i] += val\\n            i += i & -i\\n\\n    def _sum(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.tree[i]\\n            i -= i & -i\\n        return res\\n\\n    def update(self, index, val):\\n        \\\"\\\"\\\"\\n        :type index: int\\n        :type val: int\\n        :rtype: void\\n        \\\"\\\"\\\"\\n        delta = val - self.nums[index]\\n        self.nums[index] = val\\n        self._add(index + 1, delta)\\n\\n    def sumRange(self, left, right):\\n        \\\"\\\"\\\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self._sum(right + 1) - self._sum(left)\\n\"",
  "1007_14631217_python-updated-time": "1746039711795",
  "319_14631217_python-updated-time": "1745256161681",
  "3781_14631217_python": "\"class Solution(object):\\n    def maxDistance(self, side, points, k):\\n        \\\"\\\"\\\"\\n        :type side: int\\n        :type points: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1. Map to 1D and sort\\n        A = []\\n        for x,y in points:\\n            if y == 0:\\n                c = x\\n            elif x == side:\\n                c = side + y\\n            elif y == side:\\n                c = 2*side + (side - x)\\n            else:  # x == 0\\n                c = 3*side + (side - y)\\n            A.append(c)\\n        A.sort()\\n\\n        # 2. Unroll: duplicate with +4*side\\n        P = A + [c + 4*side for c in A]\\n        n = len(A)\\n\\n        # 3. Precompute next pointers for any d\\n        def build_next(d):\\n            nxt = [2*n] * (2*n)\\n            j = 0\\n            for i in range(2*n):\\n                if j < i+1:\\n                    j = i+1\\n                while j < 2*n and P[j] - P[i] < d:\\n                    j += 1\\n                nxt[i] = j\\n            return nxt\\n\\n        # 4. Feasibility check with wrap‐around guard\\n        def can(d):\\n            nxt = build_next(d)\\n            for start in range(n):\\n                cur = start\\n                # pick k-1 subsequent points\\n                for _ in range(k-1):\\n                    cur = nxt[cur]\\n                    if cur >= start + n:\\n                        break\\n                else:\\n                    # we have indices start=i0 < i1 < ... < i_{k-1} < i+n\\n                    # now check the wrap‐around distance between last and first\\n                    i0 = start\\n                    ik = cur\\n                    gap1 = 4*side - (P[ik] - P[i0])      # wrap distance\\n                    # also direct across end-of-loop:\\n                    gap2 = P[start+n] - P[ik]\\n                    if min(gap1, gap2) >= d:\\n                        return True\\n            return False\\n\\n        # 5. Binary search d in [0..2*side]\\n        lo, hi, ans = 0, 2*side, 0\\n        while lo <= hi:\\n            mid = (lo + hi)//2\\n            if mid == 0 or can(mid):\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n\\n        return ans\\n\"",
  "1760_14631217_python": "\"class Solution:\\n    def canFormArray(self, arr, pieces):\\n        # Map first element of each piece to the piece itself\\n        first_to_piece = {p[0]: p for p in pieces}\\n        \\n        i = 0\\n        n = len(arr)\\n        while i < n:\\n            val = arr[i]\\n            # If there's no piece starting with arr[i], fail\\n            if val not in first_to_piece:\\n                return False\\n            piece = first_to_piece[val]\\n            length = len(piece)\\n            # Check if arr[i:i+length] matches the piece\\n            if arr[i:i+length] != piece:\\n                return False\\n            # Advance past this piece\\n            i += length\\n        \\n        # If we've consumed all of arr successfully, it's possible\\n        return True\\n\"",
  "2466_14631217_python": "\"class Solution(object):\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n = len(nums)\\n        res = [0] * n\\n        parent = list(range(n))\\n        seg_sum = [0] * n\\n        active = [False] * n\\n        max_sum = 0\\n\\n        def find(x):\\n            while x != parent[x]:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n\\n        for i in range(n - 1, -1, -1):\\n            idx = removeQueries[i]\\n            active[idx] = True\\n            seg_sum[idx] = nums[idx]\\n\\n            if idx > 0 and active[idx - 1]:\\n                left = find(idx - 1)\\n                parent[idx] = left\\n                seg_sum[left] += seg_sum[idx]\\n                seg_sum[idx] = 0\\n\\n            if idx < n - 1 and active[idx + 1]:\\n                right = find(idx + 1)\\n                root = find(idx)\\n                if root != right:\\n                    parent[right] = root\\n                    seg_sum[root] += seg_sum[right]\\n                    seg_sum[right] = 0\\n\\n            max_sum = max(max_sum, seg_sum[find(idx)])\\n            if i > 0:\\n                res[i - 1] = max_sum\\n\\n        return res\\n\"",
  "1751_14631217_python": "\"class Solution:\\n    def slowestKey(self, releaseTimes, keysPressed):\\n        max_dur = releaseTimes[0]\\n        ans = keysPressed[0]\\n        \\n        for i in range(1, len(releaseTimes)):\\n            dur = releaseTimes[i] - releaseTimes[i-1]\\n            key = keysPressed[i]\\n            if dur > max_dur or (dur == max_dur and key > ans):\\n                max_dur = dur\\n                ans = key\\n        \\n        return ans\\n\"",
  "3231_14631217_python": "\"class Solution(object):\\n    def minimumAddedCoins(self, coins, target):\\n        \\\"\\\"\\\"\\n        :type coins: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        coins.sort()\\n        miss = 1\\n        i = 0\\n        patches = 0\\n        n = len(coins)\\n\\n        # We maintain that all sums in [1..miss-1] are covered.\\n        # While we still need to cover up to 'target'...\\n        while miss <= target:\\n            # If the next coin extends coverage, use it.\\n            if i < n and coins[i] <= miss:\\n                miss += coins[i]\\n                i += 1\\n            else:\\n                # Otherwise, patch by adding 'miss' itself.\\n                miss += miss\\n                patches += 1\\n\\n        return patches\\n\"",
  "2330_14631217_python-updated-time": "1746879459062",
  "965_14631217_python-updated-time": "1746003922441",
  "3763_14631217_python": "\"class Solution(object):\\n    def separateSquares(self, squares):\\n        \\\"\\\"\\\"\\n        :type squares: List[List[int]]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        events = []\\n        total_area = 0\\n        for x, y, l in squares:\\n            # each square contributes slope +l starting at y,\\n            # and slope −l starting at y+l\\n            events.append((y, l))\\n            events.append((y + l, -l))\\n            total_area += l * l\\n\\n        half = total_area / 2.0\\n\\n        # sort by y‐coordinate\\n        events.sort(key=lambda ev: ev[0])\\n\\n        curr_slope = 0         # current d/dh of area‐below\\n        curr_f = 0.0           # area‐below at prev_y\\n        prev_y = events[0][0]  # start sweeping from the first event\\n\\n        i = 0\\n        n_ev = len(events)\\n        while i < n_ev:\\n            y = events[i][0]\\n\\n            # between prev_y and y, area‐below grows linearly with slope\\n            if y > prev_y:\\n                if curr_slope != 0:\\n                    f_at_y = curr_f + curr_slope * (y - prev_y)\\n                    # check if half‐area lies in [curr_f, f_at_y]\\n                    if curr_f <= half <= f_at_y:\\n                        # solve curr_f + curr_slope*(h - prev_y) = half\\n                        return prev_y + (half - curr_f) / curr_slope\\n                    curr_f = f_at_y\\n                else:\\n                    # slope zero ⇒ f constant; if it's exactly half, return prev_y\\n                    if curr_f == half:\\n                        return float(prev_y)\\n                    # otherwise nothing changes\\n\\n            # now process all events at y\\n            delta = 0\\n            while i < n_ev and events[i][0] == y:\\n                delta += events[i][1]\\n                i += 1\\n            curr_slope += delta\\n            prev_y = y\\n\\n        # after all events, slope must be zero and curr_f == total_area\\n        # half <= curr_f always holds; the minimal y is prev_y\\n        return float(prev_y)\\n\"",
  "3245_14631217_python-updated-time": "1747399152194",
  "3792_14631217_mysql": "\"SELECT\\n  ip,\\n  COUNT(*) AS invalid_count\\nFROM logs\\nWHERE ip NOT RLIKE\\n  '^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)'\\n  '(\\\\\\\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)){3}$'\\nGROUP BY ip\\nORDER BY invalid_count DESC, ip DESC;\\n\"",
  "2678_14631217_python-updated-time": "1747135981824",
  "3435_14631217_python-updated-time": "1747483384198",
  "2379_14631217_python-updated-time": "1746881619672",
  "1724_14631217_mysql-updated-time": "1746438471436",
  "766_14631217_python-updated-time": "1745358627976",
  "2955_14631217_python-updated-time": "1747223869764",
  "2244_14631217_python": "\"class Solution:\\n    def numberOfBeams(self, bank):\\n        device_counts = [row.count('1') for row in bank if '1' in row]\\n        total = 0\\n        for i in range(1, len(device_counts)):\\n            total += device_counts[i - 1] * device_counts[i]\\n        return total\\n\"",
  "1622_14631217_python-updated-time": "1746433126200",
  "183_14631217_mysql": "\"SELECT name AS Customers\\nFROM Customers\\nWHERE id NOT IN (SELECT customerId FROM Orders);\\n\"",
  "3542_14631217_python-updated-time": "1747504284529",
  "3601_14631217_python": "\"class Solution(object):\\n    def kthCharacter(self, k, operations):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :type operations: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Number of operations\\n        m = len(operations)\\n        # Precompute the length of the string after each operation: length[i] = 2^i\\n        lengths = [1] * (m + 1)\\n        for i in range(m):\\n            lengths[i + 1] = lengths[i] << 1\\n        # Current position we want, and the total shift count\\n        cur_k = k\\n        shift_count = 0\\n        # Walk operations in reverse to map cur_k back to the original 'a'\\n        for i in range(m - 1, -1, -1):\\n            if cur_k > lengths[i]:\\n                # We're in the second half of the string after operation i\\n                cur_k -= lengths[i]\\n                # If this operation was a shift-append, accumulate one shift\\n                if operations[i] == 1:\\n                    shift_count = (shift_count + 1) % 26\\n        # After reversing all operations, we land at position cur_k in the initial string \\\"a\\\"\\n        # Since the initial word is \\\"a\\\" of length 1, cur_k must be 1\\n        # Apply the accumulated shifts to 'a'\\n        return chr((ord('a') - ord('a') + shift_count) % 26 + ord('a'))\"",
  "3261_14631217_python-updated-time": "1747413032899",
  "1095_14631217_python": "\"class Solution:\\n    def twoCitySchedCost(self, costs):\\n        costs.sort(key=lambda x: x[0] - x[1])\\n        n = len(costs) // 2\\n        return sum(c[0] for c in costs[:n]) + sum(c[1] for c in costs[n:])\\n\"",
  "3720_14631217_python-updated-time": "1747656860393",
  "1135_14631217_mysql": "\"SELECT\\n    customer_id\\nFROM\\n    Customer\\nGROUP BY\\n    customer_id\\nHAVING\\n    COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM Product);\\n\"",
  "2337_14631217_python-updated-time": "1746880449124",
  "2105_14631217_python": "\"class Solution:\\n    def numberOfGoodSubsets(self, nums):\\n        mod = 10**9 + 7\\n        from collections import Counter\\n\\n        freq = Counter(nums)\\n        # List of primes <= 30\\n        primes = [2,3,5,7,11,13,17,19,23,29]\\n        # Map prime to bit position\\n        p2bit = {p:i for i,p in enumerate(primes)}\\n\\n        # Precompute mask for each x in [2..30] if square-free; else mask = 0 (invalid)\\n        mask = [0]*31\\n        for x in range(2,31):\\n            m = 0\\n            y = x\\n            ok = True\\n            for p in primes:\\n                if p*p > y:\\n                    break\\n                if y % p == 0:\\n                    cnt = 0\\n                    while y % p == 0:\\n                        y //= p\\n                        cnt += 1\\n                    if cnt > 1:\\n                        ok = False\\n                        break\\n                    m |= 1 << p2bit[p]\\n            if not ok:\\n                continue\\n            # y is 1 or a prime > sqrt(x)\\n            if y > 1:\\n                if y not in p2bit:\\n                    # prime > 30? won't happen\\n                    ok = False\\n                else:\\n                    # ensure it appears only once\\n                    m |= 1 << p2bit[y]\\n            if ok:\\n                mask[x] = m\\n\\n        # dp over prime-masks\\n        M = 1 << len(primes)   # 2^10 = 1024\\n        dp = [0]*M\\n        dp[0] = 1\\n\\n        # For each x > 1 with freq and valid mask\\n        for x in range(2,31):\\n            m = mask[x]\\n            c = freq.get(x, 0)\\n            if c == 0 or m == 0:\\n                continue\\n            # update dp from high to low\\n            for pm in range(M-1, -1, -1):\\n                if dp[pm] and (pm & m) == 0:\\n                    dp[pm | m] = (dp[pm | m] + dp[pm] * c) % mod\\n\\n        # Sum all non-zero masks\\n        total = sum(dp[1:]) % mod\\n\\n        # Factor in 1's: each good subset can include any subset of 1's\\n        ones = freq.get(1, 0)\\n        if ones:\\n            total = total * pow(2, ones, mod) % mod\\n\\n        return total\\n\"",
  "104_14631217_python-updated-time": "1745081064533",
  "1469_14631217_python-updated-time": "1746262038699",
  "1928_14631217_python-updated-time": "1746542980566",
  "3233_14631217_python": "\"\\nclass Solution(object):\\n    def maxPartitionsAfterOperations(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        memo = {}\\n        n = len(s)\\n        \\n        def dp(idx, used_mask, can_change):\\n            \\\"\\\"\\\"\\n            idx: current position in string\\n            used_mask: bitmask of characters in current partition\\n            can_change: whether we can still change one character\\n            \\\"\\\"\\\"\\n            # Base case: End of string\\n            if idx == n:\\n                return 1\\n                \\n            # Check if already calculated\\n            state = (idx, used_mask, can_change)\\n            if state in memo:\\n                return memo[state]\\n                \\n            # Current character\\n            curr_char = ord(s[idx]) - ord('a')\\n            curr_bit = 1 << curr_char\\n            new_mask = used_mask | curr_bit\\n            distinct_count = bin(new_mask).count('1')\\n            \\n            # Option 1: Keep current character\\n            if distinct_count <= k:\\n                # Continue with current partition\\n                result = dp(idx + 1, new_mask, can_change)\\n            else:\\n                # Start a new partition\\n                result = 1 + dp(idx + 1, curr_bit, can_change)\\n                \\n            # Option 2: Change current character (if allowed)\\n            if can_change:\\n                max_with_change = 0\\n                \\n                # Try changing to all possible characters (except current)\\n                for new_char in range(26):\\n                    if new_char == curr_char:\\n                        continue\\n                        \\n                    # Calculate new mask with changed character\\n                    change_bit = 1 << new_char\\n                    change_mask = used_mask | change_bit\\n                    change_distinct = bin(change_mask).count('1')\\n                    \\n                    if change_distinct <= k:\\n                        # Continue current partition with changed character\\n                        max_with_change = max(max_with_change, dp(idx + 1, change_mask, False))\\n                    else:\\n                        # Start new partition with changed character\\n                        max_with_change = max(max_with_change, 1 + dp(idx + 1, change_bit, False))\\n                \\n                result = max(result, max_with_change)\\n                \\n            # Memoize and return\\n            memo[state] = result\\n            return result\\n            \\n        return dp(0, 0, True)\"",
  "876_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def isNStraightHand(self, hand, groupSize):\\n        if len(hand) % groupSize != 0:\\n            return False\\n        \\n        count = Counter(hand)\\n        keys = sorted(count)\\n        \\n        for key in keys:\\n            while count[key] > 0:\\n                for i in range(groupSize):\\n                    if count[key + i] == 0:\\n                        return False\\n                    count[key + i] -= 1\\n        return True\\n\"",
  "1260_14631217_python-updated-time": "1746125949589",
  "3891_14631217_mysql-updated-time": "1747744386976",
  "301_14631217_python": "\"class Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        from collections import deque\\n\\n        def is_valid(string):\\n            count = 0\\n            for char in string:\\n                if char == '(':\\n                    count += 1\\n                elif char == ')':\\n                    count -= 1\\n                    if count < 0:\\n                        return False\\n            return count == 0\\n\\n        queue = deque([s])\\n        visited = set([s])\\n        result = []\\n        found = False\\n\\n        while queue:\\n            current = queue.popleft()\\n            if is_valid(current):\\n                result.append(current)\\n                found = True\\n            if found:\\n                continue\\n            for i in range(len(current)):\\n                if current[i] not in ('(', ')'):\\n                    continue\\n                next_str = current[:i] + current[i+1:]\\n                if next_str not in visited:\\n                    visited.add(next_str)\\n                    queue.append(next_str)\\n\\n        return result\\n\"",
  "3451_14631217_python-updated-time": "1747483473546",
  "1802_14631217_python": "\"class Solution(object):\\n    def countStudents(self, students, sandwiches):\\n        \\\"\\\"\\\"\\n        :type students: List[int]\\n        :type sandwiches: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Count how many students prefer each type\\n        count0 = students.count(0)\\n        count1 = len(students) - count0\\n        \\n        # Serve sandwiches in order\\n        for s in sandwiches:\\n            if s == 0:\\n                if count0 > 0:\\n                    count0 -= 1\\n                else:\\n                    break\\n            else:  # s == 1\\n                if count1 > 0:\\n                    count1 -= 1\\n                else:\\n                    break\\n        \\n        # Remaining students unable to eat\\n        return count0 + count1\\n\"",
  "2580_14631217_python": "\"class Solution(object):\\n    def isCircularSentence(self, sentence):\\n        words = sentence.split(\\\" \\\")\\n        for i in range(len(words) - 1):\\n            if words[i][-1] != words[i + 1][0]:\\n                return False\\n        return words[-1][-1] == words[0][0]\\n\"",
  "3073_14631217_pythondata-updated-time": "1747306081099",
  "1786_14631217_python-updated-time": "1746452907659",
  "1346_14631217_python": "\"class Solution(object):\\n    def maximumTop(self, nums, k):\\n        n = len(nums)\\n        if k == 0:\\n            return nums[0]\\n        if n == 1:\\n            return nums[0] if k % 2 == 0 else -1\\n        if k == 1:\\n            return nums[1]\\n        if k > n:\\n            return max(nums)\\n        best = max(nums[:k - 1])               # take the largest among the first k-1 removed\\n        if k < n:                              # or leave the k-th element on top\\n            best = max(best, nums[k])\\n        return best\\n\"",
  "2877_14631217_python-updated-time": "1747223729519",
  "724_14631217_python-updated-time": "1745786877899",
  "3361_14631217_python-updated-time": "1747423744434",
  "433_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def minMutation(self, startGene, endGene, bank):\\n        bank_set = set(bank)\\n        if endGene not in bank_set:\\n            return -1\\n        \\n        queue = deque([(startGene, 0)])\\n        genes = ['A', 'C', 'G', 'T']\\n        \\n        while queue:\\n            gene, steps = queue.popleft()\\n            if gene == endGene:\\n                return steps\\n            for i in range(len(gene)):\\n                for g in genes:\\n                    if g != gene[i]:\\n                        next_gene = gene[:i] + g + gene[i+1:]\\n                        if next_gene in bank_set:\\n                            queue.append((next_gene, steps + 1))\\n                            bank_set.remove(next_gene)\\n        \\n        return -1\\n\"",
  "3803_14631217_mysql-updated-time": "1747681221831",
  "1755_14631217_python-updated-time": "1746445276972",
  "4_14631217_python": "\"class Solution(object):\\n    def findMedianSortedArrays(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        A, B = nums1, nums2\\n        m, n = len(A), len(B)\\n        if m > n:\\n            A, B, m, n = B, A, n, m\\n        \\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\\n        while imin <= imax:\\n            i = (imin + imax) // 2\\n            j = half_len - i\\n            if i < m and B[j-1] > A[i]:\\n                imin = i + 1\\n            elif i > 0 and A[i-1] > B[j]:\\n                imax = i - 1\\n            else:\\n                if i == 0: max_of_left = B[j-1]\\n                elif j == 0: max_of_left = A[i-1]\\n                else: max_of_left = max(A[i-1], B[j-1])\\n\\n                if (m + n) % 2 == 1:\\n                    return max_of_left\\n\\n                if i == m: min_of_right = B[j]\\n                elif j == n: min_of_right = A[i]\\n                else: min_of_right = min(A[i], B[j])\\n\\n                return (max_of_left + min_of_right) / 2.0\\n\"",
  "981_14631217_python-updated-time": "1746004655540",
  "3403_14631217_python": "\"class Solution(object):\\n    def minimumSubstringsInPartition(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # dp[i] = min # of balanced substrings covering s[:i]\\n        dp = [10**9] * (n+1)\\n        dp[0] = 0\\n\\n        for i in range(1, n+1):\\n            count = [0]*26\\n            distinct = 0\\n            maxf = 0\\n            # try all j ending at i\\n            for j in range(i, 0, -1):\\n                idx = ord(s[j-1]) - ord('a')\\n                if count[idx] == 0:\\n                    distinct += 1\\n                count[idx] += 1\\n                if count[idx] > maxf:\\n                    maxf = count[idx]\\n\\n                length = i - j + 1\\n                # balanced <=> all freq equal => maxf * distinct == length\\n                if maxf * distinct == length:\\n                    # we can cut here\\n                    if dp[j-1] + 1 < dp[i]:\\n                        dp[i] = dp[j-1] + 1\\n            # end for j\\n        # end for i\\n\\n        return dp[n]\\n\"",
  "62_14631217_python-updated-time": "1745014751143",
  "1529_14631217_python-updated-time": "1746347145512",
  "83_14631217_python-updated-time": "1745015394065",
  "463_14631217_python": "\"class Solution:\\n    def islandPerimeter(self, grid):\\n        rows, cols = len(grid), len(grid[0])\\n        perimeter = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c] == 1:\\n                    perimeter += 4\\n                    if r > 0 and grid[r - 1][c] == 1:\\n                        perimeter -= 2\\n                    if c > 0 and grid[r][c - 1] == 1:\\n                        perimeter -= 2\\n        return perimeter\\n\"",
  "2430_14631217_python-updated-time": "1746907909039",
  "904_14631217_python-updated-time": "1746001481140",
  "2262_14631217_python-updated-time": "1746802233596",
  "1748_14631217_python": "\"class Solution:\\n    def bestTeamScore(self, scores, ages):\\n        # Pair up and sort by age, then by score\\n        players = sorted(zip(ages, scores))\\n        n = len(players)\\n        \\n        # dp[i] = best score of a team ending with players[i]\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(n):\\n            age_i, score_i = players[i]\\n            dp[i] = score_i\\n            # Try to extend any j < i whose score <= this player's score\\n            for j in range(i):\\n                _, score_j = players[j]\\n                if score_j <= score_i:\\n                    dp[i] = max(dp[i], dp[j] + score_i)\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n\"",
  "1367_14631217_python": "\"class Solution(object):\\n    def maxHeight(self, cuboids):\\n        \\\"\\\"\\\"\\n        :type cuboids: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1. Normalize: sort dimensions of each cuboid so that d0 <= d1 <= d2\\n        for c in cuboids:\\n            c.sort()\\n        # 2. Sort cuboids lexicographically by (d0, d1, d2)\\n        cuboids.sort()\\n        \\n        n = len(cuboids)\\n        # dp[i]: max stack height ending with cuboid i on top\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(n):\\n            # standalone height is its own d2\\n            dp[i] = cuboids[i][2]\\n            # try placing it on any previous cuboid j\\n            for j in range(i):\\n                if (cuboids[j][0] <= cuboids[i][0] and\\n                    cuboids[j][1] <= cuboids[i][1] and\\n                    cuboids[j][2] <= cuboids[i][2]):\\n                    dp[i] = max(dp[i], dp[j] + cuboids[i][2])\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n\"",
  "1398_14631217_python": "\"class Solution:\\n    def numWays(self, steps, arrLen):\\n        MOD = 10**9 + 7\\n        max_pos = min(steps // 2 + 1, arrLen)\\n        dp = [0] * max_pos\\n        dp[0] = 1\\n\\n        for _ in range(steps):\\n            new_dp = [0] * max_pos\\n            for i in range(max_pos):\\n                new_dp[i] = dp[i]\\n                if i > 0:\\n                    new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\\n                if i + 1 < max_pos:\\n                    new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\\n            dp = new_dp\\n\\n        return dp[0]\\n\"",
  "1950_14631217_python-updated-time": "1746543879644",
  "1879_14631217_python": "\"class Solution(object):\\n    def maximumScore(self, a, b, c):\\n        \\\"\\\"\\\"\\n        :type a: int\\n        :type b: int\\n        :type c: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = a + b + c\\n        max_pile = max(a, b, c)\\n        return min(total // 2, total - max_pile)\\n\"",
  "121_14631217_python-updated-time": "1745081567823",
  "3439_14631217_python-updated-time": "1747486711292",
  "1678_14631217_python": "\"class Solution(object):\\n    def numWays(self, s):\\n        mod = 10**9 + 7\\n        n = len(s)\\n        total_ones = s.count('1')\\n        if total_ones % 3 != 0:\\n            return 0\\n        if total_ones == 0:\\n            # choose any two split points among n-1 gaps\\n            return ((n-1) * (n-2) // 2) % mod\\n        k = total_ones // 3\\n        ones = [i for i, ch in enumerate(s) if ch == '1']\\n        # gaps after k-th and 2k-th ones\\n        a = ones[k] - ones[k-1]\\n        b = ones[2*k] - ones[2*k-1]\\n        return (a * b) % mod\\n\"",
  "3397_14631217_python-updated-time": "1747424480150",
  "1297_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \\\"\\\"\\\"\\n        :type text: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = Counter(text)\\n        return min(\\n            count['b'],\\n            count['a'],\\n            count['l'] // 2,\\n            count['o'] // 2,\\n            count['n']\\n        )\\n\"",
  "3607_14631217_python": "\"class Solution(object):\\n    # --- Sieve precomputation as static class members ---\\n    # This code runs once when the class Solution is defined.\\n    MAX_VAL_S_STATIC = 1000000 \\n    _spf_table_s = range(MAX_VAL_S_STATIC + 1) # Initialize spf[i] = i\\n\\n    _sqrt_MAX_VAL_s = int(MAX_VAL_S_STATIC**0.5)\\n    for i in xrange(2, _sqrt_MAX_VAL_s + 1):\\n        if _spf_table_s[i] == i: # i is prime\\n            # Mark multiples of i. Start from i*i.\\n            for j in xrange(i*i, MAX_VAL_S_STATIC + 1, i):\\n                if _spf_table_s[j] == j: # If spf[j] is still j, then i is its smallest prime factor\\n                    _spf_table_s[j] = i\\n    # --- End of Sieve precomputation ---\\n\\n    def minOperations(self, nums):\\n        n = len(nums)\\n        # infinity is a value larger than any possible operation count (max n ops).\\n        infinity = n + 1 \\n\\n        # prev_ops0: min_ops for prefix ending at nums[i-1], if nums[i-1] took its original value.\\n        # prev_val0: the original value of nums[i-1].\\n        prev_ops0 = 0\\n        prev_val0 = 0 # Initial \\\"previous value\\\" before nums[0] is 0. Smallest nums[i] is 1.\\n\\n        # prev_ops1: min_ops for prefix ending at nums[i-1], if nums[i-1] took its SPF value.\\n        # prev_val1: the SPF value of nums[i-1].\\n        prev_ops1 = 0\\n        prev_val1 = 0\\n\\n        # Local reference to the static SPF table.\\n        spf_table_local_ref = Solution._spf_table_s\\n\\n        for i in xrange(n):\\n            num_val = nums[i]\\n\\n            # Case 1: nums[i] keeps its original value (num_val)\\n            # Cost for current element: 0 operations.\\n            current_orig_val = num_val\\n            current_orig_ops = infinity # Initialize with infinity\\n            \\n            # Check if num_val is non-decreasing w.r.t. prev_val0\\n            if num_val >= prev_val0:\\n                current_orig_ops = min(current_orig_ops, prev_ops0)\\n            # Check if num_val is non-decreasing w.r.t. prev_val1\\n            if num_val >= prev_val1:\\n                current_orig_ops = min(current_orig_ops, prev_ops1)\\n\\n            # Case 2: nums[i] is transformed to its SPF\\n            # Cost for current element: 1 operation.\\n            current_spf_val = infinity # Default if transformation is not possible/applicable\\n            current_spf_ops = infinity # Initialize with infinity\\n\\n            # Transformation is possible if num_val is composite and greater than 1.\\n            # spf_table_local_ref[num_val] will be < num_val if composite.\\n            # spf_table_local_ref[num_val] will be == num_val if prime.\\n            if num_val > 1 and spf_table_local_ref[num_val] != num_val:\\n                val_i_spf = spf_table_local_ref[num_val]\\n                current_spf_val = val_i_spf\\n                \\n                # Check if val_i_spf is non-decreasing w.r.t. prev_val0\\n                if val_i_spf >= prev_val0:\\n                    # prev_ops0 + 1 might exceed infinity if prev_ops0 is already infinity.\\n                    # This is fine as long as infinity + 1 is still treated as \\\"more than any valid count\\\".\\n                    current_spf_ops = min(current_spf_ops, prev_ops0 + 1)\\n                # Check if val_i_spf is non-decreasing w.r.t. prev_val1\\n                if val_i_spf >= prev_val1:\\n                    current_spf_ops = min(current_spf_ops, prev_ops1 + 1)\\n            \\n            # Update 'prev' states for the next iteration\\n            prev_val0 = current_orig_val\\n            prev_ops0 = current_orig_ops\\n            prev_val1 = current_spf_val\\n            prev_ops1 = current_spf_ops\\n        \\n        min_total_ops = min(prev_ops0, prev_ops1)\\n\\n        if min_total_ops >= infinity: # Use >= just in case infinity + 1 was stored\\n            return -1\\n        else:\\n            return min_total_ops\"",
  "2794_14631217_python-updated-time": "1747138660339",
  "3279_14631217_python": "\"class Solution(object):\\n    def flowerGame(self, n, m):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        odd_x = (n + 1) // 2\\n        even_x = n // 2\\n        odd_y = (m + 1) // 2\\n        even_y = m // 2\\n        return odd_x * even_y + even_x * odd_y\\n\"",
  "2421_14631217_python": "\"class Solution:\\n    def numberOfPairs(self, nums):\\n        counts = {}\\n        for x in nums:\\n            counts[x] = counts.get(x, 0) + 1\\n        \\n        pairs = 0\\n        for cnt in counts.values():\\n            pairs += cnt // 2\\n        \\n        leftover = len(nums) - 2 * pairs\\n        return [pairs, leftover]\\n\"",
  "268_14631217_python": "\"class Solution(object):\\n    def missingNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        expected_sum = n * (n + 1) // 2\\n        actual_sum = sum(nums)\\n        return expected_sum - actual_sum\\n\"",
  "1147_14631217_python": "\"class Solution(object):\\n    def maxEqualRowsAfterFlips(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        pattern_count = defaultdict(int)\\n\\n        for row in matrix:\\n            # Normalize by making first element 0 (flip whole row if needed)\\n            normalized = tuple(val ^ row[0] for val in row)\\n            pattern_count[normalized] += 1\\n\\n        return max(pattern_count.values())\\n\"",
  "3226_14631217_python-updated-time": "1747318769168",
  "1465_14631217_python": "\"class Solution:\\n    def maxProduct(self, root):\\n        MOD = 10**9 + 7\\n\\n        # 1) Compute total sum of all nodes\\n        def compute_total(node):\\n            if not node:\\n                return 0\\n            return node.val + compute_total(node.left) + compute_total(node.right)\\n\\n        total = compute_total(root)\\n        self.max_prod = 0\\n\\n        # 2) Compute subtree sums and update max product\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            s = node.val + dfs(node.left) + dfs(node.right)\\n            prod = s * (total - s)\\n            if prod > self.max_prod:\\n                self.max_prod = prod\\n            return s\\n\\n        dfs(root)\\n        return self.max_prod % MOD\\n\"",
  "3317_14631217_python-updated-time": "1747413732827",
  "1169_14631217_python-updated-time": "1746108199437",
  "2276_14631217_python": "\"class Solution:\\n    def groupStrings(self, words):\\n        from collections import defaultdict\\n\\n        def word_to_mask(word):\\n            mask = 0\\n            for ch in word:\\n                mask |= 1 << (ord(ch) - ord('a'))\\n            return mask\\n\\n        parent = {}\\n        size = defaultdict(int)\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px != py:\\n                parent[py] = px\\n                size[px] += size[py]\\n\\n        masks = set()\\n        for word in words:\\n            m = word_to_mask(word)\\n            masks.add(m)\\n            parent[m] = m\\n            size[m] += 1\\n\\n        for m in list(masks):\\n            # Try removing each letter\\n            for i in range(26):\\n                if (m >> i) & 1:\\n                    m2 = m ^ (1 << i)\\n                    if m2 in parent:\\n                        union(m, m2)\\n\\n            # Try replacing each letter (remove + add)\\n            for i in range(26):\\n                if (m >> i) & 1:\\n                    m_removed = m ^ (1 << i)\\n                    for j in range(26):\\n                        if not (m_removed >> j) & 1:\\n                            m2 = m_removed | (1 << j)\\n                            if m2 in parent:\\n                                union(m, m2)\\n\\n        groups = set(find(m) for m in masks)\\n        max_size = max(size[find(m)] for m in masks)\\n        return [len(groups), max_size]\\n\"",
  "2304_14631217_python-updated-time": "1746804219130",
  "preferred_lang-updated-time": "1719133614948",
  "2881_14631217_python": "\"class Solution:\\n    def splitWordsBySeparator(self, words, separator):\\n        result = []\\n        for word in words:\\n            result.extend([w for w in word.split(separator) if w])\\n        return result\\n\"",
  "1128_14631217_python-updated-time": "1746042967197",
  "3382_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # 1) Next greater element index to the right (strictly greater)\\n        NG = [n] * n\\n        stack = []\\n        for i, x in enumerate(nums):\\n            while stack and nums[stack[-1]] < x:\\n                NG[stack.pop()] = i\\n            stack.append(i)\\n        \\n        # 2) Group positions by value\\n        from collections import defaultdict\\n        pos = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            pos[x].append(i)\\n        \\n        # 3) For each group, sum up counts\\n        ans = 0\\n        for v, plist in pos.items():\\n            # plist is sorted increasing by construction\\n            k = len(plist)\\n            for t, idx in enumerate(plist):\\n                # find first position in plist where plist[u] >= NG[idx]\\n                ub = bisect.bisect_left(plist, NG[idx])\\n                ans += (ub - t)\\n        \\n        return ans\\n\"",
  "2864_14631217_javascript": "\"var isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n\"",
  "551_14631217_python-updated-time": "1745447186014",
  "3471_14631217_python": "\"class Solution(object):\\n    def minimumAverage(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: float\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        min_avg = float('inf')\\n        for i in range(n // 2):\\n            avg = (nums[i] + nums[n - 1 - i]) / 2.0\\n            if avg < min_avg:\\n                min_avg = avg\\n        return min_avg\\n\"",
  "126_14631217_python-updated-time": "1745084810826",
  "2390_14631217_python-updated-time": "1746882284390",
  "2752_14631217_python-updated-time": "1747136347018",
  "3277_14631217_python": "\"class Solution(object):\\n    def numberOfPairs(self, points):\\n        \\\"\\\"\\\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(points)\\n        # 1) Coordinate‐compress x and y separately\\n        xs = sorted({x for x, _ in points})\\n        ys = sorted({y for _, y in points})\\n        map_x = {x:i for i, x in enumerate(xs)}\\n        map_y = {y:i for i, y in enumerate(ys)}\\n        nx, ny = len(xs), len(ys)\\n        \\n        # 2) Build the occupancy grid G\\n        G = [[0]*ny for _ in range(nx)]\\n        comp = [None]*n\\n        for idx, (x, y) in enumerate(points):\\n            cx = map_x[x]\\n            cy = map_y[y]\\n            G[cx][cy] = 1\\n            comp[idx] = (cx, cy)\\n        \\n        # 3) Build 2D prefix‐sum P over G\\n        #    P[i+1][j+1] = sum of G[0..i][0..j]\\n        P = [[0]*(ny+1) for _ in range(nx+1)]\\n        for i in range(nx):\\n            row_sum = 0\\n            for j in range(ny):\\n                row_sum += G[i][j]\\n                P[i+1][j+1] = P[i][j+1] + row_sum\\n        \\n        # 4) Count all ordered pairs (i->Alice, j->Bob)\\n        ans = 0\\n        for i in range(n):\\n            xi, yi = comp[i]\\n            for j in range(n):\\n                xj, yj = comp[j]\\n                # Alice at i must be upper‐left of Bob at j\\n                if xi <= xj and yi >= yj:\\n                    # query how many points in the inclusive rectangle [xi..xj] x [yj..yi]\\n                    cnt = (\\n                        P[xj+1][yi+1]\\n                        - P[xi][yi+1]\\n                        - P[xj+1][yj]\\n                        + P[xi][yj]\\n                    )\\n                    # if exactly those two, it's empty\\n                    if cnt == 2:\\n                        ans += 1\\n        \\n        return ans\\n\"",
  "1657_14631217_python": "\"class Solution(object):\\n    def getWinner(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_elem = max(arr)\\n        win_count = 0\\n        current = arr[0]\\n\\n        for i in range(1, len(arr)):\\n            if current > arr[i]:\\n                win_count += 1\\n            else:\\n                current = arr[i]\\n                win_count = 1\\n\\n            if win_count == k or current == max_elem:\\n                return current\\n\\n        return current\\n\"",
  "804_14631217_python-updated-time": "1745877678716",
  "1764_14631217_python-updated-time": "1746445830770",
  "2527_14631217_python-updated-time": "1746968121476",
  "881_14631217_python-updated-time": "1745953617894",
  "198_14631217_python-updated-time": "1745093092358",
  "1352_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def jobScheduling(self, startTime, endTime, profit):\\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\\n        dp = [(0, 0)]  # (endTime, maxProfit)\\n\\n        for s, e, p in jobs:\\n            i = bisect.bisect_right(dp, (s, float('inf'))) - 1\\n            if dp[i][1] + p > dp[-1][1]:\\n                dp.append((e, dp[i][1] + p))\\n        \\n        return dp[-1][1]\\n\"",
  "1892_14631217_mysql-updated-time": "1746531189194",
  "3456_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # dp[i][t] = max length of a subsequence ending at i with exactly t transitions\\n        dp = [[0] * (k+1) for _ in range(n)]\\n        ans = 0\\n        \\n        for i in range(n):\\n            # You can always start a subsequence at i with 0 transitions\\n            dp[i][0] = 1\\n            ans = max(ans, 1)\\n            \\n            for j in range(i):\\n                if nums[j] == nums[i]:\\n                    # extending without using an extra transition\\n                    for t in range(k+1):\\n                        if dp[j][t]:\\n                            cand = dp[j][t] + 1\\n                            if cand > dp[i][t]:\\n                                dp[i][t] = cand\\n                                if cand > ans:\\n                                    ans = cand\\n                else:\\n                    # extending by using one more transition\\n                    for t in range(1, k+1):\\n                        if dp[j][t-1]:\\n                            cand = dp[j][t-1] + 1\\n                            if cand > dp[i][t]:\\n                                dp[i][t] = cand\\n                                if cand > ans:\\n                                    ans = cand\\n        \\n        return ans\\n\"",
  "1849_14631217_python": "\"class Solution(object):\\n    def maxAbsoluteSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        max_sum = 0\\n        min_sum = 0\\n        current_max = 0\\n        current_min = 0\\n\\n        for num in nums:\\n            current_max = max(num, current_max + num)\\n            max_sum = max(max_sum, current_max)\\n\\n            current_min = min(num, current_min + num)\\n            min_sum = min(min_sum, current_min)\\n\\n        return max(max_sum, -min_sum)\\n\"",
  "2753_14631217_python-updated-time": "1747136634227",
  "1514_14631217_python-updated-time": "1746346744384",
  "1492_14631217_python": "\"class Solution(object):\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        from collections import defaultdict\\n\\n        tree = defaultdict(list)\\n        for i in range(n):\\n            if manager[i] != -1:\\n                tree[manager[i]].append(i)\\n\\n        def dfs(emp):\\n            if not tree[emp]:\\n                return 0\\n            return informTime[emp] + max(dfs(sub) for sub in tree[emp])\\n\\n        return dfs(headID)\\n\"",
  "2189_14631217_python-updated-time": "1746720981444",
  "2198_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        self.r = [0]*n\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        if rx == ry:\\n            return False\\n        if self.r[rx] < self.r[ry]:\\n            self.p[rx] = ry\\n        elif self.r[ry] < self.r[rx]:\\n            self.p[ry] = rx\\n        else:\\n            self.p[ry] = rx\\n            self.r[rx] += 1\\n        return True\\n\\nclass Solution:\\n    def friendRequests(self, n, restrictions, requests):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type restrictions: List[List[int]]\\n        :type requests: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        dsu = DSU(n)\\n        res = []\\n        \\n        for u, v in requests:\\n            ru, rv = dsu.find(u), dsu.find(v)\\n            # if already in same group, it's successful\\n            if ru == rv:\\n                res.append(True)\\n                continue\\n            \\n            # check all restrictions: merging ru and rv should not put any\\n            # restricted pair into same component\\n            ok = True\\n            for x, y in restrictions:\\n                rx, ry = dsu.find(x), dsu.find(y)\\n                # after merge, ru and rv become same. So if one of {rx,ry}\\n                # equals ru and the other equals rv, they'd be together\\n                if (rx == ru and ry == rv) or (rx == rv and ry == ru):\\n                    ok = False\\n                    break\\n            \\n            if ok:\\n                dsu.union(ru, rv)\\n                res.append(True)\\n            else:\\n                res.append(False)\\n        \\n        return res\\n\"",
  "1530_14631217_python-updated-time": "1746347165677",
  "2626_14631217_python-updated-time": "1747061076958",
  "2107_14631217_python-updated-time": "1746715727685",
  "54_14631217_python-updated-time": "1745014285956",
  "3674_14631217_python": "\"class Solution(object):\\n    def countNonDecreasingSubarrays(self, nums, k):\\n        n = len(nums)\\n        # 1) prefix sums of nums for O(1) range‐sum\\n        P = [0]*(n+1)\\n        for i in range(n):\\n            P[i+1] = P[i] + nums[i]\\n\\n        # 2) next greater element to the right (or n if none)\\n        nge = [n]*n\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                nge[stack.pop()] = i\\n            stack.append(i)\\n\\n        # 3) build binary‐lifting tables up[k][i] and sumLen[k][i]\\n        LOG = (n+1).bit_length()\\n        up     = [ [n]*n for _ in range(LOG) ]\\n        sumLen = [ [0]*n for _ in range(LOG) ]\\n\\n        # k = 0\\n        for i in range(n):\\n            up[0][i] = nge[i]\\n            sumLen[0][i] = nums[i] * (nge[i] - i)\\n\\n        # k ≥ 1\\n        for kk in range(1, LOG):\\n            u0 = up[kk-1]\\n            s0 = sumLen[kk-1]\\n            u1 = up[kk]\\n            s1 = sumLen[kk]\\n            for i in range(n):\\n                j = u0[i]\\n                if j < n:\\n                    u1[i] = u0[j]\\n                    s1[i] = s0[i] + s0[j]\\n                else:\\n                    u1[i] = n\\n                    s1[i] = s0[i]\\n\\n        # cost(L,R) = sum_{p=L..R} max(nums[L..p]) - sum(nums[L..R])\\n        def cost(L, R):\\n            sum_a = P[R+1] - P[L]\\n            acc = 0\\n            cur = L\\n            for kk in reversed(range(LOG)):\\n                nxt = up[kk][cur]\\n                if nxt <= R:\\n                    acc += sumLen[kk][cur]\\n                    cur = nxt\\n            # last segment from cur..R all have prefix‐max = nums[cur]\\n            acc += nums[cur] * (R - cur + 1)\\n            return acc - sum_a\\n\\n        # 4) for each R, binary‐search smallest L so cost(L,R) ≤ k\\n        ans = 0\\n        for R in range(n):\\n            lo, hi, best = 0, R, R+1\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                if cost(mid, R) <= k:\\n                    best = mid\\n                    hi = mid - 1\\n                else:\\n                    lo = mid + 1\\n            if best <= R:\\n                ans += (R - best + 1)\\n        return ans\\n\"",
  "3217_14631217_python-updated-time": "1747317201296",
  "3469_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def maxHeightOfTriangle(self, red, blue):\\n        \\\"\\\"\\\"\\n        :type red: int\\n        :type blue: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n\\n        # Helper: floor of sqrt(x)\\n        def isqrt(x):\\n            return int(math.sqrt(x))\\n\\n        # For odd h = 2*k - 1:\\n        #   odd rows sum = k^2\\n        #   even rows sum = k*(k-1)\\n        # Starting with red: require k^2 <= red  and  k*(k-1) <= blue\\n        k1 = min(\\n            isqrt(red),\\n            (1 + int(math.sqrt(1 + 4*blue))) // 2\\n        )\\n        h_odd_R = 2*k1 - 1\\n\\n        # Starting with blue:\\n        k2 = min(\\n            isqrt(blue),\\n            (1 + int(math.sqrt(1 + 4*red))) // 2\\n        )\\n        h_odd_B = 2*k2 - 1\\n\\n        # For even h = 2*k:\\n        #   odd rows sum = k^2\\n        #   even rows sum = k*(k+1)\\n        # Starting with red: require k^2 <= red  and  k*(k+1) <= blue\\n        k3 = min(\\n            isqrt(red),\\n            ( -1 + int(math.sqrt(1 + 4*blue)) ) // 2\\n        )\\n        h_even_R = 2*k3\\n\\n        # Starting with blue:\\n        k4 = min(\\n            isqrt(blue),\\n            ( -1 + int(math.sqrt(1 + 4*red)) ) // 2\\n        )\\n        h_even_B = 2*k4\\n\\n        return max(h_odd_R, h_odd_B, h_even_R, h_even_B)\\n\"",
  "3611_14631217_python-updated-time": "1747577948339",
  "2422_14631217_python-updated-time": "1746907574742",
  "3351_14631217_python": "\"class Solution(object):\\n    def maximumHappinessSum(self, happiness, k):\\n        \\\"\\\"\\\"\\n        :type happiness: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Sort in descending order\\n        happiness.sort(reverse=True)\\n        \\n        total = 0\\n        # For pick i (0-based), its value is max(happiness[i] - i, 0)\\n        for i in range(k):\\n            val = happiness[i] - i\\n            if val > 0:\\n                total += val\\n            else:\\n                # further terms will only be smaller or zero\\n                break\\n        \\n        return total\\n\"",
  "781_14631217_python-updated-time": "1745876460299",
  "3638_14631217_python": "\"class Solution(object):\\n    def makeStringGood(self, s):\\n        # 1) histogram -------------------------------------------------------\\n        f = [0] * 26\\n        for ch in s:\\n            f[ord(ch) - 97] += 1\\n        M = max(f)                       # largest bucket,  ≤ n\\n\\n        INF  = 10 ** 9\\n        best = INF\\n\\n        # 2) try every target multiplicity k = 1 … M ------------------------\\n        for k in xrange(1, M + 1):\\n\\n            # dp[inc_prev][has_kept_any]\\n            dp = [[INF, INF], [INF, INF]]\\n            dp[0][0] = f[0]              # delete bucket 'a'\\n            dp[1][1] = abs(f[0] - k)     # keep bucket 'a'\\n\\n            # walk through 'b' … 'z'\\n            for i in xrange(1, 26):\\n                ndp = [[INF, INF], [INF, INF]]\\n\\n                for inc_prev in (0, 1):\\n                    for has in (0, 1):\\n                        cur = dp[inc_prev][has]\\n                        if cur >= INF:\\n                            continue\\n\\n                        surplus_prev = f[i-1] if inc_prev == 0 \\\\\\n                                       else max(0, f[i-1] - k)\\n\\n                        for inc in (0, 1):\\n                            cost_now = f[i] if inc == 0 \\\\\\n                                       else abs(f[i] - k)\\n                            deficit  = 0 if inc == 0 \\\\\\n                                       else max(0, k - f[i])\\n\\n                            benefit  = min(surplus_prev, deficit)  # use change\\n                            new_has  = has or inc\\n\\n                            cand = cur + cost_now - benefit\\n                            if cand < ndp[inc][new_has]:\\n                                ndp[inc][new_has] = cand\\n\\n                dp = ndp\\n\\n            best = min(best, dp[0][1], dp[1][1])     # must keep ≥ 1 bucket\\n\\n        return best\\n\"",
  "3367_14631217_python": "\"class Solution(object):\\n    def sumOfEncryptedInt(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        total = 0\\n        for x in nums:\\n            s = str(x)\\n            m = max(s)\\n            total += int(m * len(s))\\n        return total\\n\"",
  "732_14631217_python": "\"from collections import Counter\\n\\nclass MyCalendarThree(object):\\n    def __init__(self):\\n        self.delta = Counter()\\n\\n    def book(self, startTime, endTime):\\n        self.delta[startTime] += 1\\n        self.delta[endTime] -= 1\\n        curr = 0\\n        res = 0\\n        for t in sorted(self.delta):\\n            curr += self.delta[t]\\n            res = max(res, curr)\\n        return res\"",
  "890_14631217_python-updated-time": "1745953970722",
  "2491_14631217_python": "\"class Solution:\\n    def smallestEvenMultiple(self, n):\\n        return n if n % 2 == 0 else 2 * n\\n\"",
  "3413_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def findWinningPlayer(self, skills, k):\\n        \\\"\\\"\\\"\\n        :type skills: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(skills)\\n        # If k >= n, the best player (max skill) will inevitably win n-1 in a row\\n        # before anyone else can, so we can return its index immediately.\\n        if k >= n:\\n            # Unique skills ⇒ index of max\\n            return skills.index(max(skills))\\n        \\n        # Initialize the “current champion” and a queue of challengers.\\n        # We store (skill, index) tuples.\\n        champ_skill = skills[0]\\n        champ_idx   = 0\\n        wins = 0\\n        \\n        dq = deque()\\n        for i in range(1, n):\\n            dq.append((skills[i], i))\\n        \\n        # Simulate until someone reaches k consecutive wins\\n        while True:\\n            opp_skill, opp_idx = dq.popleft()\\n            \\n            if champ_skill > opp_skill:\\n                # champion wins\\n                wins += 1\\n                # loser goes to back\\n                dq.append((opp_skill, opp_idx))\\n            else:\\n                # challenger becomes new champion\\n                dq.append((champ_skill, champ_idx))\\n                champ_skill, champ_idx = opp_skill, opp_idx\\n                wins = 1\\n            \\n            if wins == k:\\n                return champ_idx\\n\"",
  "1264_14631217_python-updated-time": "1746638227775",
  "937_14631217_python": "\"class StockSpanner:\\n    def __init__(self):\\n        self.stack = []\\n\\n    def next(self, price):\\n        span = 1\\n        while self.stack and self.stack[-1][0] <= price:\\n            span += self.stack.pop()[1]\\n        self.stack.append((price, span))\\n        return span\\n\"",
  "885_14631217_python-updated-time": "1745953723992",
  "449_14631217_python-updated-time": "1745359186854",
  "1136_14631217_mysql": "\"SELECT actor_id, director_id\\nFROM ActorDirector\\nGROUP BY actor_id, director_id\\nHAVING COUNT(*) >= 3;\\n\"",
  "1012_14631217_python-updated-time": "1746039939292",
  "375_14631217_python-updated-time": "1745354652410",
  "3191_14631217_python": "\"class Solution(object):\\n    def maximumScoreAfterOperations(self, edges, values):\\n        n = len(values)\\n        # build adjacency\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        # root at 0, build children lists via a BFS/DFS\\n        parent = [-1]*n\\n        parent[0] = 0\\n        order = [0]\\n        for u in order:\\n            for v in adj[u]:\\n                if parent[v] < 0:\\n                    parent[v] = u\\n                    order.append(v)\\n\\n        children = [[] for _ in range(n)]\\n        for u in range(1, n):\\n            children[parent[u]].append(u)\\n\\n        # dp0[u] = min total value of chosen R-nodes in subtree(u)\\n        #           so that every root→leaf path in that subtree is hit,\\n        #           assuming no ancestor of u is in R.\\n        dp0 = [0]*n\\n\\n        # process nodes in reverse BFS/DFS order (i.e. leaves first)\\n        for u in reversed(order):\\n            if not children[u]:\\n                # u is a leaf: must pick u\\n                dp0[u] = values[u]\\n            else:\\n                # Option1: pick u itself → cost = values[u]\\n                # Option2: don't pick u → sum costs of children\\n                cost_children = sum(dp0[v] for v in children[u])\\n                dp0[u] = min(values[u], cost_children)\\n\\n        total = sum(values)\\n        # best score = total values - min cost of R\\n        return total - dp0[0]\"",
  "2427_14631217_python-updated-time": "1746907808614",
  "2444_14631217_python-updated-time": "1746964858653",
  "2263_14631217_python": "\"class Solution:\\n    def maxRunTime(self, n, batteries):\\n        total = sum(batteries)\\n        left, right = 0, total // n\\n\\n        def can_run_all(t):\\n            return sum(min(b, t) for b in batteries) >= t * n\\n\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if can_run_all(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return left\\n\"",
  "3460_14631217_python-updated-time": "1747485535214",
  "2651_14631217_python": "\"class Solution(object):\\n    def countWays(self, ranges):\\n        MOD = 10**9 + 7\\n\\n        # Step 1: Sort by start\\n        ranges.sort()\\n\\n        count = 0\\n        end = -1\\n\\n        # Step 2: Merge overlapping intervals\\n        for start, stop in ranges:\\n            if start > end:\\n                count += 1  # new component\\n                end = stop\\n            else:\\n                end = max(end, stop)\\n\\n        # Step 3: Return 2^count % MOD\\n        return pow(2, count, MOD)\\n\"",
  "2664_14631217_python-updated-time": "1747067210105",
  "1431_14631217_python": "\"class Solution:\\n    def getAncestors(self, n, edgeList):\\n        # Step 1: Build the adjacency list for the graph\\n        graph = [[] for _ in range(n)]\\n        for from_node, to_node in edgeList:\\n            graph[to_node].append(from_node)  # reverse edges for easier ancestor finding\\n        \\n        # Step 2: Cache to store the ancestors of each node\\n        ancestors_cache = {}\\n\\n        # Step 3: DFS function to find ancestors of a node\\n        def dfs(node):\\n            if node in ancestors_cache:\\n                return ancestors_cache[node]\\n            \\n            # Start with an empty set of ancestors\\n            ancestors = set()\\n            for parent in graph[node]:\\n                ancestors.add(parent)  # add the immediate parent\\n                ancestors.update(dfs(parent))  # add ancestors of the parent recursively\\n            \\n            ancestors_cache[node] = ancestors\\n            return ancestors\\n        \\n        # Step 4: Find ancestors for all nodes\\n        result = []\\n        for i in range(n):\\n            result.append(sorted(list(dfs(i))))  # Get ancestors for node i and sort them\\n            \\n        return result\"",
  "3638_14631217_python-updated-time": "1747597835636",
  "1621_14631217_python-updated-time": "1746433097857",
  "3461_14631217_python-updated-time": "1747485649935",
  "445_14631217_python": "\"# Definition for singly-linked list.\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        stack1 = []\\n        stack2 = []\\n        \\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n        \\n        carry = 0\\n        head = None\\n        \\n        while stack1 or stack2 or carry:\\n            x = stack1.pop() if stack1 else 0\\n            y = stack2.pop() if stack2 else 0\\n            total = x + y + carry\\n            carry = total // 10\\n            node = ListNode(total % 10)\\n            node.next = head\\n            head = node\\n        \\n        return head\\n\"",
  "1300_14631217_python": "\"class Solution(object):\\n    def criticalConnections(self, n, connections):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type connections: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        graph = defaultdict(list)\\n        for u, v in connections:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        disc = [-1] * n  # discovery times\\n        low = [-1] * n   # lowest reachable time\\n        res = []\\n        time = [0]\\n\\n        def dfs(u, parent):\\n            disc[u] = low[u] = time[0]\\n            time[0] += 1\\n            for v in graph[u]:\\n                if v == parent:\\n                    continue\\n                if disc[v] == -1:\\n                    dfs(v, u)\\n                    low[u] = min(low[u], low[v])\\n                    if low[v] > disc[u]:\\n                        res.append([u, v])\\n                else:\\n                    low[u] = min(low[u], disc[v])\\n\\n        dfs(0, -1)\\n        return res\\n\"",
  "2437_14631217_python-updated-time": "1746964563262",
  "3762_14631217_python": "\"class Solution(object):\\n    def maxScore(self, points, m):\\n        \\\"\\\"\\\"\\n        :type points: List[int]\\n        :type m: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(points)\\n\\n        def can(X):\\n            # how many visits we need at each i\\n            N = [(X + p - 1)//p for p in points]\\n            # L_prev = times we crossed into node 0 from -1\\n            L_prev = 1   # the very first move must be -1->0\\n            moves = 1    # that initial move\\n\\n            # now for j=0..n-2 we choose R_j and L_j greedily\\n            # R_j = max(0, N[j] - L_prev)  (visits at j from the right)\\n            # must have R_j <= L_j  (can't cross back more than we crossed forward)\\n            # so we set L_j = max(R_j, N[j+1]) when j=n-2 (to serve last node),\\n            # otherwise L_j = R_j\\n            for j in xrange(n-1):\\n                # how many times must we come back from j+1->j?\\n                R = N[j] - L_prev\\n                if R < 0:\\n                    R = 0\\n                # how many times must we go forward j->j+1?\\n                if j == n-2:\\n                    # last edge must also deliver N[n-1] visits at node n-1\\n                    L = max(R, N[j+1])\\n                else:\\n                    L = R\\n                moves += R + L\\n                if moves > m:\\n                    return False\\n                L_prev = L\\n\\n            return True\\n\\n        # binary search for the largest X with can(X) == True\\n        lo, hi, ans = 0, m*max(points), 0\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if can(mid):\\n                ans = mid\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n\\n        return ans\\n\"",
  "377_14631217_python": "\"class Solution:\\n    def combinationSum4(self, nums, target):\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[target]\\n\"",
  "1837_14631217_mysql": "\"SELECT\\n  date_id,\\n  make_name,\\n  COUNT(DISTINCT lead_id)    AS unique_leads,\\n  COUNT(DISTINCT partner_id) AS unique_partners\\nFROM\\n  DailySales\\nGROUP BY\\n  date_id,\\n  make_name;\\n\"",
  "991_14631217_python-updated-time": "1746038631008",
  "1739_14631217_python": "\"class Solution:\\n    def check(self, a, b):\\n        l, r = 0, len(a) - 1\\n        # Move inward while the mixed ends match\\n        while l < r and a[l] == b[r]:\\n            l += 1\\n            r -= 1\\n        # If we've crossed, the mix is already a palindrome\\n        if l >= r:\\n            return True\\n        # Otherwise, check the remainder in either original string\\n        return self.is_pal(a, l, r) or self.is_pal(b, l, r)\\n\\n    def is_pal(self, s, i, j):\\n        # Standard palindrome check on s[i..j]\\n        while i < j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n\\n    def checkPalindromeFormation(self, a, b):\\n        # Try aprefix + bsuffix or bprefix + asuffix\\n        return self.check(a, b) or self.check(b, a)\\n\"",
  "3729_14631217_python-updated-time": "1747683806676",
  "664_14631217_python": "\"class Solution(object):\\n    def strangePrinter(self, s):\\n        if not s:\\n            return 0\\n        \\n        # remove consecutive duplicate characters\\n        new_s = []\\n        for ch in s:\\n            if not new_s or new_s[-1] != ch:\\n                new_s.append(ch)\\n        s = ''.join(new_s)\\n        \\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n-1, -1, -1):\\n            dp[i][i] = 1\\n            for j in range(i+1, n):\\n                dp[i][j] = dp[i+1][j] + 1\\n                for k in range(i+1, j+1):\\n                    if s[k] == s[i]:\\n                        dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\\n        \\n        return dp[0][n-1]\\n\"",
  "778_14631217_python-updated-time": "1745876195286",
  "3784_14631217_python-updated-time": "1747820650610",
  "1228_14631217_python": "\"class Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        stack = [float('inf')]\\n        res = 0\\n        \\n        for num in arr:\\n            while stack[-1] <= num:\\n                mid = stack.pop()\\n                res += mid * min(stack[-1], num)\\n            stack.append(num)\\n\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n\\n        return res\\n\"",
  "977_14631217_python": "\"class Solution:\\n    def distinctSubseqII(self, s):\\n        MOD = 10**9 + 7\\n        dp = [0] * (len(s) + 1)\\n        dp[0] = 1  # empty subsequence\\n\\n        last = {}  # last occurrence index of each character\\n\\n        for i in range(len(s)):\\n            char = s[i]\\n            dp[i + 1] = (dp[i] * 2) % MOD\\n            if char in last:\\n                dp[i + 1] = (dp[i + 1] - dp[last[char]]) % MOD\\n            last[char] = i\\n\\n        # subtract the empty subsequence\\n        return (dp[len(s)] - 1) % MOD\\n\"",
  "1691_14631217_python": "\"class Solution(object):\\n    def minDays(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        \\n        def count_islands():\\n            seen = [[False]*n for _ in range(m)]\\n            def dfs(i, j):\\n                stack = [(i,j)]\\n                seen[i][j] = True\\n                while stack:\\n                    x, y = stack.pop()\\n                    for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):\\n                        nx, ny = x+dx, y+dy\\n                        if 0 <= nx < m and 0 <= ny < n \\\\\\n                           and grid[nx][ny] == 1 and not seen[nx][ny]:\\n                            seen[nx][ny] = True\\n                            stack.append((nx, ny))\\n            \\n            islands = 0\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1 and not seen[i][j]:\\n                        islands += 1\\n                        dfs(i, j)\\n            return islands\\n        \\n        # Step 1: if already disconnected\\n        if count_islands() != 1:\\n            return 0\\n        \\n        # Step 2: try removing one land cell\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    if count_islands() != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        \\n        # Step 3: otherwise, needs two removals\\n        return 2\\n\"",
  "3772_14631217_python-updated-time": "1747744021659",
  "3418_14631217_python": "\"class Solution(object):\\n    def countCompleteDayPairs(self, hours):\\n        \\\"\\\"\\\"\\n        :type hours: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Count how many times each remainder mod 24 appears\\n        freq = [0]*24\\n        for h in hours:\\n            freq[h % 24] += 1\\n\\n        # Pairs among remainder 0\\n        res = freq[0] * (freq[0] - 1) // 2\\n\\n        # Pairs between r and 24-r for r = 1..11\\n        for r in range(1, 12):\\n            res += freq[r] * freq[24 - r]\\n\\n        # Pairs among remainder 12 (since 12+12 = 24)\\n        res += freq[12] * (freq[12] - 1) // 2\\n\\n        return res\\n\"",
  "1423_14631217_python-updated-time": "1746260488203",
  "3717_14631217_python-updated-time": "1747743504343",
  "1496_14631217_python": "\"class Solution(object):\\n    def luckyNumbers(self, matrix):\\n        min_in_rows = {min(row) for row in matrix}\\n        max_in_cols = {max(col) for col in zip(*matrix)}\\n        return list(min_in_rows & max_in_cols)\\n\"",
  "240_14631217_python-updated-time": "1745247577173",
  "3379_14631217_python3": "\"class Solution:\\n    def scoreOfString(self, s: str) -> int:\\n        # Initialize the score\\n        score = 0\\n        \\n        # Iterate through the string, calculating the absolute difference between adjacent characters\\n        for i in range(len(s) - 1):\\n            score += abs(ord(s[i]) - ord(s[i + 1]))\\n        \\n        return score        \"",
  "1651_14631217_python": "\"class Solution(object):\\n    def restoreString(self, s, indices):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type indices: List[int]\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        res = [''] * len(s)\\n        for i, pos in enumerate(indices):\\n            res[pos] = s[i]\\n        return ''.join(res)\\n\"",
  "503_14631217_python": "\"class Solution:\\n    def nextGreaterElements(self, nums):\\n        n = len(nums)\\n        res = [-1] * n\\n        stack = []\\n\\n        for i in range(2 * n):\\n            num = nums[i % n]\\n            while stack and nums[stack[-1]] < num:\\n                res[stack.pop()] = num\\n            if i < n:\\n                stack.append(i)\\n        \\n        return res\\n\"",
  "1094_14631217_python-updated-time": "1746042073790",
  "2497_14631217_python": "\"class Solution:\\n    def matchPlayersAndTrainers(self, players, trainers):\\n        players.sort()\\n        trainers.sort()\\n        i = j = matches = 0\\n        n, m = len(players), len(trainers)\\n        while i < n and j < m:\\n            if trainers[j] >= players[i]:\\n                matches += 1\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return matches\\n\"",
  "3653_14631217_python": "\"class Solution(object):\\n    def maxSubarraySum(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import math\\n\\n        n = len(nums)\\n        # prefix sum\\n        S = 0\\n        # min_pref[r] = minimum S_i seen so far with i % k == r\\n        INF = 10**30\\n        min_pref = [INF] * k\\n        min_pref[0] = 0   # S_0 = 0 at index 0 (residue 0)\\n\\n        ans = -INF\\n        for j, v in enumerate(nums, start=1):\\n            S += v\\n            r = j % k\\n            # best subarray ending at j whose length divisible by k:\\n            # S - min_pref[r]\\n            ans = max(ans, S - min_pref[r])\\n            # update min prefix for this residue\\n            min_pref[r] = min(min_pref[r], S)\\n\\n        return ans\\n\"",
  "3651_14631217_python-updated-time": "1747596340830",
  "3335_14631217_python-updated-time": "1747420349053",
  "3470_14631217_python-updated-time": "1747487774067",
  "3445_14631217_python-updated-time": "1747484016332",
  "2285_14631217_python-updated-time": "1746803119917",
  "1211_14631217_python": "\"from itertools import combinations\\n\\nclass CombinationIterator:\\n    def __init__(self, characters, combinationLength):\\n        self.combos = list(combinations(characters, combinationLength))\\n        self.index = 0\\n\\n    def next(self):\\n        res = ''.join(self.combos[self.index])\\n        self.index += 1\\n        return res\\n\\n    def hasNext(self):\\n        return self.index < len(self.combos)\\n\"",
  "1375_14631217_python-updated-time": "1746810986276",
  "1556_14631217_python-updated-time": "1746347961190",
  "2340_14631217_python": "\"class Solution:\\n    def appealSum(self, s):\\n        n = len(s)\\n        last = {c: -1 for c in \\\"abcdefghijklmnopqrstuvwxyz\\\"}\\n        total = 0\\n        for i, ch in enumerate(s):\\n            prev = last[ch]\\n            total += (i - prev) * (n - i)\\n            last[ch] = i\\n        return total\\n\"",
  "1895_14631217_python-updated-time": "1746531936828",
  "2497_14631217_python-updated-time": "1746966107190",
  "1918_14631217_python": "\"class Solution(object):\\n    def maximumScore(self, nums, k):\\n        n = len(nums)\\n        left = right = k\\n        min_val = nums[k]\\n        max_score = min_val\\n\\n        while left > 0 or right < n - 1:\\n            if left == 0:\\n                right += 1\\n            elif right == n - 1:\\n                left -= 1\\n            elif nums[left - 1] > nums[right + 1]:\\n                left -= 1\\n            else:\\n                right += 1\\n            min_val = min(min_val, nums[left], nums[right])\\n            max_score = max(max_score, min_val * (right - left + 1))\\n\\n        return max_score\\n\"",
  "463_14631217_python-updated-time": "1745359642606",
  "2604_14631217_python-updated-time": "1747061492643",
  "3074_14631217_pythondata": "\"import pandas as pd\\n\\n# Assuming `students` is your DataFrame\\ndef selectData(students, target_id=101):\\n    \\\"\\\"\\\"\\n    Returns a DataFrame containing the name and age of the student\\n    whose student_id equals target_id.\\n    \\\"\\\"\\\"\\n    return students.loc[students['student_id'] == target_id, ['name', 'age']]\"",
  "2240_14631217_python-updated-time": "1746801729463",
  "3408_14631217_python-updated-time": "1747423980305",
  "2977_14631217_python": "\"class Solution(object):\\n    def isAcronym(self, words, s):\\n        if len(words) != len(s):\\n            return False\\n        for i in range(len(words)):\\n            if words[i][0] != s[i]:\\n                return False\\n        return True\\n\"",
  "722_14631217_python-updated-time": "1745786844818",
  "2434_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass NumberContainers:\\n    def __init__(self):\\n        self.index_to_num = {}\\n        self.num_to_heap = defaultdict(list)\\n\\n    def change(self, index, number):\\n        old = self.index_to_num.get(index)\\n        if old == number:\\n            return\\n        self.index_to_num[index] = number\\n        heapq.heappush(self.num_to_heap[number], index)\\n\\n    def find(self, number):\\n        heap = self.num_to_heap.get(number, [])\\n        while heap:\\n            idx = heap[0]\\n            if self.index_to_num.get(idx) == number:\\n                return idx\\n            heapq.heappop(heap)\\n        return -1\\n\"",
  "2741_14631217_javascript-updated-time": "1747135465208",
  "645_14631217_python-updated-time": "1745782561087",
  "1823_14631217_python": "\"class Solution(object):\\n    def halvesAreAlike(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        vowels = set('aeiouAEIOU')\\n        n = len(s)\\n        half = n // 2\\n        \\n        # count vowels in first half\\n        count1 = sum(1 for c in s[:half] if c in vowels)\\n        # count vowels in second half\\n        count2 = sum(1 for c in s[half:] if c in vowels)\\n        \\n        return count1 == count2\\n\"",
  "260_14631217_python": "\"class Solution(object):\\n    def singleNumber(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n\\n        diff = xor & -xor\\n        \\n        a = 0\\n        for num in nums:\\n            if num & diff:\\n                a ^= num\\n\\n        return [a, xor ^ a]\\n\"",
  "1306_14631217_python-updated-time": "1746127302790",
  "1756_14631217_python": "\"class Solution:\\n    def minimumDeletions(self, s):\\n        a_remain = s.count('a')\\n        b_count = 0\\n        ans = float('inf')\\n        \\n        for ch in s:\\n            # deletions = b's to left + a's to right\\n            ans = min(ans, b_count + a_remain)\\n            if ch == 'a':\\n                a_remain -= 1\\n            else:\\n                b_count += 1\\n        \\n        # split after the last character\\n        ans = min(ans, b_count + a_remain)\\n        return ans\\n\"",
  "2321_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumWeight(self, n, edges, src1, src2, dest):\\n        g  = [[] for _ in xrange(n)]   # forward graph\\n        rg = [[] for _ in xrange(n)]   # reversed graph (for paths *to* dest)\\n        for u, v, w in edges:\\n            g[u].append((v, w))\\n            rg[v].append((u, w))\\n\\n        def dijkstra(start, graph):\\n            INF = 10 ** 20\\n            dist = [INF] * n\\n            dist[start] = 0\\n            pq = [(0, start)]\\n            while pq:\\n                d, u = heapq.heappop(pq)\\n                if d != dist[u]:\\n                    continue\\n                for v, w in graph[u]:\\n                    nd = d + w\\n                    if nd < dist[v]:\\n                        dist[v] = nd\\n                        heapq.heappush(pq, (nd, v))\\n            return dist\\n\\n        INF = 10 ** 20\\n        d1 = dijkstra(src1, g)   # src1 -> *\\n        d2 = dijkstra(src2, g)   # src2 -> *\\n        dd = dijkstra(dest, rg)  # * -> dest  (by running on reversed graph)\\n\\n        ans = INF\\n        for i in xrange(n):      # choose meeting node i\\n            if d1[i] < INF and d2[i] < INF and dd[i] < INF:\\n                ans = min(ans, d1[i] + d2[i] + dd[i])\\n\\n        return -1 if ans == INF else ans\\n\"",
  "2233_14631217_python-updated-time": "1746800095385",
  "928_14631217_lang": "\"python\"",
  "3212_14631217_python": "\"class Solution(object):\\n    def numberOfGoodPartitions(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        if n <= 1:\\n            return 1\\n        \\n        # Record first and last occurrence of each value\\n        first = {}\\n        last = {}\\n        for i, v in enumerate(nums):\\n            if v not in first:\\n                first[v] = i\\n            last[v] = i\\n        \\n        # Build forbidden intervals [start, end] over cut positions 0..n-2\\n        intervals = []\\n        for v in first:\\n            f = first[v]\\n            l = last[v]\\n            if l > f:\\n                # forbid cuts at positions f through l-1\\n                intervals.append((f, l-1))\\n        \\n        if not intervals:\\n            # No forbidden cuts at all\\n            allowed = n - 1\\n        else:\\n            # Merge the intervals\\n            intervals.sort()\\n            merged = []\\n            cur_start, cur_end = intervals[0]\\n            for s, e in intervals[1:]:\\n                if s <= cur_end + 1:\\n                    # overlap or contiguous, extend\\n                    cur_end = max(cur_end, e)\\n                else:\\n                    merged.append((cur_start, cur_end))\\n                    cur_start, cur_end = s, e\\n            merged.append((cur_start, cur_end))\\n            \\n            # Count forbidden positions\\n            forbidden = 0\\n            for s, e in merged:\\n                forbidden += (e - s + 1)\\n            allowed = (n - 1) - forbidden\\n        \\n        # Each allowed cut may be either present or not\\n        return pow(2, allowed, MOD)\\n\"",
  "123_14631217_python-updated-time": "1745082101238",
  "891_14631217_python": "\"class Solution(object):\\n    def matrixScore(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        # Ensure the first column is all 1s by flipping rows if needed\\n        for i in range(m):\\n            if grid[i][0] == 0:\\n                for j in range(n):\\n                    grid[i][j] ^= 1\\n\\n        # For each column, maximize number of 1s\\n        res = 0\\n        for j in range(n):\\n            count = sum(grid[i][j] for i in range(m))\\n            count = max(count, m - count)\\n            res += count * (1 << (n - j - 1))\\n        \\n        return res\\n\"",
  "3620_14631217_python-updated-time": "1747651633672",
  "2816_14631217_python-updated-time": "1747139197661",
  "322_14631217_python": "\"class Solution(object):\\n    def coinChange(self, coins, amount):\\n        \\\"\\\"\\\"\\n        :type coins: List[int]\\n        :type amount: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [float('inf')] * (amount + 1)\\n        dp[0] = 0\\n        \\n        for coin in coins:\\n            for x in range(coin, amount + 1):\\n                dp[x] = min(dp[x], dp[x - coin] + 1)\\n        \\n        return dp[amount] if dp[amount] != float('inf') else -1\\n\"",
  "483_14631217_python-updated-time": "1745441720591",
  "3607_14631217_python-updated-time": "1747581570817",
  "3628_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minTimeToReach(self, moveTime):\\n        \\\"\\\"\\\"\\n        :type moveTime: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(moveTime)\\n        m = len(moveTime[0])\\n        INF = 10**30\\n        # dist[r][c][p]: minimum time to reach (r,c) with next-move parity p\\n        # p = 0 => next move takes 1 second; p = 1 => next move takes 2 seconds\\n        dist = [[[INF, INF] for _ in range(m)] for __ in range(n)]\\n        dist[0][0][0] = 0\\n        # heap entries: (current_time, r, c, parity)\\n        pq = [(0, 0, 0, 0)]\\n        dirs = [(1,0), (-1,0), (0,1), (0,-1)]\\n        \\n        while pq:\\n            t, r, c, p = heapq.heappop(pq)\\n            if t > dist[r][c][p]:\\n                continue\\n            # if we've reached the target, return immediately\\n            if r == n-1 and c == m-1:\\n                return t\\n            for dr, dc in dirs:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < n and 0 <= nc < m:\\n                    # must wait until room (nr,nc) is open\\n                    depart = max(t, moveTime[nr][nc])\\n                    # move duration alternates: 1s if p==0, else 2s\\n                    duration = 1 if p == 0 else 2\\n                    arrive = depart + duration\\n                    np = 1 - p\\n                    if arrive < dist[nr][nc][np]:\\n                        dist[nr][nc][np] = arrive\\n                        heapq.heappush(pq, (arrive, nr, nc, np))\\n        # if unreachable\\n        return -1\\n\"",
  "a_f_l_d": "{}",
  "2849_14631217_python-updated-time": "1747222012651",
  "2212_14631217_python-updated-time": "1746729626041",
  "2561_14631217_python": "\"class Solution:\\n    def distinctAverages(self, nums):\\n        nums.sort()\\n        i, j = 0, len(nums) - 1\\n        seen = set()\\n        while i < j:\\n            seen.add(nums[i] + nums[j])   # store sum, not the float average\\n            i += 1\\n            j -= 1\\n        return len(seen)\\n\"",
  "2439_14631217_python-updated-time": "1746964653944",
  "3276_14631217_python-updated-time": "1747400485116",
  "164_14631217_python": "\"class Solution(object):\\n    def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n        \\n        min_val, max_val = min(nums), max(nums)\\n        if min_val == max_val:\\n            return 0\\n        \\n        n = len(nums)\\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\\n        bucket_count = (max_val - min_val) // bucket_size + 1\\n        \\n        buckets_min = [float('inf')] * bucket_count\\n        buckets_max = [float('-inf')] * bucket_count\\n        \\n        for num in nums:\\n            idx = (num - min_val) // bucket_size\\n            buckets_min[idx] = min(buckets_min[idx], num)\\n            buckets_max[idx] = max(buckets_max[idx], num)\\n        \\n        max_gap = 0\\n        prev_max = min_val\\n        for i in range(bucket_count):\\n            if buckets_min[i] == float('inf'):\\n                continue\\n            max_gap = max(max_gap, buckets_min[i] - prev_max)\\n            prev_max = buckets_max[i]\\n        \\n        return max_gap\\n\"",
  "2123_14631217_python": "\"class Solution:\\n    def numberOfWeakCharacters(self, properties):\\n        # Sort by descending attack, and ascending defense\\n        properties.sort(key=lambda x: (-x[0], x[1]))\\n        \\n        max_def = 0\\n        weak = 0\\n\\n        for attack, defense in properties:\\n            if defense < max_def:\\n                weak += 1\\n            else:\\n                max_def = defense\\n        \\n        return weak\\n\"",
  "3407_14631217_python": "\"class Solution(object):\\n    def numberOfStableArrays(self, zero, one, limit):\\n        \\\"\\\"\\\"\\n        :type zero: int\\n        :type one: int\\n        :type limit: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        Z, O, L = zero, one, limit\\n        N = Z + O\\n\\n        # We need counts of compositions of Z into k positive parts <=L\\n        # for k up to max zero‐blocks (=ceil(N/2)), and similarly for O.\\n        max_blocks = (N + 1) // 2  # worst‐case number of blocks of one type\\n\\n        # Build dp0[b][s] = #ways to write sum=s with exactly b positive parts (each 1..L)\\n        # up to b=max_blocks and s up to Z.\\n        def build_dp(total):\\n            mb = max_blocks\\n            dp = [[0] * (total + 1) for _ in range(mb + 1)]\\n            dp[0][0] = 1\\n            for b in range(1, mb + 1):\\n                # prefix sums of dp[b-1] to get sliding window sums in O(1)\\n                pref = [0] * (total + 2)\\n                for s in range(total + 1):\\n                    pref[s+1] = (pref[s] + dp[b-1][s]) % MOD\\n                for s in range(total + 1):\\n                    # sum of dp[b-1][s - t] for t=1..L  →  pref[s] − pref[max(0, s−L)]\\n                    low = s - L\\n                    dp[b][s] = (pref[s] - (pref[low] if low >= 0 else 0)) % MOD\\n            return dp\\n\\n        dp0 = build_dp(Z)\\n        dp1 = build_dp(O)\\n\\n        ans = 0\\n        # Sum over start-bit s=0 or 1, and total blocks K=1..N\\n        for s in (0, 1):\\n            for K in range(1, N + 1):\\n                if s == 0:\\n                    zb = (K + 1) // 2\\n                    ob = K // 2\\n                else:\\n                    zb = K // 2\\n                    ob = (K + 1) // 2\\n\\n                if zb <= max_blocks and ob <= max_blocks:\\n                    ans = (ans + dp0[zb][Z] * dp1[ob][O]) % MOD\\n\\n        return ans\\n\"",
  "3532_14631217_python": "\"class Solution(object):\\n    def timeTaken(self, edges):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(edges) + 1\\n        # 1) Build undirected adjacency\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # 2) Node‐weights\\n        w = [1 if i % 2 else 2 for i in range(n)]\\n        \\n        # 3) Root at 0: extract parent/children with an explicit stack (preorder)\\n        parent = [-1]*n\\n        children = [[] for _ in range(n)]\\n        order = []  # preorder\\n        stack = [(0, -1)]\\n        while stack:\\n            v, p = stack.pop()\\n            parent[v] = p\\n            order.append(v)\\n            for u in adj[v]:\\n                if u == p: continue\\n                children[v].append(u)\\n                stack.append((u, v))\\n        \\n        # 4) Bottom‐up: compute down[v], plus track top two child‐contributions\\n        down = [0]*n\\n        best1 = [0]*n   # largest (w[c]+down[c]) among children\\n        best2 = [0]*n   # second largest\\n        bestc = [-1]*n  # which child gives best1\\n        \\n        for v in reversed(order):\\n            b1 = b2 = 0\\n            bc = -1\\n            for c in children[v]:\\n                val = w[c] + down[c]\\n                if val > b1:\\n                    b2, b1, bc = b1, val, c\\n                elif val > b2:\\n                    b2 = val\\n            best1[v], best2[v], bestc[v] = b1, b2, bc\\n            down[v] = b1\\n        \\n        # 5) Top‐down: compute up[v]\\n        up = [0]*n\\n        for v in order:\\n            for c in children[v]:\\n                # best among siblings of c under parent v\\n                sib_best = best1[v] if bestc[v] != c else best2[v]\\n                up[c] = w[v] + max(up[v], sib_best)\\n        \\n        # 6) Answer = max(down, up) for each node\\n        return [max(down[i], up[i]) for i in range(n)]\\n\"",
  "2631_14631217_python-updated-time": "1747061727885",
  "2530_14631217_python-updated-time": "1746967846400",
  "2507_14631217_python-updated-time": "1746966954526",
  "3600_14631217_python": "\"class Solution(object):\\n    def kthCharacter(self, k):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        # Start with initial word\\n        word = 'a'\\n        # Keep performing the operation until word length covers k\\n        while len(word) < k:\\n            # Generate shifted string: each character moves to next in the alphabet, with 'z' -> 'a'\\n            shifted = ''.join(\\n                chr((ord(c) - ord('a') + 1) % 26 + ord('a'))\\n                for c in word\\n            )\\n            # Append the shifted string to the original\\n            word += shifted\\n        # Return the k-th character (1-based index)\\n        return word[k-1]\"",
  "1418_14631217_python": "\"class Solution:\\n    def distributeCookies(self, cookies, k):\\n        n = len(cookies)\\n        # Sort descending to place big bags first (improves pruning)\\n        cookies.sort(reverse=True)\\n        \\n        # loads[j] = total cookies for child j\\n        loads = [0]*k\\n        self.best = sum(cookies)\\n\\n        def dfs(i):\\n            # All bags assigned\\n            if i == n:\\n                self.best = min(self.best, max(loads))\\n                return\\n\\n            bag = cookies[i]\\n            # Try giving bag i to each child j\\n            for j in range(k):\\n                # Prune if this would not improve best\\n                if loads[j] + bag >= self.best:\\n                    continue\\n\\n                # Assign\\n                loads[j] += bag\\n                dfs(i+1)\\n                loads[j] -= bag\\n\\n                # Symmetry pruning: if this child had 0 before,\\n                # no need to try other empty children\\n                if loads[j] == 0:\\n                    break\\n\\n        dfs(0)\\n        return self.best\\n\"",
  "563_14631217_python": "\"class Solution(object):\\n    def findTilt(self, root):\\n        self.tilt = 0\\n\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            left_sum = dfs(node.left)\\n            right_sum = dfs(node.right)\\n            self.tilt += abs(left_sum - right_sum)\\n            return left_sum + right_sum + node.val\\n\\n        dfs(root)\\n        return self.tilt\\n\"",
  "436_14631217_python": "\"import bisect\\n\\nclass Solution:\\n    def findRightInterval(self, intervals):\\n        n = len(intervals)\\n        starts = sorted((start, i) for i, (start, end) in enumerate(intervals))\\n        res = []\\n        \\n        for start, end in intervals:\\n            idx = bisect.bisect_left(starts, (end,))\\n            if idx < n:\\n                res.append(starts[idx][1])\\n            else:\\n                res.append(-1)\\n        \\n        return res\\n\"",
  "2404_14631217_python-updated-time": "1746883073525",
  "3736_14631217_python-updated-time": "1747671680328",
  "730_14631217_python": "\"class Solution(object):\\n    def countPalindromicSubsequences(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        n = len(s)\\n        # next_same[i]: the next index > i where s[i] occurs, or n if none\\n        # prev_same[i]: the previous index < i where s[i] occurs, or -1 if none\\n        next_same = [n] * n\\n        prev_same = [-1] * n\\n        last = {}\\n        # Build prev_same\\n        for i, ch in enumerate(s):\\n            if ch in last:\\n                prev_same[i] = last[ch]\\n            last[ch] = i\\n        last.clear()\\n        # Build next_same\\n        for i in range(n-1, -1, -1):\\n            ch = s[i]\\n            if ch in last:\\n                next_same[i] = last[ch]\\n            last[ch] = i\\n        \\n        # dp[i][j]: number of distinct non-empty palindromic subsequences in s[i..j]\\n        dp = [[0] * n for _ in range(n)]\\n        \\n        # Subsequences in a single letter\\n        for i in range(n):\\n            dp[i][i] = 1\\n        \\n        # Build up by lengths\\n        for length in range(2, n+1):\\n            for i in range(n - length + 1):\\n                j = i + length - 1\\n                if s[i] != s[j]:\\n                    # Exclude one end or the other, plus inclusion-exclusion\\n                    dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % MOD\\n                else:\\n                    # s[i] == s[j]\\n                    dp[i][j] = (dp[i+1][j-1] * 2) % MOD\\n                    L = next_same[i]\\n                    R = prev_same[j]\\n                    if L > R:\\n                        # No equal char inside\\n                        dp[i][j] = (dp[i][j] + 2) % MOD\\n                    elif L == R:\\n                        # One occurrence inside\\n                        dp[i][j] = (dp[i][j] + 1) % MOD\\n                    else:\\n                        # More than one inside: subtract the duplicates\\n                        dp[i][j] = (dp[i][j] - dp[L+1][R-1]) % MOD\\n        \\n        return dp[0][n-1] % MOD\\n\"",
  "2718_14631217_python-updated-time": "1747133817009",
  "1222_14631217_python-updated-time": "1746260315142",
  "940_14631217_python": "\"class Solution:\\n    def totalFruit(self, fruits):\\n        from collections import defaultdict\\n        count = defaultdict(int)\\n        left = 0\\n        max_fruits = 0\\n        \\n        for right, f in enumerate(fruits):\\n            count[f] += 1\\n            while len(count) > 2:\\n                count[fruits[left]] -= 1\\n                if count[fruits[left]] == 0:\\n                    del count[fruits[left]]\\n                left += 1\\n            max_fruits = max(max_fruits, right - left + 1)\\n        \\n        return max_fruits\\n\"",
  "480_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass DualHeap:\\n    def __init__(self, k):\\n        self.small = []  # max heap (invert values)\\n        self.large = []  # min heap\\n        self.delayed = defaultdict(int)\\n        self.k = k\\n        self.small_size = 0\\n        self.large_size = 0\\n\\n    def prune(self, heap):\\n        while heap:\\n            num = -heap[0] if heap is self.small else heap[0]\\n            if self.delayed[num]:\\n                heapq.heappop(heap)\\n                self.delayed[num] -= 1\\n                if self.delayed[num] == 0:\\n                    del self.delayed[num]\\n            else:\\n                break\\n\\n    def balance(self):\\n        if self.small_size > self.large_size:\\n            heapq.heappush(self.large, -heapq.heappop(self.small))\\n            self.small_size -= 1\\n            self.large_size += 1\\n        elif self.large_size > self.small_size + 1:\\n            heapq.heappush(self.small, -heapq.heappop(self.large))\\n            self.large_size -= 1\\n            self.small_size += 1\\n\\n        self.prune(self.small)\\n        self.prune(self.large)\\n\\n    def insert(self, num):\\n        if not self.large or num >= self.large[0]:\\n            heapq.heappush(self.large, num)\\n            self.large_size += 1\\n        else:\\n            heapq.heappush(self.small, -num)\\n            self.small_size += 1\\n        self.balance()\\n\\n    def erase(self, num):\\n        self.delayed[num] += 1\\n        if self.large and num >= self.large[0]:\\n            self.large_size -= 1\\n            if self.large and num == self.large[0]:\\n                self.prune(self.large)\\n        else:\\n            self.small_size -= 1\\n            if self.small and num == -self.small[0]:\\n                self.prune(self.small)\\n        self.balance()\\n\\n    def get_median(self):\\n        self.prune(self.small)\\n        self.prune(self.large)\\n        if self.k % 2 == 1:\\n            return float(self.large[0])\\n        return (self.large[0] - self.small[0]) / 2.0\\n\\n\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \\\"\\\"\\\"\\n        dh = DualHeap(k)\\n        for i in range(k):\\n            dh.insert(nums[i])\\n        res = [dh.get_median()]\\n        for i in range(k, len(nums)):\\n            dh.insert(nums[i])\\n            dh.erase(nums[i - k])\\n            res.append(dh.get_median())\\n        return res\\n\"",
  "919_14631217_python-updated-time": "1746001808671",
  "2042_14631217_python": "\"class Solution:\\n    def maxProductDifference(self, nums):\\n        nums.sort()\\n        return nums[-1] * nums[-2] - nums[0] * nums[1]\\n\"",
  "200_14631217_python-updated-time": "1745093177002",
  "324_14631217_python": "\"class Solution(object):\\n    def wiggleSort(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        half = (n + 1) // 2\\n        small = nums[:half][::-1]\\n        large = nums[half:][::-1]\\n        \\n        for i in range(n):\\n            if i % 2 == 0:\\n                nums[i] = small.pop(0)\\n            else:\\n                nums[i] = large.pop(0)\\n\"",
  "2810_14631217_python": "\"class Solution:\\n    def minCost(self, nums, x):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # best_costs[t] = min cost to collect type t using up to r rotations\\n        best_costs = nums[:]  # for r = 0, window size = 1\\n        total = sum(best_costs)\\n        ans = total  # r = 0, rotation cost = 0\\n        \\n        # try r = 1 to n-1 rotations\\n        for r in range(1, n):\\n            # include the cost of the newly reachable index for each t:\\n            # index = (t - r) mod n\\n            for t in range(n):\\n                candidate = nums[(t - r) % n]\\n                if candidate < best_costs[t]:\\n                    best_costs[t] = candidate\\n            total = sum(best_costs)\\n            cost = total + r * x\\n            if cost < ans:\\n                ans = cost\\n        \\n        return ans\\n\"",
  "2608_14631217_python-updated-time": "1747060031191",
  "969_14631217_python-updated-time": "1746004046083",
  "1137_14631217_python": "\"class Solution(object):\\n    def heightChecker(self, heights):\\n        \\\"\\\"\\\"\\n        :type heights: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        expected = sorted(heights)\\n        return sum(h != e for h, e in zip(heights, expected))\\n\"",
  "3566_14631217_python": "\"class Solution(object):\\n    def stringSequence(self, target):\\n        \\\"\\\"\\\"\\n        :type target: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        result = []\\n        screen = \\\"\\\"\\n        for c in target:\\n            # 1) Press Key 1: append 'a'\\n            screen += 'a'\\n            result.append(screen)\\n            \\n            # 2) Press Key 2 dist times to shift 'a' → c\\n            dist = ord(c) - ord('a')  # 0..25\\n            for _ in range(dist):\\n                last = screen[-1]\\n                # increment with wrap 'z' → 'a'\\n                if last == 'z':\\n                    nxt = 'a'\\n                else:\\n                    nxt = chr(ord(last) + 1)\\n                screen = screen[:-1] + nxt\\n                result.append(screen)\\n        \\n        return result\\n\"",
  "732_14631217_python-updated-time": "1745787198000",
  "2590_14631217_python-updated-time": "1747058088120",
  "3066_14631217_pythondata": "\"import pandas as pd\\n\\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame employees with columns ['name', 'salary'],\\n    returns the DataFrame with an added 'bonus' column equal to 2 * salary.\\n    \\\"\\\"\\\"\\n    employees['bonus'] = employees['salary'] * 2\\n    return employees\\n\"",
  "1603_14631217_python": "\"class Solution(object):\\n    def runningSum(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n\"",
  "224_14631217_python-updated-time": "1745246880571",
  "120_14631217_python": "\"class Solution(object):\\n    def minimumTotal(self, triangle):\\n        \\\"\\\"\\\"\\n        :type triangle: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(triangle)\\n        dp = triangle[-1][:]\\n        \\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1):\\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1])\\n                \\n        return dp[0]\\n\"",
  "3824_14631217_python-updated-time": "1747683391503",
  "3570_14631217_python": "\"class Solution(object):\\n    def kthCharacter(self, k):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        word = 'a'\\n        while len(word) < k:\\n            shifted = ''.join(\\n                chr((ord(c) - ord('a') + 1) % 26 + ord('a'))\\n                for c in word\\n            )\\n            word += shifted\\n        return word[k-1]\\n\\n    def countOfSubstrings(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        vowels = set('aeiou')\\n        n = len(word)\\n        result = 0\\n        # Iterate over all possible start indices\\n        for i in range(n):\\n            # Counts of each vowel in the current window\\n            vowel_count = {v: 0 for v in vowels}\\n            consonants = 0\\n            # Extend the substring from i to j\\n            for j in range(i, n):\\n                c = word[j]\\n                if c in vowels:\\n                    vowel_count[c] += 1\\n                else:\\n                    consonants += 1\\n                # If consonants exceed k, no further extension from this i will work\\n                if consonants > k:\\n                    break\\n                # Check if all vowels are present and consonant count matches k\\n                if consonants == k and all(vowel_count[v] > 0 for v in vowels):\\n                    result += 1\\n        return result\"",
  "1254_14631217_python-updated-time": "1746260602683",
  "2149_14631217_python-updated-time": "1746719853517",
  "2668_14631217_python-updated-time": "1747134307580",
  "3486_14631217_python": "\"class Solution(object):\\n    def countGoodNodes(self, edges):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Number of nodes\\n        n = len(edges) + 1\\n        \\n        # Build undirected adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        # Root the tree at 0: compute parent and DFS order\\n        parent = [-1] * n\\n        parent[0] = 0\\n        order = []\\n        stack = [0]\\n        while stack:\\n            u = stack.pop()\\n            order.append(u)\\n            for v in adj[u]:\\n                if parent[v] == -1:\\n                    parent[v] = u\\n                    stack.append(v)\\n        \\n        # Build children lists\\n        children = [[] for _ in range(n)]\\n        for v in range(1, n):\\n            p = parent[v]\\n            children[p].append(v)\\n        \\n        # Compute subtree sizes in reverse DFS order\\n        subtree_size = [1] * n\\n        for u in reversed(order):\\n            for w in children[u]:\\n                subtree_size[u] += subtree_size[w]\\n        \\n        # Count \\\"good\\\" nodes\\n        # A node is good if all its children's subtree sizes are equal\\n        count = 0\\n        for u in range(n):\\n            sizes = [subtree_size[w] for w in children[u]]\\n            # zero or one child always trivially equal\\n            if len(sizes) <= 1 or all(sz == sizes[0] for sz in sizes):\\n                count += 1\\n        \\n        return count\\n\"",
  "2192_14631217_python-updated-time": "1746729501743",
  "2860_14631217_javascript": "\"/**\\n * @param {any[]} arr\\n * @param {function(any): number} fn\\n * @return {any[]}\\n */\\nfunction sortBy(arr, fn) {\\n  // Decorate: pair each element with its key\\n  const paired = arr.map(item => ({ key: fn(item), value: item }));\\n  // Sort by the computed key\\n  paired.sort((a, b) => a.key - b.key);\\n  // Undecorate: extract the original items in sorted order\\n  return paired.map(pair => pair.value);\\n}\\n\"",
  "1179_14631217_mysql": "\"SELECT player_id, MIN(event_date) AS first_login\\nFROM Activity\\nGROUP BY player_id;\\n\"",
  "322_14631217_python-updated-time": "1745256258605",
  "3431_14631217_python": "\"class Solution(object):\\n    def findPermutation(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Build cost matrix: cost[u][v] = |u - nums[v]|\\n        cost = [[0]*n for _ in range(n)]\\n        for u in range(n):\\n            for v in range(n):\\n                cost[u][v] = abs(u - nums[v])\\n        \\n        # We'll mask over vertices 1..n-1\\n        N = 1 << (n-1)\\n        INF = 10**12\\n        \\n        # dp[mask][u] = min cost of a path starting at u,\\n        # visiting all vertices in 'mask', then returning to 0.\\n        # mask runs 0..N-1, u runs 0..n-1, but dp[mask][u] only\\n        # valid when u not in mask (i.e. if u>=1 then bit u-1 of mask = 0).\\n        dp = [[INF]*n for _ in range(N)]\\n        \\n        # Base case: mask=0, no vertices to visit => just go u->0\\n        for u in range(n):\\n            dp[0][u] = cost[u][0]\\n        \\n        # Fill DP for all nonempty masks\\n        for mask in range(1, N):\\n            # Enumerate which vertices are still to visit (v in mask)\\n            m = mask\\n            verts = []\\n            while m:\\n                b = m & -m\\n                j = (b.bit_length() - 1)   # bit index in 0..n-2\\n                v = j + 1                  # actual vertex\\n                verts.append((b, v))\\n                m ^= b\\n            \\n            # Now for each \\\"current\\\" u not in mask, compute dp[mask][u]\\n            # u=0 is always allowed; for u>0 check bit u-1 of mask == 0.\\n            for u in range(n):\\n                if u > 0 and ((mask >> (u-1)) & 1):\\n                    continue\\n                best = INF\\n                # Try going u -> v, then finish mask\\\\{v} from v\\n                for (b, v) in verts:\\n                    prev = dp[mask ^ b][v] + cost[u][v]\\n                    if prev < best:\\n                        best = prev\\n                dp[mask][u] = best\\n        \\n        full = N - 1\\n        # Minimum cycle cost starting & ending at 0:\\n        C = dp[full][0]\\n        \\n        # Reconstruct lexicographically smallest permutation\\n        perm = [0] * n\\n        perm[0] = 0\\n        curr = 0\\n        rem_cost = C\\n        mask = full\\n        \\n        for i in range(1, n):\\n            # Try next in ascending order\\n            for v in range(1, n):\\n                bit = 1 << (v-1)\\n                if mask & bit == 0:\\n                    continue\\n                # cost of edge curr->v plus optimal suffix from v\\n                c = cost[curr][v] + dp[mask ^ bit][v]\\n                if c == rem_cost:\\n                    # this is our lexicographically smallest choice\\n                    perm[i] = v\\n                    curr = v\\n                    mask ^= bit\\n                    rem_cost -= cost[perm[i-1]][v]\\n                    break\\n        \\n        return perm\\n\"",
  "338_14631217_python": "\"class Solution(object):\\n    def countBits(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        ans = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            ans[i] = ans[i >> 1] + (i & 1)\\n        return ans\\n\"",
  "1037_14631217_python-updated-time": "1746040705208",
  "2365_14631217_python-updated-time": "1746881414536",
  "1022_14631217_python-updated-time": "1746040208597",
  "2701_14631217_python-updated-time": "1747065338451",
  "941_14631217_python": "\"class Solution:\\n    def sortArrayByParity(self, nums):\\n        # Two-pointer approach: partition evens to the front, odds to the back\\n        i, j = 0, len(nums) - 1\\n        while i < j:\\n            if nums[i] % 2 > nums[j] % 2:\\n                nums[i], nums[j] = nums[j], nums[i]\\n            if nums[i] % 2 == 0:\\n                i += 1\\n            if nums[j] % 2 == 1:\\n                j -= 1\\n        return nums\\n\"",
  "218_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def getSkyline(self, buildings):\\n        \\\"\\\"\\\"\\n        :type buildings: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        events = []\\n        for l, r, h in buildings:\\n            events.append((l, -h, r))\\n            events.append((r, 0, 0))\\n        events.sort()\\n\\n        res = [[0, 0]]\\n        heap = [(0, float('inf'))]\\n\\n        for x, neg_h, r in events:\\n            while heap[0][1] <= x:\\n                heapq.heappop(heap)\\n            if neg_h:\\n                heapq.heappush(heap, (neg_h, r))\\n            if res[-1][1] != -heap[0][0]:\\n                res.append([x, -heap[0][0]])\\n\\n        return res[1:]\\n\"",
  "525_14631217_python-updated-time": "1745446633762",
  "3416_14631217_python": "\"class Solution:\\n    def sumDigitDifferences(self, nums, queries=None):\\n        # (ignore `queries`—we only care about nums here)\\n        n = len(nums)\\n        # turn all numbers into strings so we can index digits\\n        s = list(map(str, nums))\\n        d = len(s[0])  # they all have the same number of digits\\n        \\n        total_pairs = n*(n-1)//2\\n        ans = 0\\n        \\n        # for each digit position\\n        for i in range(d):\\n            # count how many numbers have each digit 0–9 in position i\\n            cnt = [0]*10\\n            for x in s:\\n                cnt[ord(x[i]) - 48] += 1  # ord('0') == 48\\n            \\n            # same‐digit pairs at this position\\n            same = 0\\n            for c in cnt:\\n                if c > 1:\\n                    same += c*(c-1)//2\\n            \\n            # the rest of the pairs differ here\\n            ans += total_pairs - same\\n        \\n        return ans\"",
  "121_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, prices):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        min_price = float('inf')\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            else:\\n                max_profit = max(max_profit, price - min_price)\\n        \\n        return max_profit\\n\"",
  "1583_14631217_python-updated-time": "1746432478051",
  "726_14631217_python-updated-time": "1745786940793",
  "2384_14631217_python": "\"class Solution:\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n\"",
  "73_14631217_python-updated-time": "1745015095505",
  "911_14631217_python": "\"class Solution(object):\\n    def profitableSchemes(self, n, minProfit, group, profit):\\n        MOD = 10**9 + 7\\n        dp = [[[0] * (minProfit + 1) for _ in range(n + 1)] for _ in range(len(group) + 1)]\\n        dp[0][0][0] = 1\\n\\n        for i in range(1, len(group) + 1):\\n            g = group[i - 1]\\n            p = profit[i - 1]\\n            for j in range(n + 1):\\n                for k in range(minProfit + 1):\\n                    dp[i][j][k] = dp[i - 1][j][k]\\n                    if j >= g:\\n                        dp[i][j][k] += dp[i - 1][j - g][max(0, k - p)]\\n                        dp[i][j][k] %= MOD\\n\\n        return sum(dp[len(group)][j][minProfit] for j in range(n + 1)) % MOD\\n\"",
  "2331_14631217_python": "\"class Solution:\\n    def intersection(self, nums):\\n        counts = {}\\n        n = len(nums)\\n        for arr in nums:\\n            for x in arr:\\n                counts[x] = counts.get(x, 0) + 1\\n        \\n        # Collect those present in all n arrays\\n        res = [x for x, c in counts.items() if c == n]\\n        res.sort()\\n        return res\\n\"",
  "3767_14631217_mysql-updated-time": "1747658913432",
  "1744_14631217_python": "\"class Solution:\\n    def numWays(self, words, target):\\n        MOD = 10**9 + 7\\n        m = len(words[0])\\n        tlen = len(target)\\n        \\n        # 1) Build frequency table: freq[i][c] = count of char c at column i\\n        freq = [[0]*26 for _ in range(m)]\\n        for w in words:\\n            for i, ch in enumerate(w):\\n                freq[i][ord(ch)-97] += 1\\n        \\n        # 2) dp[j] = number of ways to form target[:j] so far\\n        dp = [0] * (tlen + 1)\\n        dp[0] = 1\\n        \\n        # 3) Process columns one by one\\n        for i in range(m):\\n            f = freq[i]\\n            # update dp from back to front so we don't reuse this column\\n            for j in range(tlen-1, -1, -1):\\n                c = ord(target[j]) - 97\\n                cnt = f[c]\\n                if cnt:\\n                    dp[j+1] = (dp[j+1] + dp[j] * cnt) % MOD\\n        \\n        return dp[tlen]\\n\"",
  "206_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def reverseList(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        prev = None\\n        curr = head\\n        while curr:\\n            next_tmp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_tmp\\n        return prev\\n\\n    def reverseListRecursive(self, head):\\n        if not head or not head.next:\\n            return head\\n        p = self.reverseListRecursive(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return p\\n\"",
  "2006_14631217_python-updated-time": "1746626583974",
  "3291_14631217_python": "\"class Solution(object):\\n    def canSortArray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def popcount(x):\\n            return bin(x).count('1')\\n        \\n        n = len(nums)\\n        if n <= 1:\\n            return True\\n        \\n        # 1) identify runs of equal popcount\\n        runs = []\\n        start = 0\\n        for i in range(n-1):\\n            if popcount(nums[i]) != popcount(nums[i+1]):\\n                runs.append((start, i))\\n                start = i+1\\n        runs.append((start, n-1))\\n        \\n        # 2) sort each run in-place\\n        arr = list(nums)\\n        for l, r in runs:\\n            arr[l:r+1] = sorted(arr[l:r+1])\\n        \\n        # 3) check if fully sorted\\n        return all(arr[i] <= arr[i+1] for i in range(n-1))\\n\"",
  "556_14631217_python": "\"class Solution(object):\\n    def nextGreaterElement(self, n):\\n        s = list(str(n))\\n        # 1. find the pivot\\n        i = len(s) - 2\\n        while i >= 0 and s[i] >= s[i+1]:\\n            i -= 1\\n        if i < 0:\\n            return -1\\n        # 2. find the rightmost successor to pivot\\n        j = len(s) - 1\\n        while s[j] <= s[i]:\\n            j -= 1\\n        # 3. swap pivot and successor\\n        s[i], s[j] = s[j], s[i]\\n        # 4. reverse the suffix\\n        s[i+1:] = reversed(s[i+1:])\\n        res = int(\\\"\\\".join(s))\\n        # 5. check 32-bit limit\\n        return res if res <= 2**31 - 1 else -1\\n\"",
  "649_14631217_python-updated-time": "1745782679115",
  "204_14631217_python-updated-time": "1745245819712",
  "2549_14631217_python-updated-time": "1746968444713",
  "3591_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def shiftDistance(self, s, t, nextCost, previousCost):\\n        # 1) build the cycle graph\\n        graph = [[] for _ in range(26)]\\n        for u in range(26):\\n            v1 = (u + 1) % 26\\n            graph[u].append((v1, nextCost[u]))\\n            v2 = (u - 1) % 26\\n            graph[u].append((v2, previousCost[u]))\\n\\n        # 2) Dijkstra from each source u\\n        dist = [[float('inf')]*26 for _ in range(26)]\\n        for src in range(26):\\n            dist[src][src] = 0\\n            pq = [(0, src)]\\n            while pq:\\n                d, u = heapq.heappop(pq)\\n                if d > dist[src][u]:\\n                    continue\\n                for v, w in graph[u]:\\n                    nd = d + w\\n                    if nd < dist[src][v]:\\n                        dist[src][v] = nd\\n                        heapq.heappush(pq, (nd, v))\\n\\n        # 3) sum up per-character minimum costs\\n        total = 0\\n        for cs, ct in zip(s, t):\\n            u = ord(cs) - ord('a')\\n            v = ord(ct) - ord('a')\\n            total += dist[u][v]\\n        return total\\n\"",
  "1872_14631217_python": "\"class Solution(object):\\n    def canEat(self, candiesCount, queries):\\n        \\\"\\\"\\\"\\n        :type candiesCount: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \\\"\\\"\\\"\\n        n = len(candiesCount)\\n        \\n        # Step 1: Build prefix sum of candiesCount\\n        prefixSum = [0] * (n + 1)\\n        for i in range(n):\\n            prefixSum[i + 1] = prefixSum[i] + candiesCount[i]\\n        \\n        res = []\\n        for t, d, cap in queries:\\n            minCandiesEaten = d + 1\\n            maxCandiesEaten = (d + 1) * cap\\n            # Check overlap between [prefixSum[t] + 1, prefixSum[t+1]]\\n            canEat = maxCandiesEaten > prefixSum[t] and minCandiesEaten <= prefixSum[t + 1]\\n            res.append(canEat)\\n        \\n        return res\\n\"",
  "1299_14631217_python": "\"class Solution(object):\\n    def kConcatenationMaxSum(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n\\n        def kadane(nums):\\n            max_end = max_so_far = 0\\n            for x in nums:\\n                max_end = max(x, max_end + x)\\n                max_so_far = max(max_so_far, max_end)\\n            return max_so_far\\n\\n        one = kadane(arr)\\n        if k == 1:\\n            return one % MOD\\n\\n        total_sum = sum(arr)\\n        two = kadane(arr * 2)\\n\\n        if total_sum > 0:\\n            return (two + (k - 2) * total_sum) % MOD\\n        else:\\n            return two % MOD\\n\"",
  "3001_14631217_python-updated-time": "1747225486300",
  "3265_14631217_python-updated-time": "1747413194008",
  "713_14631217_python-updated-time": "1745786549704",
  "2005_14631217_python": "\"class Solution:\\n    def isCovered(self, ranges, left, right):\\n        covered = [0] * 51\\n        for start, end in ranges:\\n            for i in range(start, end + 1):\\n                covered[i] = 1\\n        for i in range(left, right + 1):\\n            if covered[i] == 0:\\n                return False\\n        return True\\n\"",
  "1009_14631217_python-updated-time": "1746039772464",
  "2442_14631217_python": "\"class Solution(object):\\n    def arithmeticTriplets(self, nums, diff):\\n        s = set(nums)\\n        count = 0\\n        for x in nums:\\n            if x + diff in s and x + 2 * diff in s:\\n                count += 1\\n        return count\\n\"",
  "3865_14631217_mysql": "\"WITH DistinctPurchases AS (\\n  SELECT DISTINCT user_id, product_id\\n  FROM ProductPurchases\\n)\\nSELECT\\n  p1.product_id   AS product1_id,\\n  p2.product_id   AS product2_id,\\n  i1.category     AS product1_category,\\n  i2.category     AS product2_category,\\n  COUNT(*)        AS customer_count\\nFROM DistinctPurchases p1\\nJOIN DistinctPurchases p2\\n  ON p1.user_id = p2.user_id\\n AND p1.product_id < p2.product_id\\nJOIN ProductInfo i1\\n  ON p1.product_id = i1.product_id\\nJOIN ProductInfo i2\\n  ON p2.product_id = i2.product_id\\nGROUP BY\\n  p1.product_id,\\n  p2.product_id,\\n  i1.category,\\n  i2.category\\nHAVING\\n  COUNT(*) >= 3\\nORDER BY\\n  customer_count DESC,\\n  product1_id ASC,\\n  product2_id ASC;\\n\"",
  "2889_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def countBlackBlocks(self, m, n, coordinates):\\n        block_count = defaultdict(int)\\n        black = set((x, y) for x, y in coordinates)\\n\\n        for x, y in black:\\n            for dx in (0, -1):\\n                for dy in (0, -1):\\n                    i, j = x + dx, y + dy\\n                    if 0 <= i < m - 1 and 0 <= j < n - 1:\\n                        block_count[(i, j)] += 1\\n\\n        result = [0] * 5\\n        for cnt in block_count.values():\\n            result[cnt] += 1\\n\\n        total_blocks = (m - 1) * (n - 1)\\n        result[0] = total_blocks - sum(result[1:])\\n\\n        return result\\n\"",
  "2291_14631217_python": "\"class Solution:\\n    def maximumANDSum(self, nums, numSlots):\\n        memo = {}\\n        n = len(nums)\\n\\n        def dp(i, mask):\\n            if i == n:\\n                return 0\\n            if (i, mask) in memo:\\n                return memo[(i, mask)]\\n\\n            res = 0\\n            for slot in range(numSlots):\\n                count = (mask // (3 ** slot)) % 3\\n                if count < 2:\\n                    new_mask = mask + (3 ** slot)\\n                    res = max(res, (nums[i] & (slot + 1)) + dp(i + 1, new_mask))\\n\\n            memo[(i, mask)] = res\\n            return res\\n\\n        return dp(0, 0)\\n\"",
  "2256_14631217_python": "\"class Solution:\\n    def wordCount(self, startWords, targetWords):\\n        def to_mask(word):\\n            mask = 0\\n            for ch in word:\\n                mask |= 1 << (ord(ch) - ord('a'))\\n            return mask\\n\\n        start_masks = set(to_mask(word) for word in startWords)\\n        res = 0\\n\\n        for word in targetWords:\\n            mask = to_mask(word)\\n            for ch in word:\\n                prev_mask = mask ^ (1 << (ord(ch) - ord('a')))\\n                if prev_mask in start_masks:\\n                    res += 1\\n                    break\\n\\n        return res\\n\"",
  "1241_14631217_python-updated-time": "1746261079676",
  "2219_14631217_python-updated-time": "1746800159581",
  "3680_14631217_python": "\"class DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self, a, b):\\n        ra, rb = self.find(a), self.find(b)\\n        if ra != rb:\\n            self.p[rb] = ra\\n\\nclass Solution(object):\\n    def countComponents(self, nums, threshold):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type threshold: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        dsu = DSU(n)\\n\\n        # Map small numbers to their index, and isolate large ones\\n        present = [-1]*(threshold+1)\\n        for i, v in enumerate(nums):\\n            if v <= threshold:\\n                present[v] = i\\n\\n        # rep[x] = first index we saw whose value divides x\\n        rep = [-1]*(threshold+1)\\n\\n        # For each possible divisor d<=threshold that actually appears,\\n        # union all other nums[i] dividing the same x.\\n        for d in range(1, threshold+1):\\n            i = present[d]\\n            if i < 0:\\n                continue\\n            for x in range(d, threshold+1, d):\\n                j = rep[x]\\n                if j < 0:\\n                    rep[x] = i\\n                else:\\n                    dsu.union(i, j)\\n\\n        # Count unique roots over ALL nodes\\n        roots = set()\\n        for i in range(n):\\n            roots.add(dsu.find(i))\\n        return len(roots)\\n\"",
  "1303_14631217_python": "\"class Solution:\\n    def minMoves(self, target, maxDoubles):\\n        moves = 0\\n        while target > 1 and maxDoubles > 0:\\n            if target % 2 == 0:\\n                target //= 2\\n                maxDoubles -= 1\\n            else:\\n                target -= 1\\n            moves += 1\\n        return moves + (target - 1)\\n\"",
  "2365_14631217_python": "\"class Solution:\\n    def percentageLetter(self, s, letter):\\n        count = s.count(letter)\\n        return (count * 100) // len(s)\\n\"",
  "1569_14631217_python": "\"class Solution(object):\\n    def maxDotProduct(self, nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        # dp[i][j] = max dot product using nums1[:i] and nums2[:j]\\n        NEG_INF = -10**18\\n        dp = [[NEG_INF] * (n+1) for _ in range(m+1)]\\n        ans = NEG_INF\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                prod = nums1[i-1] * nums2[j-1]\\n                dp[i][j] = max(\\n                    dp[i-1][j],          # skip nums1[i-1]\\n                    dp[i][j-1],          # skip nums2[j-1]\\n                    dp[i-1][j-1] + prod, # take both and extend\\n                    prod                 # start new subsequence here\\n                )\\n                ans = max(ans, dp[i][j])\\n        return ans\\n\"",
  "3328_14631217_python-updated-time": "1747422516370",
  "1379_14631217_python-updated-time": "1746259591219",
  "784_14631217_python": "\"class Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if not root:\\n            from collections import deque\\n            return TreeNode(val)\\n        \\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else:\\n            root.right = self.insertIntoBST(root.right, val)\\n        \\n        return root\\n\"",
  "3739_14631217_python": "\"class Solution(object):\\n    def distanceSum(self, m, n, k):\\n        MOD = 10**9 + 7\\n        N = m * n\\n        \\n        # 1) Precompute factorials + inverse factorials up to N\\n        fac = [1] * (N + 1)\\n        for i in range(1, N + 1):\\n            fac[i] = fac[i - 1] * i % MOD\\n        \\n        invfac = [1] * (N + 1)\\n        invfac[N] = pow(fac[N], MOD - 2, MOD)\\n        for i in range(N, 0, -1):\\n            invfac[i - 1] = invfac[i] * i % MOD\\n        \\n        def comb(a, b):\\n            if b < 0 or b > a: \\n                return 0\\n            return fac[a] * invfac[b] % MOD * invfac[a - b] % MOD\\n        \\n        # 2) How many arrangements include any fixed pair?  C(N-2, k-2)\\n        choose_pair = comb(N - 2, k - 2)\\n        \\n        # 3) Sum of |r1-r2| over all row-pairs and |c1-c2| over all column-pairs:\\n        #    sum_{i<j}(j-i) for L = L*(L-1)*(L+1)/6.\\n        inv6 = pow(6, MOD - 2, MOD)\\n        # row-contribution = n^2 * (m^3 - m) / 6\\n        row_term = (pow(m, 3, MOD) - m) % MOD\\n        sum_row = (n * n % MOD) * row_term % MOD * inv6 % MOD\\n        # col-contribution = m^2 * (n^3 - n) / 6\\n        col_term = (pow(n, 3, MOD) - n) % MOD\\n        sum_col = (m * m % MOD) * col_term % MOD * inv6 % MOD\\n        \\n        total_pair_dist = (sum_row + sum_col) % MOD\\n        \\n        # 4) Answer = choose_pair * total_pair_dist  (mod MOD)\\n        return choose_pair * total_pair_dist % MOD\\n\"",
  "344_14631217_python": "\"class Solution(object):\\n    def reverseString(self, s):\\n        \\\"\\\"\\\"\\n        :type s: List[str]\\n        :rtype: None Do not return anything, modify s in-place instead.\\n        \\\"\\\"\\\"\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            s[left], s[right] = s[right], s[left]\\n            left += 1\\n            right -= 1\\n\"",
  "1526_14631217_python": "\"class Solution(object):\\n    def entityParser(self, text):\\n        entities = {\\n            \\\"&quot;\\\": '\\\"',\\n            \\\"&apos;\\\": \\\"'\\\",\\n            \\\"&amp;\\\": '&',\\n            \\\"&gt;\\\": '>',\\n            \\\"&lt;\\\": '<',\\n            \\\"&frasl;\\\": '/',\\n        }\\n\\n        i = 0\\n        n = len(text)\\n        result = []\\n        while i < n:\\n            if text[i] == '&':\\n                matched = False\\n                for entity, char in entities.items():\\n                    if text.startswith(entity, i):\\n                        result.append(char)\\n                        i += len(entity)\\n                        matched = True\\n                        break\\n                if not matched:\\n                    result.append(text[i])\\n                    i += 1\\n            else:\\n                result.append(text[i])\\n                i += 1\\n        return ''.join(result)\\n\"",
  "2582_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def minScore(self, n, roads):\\n        # build adjacency list\\n        adj = [[] for _ in range(n+1)]\\n        for a, b, d in roads:\\n            adj[a].append((b, d))\\n            adj[b].append((a, d))\\n        # BFS/DFS from city 1 to collect all edges in its component\\n        visited = [False] * (n+1)\\n        q = deque([1])\\n        visited[1] = True\\n        min_edge = float('inf')\\n        while q:\\n            u = q.popleft()\\n            for v, d in adj[u]:\\n                # track the smallest edge seen in this component\\n                if d < min_edge:\\n                    min_edge = d\\n                if not visited[v]:\\n                    visited[v] = True\\n                    q.append(v)\\n        return min_edge\\n\"",
  "1002_14631217_python": "\"class Solution:\\n    def maxWidthRamp(self, nums):\\n        stack = []\\n        for i in range(len(nums)):\\n            if not stack or nums[i] < nums[stack[-1]]:\\n                stack.append(i)\\n\\n        max_width = 0\\n        for j in reversed(range(len(nums))):\\n            while stack and nums[j] >= nums[stack[-1]]:\\n                i = stack.pop()\\n                max_width = max(max_width, j - i)\\n\\n        return max_width\\n\"",
  "3383_14631217_python": "\"class Solution(object):\\n    def maximumEnergy(self, energy, k):\\n        \\\"\\\"\\\"\\n        :type energy: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(energy)\\n        dp = [0] * n\\n\\n        # Process backwards to ensure we compute dp[i + k] before dp[i]\\n        for i in range(n - 1, -1, -1):\\n            if i + k < n:\\n                dp[i] = energy[i] + dp[i + k]\\n            else:\\n                dp[i] = energy[i]\\n\\n        return max(dp)\\n\"",
  "101_14631217_python-updated-time": "1745080924012",
  "2454_14631217_python-updated-time": "1746964881092",
  "9_14631217_python-updated-time": "1744979205144",
  "393_14631217_python": "\"class Solution:\\n    def validUtf8(self, data):\\n        count = 0\\n        \\n        for byte in data:\\n            if count == 0:\\n                if (byte >> 5) == 0b110:\\n                    count = 1\\n                elif (byte >> 4) == 0b1110:\\n                    count = 2\\n                elif (byte >> 3) == 0b11110:\\n                    count = 3\\n                elif (byte >> 7):\\n                    return False\\n            else:\\n                if (byte >> 6) != 0b10:\\n                    return False\\n                count -= 1\\n        \\n        return count == 0\\n\"",
  "37_14631217_python-updated-time": "1744999191432",
  "448_14631217_python-updated-time": "1745359154967",
  "3721_14631217_python-updated-time": "1747671274669",
  "2634_14631217_python-updated-time": "1747061441663",
  "2661_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def findSmallestInteger(self, nums, value):\\n        # Count how many nums fall into each remainder class mod ‘value’\\n        freq = Counter(x % value for x in nums)\\n        \\n        # Try mex = 0,1,2,…; for each i we need one element with remainder i%value\\n        mex = 0\\n        while True:\\n            r = mex % value\\n            if freq[r] > 0:\\n                # we “use up” one such element to cover this mex\\n                freq[r] -= 1\\n                mex += 1\\n            else:\\n                # no element left that can be moved to i, so mex stops here\\n                return mex\\n\"",
  "1104_14631217_python-updated-time": "1746042264761",
  "1572_14631217_python-updated-time": "1746432548196",
  "1415_14631217_mysql-updated-time": "1746260149884",
  "3363_14631217_python-updated-time": "1747422627160",
  "2767_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maximizeSum(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Use a max-heap (invert signs for Python's min-heap)\\n        max_heap = [-x for x in nums]\\n        heapq.heapify(max_heap)\\n\\n        score = 0\\n        for _ in range(k):\\n            # Pop the largest element\\n            m = -heapq.heappop(max_heap)\\n            score += m\\n            # Increment it by 1 and push back\\n            heapq.heappush(max_heap, -(m + 1))\\n\\n        return score\\n\"",
  "3456_14631217_python-updated-time": "1747484240950",
  "2304_14631217_python": "\"class Solution:\\n    def cellsInRange(self, s):\\n        col1, row1, _, col2, row2 = s\\n        cols = [chr(i) for i in range(ord(col1), ord(col2) + 1)]\\n        rows = [str(i) for i in range(int(row1), int(row2) + 1)]\\n        \\n        result = []\\n        for col in cols:\\n            for row in rows:\\n                result.append(col + row)\\n        \\n        return result\\n\"",
  "3380_14631217_python-updated-time": "1747422921355",
  "39_14631217_python": "\"class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \\\"\\\"\\\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n\\n        def backtrack(start, path, total):\\n            if total == target:\\n                res.append(list(path))\\n                return\\n            if total > target:\\n                return\\n\\n            for i in range(start, len(candidates)):\\n                path.append(candidates[i])\\n                backtrack(i, path, total + candidates[i])\\n                path.pop()\\n\\n        backtrack(0, [], 0)\\n        return res\\n\"",
  "1117_14631217_python-updated-time": "1746126162105",
  "25_14631217_python-updated-time": "1744987757565",
  "1388_14631217_python": "\"class Solution:\\n    def maxSumDivThree(self, nums):\\n        total = sum(nums)\\n        rem1, rem2 = [], []\\n\\n        for num in nums:\\n            if num % 3 == 1:\\n                rem1.append(num)\\n            elif num % 3 == 2:\\n                rem2.append(num)\\n\\n        rem1.sort()\\n        rem2.sort()\\n\\n        if total % 3 == 0:\\n            return total\\n        elif total % 3 == 1:\\n            option1 = total - rem1[0] if rem1 else 0\\n            option2 = total - sum(rem2[:2]) if len(rem2) >= 2 else 0\\n        else:  # total % 3 == 2\\n            option1 = total - rem2[0] if rem2 else 0\\n            option2 = total - sum(rem1[:2]) if len(rem1) >= 2 else 0\\n\\n        return max(option1, option2)\\n\"",
  "1884_14631217_python": "\"class Solution(object):\\n    def minOperations(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mismatch_start_with_0 = 0\\n        mismatch_start_with_1 = 0\\n\\n        for i, ch in enumerate(s):\\n            expected_0 = str(i % 2)         # Pattern: 0, 1, 0, 1,...\\n            expected_1 = str((i + 1) % 2)   # Pattern: 1, 0, 1, 0,...\\n            \\n            if ch != expected_0:\\n                mismatch_start_with_0 += 1\\n            if ch != expected_1:\\n                mismatch_start_with_1 += 1\\n\\n        return min(mismatch_start_with_0, mismatch_start_with_1)\\n\"",
  "3327_14631217_python": "\"class Solution(object):\\n    def minimumMoves(self, nums, k, maxChanges):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type maxChanges: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        cnt = [0] * (n + 1)      # prefix count of 1s\\n        s = [0] * (n + 1)        # prefix sum of indices of 1s\\n        for idx, v in enumerate(nums, 1):     # 1-indexed\\n            cnt[idx] = cnt[idx - 1] + v\\n            s[idx] = s[idx - 1] + idx * v\\n\\n        INF = 1 << 60\\n        ans = INF\\n\\n        for i in xrange(1, n + 1):            # Alice stands at i (1-indexed)\\n            need = k - nums[i - 1]            # ones still needed after free pickup\\n            moves = 0\\n\\n            # take from immediate neighbours if possible (cost 1 each)\\n            for j in (i - 1, i + 1):\\n                if need and 1 <= j <= n and nums[j - 1]:\\n                    need -= 1\\n                    moves += 1\\n\\n            # create at neighbours, then swap in (cost 2 each)\\n            c = min(need, maxChanges)\\n            need -= c\\n            moves += c * 2\\n\\n            if need <= 0:\\n                ans = min(ans, moves)\\n                continue\\n\\n            # binary-search minimal radius to collect remaining ones\\n            left, right = 2, max(i - 1, n - i)\\n            while left <= right:\\n                mid = (left + right) >> 1\\n\\n                l1, r1 = max(1, i - mid), max(0, i - 2)\\n                l2, r2 = min(n + 1, i + 2), min(n, i + mid)\\n\\n                c1 = cnt[r1] - cnt[l1 - 1] if r1 >= l1 else 0\\n                c2 = cnt[r2] - cnt[l2 - 1] if r2 >= l2 else 0\\n\\n                if c1 + c2 >= need:\\n                    # distance cost on the left\\n                    sum_left = s[r1] - s[l1 - 1] if r1 >= l1 else 0\\n                    dist_left = c1 * i - sum_left\\n                    # distance cost on the right\\n                    sum_right = s[r2] - s[l2 - 1] if r2 >= l2 else 0\\n                    dist_right = sum_right - c2 * i\\n                    ans = min(ans, moves + dist_left + dist_right)\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n        return ans\\n\"",
  "677_14631217_python-updated-time": "1745783455173",
  "1976_14631217_python": "\"class Solution:\\n    def splitString(self, s):\\n        def dfs(prev, i, cnt):\\n            if i == len(s):\\n                return cnt >= 2\\n            num = 0\\n            for j in range(i, len(s)):\\n                num = num * 10 + int(s[j])\\n                if prev is None or prev - num == 1:\\n                    if dfs(num, j + 1, cnt + 1):\\n                        return True\\n                if prev is not None and num >= prev:\\n                    break\\n            return False\\n        return dfs(None, 0, 0)\\n\"",
  "434_14631217_python-updated-time": "1745358765784",
  "1402_14631217_python": "\"class Solution:\\n    def countSquares(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0]*n for _ in range(m)]\\n        total = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 1:\\n                    if i == 0 or j == 0:\\n                        dp[i][j] = 1\\n                    else:\\n                        dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\\n                    total += dp[i][j]\\n        \\n        return total\\n\"",
  "1950_14631217_python": "\"class Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            if x < 0:\\n                neg += 1\\n        return -1 if neg % 2 else 1\\n\"",
  "3428_14631217_python": "\"class Solution(object):\\n    def duplicateNumbersXOR(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        seen = set()\\n        dup = set()\\n        for x in nums:\\n            if x in seen:\\n                dup.add(x)\\n            else:\\n                seen.add(x)\\n\\n        res = 0\\n        for x in dup:\\n            res ^= x\\n        return res\\n\"",
  "3550_14631217_python-updated-time": "1747501522885",
  "972_14631217_python": "\"class Solution:\\n    def knightDialer(self, n):\\n        MOD = 10**9 + 7\\n\\n        # Knight move transitions for digits 0 through 9\\n        moves = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n\\n        dp = [1] * 10  # dp[i] = number of ways to end at digit i at step 1\\n\\n        for _ in range(n - 1):\\n            next_dp = [0] * 10\\n            for i in range(10):\\n                for nei in moves[i]:\\n                    next_dp[nei] = (next_dp[nei] + dp[i]) % MOD\\n            dp = next_dp\\n\\n        return sum(dp) % MOD\\n\"",
  "2878_14631217_python": "\"class Solution:\\n    def checkArray(self, nums, k):\\n        n = len(nums)\\n        delta = [0] * (n + 1)\\n        cur = 0\\n\\n        for i in range(n):\\n            cur += delta[i]\\n            diff = nums[i] - cur\\n\\n            if diff < 0:\\n                return False\\n            if diff > 0:\\n                if i + k > n:\\n                    return False\\n                cur += diff\\n                delta[i + k] -= diff\\n\\n        return True\\n\"",
  "1249_14631217_python-updated-time": "1746125869411",
  "2721_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def distance(self, nums):\\n        index_map = defaultdict(list)\\n        for i, val in enumerate(nums):\\n            index_map[val].append(i)\\n\\n        res = [0] * len(nums)\\n\\n        for positions in index_map.values():\\n            prefix = [0]\\n            for pos in positions:\\n                prefix.append(prefix[-1] + pos)\\n\\n            m = len(positions)\\n            for idx, pos in enumerate(positions):\\n                left = idx\\n                right = m - 1 - idx\\n                sum_left = prefix[idx]\\n                sum_right = prefix[-1] - prefix[idx + 1]\\n                res[pos] = pos * left - sum_left + sum_right - pos * right\\n\\n        return res\\n\"",
  "1819_14631217_python-updated-time": "1746454299518",
  "958_14631217_python-updated-time": "1746003688599",
  "2652_14631217_python-updated-time": "1747066442924",
  "3025_14631217_python-updated-time": "1747226405609",
  "2398_14631217_python-updated-time": "1746883108723",
  "1240_14631217_python": "\"class Solution(object):\\n    def stoneGameII(self, piles):\\n        \\\"\\\"\\\"\\n        :type piles: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(piles)\\n        suffix_sum = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            suffix_sum[i] = suffix_sum[i + 1] + piles[i]\\n\\n        memo = {}\\n\\n        def dp(i, M):\\n            if i >= n:\\n                return 0\\n            if (i, M) in memo:\\n                return memo[(i, M)]\\n\\n            max_stones = 0\\n            for X in range(1, 2 * M + 1):\\n                if i + X > n:\\n                    break\\n                max_stones = max(\\n                    max_stones,\\n                    suffix_sum[i] - dp(i + X, max(M, X))\\n                )\\n            memo[(i, M)] = max_stones\\n            return max_stones\\n\\n        return dp(0, 1)\\n\"",
  "3389_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minimumTime(self, n, edges, disappear):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type disappear: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Build adjacency list\\n        g = [[] for _ in range(n)]\\n        for u, v, w in edges:\\n            g[u].append((v, w))\\n            g[v].append((u, w))\\n        \\n        INF = 10**30\\n        dist = [INF]*n\\n        dist[0] = 0\\n        \\n        # Min-heap of (time, node)\\n        pq = [(0, 0)]\\n        \\n        while pq:\\n            t, u = heapq.heappop(pq)\\n            # If this is stale or node already disappeared, skip\\n            if t > dist[u] or t >= disappear[u]:\\n                continue\\n            # Relax edges\\n            for v, w in g[u]:\\n                nt = t + w\\n                # Only if we can get to v *before* it disappears\\n                if nt < disappear[v] and nt < dist[v]:\\n                    dist[v] = nt\\n                    heapq.heappush(pq, (nt, v))\\n        \\n        # Build answer\\n        ans = []\\n        for i in range(n):\\n            if dist[i] < disappear[i]:\\n                ans.append(dist[i])\\n            else:\\n                ans.append(-1)\\n        return ans\\n\"",
  "1105_14631217_python-updated-time": "1746042292053",
  "2170_14631217_python": "\"class Solution(object):\\n    def countMaxOrSubsets(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        self.max_or = 0\\n        self.count = 0\\n\\n        def backtrack(index, current_or):\\n            if index == len(nums):\\n                if current_or == self.max_or:\\n                    self.count += 1\\n                return\\n            # Include nums[index]\\n            backtrack(index + 1, current_or | nums[index])\\n            # Exclude nums[index]\\n            backtrack(index + 1, current_or)\\n\\n        # Compute the maximum OR\\n        for num in nums:\\n            self.max_or |= num\\n\\n        backtrack(0, 0)\\n        return self.count\\n\"",
  "1278_14631217_mysql": "\"SELECT \\n    p.product_id,\\n    COALESCE(\\n        (\\n            SELECT new_price\\n            FROM Products\\n            WHERE product_id = p.product_id AND change_date <= '2019-08-16'\\n            ORDER BY change_date DESC\\n            LIMIT 1\\n        ),\\n        10\\n    ) AS price\\nFROM (\\n    SELECT DISTINCT product_id\\n    FROM Products\\n) p;\\n\"",
  "2035_14631217_python-updated-time": "1746627796275",
  "639_14631217_python-updated-time": "1745782407984",
  "1661_14631217_python-updated-time": "1746434580672",
  "2821_14631217_javascript-updated-time": "1747140392320",
  "3227_14631217_python-updated-time": "1747317974192",
  "174_14631217_python-updated-time": "1745092170537",
  "2645_14631217_python-updated-time": "1747066472417",
  "1642_14631217_python-updated-time": "1746433610642",
  "1572_14631217_python": "\"class SubrectangleQueries(object):\\n\\n    def __init__(self, rectangle):\\n        \\\"\\\"\\\"\\n        :type rectangle: List[List[int]]\\n        \\\"\\\"\\\"\\n        self.rectangle = [row[:] for row in rectangle]\\n\\n    def updateSubrectangle(self, row1, col1, row2, col2, newValue):\\n        \\\"\\\"\\\"\\n        :type row1: int\\n        :type col1: int\\n        :type row2: int\\n        :type col2: int\\n        :type newValue: int\\n        :rtype: None\\n        \\\"\\\"\\\"\\n        for i in range(row1, row2 + 1):\\n            for j in range(col1, col2 + 1):\\n                self.rectangle[i][j] = newValue\\n\\n    def getValue(self, row, col):\\n        \\\"\\\"\\\"\\n        :type row: int\\n        :type col: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        return self.rectangle[row][col]\\n\"",
  "3507_14631217_python": "\"class Solution(object):\\n    def nonSpecialCount(self, l, r):\\n        \\\"\\\"\\\"\\n        :type l: int\\n        :type r: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import math\\n        \\n        # integer sqrt helper\\n        def isqrt(n):\\n            x = int(n**0.5)\\n            # adjust for floating-point drift\\n            while (x+1)*(x+1) <= n:\\n                x += 1\\n            while x*x > n:\\n                x -= 1\\n            return x\\n        \\n        lo = isqrt(l)\\n        if lo*lo < l:\\n            lo += 1\\n        hi = isqrt(r)\\n        \\n        if lo > hi:\\n            # no squares in [l,r]\\n            return r - l + 1\\n        \\n        # sieve primes up to hi\\n        m = hi + 1\\n        sieve = [True] * m\\n        sieve[0] = sieve[1] = False\\n        for i in xrange(2, int(m**0.5) + 1):\\n            if sieve[i]:\\n                step = i\\n                start = i*i\\n                for j in xrange(start, m, step):\\n                    sieve[j] = False\\n        \\n        # count primes p in [lo..hi]\\n        cnt_special = 0\\n        for p in xrange(lo, hi+1):\\n            if sieve[p]:\\n                cnt_special += 1\\n        \\n        return (r - l + 1) - cnt_special\\n\"",
  "1517_14631217_python-updated-time": "1746346822184",
  "3371_14631217_python": "\"class Solution(object):\\n    def sumOfTheDigitsOfHarshadNumber(self, x):\\n        \\\"\\\"\\\"\\n        :type x: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # compute sum of digits\\n        s = 0\\n        t = x\\n        while t:\\n            s += t % 10\\n            t //= 10\\n        \\n        # check Harshad condition\\n        return s if x % s == 0 else -1\\n\"",
  "2222_14631217_python": "\"import math\\n\\nclass Solution:\\n    def abbreviateProduct(self, left, right):          # no type hints, no f-strings\\n        # ---------- count powers of 2 and 5 ----------\\n        pow2 = pow5 = 0\\n        stripped = []                                  # numbers with 2- and 5-factors removed\\n        for x in range(left, right + 1):\\n            t = x\\n            while t % 2 == 0:\\n                pow2 += 1\\n                t //= 2\\n            while t % 5 == 0:\\n                pow5 += 1\\n                t //= 5\\n            stripped.append(t)\\n\\n        C = pow2 if pow2 < pow5 else pow5              # trailing-zero count\\n        pow2 -= C                                      # remaining unpaired 2’s\\n        pow5 -= C                                      # remaining unpaired 5’s\\n\\n        # ---------- suffix (last 5 non-zero digits) ----------\\n        MOD = 1000000000                               # keep 9 tail digits\\n        tail = 1\\n        for v in stripped:\\n            tail = (tail * v) % MOD\\n        tail = (tail * pow(2, pow2, MOD)) % MOD\\n        tail = (tail * pow(5, pow5, MOD)) % MOD\\n        while tail % 10 == 0:\\n            tail //= 10\\n        suf = str(tail % 100000).zfill(5)              # exactly 5 digits\\n\\n        # ---------- prefix (first 5 digits) ----------\\n        lead = 1\\n        LIMIT = 10000000000000000                      # 10^16  (keep 16 leading digits)\\n        for v in stripped:\\n            lead *= v\\n            while lead >= LIMIT:                       # trim to 16 digits\\n                lead //= 10\\n        for _ in range(pow2):                          # leftover 2’s\\n            lead *= 2\\n            while lead >= LIMIT:\\n                lead //= 10\\n        for _ in range(pow5):                          # leftover 5’s\\n            lead *= 5\\n            while lead >= LIMIT:\\n                lead //= 10\\n        pre = (str(lead) + \\\"00000\\\")[:5]               # first 5 digits (pad if needed)\\n\\n        # ---------- total digit count after removing zeros ----------\\n        log_sum = 0.0\\n        for x in range(left, right + 1):\\n            log_sum += math.log10(x)\\n        digits = int(log_sum) + 1 - C\\n\\n        # ---------- if result is small (<=10 digits) compute exactly ----------\\n        if digits <= 10:\\n            prod = 1\\n            for x in range(left, right + 1):\\n                prod *= x\\n            while prod % 10 == 0:\\n                prod //= 10\\n            return str(prod) + \\\"e\\\" + str(C)\\n\\n        # ---------- assemble abbreviated form ----------\\n        return pre + \\\"...\\\" + suf + \\\"e\\\" + str(C)\\n\"",
  "2737_14631217_python": "\"class Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \\\"\\\"\\\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]  # [rowIndex, maxOnesCount]\\n        \\\"\\\"\\\"\\n        max_count = -1\\n        best_row = 0\\n        \\n        for i, row in enumerate(mat):\\n            cnt = sum(row)  # since row entries are 0 or 1\\n            if cnt > max_count:\\n                max_count = cnt\\n                best_row = i\\n        \\n        return [best_row, max_count]\\n\"",
  "3165_14631217_python": "\"class Solution(object):\\n    def findIndices(self, nums, indexDifference, valueDifference):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type indexDifference: int\\n        :type valueDifference: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(n):\\n                if abs(i - j) >= indexDifference and abs(nums[i] - nums[j]) >= valueDifference:\\n                    return [i, j]\\n        return [-1, -1]\\n\"",
  "3191_14631217_python-updated-time": "1747309889408",
  "3031_14631217_python": "\"class Solution(object):\\n    def constructProductMatrix(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        MOD = 12345\\n        # Flatten grid\\n        n = len(grid)\\n        m = len(grid[0])\\n        N = n * m\\n        A = [0] * N\\n        idx = 0\\n        for i in range(n):\\n            for j in range(m):\\n                A[idx] = grid[i][j] % MOD\\n                idx += 1\\n\\n        # Prefix products\\n        P = [1] * (N + 1)\\n        for i in range(N):\\n            P[i+1] = (P[i] * A[i]) % MOD\\n\\n        # Suffix products\\n        S = [1] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = (S[i+1] * A[i]) % MOD\\n\\n        # Build result\\n        res = [[0] * m for _ in range(n)]\\n        idx = 0\\n        for i in range(n):\\n            for j in range(m):\\n                res[i][j] = (P[idx] * S[idx+1]) % MOD\\n                idx += 1\\n\\n        return res\\n\"",
  "3214_14631217_python-updated-time": "1747312315100",
  "2054_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def smallestChair(self, times, targetFriend):\\n        # Attach friend index to each time and sort by arrival\\n        events = sorted([(arr, leave, i) for i, (arr, leave) in enumerate(times)],\\n                        key=lambda x: x[0])\\n        \\n        available = []        # min-heap of free chair numbers\\n        occupied = []         # min-heap of (leave_time, chair)\\n        next_chair = 0\\n        \\n        for arr, leave, idx in events:\\n            # Free up chairs from friends who have left by time arr\\n            while occupied and occupied[0][0] <= arr:\\n                _, chair = heapq.heappop(occupied)\\n                heapq.heappush(available, chair)\\n            \\n            # Assign the smallest available chair\\n            if available:\\n                chair = heapq.heappop(available)\\n            else:\\n                chair = next_chair\\n                next_chair += 1\\n            \\n            # If this is the target friend, we're done\\n            if idx == targetFriend:\\n                return chair\\n            \\n            # Mark this chair occupied until 'leave'\\n            heapq.heappush(occupied, (leave, chair))\\n        \\n        # Should never reach here if input guarantees targetFriend in times\\n        return -1\\n\"",
  "2419_14631217_python": "\"class Solution:\\n    def validSubarraySize(self, nums, threshold):\\n        n = len(nums)\\n        \\n        # Disjoint Set Union to track lengths of active segments\\n        parent = list(range(n))\\n        size = [0] * n\\n        active = [False] * n\\n        \\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        def union(a, b):\\n            ra, rb = find(a), find(b)\\n            if ra == rb:\\n                return ra\\n            # merge smaller into larger\\n            if size[ra] < size[rb]:\\n                ra, rb = rb, ra\\n            parent[rb] = ra\\n            size[ra] += size[rb]\\n            return ra\\n        \\n        # Group indices by value\\n        from collections import defaultdict\\n        pos = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            pos[v].append(i)\\n        \\n        # Process distinct values in descending order\\n        for v in sorted(pos.keys(), reverse=True):\\n            # compute needed subarray length for this value\\n            k_needed = threshold // v + 1\\n            \\n            # activate all positions with value == v\\n            for i in pos[v]:\\n                active[i] = True\\n                parent[i] = i\\n                size[i] = 1\\n                # merge with left neighbor if active\\n                if i > 0 and active[i-1]:\\n                    ri = union(i, i-1)\\n                    # size[ri] updated in union\\n                # merge with right neighbor if active\\n                if i+1 < n and active[i+1]:\\n                    ri = union(i, i+1)\\n                # after unions, check the component size\\n                root = find(i)\\n                if size[root] >= k_needed:\\n                    return k_needed\\n        \\n        # no valid subarray found\\n        return -1\\n\"",
  "3165_14631217_python-updated-time": "1747307629758",
  "3445_14631217_python": "\"from collections import defaultdict\\nimport heapq\\n\\nclass Solution(object):\\n    def clearStars(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        from bisect import bisect_left, insort\\n\\n        stack = []\\n        freq = defaultdict(list)  # char -> list of indices\\n\\n        for i, ch in enumerate(s):\\n            if ch == '*':\\n                # Remove the smallest char in stack\\n                min_char = min(freq)\\n                index = freq[min_char].pop()\\n                stack[index] = None\\n                if not freq[min_char]:\\n                    del freq[min_char]\\n            else:\\n                freq[ch].append(len(stack))\\n                stack.append(ch)\\n\\n        return ''.join(ch for ch in stack if ch is not None)\\n\"",
  "3313_14631217_python": "\"class Solution(object):\\n    def maximumStrength(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int  # guaranteed odd\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        import math\\n        \\n        # Precompute the weight for choosing segment j:\\n        # w[j] = (-1)^(j-1) * (k - j + 1), 1-based\\n        w = [0]*(k+1)\\n        for j in range(1, k+1):\\n            sign = -1 if (j-1)%2 else 1\\n            w[j] = sign * (k - j + 1)\\n        \\n        # end[j]: best strength for j segments, with the j-th ending exactly here\\n        # any_[j]: best strength for j segments ending anywhere so far\\n        end = [-10**30]*(k+1)\\n        any_ = [-10**30]*(k+1)\\n        any_[0] = 0  # zero segments gives strength 0\\n        \\n        for x in nums:\\n            # update in descending j to avoid overwriting what we need\\n            for j in range(k, 0, -1):\\n                extend = end[j] + w[j] * x\\n                start  = any_[j-1] + w[j] * x\\n                new_end_j = extend if extend > start else start\\n                end[j] = new_end_j\\n                # record best so far for j segments\\n                if new_end_j > any_[j]:\\n                    any_[j] = new_end_j\\n        \\n        return any_[k]\\n\"",
  "1498_14631217_python-updated-time": "1746345830423",
  "1257_14631217_python-updated-time": "1746444843637",
  "1081_14631217_python": "\"class Solution:\\n    def videoStitching(self, clips, time):\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        res = 0\\n        curr_end = 0\\n        i = 0\\n        n = len(clips)\\n        while curr_end < time:\\n            furthest = curr_end\\n            while i < n and clips[i][0] <= curr_end:\\n                furthest = max(furthest, clips[i][1])\\n                i += 1\\n            if furthest == curr_end:\\n                return -1\\n            res += 1\\n            curr_end = furthest\\n        return res\\n\"",
  "3349_14631217_python": "\"class Solution(object):\\n    def maximumLengthSubstring(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import defaultdict\\n\\n        left = 0\\n        count = defaultdict(int)\\n        max_len = 0\\n\\n        for right in range(len(s)):\\n            count[s[right]] += 1\\n\\n            # If any character count goes above 2, shrink the window from the left\\n            while any(v > 2 for v in count.values()):\\n                count[s[left]] -= 1\\n                left += 1\\n\\n            # Update maximum length\\n            max_len = max(max_len, right - left + 1)\\n\\n        return max_len\\n\"",
  "2846_14631217_python": "\"class Solution:\\n    def survivedRobotsHealths(self, positions, healths, directions):\\n        # Prepare robots sorted by position ascending\\n        robots = sorted(\\n            [(pos, i, healths[i], directions[i]) for i, pos in enumerate(positions)],\\n            key=lambda x: x[0]\\n        )\\n        \\n        stack = []   # stack of (orig_index, health) for 'R' robots\\n        survivors = []  # list of (orig_index, final_health) for surviving 'L' robots\\n        \\n        for _, idx, hp, d in robots:\\n            if d == 'R':\\n                stack.append([idx, hp])\\n            else:  # d == 'L'\\n                cur_hp = hp\\n                # collide with any R-robots on stack\\n                while stack and cur_hp > 0:\\n                    top_idx, top_hp = stack[-1]\\n                    if top_hp < cur_hp:\\n                        # top dies\\n                        stack.pop()\\n                        cur_hp -= 1\\n                    elif top_hp == cur_hp:\\n                        # both die\\n                        stack.pop()\\n                        cur_hp = 0\\n                    else:  # top_hp > cur_hp\\n                        # current dies, top loses 1 hp\\n                        stack[-1][1] -= 1\\n                        cur_hp = 0\\n                # if it survived all collisions, record it\\n                if cur_hp > 0:\\n                    survivors.append((idx, cur_hp))\\n        \\n        # any R-robots left on stack survive with their updated health\\n        for idx, hp in stack:\\n            survivors.append((idx, hp))\\n        \\n        # sort survivors by original index and return healths\\n        survivors.sort(key=lambda x: x[0])\\n        return [hp for _, hp in survivors]\\n\"",
  "3853_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\nclass Solution(object):\\n    def minimumWeight(self, edges, queries):\\n        \\\"\\\"\\\"\\n        :type edges: List[List[int]]\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(edges) + 1\\n        # build adjacency list\\n        G = [[] for _ in range(n)]\\n        for u,v,w in edges:\\n            G[u].append((v,w))\\n            G[v].append((u,w))\\n        \\n        LOG = (n-1).bit_length()\\n        up = [[-1]*n for _ in range(LOG)]  # up[k][v] = 2^k-th ancestor of v\\n        depth = [0]*n\\n        dist = [0]*n  # distance from root (0)\\n        \\n        # iterative DFS to set up depth, parent[0], dist\\n        stack = [(0, -1, 0, 0)]  # node, parent, depth, dist\\n        while stack:\\n            v, p, d, dv = stack.pop()\\n            up[0][v] = p\\n            depth[v] = d\\n            dist[v] = dv\\n            for w, wt in G[v]:\\n                if w == p: \\n                    continue\\n                stack.append((w, v, d+1, dv+wt))\\n        \\n        # binary-lift preprocessing\\n        for k in range(1, LOG):\\n            for v in range(n):\\n                pv = up[k-1][v]\\n                up[k][v] = -1 if pv < 0 else up[k-1][pv]\\n        \\n        def lca(u, v):\\n            if depth[u] < depth[v]:\\n                u, v = v, u\\n            # lift u up to depth[v]\\n            diff = depth[u] - depth[v]\\n            for k in range(LOG):\\n                if diff & (1<<k):\\n                    u = up[k][u]\\n            if u == v:\\n                return u\\n            # binary lift both\\n            for k in reversed(range(LOG)):\\n                if up[k][u] != up[k][v]:\\n                    u = up[k][u]\\n                    v = up[k][v]\\n            return up[0][u]\\n        \\n        def distance(a, b):\\n            \\\"\\\"\\\"Return distance between a and b.\\\"\\\"\\\"\\n            c = lca(a, b)\\n            return dist[a] + dist[b] - 2*dist[c]\\n        \\n        ans = []\\n        for u, v, w in queries:\\n            duw = distance(u, w)\\n            dvw = distance(v, w)\\n            duv = distance(u, v)\\n            # union of paths weight\\n            ans.append((duw + dvw + duv) // 2)\\n        \\n        return ans\\n\"",
  "3250_14631217_python-updated-time": "1747318852416",
  "1231_14631217_python-updated-time": "1746260535513",
  "1369_14631217_python": "\"class Solution:\\n    def minimumSwap(self, s1, s2):\\n        xy = yx = 0\\n        for a, b in zip(s1, s2):\\n            if a == 'x' and b == 'y':\\n                xy += 1\\n            elif a == 'y' and b == 'x':\\n                yx += 1\\n\\n        if (xy + yx) % 2 != 0:\\n            return -1\\n\\n        return xy // 2 + yx // 2 + (xy % 2) * 2\\n\"",
  "1663_14631217_python": "\"class Solution(object):\\n    def containsCycle(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[str]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False] * n for _ in range(m)]\\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if not visited[i][j]:\\n                    char = grid[i][j]\\n                    visited[i][j] = True\\n                    stack = [(i, j, -1, -1)]  # (row, col, parent_row, parent_col)\\n                    while stack:\\n                        r, c, pr, pc = stack.pop()\\n                        for dr, dc in dirs:\\n                            nr, nc = r + dr, c + dc\\n                            if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == char:\\n                                if not visited[nr][nc]:\\n                                    visited[nr][nc] = True\\n                                    stack.append((nr, nc, r, c))\\n                                elif not (nr == pr and nc == pc):\\n                                    # Found a cycle\\n                                    return True\\n        return False\\n\"",
  "2459_14631217_python-updated-time": "1746965074491",
  "2119_14631217_python-updated-time": "1746718051324",
  "31_14631217_python": "\"class Solution(object):\\n    def nextPermutation(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        \\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        left, right = i+1, len(nums)-1\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\"",
  "424_14631217_python-updated-time": "1745358509824",
  "3785_14631217_python-updated-time": "1747681990143",
  "1300_14631217_python-updated-time": "1746126830998",
  "1817_14631217_python": "\"class Solution(object):\\n    def totalMoney(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Number of complete weeks and leftover days\\n        w, r = divmod(n, 7)\\n        \\n        # Sum from full weeks:\\n        # Each week i (0-based) contributes 28 + 7*i\\n        # Sum_{i=0 to w-1} (28 + 7*i) = 28*w + 7 * (w*(w-1)//2)\\n        full_weeks_sum = 28 * w + 7 * (w * (w - 1) // 2)\\n        \\n        # Sum from leftover r days in week w:\\n        # Day k in that week gives (k + w) for k=1..r\\n        # Sum = sum(k, k=1..r) + w * r = r*(r+1)//2 + w*r\\n        leftover_sum = r * (r + 1) // 2 + w * r\\n        \\n        return full_weeks_sum + leftover_sum\\n\"",
  "3450_14631217_python-updated-time": "1747484766999",
  "2616_14631217_python-updated-time": "1747060510521",
  "2715_14631217_python-updated-time": "1747133717772",
  "1333_14631217_python-updated-time": "1746803970587",
  "3024_14631217_python-updated-time": "1747227190818",
  "2118_14631217_python": "\"class Solution:\\n    def maxTaxiEarnings(self, n, rides):\\n        from collections import defaultdict\\n\\n        # Group rides by their end point\\n        end_at = defaultdict(list)\\n        for start, end, tip in rides:\\n            end_at[end].append((start, tip))\\n\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            # Option 1: skip taking a ride ending at i\\n            dp[i] = dp[i - 1]\\n            # Option 2: consider rides ending at i\\n            for start, tip in end_at[i]:\\n                dp[i] = max(dp[i], dp[start] + i - start + tip)\\n\\n        return dp[n]\\n\"",
  "3595_14631217_python-updated-time": "1747595631141",
  "3330_14631217_python-updated-time": "1747413649189",
  "2741_14631217_javascript": "\"function compose(functions) {\\n  return function(x) {\\n    return functions.reduceRight((acc, fn) => fn(acc), x);\\n  };\\n}\\n\"",
  "3355_14631217_python": "\"class Solution(object):\\n    def minimumLevels(self, possible):\\n        \\\"\\\"\\\"\\n        :type possible: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(possible)\\n        # Convert to +1 (clear) / -1 (fail)\\n        arr = [1 if x == 1 else -1 for x in possible]\\n        \\n        S = sum(arr)\\n        prefix = 0\\n        \\n        # Alice must take at least 1 and Bob at least 1,\\n        # so k ranges from 1 to n-1.\\n        for k in range(1, n):\\n            prefix += arr[k-1]\\n            # check 2 * AliceScore > total S\\n            if 2 * prefix > S:\\n                return k\\n        \\n        return -1\\n\"",
  "914_14631217_python": "\"import random\\nimport bisect\\n\\nclass Solution:\\n    def __init__(self, rects):\\n        self.rects = rects\\n        self.weights = []\\n        total = 0\\n        for a, b, x, y in rects:\\n            area = (x - a + 1) * (y - b + 1)\\n            total += area\\n            self.weights.append(total)\\n        self.total = total\\n\\n    def pick(self):\\n        k = random.randint(1, self.total)\\n        i = bisect.bisect_left(self.weights, k)\\n        a, b, x, y = self.rects[i]\\n        rand_x = random.randint(a, x)\\n        rand_y = random.randint(b, y)\\n        return [rand_x, rand_y]\\n\"",
  "2590_14631217_python": "\"class Solution(object):\\n    def maxStarSum(self, vals, edges, k):\\n        n = len(vals)\\n        # build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        ans = float('-inf')\\n        # for each node, pick up to k largest positive neighbor values\\n        for i in range(n):\\n            neigh_vals = [vals[j] for j in adj[i]]\\n            neigh_vals.sort(reverse=True)\\n            total = vals[i]\\n            for t in neigh_vals[:k]:\\n                if t > 0:\\n                    total += t\\n                else:\\n                    break\\n            ans = max(ans, total)\\n        return ans\\n\"",
  "2701_14631217_python": "\"import bisect\\n\\nclass Solution(object):\\n    def minimumScore(self, s, t):\\n        n, m = len(s), len(t)\\n        # pre[i]: end position in s matching t[:i] as subsequence\\n        pre = [0] * (m + 1)\\n        pre[0] = -1\\n        j = 0\\n        for i in range(1, m + 1):\\n            # find t[i-1] after pre[i-1]\\n            while j < n and s[j] != t[i-1]:\\n                j += 1\\n            if j < n:\\n                pre[i] = j\\n                j += 1\\n            else:\\n                # no match\\n                pre[i] = float('inf')\\n        # if whole t matches, score = 0\\n        if pre[m] < float('inf'):\\n            return 0\\n\\n        # suf[i]: start position in s matching t[i:] as subsequence\\n        suf = [0] * (m + 1)\\n        suf[m] = n\\n        j = n - 1\\n        for i in range(m - 1, -1, -1):\\n            # find t[i] before suf[i+1]\\n            while j >= 0 and s[j] != t[i]:\\n                j -= 1\\n            if j >= 0:\\n                suf[i] = j\\n                j -= 1\\n            else:\\n                suf[i] = -float('inf')\\n\\n        # suf is strictly increasing with index i\\n        # find minimal (r - l + 1) == (idx - l), where idx = r+1\\n        ans = m  # worst: remove all\\n        for l in range(0, m + 1):\\n            if pre[l] == float('inf'):\\n                break\\n            # need suf[idx] > pre[l], idx in [l+1..m]\\n            idx = bisect.bisect_right(suf, pre[l])\\n            # ensure idx >= l+1\\n            if idx < l + 1:\\n                idx = l + 1\\n            if idx <= m:\\n                # removal segment [l, idx-1], length = idx - l\\n                ans = min(ans, idx - l)\\n        return ans\\n\"",
  "3647_14631217_python-updated-time": "1747595283074",
  "1826_14631217_python-updated-time": "1746453912271",
  "230_14631217_python-updated-time": "1745247166253",
  "636_14631217_python": "\"class Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        res = [0] * n\\n        stack = []\\n        prev_time = 0\\n        \\n        for log in logs:\\n            fn, typ, time = log.split(':')\\n            fn, time = int(fn), int(time)\\n            if typ == 'start':\\n                if stack:\\n                    res[stack[-1]] += time - prev_time\\n                stack.append(fn)\\n                prev_time = time\\n            else:\\n                res[stack.pop()] += time - prev_time + 1\\n                prev_time = time + 1\\n        \\n        return res\\n\"",
  "3176_14631217_python-updated-time": "1747307824326",
  "355_14631217_python-updated-time": "1745257302257",
  "1984_14631217_python": "\"class Solution:\\n    def maxDistance(self, nums1, nums2):\\n        i = j = ans = 0\\n        n1, n2 = len(nums1), len(nums2)\\n        while i < n1 and j < n2:\\n            if nums1[i] <= nums2[j]:\\n                ans = max(ans, j - i)\\n                j += 1\\n            else:\\n                i += 1\\n        return ans\\n\"",
  "918_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def reachableNodes(self, edges, maxMoves, n):\\n        graph = defaultdict(list)\\n        for u, v, cnt in edges:\\n            graph[u].append((v, cnt))\\n            graph[v].append((u, cnt))\\n\\n        dist = [float('inf')] * n\\n        dist[0] = 0\\n        heap = [(0, 0)]  # (distance, node)\\n\\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if d > dist[u]:\\n                continue\\n            for v, cnt in graph[u]:\\n                nd = d + cnt + 1\\n                if nd < dist[v]:\\n                    dist[v] = nd\\n                    heapq.heappush(heap, (nd, v))\\n\\n        reachable = sum(d <= maxMoves for d in dist)\\n\\n        used = {}\\n        for u, v, cnt in edges:\\n            a = max(0, maxMoves - dist[u])\\n            b = max(0, maxMoves - dist[v])\\n            reachable += min(cnt, a + b)\\n\\n        return reachable\\n\"",
  "779_14631217_python": "\"class Solution(object):\\n    def maxChunksToSorted(self, arr):\\n        sorted_arr = sorted(arr)\\n        count = res = 0\\n        freq = {}\\n        for a, b in zip(arr, sorted_arr):\\n            freq[a] = freq.get(a, 0) + 1\\n            if freq[a] == 0:\\n                del freq[a]\\n            freq[b] = freq.get(b, 0) - 1\\n            if freq[b] == 0:\\n                del freq[b]\\n            if not freq:\\n                res += 1\\n        return res\\n\"",
  "415_14631217_python": "\"class Solution:\\n    def addStrings(self, num1, num2):\\n        i, j = len(num1) - 1, len(num2) - 1\\n        carry = 0\\n        res = []\\n        \\n        while i >= 0 or j >= 0 or carry:\\n            n1 = int(num1[i]) if i >= 0 else 0\\n            n2 = int(num2[j]) if j >= 0 else 0\\n            total = n1 + n2 + carry\\n            res.append(str(total % 10))\\n            carry = total // 10\\n            i -= 1\\n            j -= 1\\n        \\n        return ''.join(res[::-1])\\n\"",
  "1945_14631217_python-updated-time": "1746543773185",
  "3509_14631217_python-updated-time": "1747578307111",
  "639_14631217_python": "\"class Solution(object):\\n    def numDecodings(self, s):\\n        MOD = 10**9 + 7\\n        n = len(s)\\n        dp0, dp1 = 1, 0\\n        \\n        if s[0] == '*':\\n            dp1 = 9\\n        elif s[0] != '0':\\n            dp1 = 1\\n        \\n        for i in range(1, n):\\n            temp = dp1\\n            if s[i] == '*':\\n                dp1 = 9 * dp1\\n            elif s[i] != '0':\\n                dp1 = dp1\\n            else:\\n                dp1 = 0\\n            \\n            if s[i-1] == '*' and s[i] == '*':\\n                dp1 += 15 * dp0\\n            elif s[i-1] == '*':\\n                if '0' <= s[i] <= '6':\\n                    dp1 += 2 * dp0\\n                else:\\n                    dp1 += dp0\\n            elif s[i] == '*':\\n                if s[i-1] == '1':\\n                    dp1 += 9 * dp0\\n                elif s[i-1] == '2':\\n                    dp1 += 6 * dp0\\n            else:\\n                if 10 <= int(s[i-1:i+1]) <= 26:\\n                    dp1 += dp0\\n            \\n            dp1 %= MOD\\n            dp0 = temp\\n        \\n        return dp1\\n\"",
  "2026_14631217_python": "\"class Solution:\\n    def mergeTriplets(self, triplets, target):\\n        seen = [False, False, False]\\n\\n        for a, b, c in triplets:\\n            if a <= target[0] and b <= target[1] and c <= target[2]:\\n                if a == target[0]: seen[0] = True\\n                if b == target[1]: seen[1] = True\\n                if c == target[2]: seen[2] = True\\n\\n        return all(seen)\\n\"",
  "1632_14631217_python-updated-time": "1746433825665",
  "797_14631217_python-updated-time": "1745877376550",
  "149_14631217_python-updated-time": "1745090730488",
  "2397_14631217_python": "\"MOD = 10**9 + 7\\n\\nclass Solution:\\n    def countHousePlacements(self, n):\\n        a, b = 1, 2  # dp[0], dp[1]\\n        for _ in range(2, n + 1):\\n            a, b = b, (a + b) % MOD\\n        return (b * b) % MOD\\n\"",
  "912_14631217_python-updated-time": "1745446691860",
  "98_14631217_python-updated-time": "1745080843447",
  "1272_14631217_python-updated-time": "1746126258381",
  "3764_14631217_python": "\"class Solution(object):\\n    def maxSum(self, grid, limits, k):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :type limits: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        cand = []\\n        for row, lim in zip(grid, limits):\\n            # sort this row descending\\n            row.sort(reverse=True)\\n            # take up to `lim` largest pizzas\\n            cand.extend(row[:lim])\\n        # pick the k largest across all rows\\n        cand.sort(reverse=True)\\n        # sum up the top k (or all, if fewer than k)\\n        return sum(cand[:k])\\n\"",
  "2698_14631217_python": "\"class Solution(object):\\n    def findTheArrayConcVal(self, nums):\\n        res = 0\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            res += int(str(nums[l]) + str(nums[r]))\\n            l += 1\\n            r -= 1\\n        if l == r:\\n            res += nums[l]\\n        return res\\n\"",
  "565_14631217_python-updated-time": "1745447753771",
  "223_14631217_python-updated-time": "1745246791804",
  "2731_14631217_javascript": "\"function memoize(fn) {\\n  const cache = new Map();\\n  let callCount = 0;\\n\\n  const memoizedFn = (...args) => {\\n    const key = JSON.stringify(args); // ensures (2,3) ≠ (3,2)\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    callCount++;\\n    return result;\\n  };\\n\\n  memoizedFn.getCallCount = () => callCount;\\n\\n  return memoizedFn;\\n}\\n\"",
  "3518_14631217_python": "\"class Solution(object):\\n    def maxScore(self, a, b):\\n        \\\"\\\"\\\"\\n        :type a: List[int]\\n        :type b: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp = [float('-inf')] * 5  # dp[i] = max score using i elements\\n        dp[0] = 0  # base case: using 0 elements gives 0 score\\n\\n        for val in b:\\n            # iterate in reverse to avoid overwriting previous states\\n            for i in range(3, -1, -1):\\n                dp[i+1] = max(dp[i+1], dp[i] + a[i] * val)\\n\\n        return dp[4]\\n\"",
  "975_14631217_python-updated-time": "1746004318720",
  "1619_14631217_python-updated-time": "1746433049514",
  "1522_14631217_python": "\"class Solution(object):\\n    def stoneGameIII(self, stoneValue):\\n        n = len(stoneValue)\\n        dp = [0] * (n + 1)\\n\\n        for i in range(n - 1, -1, -1):\\n            max_score = float('-inf')\\n            total = 0\\n            for k in range(1, 4):\\n                if i + k <= n:\\n                    total += stoneValue[i + k - 1]\\n                    max_score = max(max_score, total - dp[i + k])\\n            dp[i] = max_score\\n\\n        if dp[0] > 0:\\n            return \\\"Alice\\\"\\n        elif dp[0] < 0:\\n            return \\\"Bob\\\"\\n        else:\\n            return \\\"Tie\\\"\\n\"",
  "1042_14631217_python-updated-time": "1746040881618",
  "139_14631217_python-updated-time": "1745086899168",
  "981_14631217_python": "\"class Solution:\\n    def minDeletionSize(self, strs):\\n        if not strs:\\n            return 0\\n        n, m = len(strs), len(strs[0])\\n        delete_count = 0\\n\\n        for col in range(m):\\n            for row in range(1, n):\\n                if strs[row][col] < strs[row - 1][col]:\\n                    delete_count += 1\\n                    break\\n\\n        return delete_count\\n\"",
  "3242_14631217_python-updated-time": "1747399114144",
  "1012_14631217_python": "\"from fractions import Fraction\\n\\nclass Solution:\\n    def isRationalEqual(self, s, t):\\n        def to_fraction(s):\\n            if '(' not in s:\\n                return Fraction(s)\\n            \\n            base, repeat = s.split('(')\\n            repeat = repeat.rstrip(')')\\n            \\n            if '.' in base:\\n                int_part, frac_part = base.split('.')\\n            else:\\n                int_part, frac_part = base, ''\\n            \\n            # Build base value: integer + non-repeating decimal part\\n            base_frac = Fraction(int_part)\\n            if frac_part:\\n                base_frac += Fraction(int(frac_part), 10 ** len(frac_part))\\n            \\n            # Add repeating part as infinite geometric series\\n            repeat_denominator = (10 ** len(frac_part)) * (10 ** len(repeat) - 1)\\n            repeat_numerator = int(repeat)\\n            repeat_frac = Fraction(repeat_numerator, repeat_denominator)\\n\\n            return base_frac + repeat_frac\\n\\n        return to_fraction(s) == to_fraction(t)\\n\"",
  "1341_14631217_python": "\"class Solution:\\n    def balancedStringSplit(self, s):\\n        balance = 0\\n        count = 0\\n        for c in s:\\n            if c == 'R':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance == 0:\\n                count += 1\\n        return count\\n\"",
  "3701_14631217_python-updated-time": "1747819556413",
  "1716_14631217_python": "\"class Solution(object):\\n    def maxProductPath(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dp_max[i][j], dp_min[i][j]: max/min product to reach (i,j)\\n        dp_max = [[None]*n for _ in range(m)]\\n        dp_min = [[None]*n for _ in range(m)]\\n        \\n        dp_max[0][0] = dp_min[0][0] = grid[0][0]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 and j == 0:\\n                    continue\\n                val = grid[i][j]\\n                candidates = []\\n                \\n                # from top\\n                if i > 0 and dp_max[i-1][j] is not None:\\n                    candidates.append(dp_max[i-1][j] * val)\\n                    candidates.append(dp_min[i-1][j] * val)\\n                \\n                # from left\\n                if j > 0 and dp_max[i][j-1] is not None:\\n                    candidates.append(dp_max[i][j-1] * val)\\n                    candidates.append(dp_min[i][j-1] * val)\\n                \\n                if candidates:\\n                    dp_max[i][j] = max(candidates)\\n                    dp_min[i][j] = min(candidates)\\n        \\n        res = dp_max[m-1][n-1]\\n        if res is None or res < 0:\\n            return -1\\n        return res % MOD\\n\"",
  "3696_14631217_python-updated-time": "1747679257423",
  "2115_14631217_python": "\"class Solution:\\n    def numberOfUniqueGoodSubsequences(self, binary):\\n        mod = 10**9 + 7\\n        ends_with_0 = 0\\n        ends_with_1 = 0\\n        has_zero = False\\n\\n        for c in binary:\\n            if c == '0':\\n                # Append '0' to all subsequences that end with '1'\\n                ends_with_0 = (ends_with_0 + ends_with_1) % mod\\n                has_zero = True\\n            else:\\n                # Append '1' to all existing subsequences (ends_with_0 + ends_with_1)\\n                # and also start a new subsequence \\\"1\\\"\\n                ends_with_1 = (ends_with_1 + ends_with_0 + 1) % mod\\n\\n        # Total = all non-empty subsequences starting with '1' (those ending in '0' or '1')\\n        #      + the single \\\"0\\\" subsequence if any '0' exists\\n        return (ends_with_1 + ends_with_0 + (1 if has_zero else 0)) % mod\\n\"",
  "3396_14631217_python-updated-time": "1747478776055",
  "2891_14631217_python": "\"class Solution:\\n    def maximumBeauty(self, nums, k):\\n        from collections import defaultdict\\n\\n        freq = defaultdict(int)\\n        for num in nums:\\n            freq[num - k] += 1\\n            freq[num + k + 1] -= 1\\n\\n        max_beauty = curr = 0\\n        for key in sorted(freq):\\n            curr += freq[key]\\n            max_beauty = max(max_beauty, curr)\\n\\n        return max_beauty\\n\"",
  "3702_14631217_python-updated-time": "1747654786550",
  "321_14631217_python": "\"class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def maxSubArray(nums, k):\\n            drop = len(nums) - k\\n            stack = []\\n            for num in nums:\\n                while drop and stack and stack[-1] < num:\\n                    stack.pop()\\n                    drop -= 1\\n                stack.append(num)\\n            return stack[:k]\\n\\n        def merge(a, b):\\n            res = []\\n            while a or b:\\n                if a > b:\\n                    res.append(a.pop(0))\\n                else:\\n                    res.append(b.pop(0))\\n            return res\\n        \\n        max_num = []\\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\\n            candidate = merge(maxSubArray(nums1, i), maxSubArray(nums2, k - i))\\n            max_num = max(max_num, candidate)\\n        \\n        return max_num\\n\"",
  "1830_14631217_python-updated-time": "1746453967596",
  "506_14631217_python-updated-time": "1745446204357",
  "1358_14631217_python": "\"class Solution:\\n    def findSolution(self, customfunction, z):\\n        res = []\\n        x, y = 1, 1000\\n        while x <= 1000 and y >= 1:\\n            val = customfunction.f(x, y)\\n            if val == z:\\n                res.append([x, y])\\n                x += 1\\n                y -= 1\\n            elif val < z:\\n                x += 1\\n            else:\\n                y -= 1\\n        return res\\n\"",
  "1987_14631217_python": "\"class Solution:\\n    def countGoodSubstrings(self, s):\\n        cnt = 0\\n        for i in range(len(s) - 2):\\n            a, b, c = s[i], s[i+1], s[i+2]\\n            if a != b and a != c and b != c:\\n                cnt += 1\\n        return cnt\\n\"",
  "3024_14631217_python": "\"class Solution:\\n    MOD = 10**9 + 7\\n\\n    def numberOfWays(self, s, t, k):\\n        n = len(s)\\n        # 1) Find all rotations d in [0..n-1] with rotateRight(s,d)==t via KMP\\n        # Build prefix-function on pattern t\\n        def kmp_prefix(p):\\n            m = len(p)\\n            pi = [0]*m\\n            j = 0\\n            for i in range(1, m):\\n                while j and p[i] != p[j]:\\n                    j = pi[j-1]\\n                if p[i] == p[j]:\\n                    j += 1\\n                pi[i] = j\\n            return pi\\n\\n        pi = kmp_prefix(t)\\n        D0 = 0\\n        Dnz = 0\\n        j = 0\\n        ss = s + s\\n        for i, ch in enumerate(ss):\\n            # only consider matches completing at i with start = i - (n-1) < n\\n            while j and ch != t[j]:\\n                j = pi[j-1]\\n            if ch == t[j]:\\n                j += 1\\n                if j == n:\\n                    start = i - (n - 1)\\n                    if start < n:\\n                        if start % n == 0:\\n                            D0 += 1\\n                        else:\\n                            Dnz += 1\\n                    j = pi[j-1]\\n\\n        if D0 + Dnz == 0:\\n            return 0\\n\\n        # 2) Compute F_k(0) and F_k(nonzero) in Z_n*\\n        M = n - 1\\n        Mk = pow(M, k, self.MOD)\\n        neg1k = 1 if (k & 1) == 0 else self.MOD - 1\\n        inv_n = pow(n, self.MOD - 2, self.MOD)\\n\\n        F0 = (Mk + (n - 1) * neg1k) % self.MOD * inv_n % self.MOD\\n        F1 = (Mk - neg1k) % self.MOD * inv_n % self.MOD\\n\\n        # Total ways = D0*F0 + Dnz*F1 mod\\n        return (D0 * F0 + Dnz * F1) % self.MOD\\n\"",
  "3548_14631217_python-updated-time": "1747570264231",
  "1505_14631217_python-updated-time": "1746346084563",
  "1046_14631217_python-updated-time": "1746041018667",
  "2764_14631217_python-updated-time": "1747136783534",
  "1676_14631217_python": "\"class Solution(object):\\n    def minDays(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        memo = {}\\n\\n        def dp(x):\\n            if x <= 1:\\n                return x\\n            if x in memo:\\n                return memo[x]\\n            result = min(\\n                x % 2 + 1 + dp(x // 2),  # eat x % 2 times + 1 (half) + recurse\\n                x % 3 + 1 + dp(x // 3)   # eat x % 3 times + 1 (2/3) + recurse\\n            )\\n            memo[x] = result\\n            return result\\n\\n        return dp(n)\\n\"",
  "2752_14631217_python": "\"class Solution(object):\\n    def sumOfMultiples(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Helper: sum of multiples of k up to n\\n        def sum_k(k):\\n            m = n // k\\n            return k * m * (m + 1) // 2\\n\\n        # Inclusion-Exclusion over 3,5,7\\n        sum3 = sum_k(3)\\n        sum5 = sum_k(5)\\n        sum7 = sum_k(7)\\n        sum15 = sum_k(15)\\n        sum21 = sum_k(21)\\n        sum35 = sum_k(35)\\n        sum105 = sum_k(105)\\n\\n        return (sum3 + sum5 + sum7\\n                - sum15 - sum21 - sum35\\n                + sum105)\\n\"",
  "674_14631217_python-updated-time": "1745783356031",
  "3833_14631217_python-updated-time": "1747817806451",
  "1489_14631217_python-updated-time": "1746346053167",
  "2499_14631217_python-updated-time": "1746966368826",
  "36_14631217_python-updated-time": "1744988627972",
  "3092_14631217_python": "\"class Solution(object):\\n    def minimumMoves(self, grid):\\n        # Flatten initial stones: list of (r,c), length 9\\n        stones = []\\n        for r in range(3):\\n            for c in range(3):\\n                for _ in range(grid[r][c]):\\n                    stones.append((r, c))\\n        # Must have exactly 9 stones\\n        # Targets: one per cell\\n        targets = [(r, c) for r in range(3) for c in range(3)]\\n        \\n        N = 9\\n        FULL = (1 << N) - 1\\n        # dp[mask] = minimal cost assigning first popcount(mask) stones to targets in mask\\n        dp = [float('inf')] * (1 << N)\\n        dp[0] = 0\\n        \\n        for mask in range(1 << N):\\n            k = bin(mask).count('1')  # number of stones already assigned\\n            if k >= N:\\n                continue\\n            sr, sc = stones[k]\\n            # try assign k-th stone to any free target j\\n            for j in range(N):\\n                if not (mask & (1 << j)):\\n                    tr, tc = targets[j]\\n                    cost = abs(sr - tr) + abs(sc - tc)\\n                    nxt = mask | (1 << j)\\n                    if dp[mask] + cost < dp[nxt]:\\n                        dp[nxt] = dp[mask] + cost\\n        \\n        return dp[FULL]\\n\"",
  "3702_14631217_python": "\"import math\\n\\nclass Solution(object):\\n    def maxLength(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # If you ever have at least two elements, there's always\\n        # a valid subarray of length 2 (since a*b = gcd(a,b)*lcm(a,b)).\\n        # So start with ans = 2.\\n        # (For completeness one could handle n<2, but constraints say n>=2.)\\n        ans = 2\\n\\n        last = {}    # last[p] = most recent index in window where prime p appeared\\n        l = 0        # left end of our sliding window\\n\\n        for r, val in enumerate(nums):\\n            # factor val into its distinct prime divisors\\n            x = val\\n            primes = []\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    primes.append(d)\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                primes.append(x)\\n\\n            # If any prime p reoccurs in our current window [l..r-1],\\n            # we must advance l past its last occurrence to keep\\n            # \\\"no prime divides more than one element\\\" for windows ≥3.\\n            for p in primes:\\n                if p in last and last[p] >= l:\\n                    l = last[p] + 1\\n                last[p] = r\\n\\n            # Now [l..r] has no repeated primes.\\n            # If its length is ≥3, it's a valid “product-equivalent” subarray.\\n            length = r - l + 1\\n            if length >= 3:\\n                ans = max(ans, length)\\n\\n        return ans\\n\"",
  "692_14631217_python-updated-time": "1745785624919",
  "3681_14631217_python-updated-time": "1747596378830",
  "30_14631217_python-updated-time": "1744988019362",
  "3656_14631217_python-updated-time": "1747651410450",
  "1030_14631217_python": "\"class Solution:\\n    def smallestFromLeaf(self, root):\\n        self.smallest = \\\"~\\\"  # '~' is lex greater than any lowercase string\\n\\n        def dfs(node, path):\\n            if not node:\\n                return\\n            # Prepend current character to path\\n            path = chr(ord('a') + node.val) + path\\n            if not node.left and not node.right:\\n                self.smallest = min(self.smallest, path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n\\n        dfs(root, \\\"\\\")\\n        return self.smallest\\n\"",
  "3523_14631217_python": "\"class Solution(object):\\n    def resultsArray(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # Build diff array: diff[i]=1 iff nums[i]-nums[i-1]==1\\n        diff = [0]*n\\n        for i in range(1, n):\\n            diff[i] = 1 if nums[i] - nums[i-1] == 1 else 0\\n        \\n        # Prefix sums of diff\\n        # ps[i] = sum of diff[0..i-1], so sum over diff[l..r] is ps[r+1] - ps[l]\\n        ps = [0]*(n+1)\\n        for i in range(n):\\n            ps[i+1] = ps[i] + diff[i]\\n        \\n        res = []\\n        for s in range(n - k + 1):\\n            e = s + k - 1\\n            # sum of diff[s+1..e] = ps[e+1] - ps[s+1]\\n            if ps[e+1] - ps[s+1] == k - 1:\\n                res.append(nums[e])\\n            else:\\n                res.append(-1)\\n        \\n        return res\\n\"",
  "3765_14631217_python": "\"class Solution(object):\\n    def minimumCost(self, nums, cost, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type cost: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        from collections import deque\\n\\n        n = len(nums)\\n        # prefix sums\\n        Pnum = [0]*n\\n        Pcost = [0]*n\\n        s1 = s2 = 0\\n        for i in range(n):\\n            s1 += nums[i]\\n            s2 += cost[i]\\n            Pnum[i] = s1\\n            Pcost[i] = s2\\n\\n        INF = float('inf')\\n        # dpPrev[r] = best cost partitioning [0..r] into t-1 subarrays\\n        dpPrev = [INF]*n\\n        for r in range(n):\\n            dpPrev[r] = (Pnum[r] + k) * Pcost[r]\\n        ans = dpPrev[-1]\\n\\n        def add_line(hull, m, b):\\n            # remove last while new line (m,b) makes it obsolete\\n            # lines in hull: ... (m1,b1), (m2,b2)\\n            # new is (m3,b3) = (m,b)\\n            # if (b2-b1)/(m1-m2) >= (b3-b2)/(m2-m3) then pop (m2,b2)\\n            while len(hull) >= 2:\\n                m1, b1 = hull[-2]\\n                m2, b2 = hull[-1]\\n                # correct check:\\n                if (b2 - b1) * (m2 - m) >= (b - b2) * (m1 - m2):\\n                    hull.pop()\\n                else:\\n                    break\\n            hull.append((m, b))\\n\\n        def query(hull, x):\\n            # lines sorted by decreasing slope, x queries increasing\\n            while len(hull) >= 2 and hull[0][0]*x + hull[0][1] >= hull[1][0]*x + hull[1][1]:\\n                hull.popleft()\\n            m, b = hull[0]\\n            return m*x + b\\n\\n        # build up number of subarrays t = 2..n\\n        for t in range(2, n+1):\\n            hull = deque()\\n            dpCurr = [INF]*n\\n            for r in range(t-1, n):\\n                # candidate from splitting before r:\\n                l = r-1\\n                add_line(hull, -Pcost[l], dpPrev[l])\\n\\n                x = Pnum[r] + k*t\\n                best = query(hull, x)\\n                dpCurr[r] = x * Pcost[r] + best\\n\\n            dpPrev = dpCurr\\n            ans = min(ans, dpPrev[-1])\\n\\n        return ans\\n\"",
  "1333_14631217_python": "\"class Solution(object):\\n    def sortJumbled(self, mapping, nums):\\n        \\\"\\\"\\\"\\n        :type mapping: List[int]\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        # Helper function to map a number using the provided mapping\\n        def mapped_value(num):\\n            # Convert the number to a string and map each digit using the mapping array\\n            mapped_num = ''.join(str(mapping[int(digit)]) for digit in str(num))\\n            # Remove leading zeros by converting to integer and back to string\\n            return int(mapped_num)\\n        \\n        # Sort the nums array using a key based on the mapped value of each number\\n        return sorted(nums, key=lambda num: mapped_value(num))\\n\"",
  "2401_14631217_python-updated-time": "1746882889437",
  "83_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \\\"\\\"\\\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \\\"\\\"\\\"\\n        current = head\\n\\n        while current and current.next:\\n            if current.val == current.next.val:\\n                current.next = current.next.next\\n            else:\\n                current = current.next\\n\\n        return head\\n\"",
  "2871_14631217_python-updated-time": "1747225346898",
  "980_14631217_python": "\"class Solution:\\n    def shortestSuperstring(self, words):\\n        n = len(words)\\n        # Precompute overlap lengths: overlap[i][j] = max k where\\n        # suffix of words[i] of length k == prefix of words[j] of length k\\n        overlap = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                # find max overlap\\n                w1, w2 = words[i], words[j]\\n                max_ol = min(len(w1), len(w2))\\n                # check k from max down to 1\\n                for k in range(max_ol, 0, -1):\\n                    if w1.endswith(w2[:k]):\\n                        overlap[i][j] = k\\n                        break\\n\\n        # DP[mask][i]: length of shortest superstring for set mask ending with word i\\n        N = 1 << n\\n        dp = [[float('inf')]*n for _ in range(N)]\\n        parent = [[-1]*n for _ in range(N)]\\n        # Initialize with single words\\n        for i in range(n):\\n            dp[1<<i][i] = len(words[i])\\n\\n        # Fill DP\\n        for mask in range(N):\\n            for last in range(n):\\n                if not (mask & (1<<last)):\\n                    continue\\n                prev_mask = mask ^ (1<<last)\\n                if prev_mask == 0:\\n                    continue\\n                # Try all possible previous words\\n                for prev in range(n):\\n                    if not (prev_mask & (1<<prev)):\\n                        continue\\n                    val = dp[prev_mask][prev] + len(words[last]) - overlap[prev][last]\\n                    if val < dp[mask][last]:\\n                        dp[mask][last] = val\\n                        parent[mask][last] = prev\\n\\n        # Find best end word\\n        full_mask = N - 1\\n        min_len = float('inf')\\n        end = 0\\n        for i in range(n):\\n            if dp[full_mask][i] < min_len:\\n                min_len = dp[full_mask][i]\\n                end = i\\n\\n        # Reconstruct path\\n        path = []\\n        mask = full_mask\\n        while end != -1:\\n            path.append(end)\\n            prev = parent[mask][end]\\n            mask ^= (1 << end)\\n            end = prev\\n        path.reverse()\\n\\n        # Build answer string\\n        ans = words[path[0]]\\n        for i in range(1, len(path)):\\n            i_prev, i_cur = path[i-1], path[i]\\n            ol = overlap[i_prev][i_cur]\\n            ans += words[i_cur][ol:]\\n\\n        return ans\\n\"",
  "234_14631217_python": "\"# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def isPalindrome(self, head):\\n        \\\"\\\"\\\"\\n        :type head: ListNode\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # Find the middle of the list\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        # Reverse second half\\n        prev = None\\n        while slow:\\n            next_temp = slow.next\\n            slow.next = prev\\n            prev = slow\\n            slow = next_temp\\n\\n        # Compare first and second half\\n        left, right = head, prev\\n        while right:\\n            if left.val != right.val:\\n                return False\\n            left = left.next\\n            right = right.next\\n\\n        return True\\n\"",
  "173_14631217_python-updated-time": "1745092107127",
  "150_14631217_python-updated-time": "1745090774191",
  "1905_14631217_python-updated-time": "1746542842288",
  "1888_14631217_python": "\"class Solution:\\n    def nearestValidPoint(self, x, y, points):\\n        min_dist = float('inf')\\n        index = -1\\n\\n        for i, (a, b) in enumerate(points):\\n            if a == x or b == y:\\n                dist = abs(x - a) + abs(y - b)\\n                if dist < min_dist:\\n                    min_dist = dist\\n                    index = i\\n\\n        return index\\n\"",
  "676_14631217_python-updated-time": "1745783430451",
  "110_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        def check(node):\\n            if not node:\\n                return 0, True\\n            left_height, left_balanced = check(node.left)\\n            right_height, right_balanced = check(node.right)\\n            balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\\n            return 1 + max(left_height, right_height), balanced\\n        \\n        return check(root)[1]\\n\"",
  "1482_14631217_python": "\"class Solution(object):\\n    def smallerNumbersThanCurrent(self, nums):\\n        count = [0] * 101  # frequency of each number from 0 to 100\\n\\n        for num in nums:\\n            count[num] += 1\\n\\n        # prefix sum to know how many numbers are smaller than current\\n        for i in range(1, 101):\\n            count[i] += count[i - 1]\\n\\n        result = []\\n        for num in nums:\\n            result.append(count[num - 1] if num > 0 else 0)\\n\\n        return result\\n\"",
  "1954_14631217_python-updated-time": "1746544514187",
  "1995_14631217_python-updated-time": "1746625341903",
  "1866_14631217_python-updated-time": "1746531273421",
  "321_14631217_python-updated-time": "1745256205355",
  "2272_14631217_python-updated-time": "1746802710466",
  "2952_14631217_python": "\"class Solution(object):\\n    def minimumTime(self, nums1, nums2, x):\\n        n = len(nums1)\\n        total1 = sum(nums1)\\n        total2 = sum(nums2)\\n        if total1 <= x:\\n            return 0\\n\\n        pairs = sorted(zip(nums2, nums1))          # sort by nums2 ascending\\n        neg_inf = -10**18\\n        dp = [neg_inf] * (n + 1)\\n        dp[0] = 0\\n\\n        for b, a in pairs:                         # b = nums2, a = nums1\\n            for j in range(n - 1, -1, -1):\\n                if dp[j] == neg_inf:\\n                    continue\\n                val = dp[j] + a + (j + 1) * b\\n                if val > dp[j + 1]:\\n                    dp[j + 1] = val\\n\\n        for t in range(1, n + 1):\\n            if total1 + t * total2 - dp[t] <= x:\\n                return t\\n        return -1\\n\"",
  "3263_14631217_python-updated-time": "1747399368215",
  "3171_14631217_python-updated-time": "1747309454035",
  "962_14631217_python-updated-time": "1746003803372",
  "1263_14631217_python-updated-time": "1746125989403",
  "202_14631217_python-updated-time": "1745093285011",
  "458_14631217_python": "\"import math\\n\\nclass Solution:\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        tests = minutesToTest // minutesToDie\\n        pigs = 0\\n        while (tests + 1) ** pigs < buckets:\\n            pigs += 1\\n        return pigs\\n\"",
  "3633_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxTargetNodes(self, edges1, edges2, k):\\n        \\\"\\\"\\\"\\n        :type edges1: List[List[int]]\\n        :type edges2: List[List[int]]\\n        :type k: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        def build_adj(n, edges):\\n            adj = [[] for _ in range(n)]\\n            for u, v in edges:\\n                adj[u].append(v)\\n                adj[v].append(u)\\n            return adj\\n\\n        def all_reaches(adj, threshold):\\n            \\\"\\\"\\\"\\n            For each node i, return the count of nodes within distance <= threshold.\\n            \\\"threshold\\\" may be negative, in which case everyone is 0.\\n            \\\"\\\"\\\"\\n            n = len(adj)\\n            reaches = [0]*n\\n            if threshold < 0:\\n                # no node except itself would ever count, but\\n                # 1 + dist > k always, so we set 0\\n                return reaches\\n\\n            for i in range(n):\\n                dist = [-1]*n\\n                dist[i] = 0\\n                q = deque([i])\\n                cnt = 0\\n                while q:\\n                    u = q.popleft()\\n                    if dist[u] > threshold:\\n                        continue\\n                    cnt += 1\\n                    for w in adj[u]:\\n                        if dist[w] == -1:\\n                            dist[w] = dist[u] + 1\\n                            q.append(w)\\n                reaches[i] = cnt\\n            return reaches\\n\\n        # Build adjacency lists\\n        n = len(edges1) + 1\\n        m = len(edges2) + 1\\n        adj1 = build_adj(n, edges1)\\n        adj2 = build_adj(m, edges2)\\n\\n        # reach1[i] = # nodes in tree1 within dist<=k from i\\n        reach1 = all_reaches(adj1, k)\\n        # reach2[j] = # nodes in tree2 within dist<=k-1 from j\\n        reach2 = all_reaches(adj2, k-1)\\n\\n        best2 = max(reach2) if reach2 else 0\\n        # For each i, answer = reach1[i] + best2\\n        return [r1 + best2 for r1 in reach1]\\n\"",
  "1299_14631217_python-updated-time": "1746126802699",
  "387_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def firstUniqChar(self, s):\\n        count = Counter(s)\\n        for idx, char in enumerate(s):\\n            if count[char] == 1:\\n                return idx\\n        return -1\\n\"",
  "3491_14631217_python-updated-time": "1747486643306",
  "932_14631217_python-updated-time": "1746002210071",
  "1080_14631217_python-updated-time": "1746041838721",
  "167_14631217_python": "\"class Solution(object):\\n    def twoSum(self, numbers, target):\\n        left, right = 0, len(numbers) - 1\\n        while left < right:\\n            s = numbers[left] + numbers[right]\\n            if s == target:\\n                return [left + 1, right + 1]\\n            elif s < target:\\n                left += 1\\n            else:\\n                right -= 1\\n\"",
  "2783_14631217_javascript": "\"function* inorderTraversal(arr) {\\n  for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      // Recurse into sub-array\\n      yield* inorderTraversal(item);\\n    } else {\\n      // Yield integer\\n      yield item;\\n    }\\n  }\\n}\"",
  "1762_14631217_python-updated-time": "1746445090781",
  "3639_14631217_python": "\"class Solution(object):\\n    def isZeroArray(self, nums, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type queries: List[List[int]]\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        cover = [0] * (n + 1)\\n        \\n        # Build coverage counts via difference array\\n        for l, r in queries:\\n            cover[l]   += 1\\n            cover[r+1] -= 1\\n        \\n        # Prefix sum to get how many queries cover each index\\n        for i in range(1, n):\\n            cover[i] += cover[i-1]\\n        \\n        # Check feasibility: each nums[i] needs that many decrements,\\n        # but can only decrement at most cover[i] times.\\n        for i in range(n):\\n            if cover[i] < nums[i]:\\n                return False\\n        \\n        return True\\n\"",
  "1757_14631217_python-updated-time": "1746445357239",
  "1976_14631217_python-updated-time": "1746624774632",
  "745_14631217_python": "\"class Solution(object):\\n    def nextGreatestLetter(self, letters, target):\\n        left, right = 0, len(letters)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if letters[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return letters[left % len(letters)]\\n\"",
  "2887_14631217_python-updated-time": "1747222511576",
  "3267_14631217_python": "\"class Solution(object):\\n    def maximumLength(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        best = 0\\n        \\n        # for each character c, find runs of c in s\\n        for c in set(s):\\n            # collect lengths of consecutive runs of c\\n            runs = []\\n            length = 0\\n            for ch in s:\\n                if ch == c:\\n                    length += 1\\n                else:\\n                    if length > 0:\\n                        runs.append(length)\\n                        length = 0\\n            if length > 0:\\n                runs.append(length)\\n            \\n            if sum(runs) < 3:\\n                # fewer than 3 occurrences total → cannot get 3 substrings of c^1\\n                continue\\n            \\n            max_run = max(runs)\\n            # try k from max_run down to 1\\n            for k in range(max_run, 0, -1):\\n                # total occurrences of substring c^k is sum over runs of max(L - k + 1, 0)\\n                occ = 0\\n                for L in runs:\\n                    if L >= k:\\n                        occ += (L - k + 1)\\n                        if occ >= 3:\\n                            break\\n                if occ >= 3:\\n                    best = max(best, k)\\n                    break  # no need to try smaller k for this character\\n        \\n        return best if best > 0 else -1\\n\"",
  "2791_14631217_python": "\"class Solution:\\n    def circularGameLosers(self, n, k):\\n        seen = set()\\n        current = 0  # 0-based index for friend 1\\n        i = 1  # round count multiplier\\n        while current not in seen:\\n            seen.add(current)\\n            current = (current + i * k) % n\\n            i += 1\\n        return sorted([j + 1 for j in range(n) if j not in seen])\\n\"",
  "546_14631217_python-updated-time": "1745447067998",
  "2229_14631217_python-updated-time": "1746799994641",
  "1062_14631217_python-updated-time": "1746041455468",
  "3784_14631217_python": "\"import collections\\n\\nclass Solution(object):\\n    def longestCommonPrefix(self, words, k):\\n        n = len(words)\\n        ans = [0] * n\\n\\n        if n < k: # Not even enough words initially\\n            return [0] * n\\n        \\n        # Handle the edge case where after removing a word, there are not enough strings\\n        if n - 1 < k:\\n            # This means k = n. We need all n-1 strings.\\n            # If k=n=1, then n-1=0 < k=1. answer[0]=0.\\n            # If n=0, no, n>=1. words.length >= k, so n >= k.\\n            # This case occurs if k = n.\\n            # Then after removing 1 word, we have n-1 words. We need LCP of k=n words. Impossible.\\n             for i in xrange(n):\\n                 ans[i] = 0 # Not enough words left.\\n             if k==0: # LCP of 0 strings is undefined or infinite. If k>=1, this is fine.\\n                 # Constraints say 1 <= k.\\n                 pass # ans is already [0]*n\\n             return ans\\n\\n\\n        # Trie Node structure (using dictionary for children)\\n        # {'#count': 0, '#depth': d, '#paths': set(), 'c': child_node, ...}\\n        # '#count' = number of original words passing through this node\\n        # '#depth' = depth of node (length of prefix)\\n        # '#paths' = set of indices of original words passing through this node\\n        \\n        trie = {'#count': 0, '#depth': 0, '#paths': set()}\\n\\n        for i, word in enumerate(words):\\n            node = trie\\n            node['#count'] += 1\\n            node['#paths'].add(i)\\n            for char_idx, char in enumerate(word):\\n                if char not in node:\\n                    node[char] = {'#count': 0, '#depth': char_idx + 1, '#paths': set()}\\n                node = node[char]\\n                node['#count'] += 1\\n                node['#paths'].add(i)\\n        \\n        # Calculate L0: max depth of a node u where count[u] >= k+1\\n        L0 = 0\\n        \\n        # Collect nodes for V_k: (depth, PathStrings_set) for nodes u where count[u] = k\\n        # M_D = list of (depth, frozenset_of_PathStrings)\\n        M_D = [] \\n\\n        queue = collections.deque([trie])\\n        visited_nodes_for_MD = [] # Store actual node dicts to avoid reparsing\\n\\n        while queue:\\n            node = queue.popleft()\\n            \\n            count_u = node['#count']\\n            depth_u = node['#depth']\\n\\n            if count_u >= k + 1:\\n                L0 = max(L0, depth_u)\\n            \\n            if count_u == k:\\n                # Store depth and the set of paths (indices of words)\\n                # PathStrings set must be frozenset to be hashable if used as dict key later\\n                M_D.append((depth_u, frozenset(node['#paths'])))\\n\\n            for char_code in \\\"abcdefghijklmnopqrstuvwxyz\\\":\\n                if char_code in node:\\n                    queue.append(node[char_code])\\n        \\n        for i in xrange(n):\\n            ans[i] = L0\\n\\n        # Sort M_D by depth descending. If depths equal, doesn't strictly matter for this logic.\\n        M_D.sort(key=lambda p: p[0], reverse=True)\\n        \\n        # Optimized L1 calculation:\\n        # For each distinct depth d (descending):\\n        #   intersect_S_d = intersection of all PathStrings sets for this depth d\\n        #   For unresolved i: if i is NOT in intersect_S_d, then L1[i] = d.\\n        \\n        L1_values = [0] * n # Stores L1(i)\\n        \\n        # Group M_D by depth\\n        depth_to_path_sets = collections.defaultdict(list)\\n        for depth_val, path_set_val in M_D:\\n            depth_to_path_sets[depth_val].append(path_set_val)\\n\\n        sorted_unique_depths = sorted(depth_to_path_sets.keys(), reverse=True)\\n\\n        unresolved_indices = list(range(n)) # Indices for which L1_values[idx] is not set\\n\\n        for d_val in sorted_unique_depths:\\n            if not unresolved_indices:\\n                break\\n            \\n            path_sets_for_d = depth_to_path_sets[d_val]\\n            \\n            # Calculate intersection_of_all_S_for_this_d\\n            # If no sets for this depth (should not happen due to defaultdict construction),\\n            # treat intersection as empty (so all unresolved_indices get this d_val).\\n            # This means if path_sets_for_d is empty, any index i is not in intersection.\\n            \\n            # Initial intersection: if no sets, all indices qualify (i.e., not in empty intersection).\\n            # If sets exist, start with the first set.\\n            # All indices in `range(n)` are candidates if this list is empty.\\n            # Effectively, if path_sets_for_d is empty, intersection should be an empty set,\\n            # meaning for any i, i is NOT in the intersection.\\n            \\n            current_intersection = set() \\n            if path_sets_for_d: # only if list is not empty\\n                # Initialize with a copy of the first set\\n                current_intersection = set(path_sets_for_d[0]) \\n                for s_idx in xrange(1, len(path_sets_for_d)):\\n                    current_intersection.intersection_update(path_sets_for_d[s_idx])\\n            \\n            next_unresolved_indices = []\\n            for idx in unresolved_indices:\\n                # An index `idx` gets this depth `d_val` if there is AT LEAST ONE path_set for `d_val`\\n                # that does NOT contain `idx`.\\n                # This is equivalent to: `idx` is NOT IN (intersection of all path_sets for `d_val`).\\n                if not path_sets_for_d: # No sets of count k at this depth\\n                    # This case should not occur given how sorted_unique_depths is made\\n                    next_unresolved_indices.append(idx) # Still unresolved by this (empty) depth\\n                    continue\\n\\n                if idx not in current_intersection:\\n                    L1_values[idx] = d_val\\n                    # This idx is now resolved for L1\\n                else:\\n                    # idx is in ALL path_sets for this depth d_val.\\n                    # So, d_val is not a candidate for L1_values[idx].\\n                    # It remains unresolved for a potentially smaller depth.\\n                    next_unresolved_indices.append(idx)\\n            \\n            unresolved_indices = next_unresolved_indices\\n\\n        for i in xrange(n):\\n            ans[i] = max(ans[i], L1_values[i])\\n            \\n        return ans\"",
  "3847_14631217_python-updated-time": "1747684192258",
  "2569_14631217_python-updated-time": "1746969832734",
  "491_14631217_python": "\"class Solution:\\n    def findSubsequences(self, nums):\\n        ans = []\\n\\n        def dfs(idx, path):\\n            if len(path) >= 2:          # record any subsequence of length ≥ 2\\n                ans.append(path[:])     # append a copy\\n            if idx == len(nums):\\n                return\\n\\n            used = set()                # values tried at *this* depth\\n            for i in range(idx, len(nums)):\\n                if nums[i] in used:     # skip duplicates on this level\\n                    continue\\n                if not path or nums[i] >= path[-1]:   # keep non-decreasing\\n                    used.add(nums[i])\\n                    path.append(nums[i])\\n                    dfs(i + 1, path)    # explore further\\n                    path.pop()          # back-track\\n\\n        dfs(0, [])\\n        return ans\\n\"",
  "717_14631217_python": "\"class Solution(object):\\n    def isOneBitCharacter(self, bits):\\n        i, n = 0, len(bits)\\n        # Parse until the last bit\\n        while i < n - 1:\\n            if bits[i] == 1:\\n                i += 2\\n            else:\\n                i += 1\\n        # If we land on the last index, it's a one-bit character\\n        return i == n - 1\\n\"",
  "583_14631217_python": "\"class Solution(object):\\n    def minDistance(self, word1, word2):\\n        m, n = len(word1), len(word2)\\n        # dp[i][j]: LCS length of word1[:i] and word2[:j]\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n        lcs = dp[m][n]\\n        # deletions = (m - lcs) + (n - lcs)\\n        return m + n - 2 * lcs\\n\"",
  "2826_14631217_python-updated-time": "1747220936772",
  "3841_14631217_python": "\"class Solution(object):\\n    def concatenatedDivisibility(self, nums, k):\\n        n = len(nums)\\n        fullMask = (1 << n) - 1\\n\\n        # 1) Precompute lengths, mods, total digits, and powers of ten mod k\\n        lens = [len(str(x)) for x in nums]\\n        modv = [x % k for x in nums]\\n        total_digits = sum(lens)\\n\\n        p10 = [1] * (total_digits + 1)\\n        for i in range(1, total_digits + 1):\\n            p10[i] = (p10[i-1] * 10) % k\\n\\n        # 2) Build dp[mask][r]: can unused=mask be arranged to remainder=r?\\n        dp = [[False] * k for _ in range(1 << n)]\\n        dp[0][0] = True\\n\\n        masks_by_pc = [[] for _ in range(n+1)]\\n        for mask in range(1 << n):\\n            masks_by_pc[bin(mask).count('1')].append(mask)\\n\\n        for pc in range(1, n+1):\\n            for mask in masks_by_pc[pc]:\\n                arr_dp = dp[mask]\\n                m = mask\\n                while m:\\n                    low = m & -m\\n                    i = low.bit_length() - 1\\n                    m ^= low\\n                    prevMask = mask ^ (1 << i)\\n                    L = lens[i]\\n                    mul = p10[L]\\n                    mv = modv[i]\\n                    for prev in range(k):\\n                        if dp[prevMask][prev]:\\n                            arr_dp[(prev * mul + mv) % k] = True\\n                    if all(arr_dp):\\n                        break\\n\\n        if not dp[fullMask][0]:\\n            return []\\n\\n        # 3) Forward reconstruct the lexicographically smallest valid perm\\n        res = []\\n        mask = fullMask\\n        rem_pref = 0\\n        used_digits = 0\\n\\n        for _ in range(n):\\n            found = False\\n            for i in sorted(range(n), key=lambda i: nums[i]):\\n                if not (mask & (1 << i)):\\n                    continue\\n                # simulate picking nums[i] next\\n                # 3a) update prefix remainder and digits\\n                L = lens[i]\\n                P_new = (rem_pref * p10[L] + modv[i]) % k\\n                d_new = used_digits + L\\n                # 3b) compute what remainder the suffix must have\\n                suffix_len = total_digits - d_new\\n                target = (-P_new * p10[suffix_len]) % k\\n\\n                rem_mask = mask ^ (1 << i)\\n                if dp[rem_mask][target]:\\n                    # pick i\\n                    res.append(nums[i])\\n                    rem_pref = P_new\\n                    used_digits = d_new\\n                    mask = rem_mask\\n                    found = True\\n                    break\\n            if not found:\\n                return []   # should not happen if dp[fullMask][0]\\n\\n        return res\\n\"",
  "report_random_id": "v#bOaQt+7X99f5HKHd)7OE7uNwsm^LNuRq+La@JssBlJJWndpb2H3&QeHR9Z",
  "2581_14631217_python-updated-time": "1747057635984",
  "1351_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def balancedString(self, s):\\n        n = len(s)\\n        count = Counter(s)\\n        target = n // 4\\n        if all(count[c] == target for c in \\\"QWER\\\"):\\n            return 0\\n\\n        left = 0\\n        res = n\\n        for right in range(n):\\n            count[s[right]] -= 1\\n            while left < n and all(count[c] <= target for c in \\\"QWER\\\"):\\n                res = min(res, right - left + 1)\\n                count[s[left]] += 1\\n                left += 1\\n        return res\\n\"",
  "3516_14631217_python": "\"class NeighborSum(object):\\n\\n    def __init__(self, grid):\\n        \\\"\\\"\\\"\\n        :type grid: List[List[int]]\\n        \\\"\\\"\\\"\\n        self.grid = grid\\n        self.n = len(grid)\\n        # Build a map from value → (row, col)\\n        self.pos = {}\\n        for i in range(self.n):\\n            for j in range(self.n):\\n                self.pos[grid[i][j]] = (i, j)\\n\\n    def adjacentSum(self, value):\\n        \\\"\\\"\\\"\\n        :type value: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        i, j = self.pos[value]\\n        total = 0\\n        # up, down, left, right\\n        for di, dj in ((-1,0),(1,0),(0,-1),(0,1)):\\n            ni, nj = i + di, j + dj\\n            if 0 <= ni < self.n and 0 <= nj < self.n:\\n                total += self.grid[ni][nj]\\n        return total\\n\\n    def diagonalSum(self, value):\\n        \\\"\\\"\\\"\\n        :type value: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        i, j = self.pos[value]\\n        total = 0\\n        # top-left, top-right, bottom-left, bottom-right\\n        for di, dj in ((-1,-1),(-1,1),(1,-1),(1,1)):\\n            ni, nj = i + di, j + dj\\n            if 0 <= ni < self.n and 0 <= nj < self.n:\\n                total += self.grid[ni][nj]\\n        return total\\n\"",
  "504_14631217_python": "\"class Solution:\\n    def convertToBase7(self, num):\\n        if num == 0:\\n            return \\\"0\\\"\\n        negative = num < 0\\n        num = abs(num)\\n        res = []\\n        while num:\\n            res.append(str(num % 7))\\n            num //= 7\\n        if negative:\\n            res.append('-')\\n        return ''.join(res[::-1])\\n\"",
  "1819_14631217_python": "\"class Solution(object):\\n    def constructDistancedSequence(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        L = 2*n - 1\\n        res = [0]*L\\n        # used[i] = True means we still need to place the number i\\n        used = [False, True] + [True]*(n-1)  # indices 0..n, but we only use 1..n\\n        \\n        def dfs(pos):\\n            # If we've filled every position, we're done\\n            if pos == L:\\n                return True\\n            # Skip already filled slots\\n            if res[pos] != 0:\\n                return dfs(pos+1)\\n            # Try to place the largest possible number at pos\\n            # First try i=n..2 (needs a pair), then i=1 (single)\\n            for i in range(n, 1, -1):\\n                j = pos + i\\n                if used[i] and j < L and res[j] == 0:\\n                    # place both occurrences of i\\n                    used[i] = False\\n                    res[pos] = res[j] = i\\n                    if dfs(pos+1):\\n                        return True\\n                    # backtrack\\n                    used[i] = True\\n                    res[pos] = res[j] = 0\\n            # Finally, try placing the single 1 if still unused\\n            if used[1]:\\n                used[1] = False\\n                res[pos] = 1\\n                if dfs(pos+1):\\n                    return True\\n                used[1] = True\\n                res[pos] = 0\\n            # No valid placement leads to a solution\\n            return False\\n        \\n        dfs(0)\\n        return res\\n\"",
  "2043_14631217_python": "\"class Solution:\\n    def rotateGrid(self, grid, k):\\n        m, n = len(grid), len(grid[0])\\n        layers = min(m, n) // 2\\n\\n        for layer in range(layers):\\n            elems = []\\n\\n            # Top row (left to right)\\n            for j in range(layer, n - layer):\\n                elems.append(grid[layer][j])\\n            # Right column (top to bottom)\\n            for i in range(layer + 1, m - layer - 1):\\n                elems.append(grid[i][n - layer - 1])\\n            # Bottom row (right to left)\\n            for j in range(n - layer - 1, layer - 1, -1):\\n                elems.append(grid[m - layer - 1][j])\\n            # Left column (bottom to top)\\n            for i in range(m - layer - 2, layer, -1):\\n                elems.append(grid[i][layer])\\n\\n            # Rotate the elements\\n            k_mod = k % len(elems)\\n            rotated = elems[k_mod:] + elems[:k_mod]\\n\\n            # Put rotated elements back\\n            idx = 0\\n            for j in range(layer, n - layer):\\n                grid[layer][j] = rotated[idx]\\n                idx += 1\\n            for i in range(layer + 1, m - layer - 1):\\n                grid[i][n - layer - 1] = rotated[idx]\\n                idx += 1\\n            for j in range(n - layer - 1, layer - 1, -1):\\n                grid[m - layer - 1][j] = rotated[idx]\\n                idx += 1\\n            for i in range(m - layer - 2, layer, -1):\\n                grid[i][layer] = rotated[idx]\\n                idx += 1\\n\\n        return grid\\n\"",
  "781_14631217_python": "\"class Solution(object):\\n    def basicCalculatorIV(self, expression, evalvars, evalints):\\n        # Build evaluation map\\n        evalmap = dict(zip(evalvars, evalints))\\n\\n        # Tokenize the expression\\n        tokens = []\\n        i, n = 0, len(expression)\\n        while i < n:\\n            c = expression[i]\\n            if c == ' ':\\n                i += 1\\n            elif c in '+-*()':\\n                tokens.append(c)\\n                i += 1\\n            else:\\n                j = i\\n                while j < n and expression[j].isalnum():\\n                    j += 1\\n                tokens.append(expression[i:j])\\n                i = j\\n\\n        # Polynomial arithmetic on dicts mapping var‐tuples → coefficient\\n        def add_poly(A, B):\\n            C = A.copy()\\n            for k, v in B.items():\\n                C[k] = C.get(k, 0) + v\\n                if C[k] == 0:\\n                    del C[k]\\n            return C\\n\\n        def sub_poly(A, B):\\n            C = A.copy()\\n            for k, v in B.items():\\n                C[k] = C.get(k, 0) - v\\n                if C[k] == 0:\\n                    del C[k]\\n            return C\\n\\n        def mul_poly(A, B):\\n            C = {}\\n            for ka, va in A.items():\\n                for kb, vb in B.items():\\n                    key = tuple(sorted(ka + kb))\\n                    C[key] = C.get(key, 0) + va * vb\\n                    if C[key] == 0:\\n                        del C[key]\\n            return C\\n\\n        # Recursive‐descent parser\\n        def parse_expr(idx):\\n            # expr := term { (+ | -) term }\\n            res, idx = parse_term(idx)\\n            while idx < len(tokens) and tokens[idx] in ('+', '-'):\\n                op = tokens[idx]\\n                rhs, idx = parse_term(idx + 1)\\n                if op == '+':\\n                    res = add_poly(res, rhs)\\n                else:\\n                    res = sub_poly(res, rhs)\\n            return res, idx\\n\\n        def parse_term(idx):\\n            # term := factor { * factor }\\n            res, idx = parse_factor(idx)\\n            while idx < len(tokens) and tokens[idx] == '*':\\n                rhs, idx = parse_factor(idx + 1)\\n                res = mul_poly(res, rhs)\\n            return res, idx\\n\\n        def parse_factor(idx):\\n            tok = tokens[idx]\\n            if tok == '(':\\n                # parenthesized sub‐expression\\n                sub, idx2 = parse_expr(idx + 1)\\n                return sub, idx2 + 1  # skip ')'\\n            else:\\n                # number or variable\\n                if tok.isdigit():\\n                    poly = {(): int(tok)}\\n                elif tok in evalmap:\\n                    poly = {(): evalmap[tok]}\\n                else:\\n                    poly = {(tok,): 1}\\n                return poly, idx + 1\\n\\n        # Parse and evaluate\\n        poly, _ = parse_expr(0)\\n\\n        # Format output: sort by degree desc, then lex order\\n        items = sorted(poly.items(),\\n                       key=lambda kv: (-len(kv[0]), kv[0]))\\n        result = []\\n        for vars_tuple, coeff in items:\\n            if coeff == 0:\\n                continue\\n            s = str(coeff)\\n            if vars_tuple:\\n                s += '*' + '*'.join(vars_tuple)\\n            result.append(s)\\n        return result\\n\"",
  "914_14631217_python-updated-time": "1745446018960",
  "2342_14631217_python": "\"class Solution:\\n    def minimumAverageDifference(self, nums):\\n        n = len(nums)\\n        total = sum(nums)\\n        prefix = 0\\n        best_diff = float('inf')\\n        best_i = 0\\n        \\n        for i, x in enumerate(nums):\\n            prefix += x\\n            left_avg = prefix // (i + 1)\\n            if i < n - 1:\\n                right_avg = (total - prefix) // (n - i - 1)\\n            else:\\n                right_avg = 0\\n            \\n            diff = abs(left_avg - right_avg)\\n            if diff < best_diff:\\n                best_diff = diff\\n                best_i = i\\n        \\n        return best_i\\n\"",
  "966_14631217_python-updated-time": "1746003952790",
  "1649_14631217_python-updated-time": "1746434394464",
  "1955_14631217_python": "\"import heapq\\n\\nclass SeatManager(object):\\n    def __init__(self, n):\\n        self.heap = list(range(1, n+1))\\n        heapq.heapify(self.heap)\\n\\n    def reserve(self):\\n        return heapq.heappop(self.heap)\\n\\n    def unreserve(self, seatNumber):\\n        heapq.heappush(self.heap, seatNumber)\\n\"",
  "1570_14631217_python": "\"class Solution(object):\\n    def finalPrices(self, prices):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        n = len(prices)\\n        result = prices[:]\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if prices[j] <= prices[i]:\\n                    result[i] -= prices[j]\\n                    break\\n\\n        return result\\n\"",
  "2377_14631217_python-updated-time": "1746881564430",
  "1604_14631217_python-updated-time": "1746432662044",
  "2801_14631217_python-updated-time": "1747140150823",
  "135_14631217_python": "\"class Solution(object):\\n    def candy(self, ratings):\\n        \\\"\\\"\\\"\\n        :type ratings: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(ratings)\\n        candies = [1] * n  # Step 1: Give each child 1 candy\\n        \\n        # Step 2: Left to Right\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i - 1]:\\n                candies[i] = candies[i - 1] + 1\\n        \\n        # Step 3: Right to Left\\n        for i in range(n - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                candies[i] = max(candies[i], candies[i + 1] + 1)\\n        \\n        # Step 4: Total candies\\n        return sum(candies)\\n\"",
  "3364_14631217_python-updated-time": "1747423946113",
  "2044_14631217_python-updated-time": "1746637393923",
  "357_14631217_python": "\"class Solution:\\n    def countNumbersWithUniqueDigits(self, n):\\n        if n == 0:\\n            return 1\\n        ans = 10\\n        unique_digits = 9\\n        available_number = 9\\n        while n > 1 and available_number > 0:\\n            unique_digits *= available_number\\n            ans += unique_digits\\n            available_number -= 1\\n            n -= 1\\n        return ans\\n\"",
  "1637_14631217_python": "\"class Solution(object):\\n    def getLengthOfOptimalCompression(self, s, k):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        memo = {}\\n\\n        def getLength(count):\\n            if count == 1:\\n                return 1\\n            elif count < 10:\\n                return 2\\n            elif count < 100:\\n                return 3\\n            else:\\n                return 4\\n\\n        def dp(i, k):\\n            if k < 0:\\n                return float('inf')\\n            if i == len(s):\\n                return 0\\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n\\n            res = float('inf')\\n            count = 0\\n            del_count = 0\\n\\n            for j in range(i, len(s)):\\n                if s[j] == s[i]:\\n                    count += 1\\n                else:\\n                    del_count += 1\\n\\n                if del_count > k:\\n                    break\\n\\n                res = min(res, getLength(count) + dp(j + 1, k - del_count))\\n\\n            # Option to delete s[i]\\n            res = min(res, dp(i + 1, k - 1))\\n\\n            memo[(i, k)] = res\\n            return res\\n\\n        return dp(0, k)\\n\"",
  "3418_14631217_python-updated-time": "1747485249351",
  "2100_14631217_python-updated-time": "1746639450846",
  "236_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        if left and right:\\n            return root\\n        return left if left else right\\n\"",
  "2868_14631217_python": "\"from collections import deque\\n\\nclass Solution:\\n    def continuousSubarrays(self, nums):\\n        minq = deque()\\n        maxq = deque()\\n        l = 0\\n        total = 0\\n\\n        for r in range(len(nums)):\\n            # Maintain monotonic increasing min queue\\n            while minq and nums[r] < nums[minq[-1]]:\\n                minq.pop()\\n            minq.append(r)\\n\\n            # Maintain monotonic decreasing max queue\\n            while maxq and nums[r] > nums[maxq[-1]]:\\n                maxq.pop()\\n            maxq.append(r)\\n\\n            # Shrink from left if condition fails\\n            while nums[maxq[0]] - nums[minq[0]] > 2:\\n                if minq[0] == l:\\n                    minq.popleft()\\n                if maxq[0] == l:\\n                    maxq.popleft()\\n                l += 1\\n\\n            # Add the number of valid subarrays ending at r\\n            total += r - l + 1\\n\\n        return total\\n\"",
  "1047_14631217_python-updated-time": "1746041071748",
  "2548_14631217_python": "\"class Solution:\\n    def destroyTargets(self, nums, space):\\n        # Map residue -> (count, minimal num with that residue)\\n        stats = {}\\n        for x in nums:\\n            r = x % space\\n            if r not in stats:\\n                stats[r] = [0, x]\\n            stats[r][0] += 1\\n            if x < stats[r][1]:\\n                stats[r][1] = x\\n        \\n        # Find residue with max count (tie-break by minimal seed)\\n        best_count = -1\\n        answer = None\\n        for count, mn in stats.values():\\n            if count > best_count or (count == best_count and mn < answer):\\n                best_count = count\\n                answer = mn\\n        \\n        return answer\\n\"",
  "3546_14631217_python": "\"class Solution(object):\\n    def countKConstraintSubstrings(self, s, k, queries):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type k: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        Precompute for each end j the smallest start L[j] such that substring i..j is k-valid\\n        iff i >= L[j]. Then for each query [l,r],\\n        total substrings = m*(m+1)//2 where m = r-l+1,\\n        minus bad reduction = sum_{j=l..r, L[j]>=l} (L[j]-l).\\n        Use BIT to answer sum and count over j for L[j]>=l.\\n        O((n+q) log n) time.\\n        \\\"\\\"\\\"\\n        n = len(s)\\n        # Compute L0 and L1 via sliding windows\\n        L0 = [0] * n\\n        L1 = [0] * n\\n        # zeros window\\n        l0 = 0\\n        zeros = 0\\n        for j in range(n):\\n            if s[j] == '0': zeros += 1\\n            while zeros > k:\\n                if s[l0] == '0': zeros -= 1\\n                l0 += 1\\n            L0[j] = l0\\n        # ones window\\n        l1 = 0\\n        ones = 0\\n        for j in range(n):\\n            if s[j] == '1': ones += 1\\n            while ones > k:\\n                if s[l1] == '1': ones -= 1\\n                l1 += 1\\n            L1[j] = l1\\n        # L[j] = min(L0[j], L1[j])\\n        L = [min(L0[j], L1[j]) for j in range(n)]\\n        # Prepare positions by L value\\n        pos_by_L = [[] for _ in range(n)]\\n        for j, lj in enumerate(L):\\n            pos_by_L[lj].append(j)\\n        # Group queries by l\\n        from collections import defaultdict\\n        q_by_l = defaultdict(list)\\n        for idx, (l, r) in enumerate(queries):\\n            q_by_l[l].append((r, idx))\\n        # BIT implementation (1-indexed)\\n        class BIT:\\n            def __init__(self, n):\\n                self.n = n\\n                self.bit = [0] * (n+1)\\n            def update(self, i, v):\\n                while i <= self.n:\\n                    self.bit[i] += v\\n                    i += i & -i\\n            def query(self, i):\\n                s = 0\\n                while i > 0:\\n                    s += self.bit[i]\\n                    i -= i & -i\\n                return s\\n            def range_query(self, l, r):\\n                return self.query(r) - self.query(l-1)\\n        # BITs for count and sumL\\n        bit_cnt = BIT(n)\\n        bit_sum = BIT(n)\\n        res = [0] * len(queries)\\n        # process l from n-1 down to 0\\n        # j indices are 0-based, BIT uses j+1\\n        for l in range(n-1, -1, -1):\\n            # add all j with L[j] == l\\n            for j in pos_by_L[l]:\\n                bit_cnt.update(j+1, 1)\\n                bit_sum.update(j+1, l)\\n            # answer queries starting at l\\n            if l in q_by_l:\\n                for r, idx in q_by_l[l]:\\n                    m = r - l + 1\\n                    total = m * (m + 1) // 2\\n                    cnt = bit_cnt.range_query(l+1, r+1)\\n                    sumL = bit_sum.range_query(l+1, r+1)\\n                    bad = sumL - cnt * l\\n                    res[idx] = total - bad\\n        return res\\n\"",
  "1814_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def maxResult(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        # dp[i] = max score to reach i\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        # deque will store indices of dp, in decreasing dp value\\n        dq = deque([0])\\n        \\n        for i in range(1, n):\\n            # remove indices outside the window [i-k, i-1]\\n            while dq and dq[0] < i - k:\\n                dq.popleft()\\n            # the best previous is at dq[0]\\n            dp[i] = nums[i] + dp[dq[0]]\\n            # maintain decreasing dp in deque\\n            while dq and dp[i] >= dp[dq[-1]]:\\n                dq.pop()\\n            dq.append(i)\\n        \\n        return dp[-1]\\n\"",
  "185_14631217_mysql-updated-time": "1745092621788",
  "3608_14631217_python": "\"import sys\\nsys.setrecursionlimit(10**7)\\n\\n# Ensure gcd compatibility\\ntry:\\n    from math import gcd\\nexcept ImportError:\\n    from fractions import gcd\\n\\nclass Solution(object):\\n    def maxTravelScore(self, n, k, stayScore, travelScore):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type k: int\\n        :type stayScore: List[List[int]]\\n        :type travelScore: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        dp_prev = [0] * n\\n        for day in range(k):\\n            dp_cur = [0] * n\\n            for dest in range(n):\\n                stay = dp_prev[dest] + stayScore[day][dest]\\n                max_travel = max(dp_prev[p] + travelScore[p][dest] for p in range(n))\\n                dp_cur[dest] = max(stay, max_travel)\\n            dp_prev = dp_cur\\n        return max(dp_prev)\\n\\n    def possibleStringCount(self, word, k):\\n        \\\"\\\"\\\"\\n        :type word: str\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        runs = []\\n        cur_char, cur_len = None, 0\\n        for c in word:\\n            if c == cur_char:\\n                cur_len += 1\\n            else:\\n                if cur_len:\\n                    runs.append(cur_len)\\n                cur_char, cur_len = c, 1\\n        if cur_len:\\n            runs.append(cur_len)\\n        m = len(runs)\\n        total = 1\\n        for Li in runs:\\n            total = total * Li % mod\\n        if m >= k:\\n            return total\\n        dp = [0] * k\\n        dp[0] = 1\\n        for Li in runs:\\n            prefix = [0] * k\\n            prefix[0] = dp[0]\\n            for i in range(1, k):\\n                prefix[i] = (prefix[i-1] + dp[i]) % mod\\n            new_dp = [0] * k\\n            for t_idx in range(1, k):\\n                a = prefix[t_idx-1]\\n                b = prefix[t_idx-1-Li] if t_idx-1-Li >= 0 else 0\\n                new_dp[t_idx] = (a - b) % mod\\n            dp = new_dp\\n        count_bad = sum(dp) % mod\\n        return (total - count_bad + mod) % mod\\n\\n    def maxScore(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def lcm(a, b):\\n            return a // gcd(a, b) * b\\n\\n        n = len(nums)\\n        if n == 0:\\n            return 0\\n\\n        prefix_g = [0] * n\\n        prefix_l = [0] * n\\n        suffix_g = [0] * n\\n        suffix_l = [0] * n\\n\\n        for i in range(n):\\n            if i == 0:\\n                prefix_g[i] = nums[i]\\n                prefix_l[i] = nums[i]\\n            else:\\n                prefix_g[i] = gcd(prefix_g[i-1], nums[i])\\n                prefix_l[i] = lcm(prefix_l[i-1], nums[i])\\n\\n        for i in range(n-1, -1, -1):\\n            if i == n-1:\\n                suffix_g[i] = nums[i]\\n                suffix_l[i] = nums[i]\\n            else:\\n                suffix_g[i] = gcd(suffix_g[i+1], nums[i])\\n                suffix_l[i] = lcm(suffix_l[i+1], nums[i])\\n\\n        max_score = prefix_g[n-1] * prefix_l[n-1]\\n\\n        for i in range(n):\\n            if n == 1:\\n                continue\\n            if i == 0:\\n                g = suffix_g[1]\\n                l = suffix_l[1]\\n            elif i == n-1:\\n                g = prefix_g[n-2]\\n                l = prefix_l[n-2]\\n            else:\\n                g = gcd(prefix_g[i-1], suffix_g[i+1])\\n                l = lcm(prefix_l[i-1], suffix_l[i+1])\\n            max_score = max(max_score, g * l)\\n\\n        return max_score\\n\\n    def lengthAfterTransformations(self, s, t):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :type t: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        dp = [1] * 26\\n        for _ in range(t):\\n            new_dp = [0] * 26\\n            for i in range(25):\\n                new_dp[i] = dp[i+1]\\n            new_dp[25] = (dp[0] + dp[1]) % mod\\n            dp = new_dp\\n        result = 0\\n        for ch in s:\\n            result = (result + dp[ord(ch) - ord('a')]) % mod\\n        return result\\n\\n    def subsequencePairCount(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        mod = 10**9+7\\n        n = len(nums)\\n        maxv = max(nums) if nums else 0\\n        # Precompute gcd table\\n        gcd_table = [[0] * (maxv+1) for _ in range(maxv+1)]\\n        for i in range(maxv+1):\\n            for j in range(maxv+1):\\n                gcd_table[i][j] = gcd(i, j)\\n        # dp[g1][g2]: number of ways so far with gcd(seq1)=g1, gcd(seq2)=g2\\n        dp = [[0] * (maxv+1) for _ in range(maxv+1)]\\n        dp[0][0] = 1\\n        for x in nums:\\n            new_dp = [[0] * (maxv+1) for _ in range(maxv+1)]\\n            for g1 in range(maxv+1):\\n                for g2 in range(maxv+1):\\n                    ways = dp[g1][g2]\\n                    if ways == 0: continue\\n                    # skip x\\n                    new_dp[g1][g2] = (new_dp[g1][g2] + ways) % mod\\n                    # put in seq1\\n                    ng1 = x if g1 == 0 else gcd_table[g1][x]\\n                    new_dp[ng1][g2] = (new_dp[ng1][g2] + ways) % mod\\n                    # put in seq2\\n                    ng2 = x if g2 == 0 else gcd_table[g2][x]\\n                    new_dp[g1][ng2] = (new_dp[g1][ng2] + ways) % mod\\n            dp = new_dp\\n        # count pairs with equal non-zero gcd\\n        result = 0\\n        for g in range(1, maxv+1):\\n            result = (result + dp[g][g]) % mod\\n        return result\"",
  "2479_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def mostBooked(self, n, meetings):\\n        # 1) Sort meetings by their original start time\\n        meetings.sort(key=lambda x: x[0])\\n        \\n        # 2) Min‐heap of free rooms (by index)\\n        free = list(range(n))\\n        heapq.heapify(free)\\n        \\n        # 3) Min‐heap of busy rooms: (time_when_free, room_index)\\n        busy = []\\n        \\n        # 4) Count of meetings per room\\n        count = [0]*n\\n        \\n        # 5) Process each meeting\\n        for start, end in meetings:\\n            dur = end - start\\n            \\n            # Free up any rooms that have finished by 'start'\\n            while busy and busy[0][0] <= start:\\n                t_free, room = heapq.heappop(busy)\\n                heapq.heappush(free, room)\\n            \\n            if free:\\n                # Assign at its scheduled start\\n                room = heapq.heappop(free)\\n                finish = start + dur\\n            else:\\n                # No free room now → fast-forward to the earliest free\\n                t_free, room = heapq.heappop(busy)\\n                finish = t_free + dur\\n            \\n            # Mark room busy until 'finish'\\n            heapq.heappush(busy, (finish, room))\\n            count[room] += 1\\n        \\n        # 6) Return the room with the highest count (tie → smallest index)\\n        best = max(range(n), key=lambda i: (count[i], -i))\\n        return best\\n\"",
  "2249_14631217_python": "\"class Solution:\\n    def numberOfArrays(self, differences, lower, upper):\\n        curr = 0\\n        min_val = 0\\n        max_val = 0\\n\\n        for diff in differences:\\n            curr += diff\\n            min_val = min(min_val, curr)\\n            max_val = max(max_val, curr)\\n\\n        total_range = upper - lower\\n        needed_range = max_val - min_val\\n\\n        return max(0, total_range - needed_range + 1)\\n\"",
  "1520_14631217_python-updated-time": "1746346499018",
  "1255_14631217_python-updated-time": "1746261552867",
  "289_14631217_python-updated-time": "1745254944864",
  "3827_14631217_python-updated-time": "1747683285794",
  "263_14631217_python-updated-time": "1745247991376",
  "195_14631217_bash": "\"# Read from the file file.txt and output the tenth line to stdout.\\nsed -n '10p' file.txt\\n\"",
  "1183_14631217_python-updated-time": "1746108288479",
  "1361_14631217_python-updated-time": "1746259411571",
  "1196_14631217_python-updated-time": "1746108520341",
  "2390_14631217_python": "\"class Solution:\\n    def distinctNames(self, ideas):\\n        # Group suffixes by their first letter\\n        groups = [set() for _ in range(26)]\\n        for w in ideas:\\n            idx = ord(w[0]) - ord('a')\\n            groups[idx].add(w[1:])\\n        \\n        ans = 0\\n        # For each pair of different starting letters\\n        for i in range(26):\\n            si = groups[i]\\n            if not si:\\n                continue\\n            for j in range(i+1, 26):\\n                sj = groups[j]\\n                if not sj:\\n                    continue\\n                # Count common suffixes\\n                common = len(si & sj)\\n                # Valid swaps in ordered pairs: two directions\\n                count_i = len(si) - common\\n                count_j = len(sj) - common\\n                ans += 2 * count_i * count_j\\n        \\n        return ans\\n\"",
  "56_14631217_python": "\"class Solution(object):\\n    def merge(self, intervals):\\n        \\\"\\\"\\\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        if not intervals:\\n            return []\\n\\n        intervals.sort(key=lambda x: x[0])\\n        merged = [intervals[0]]\\n\\n        for current in intervals[1:]:\\n            if current[0] <= merged[-1][1]:\\n                merged[-1][1] = max(merged[-1][1], current[1])\\n            else:\\n                merged.append(current)\\n\\n        return merged\\n\"",
  "1890_14631217_python": "\"class Solution:\\n    def beautySum(self, s):\\n        total = 0\\n        n = len(s)\\n\\n        for i in range(n):\\n            freq = [0] * 26\\n            for j in range(i, n):\\n                idx = ord(s[j]) - ord('a')\\n                freq[idx] += 1\\n\\n                max_freq = max(freq)\\n                min_freq = min(f for f in freq if f > 0)\\n\\n                total += max_freq - min_freq\\n\\n        return total\\n\"",
  "notification-status:lastFetched-updated-time": "1747738765182",
  "1343_14631217_python": "\"class Solution:\\n    def dieSimulator(self, n, rollMax):\\n        MOD = 10**9 + 7\\n        dp = [[[0] * 16 for _ in range(6)] for _ in range(n+1)]\\n        \\n        for i in range(6):\\n            dp[1][i][1] = 1\\n        \\n        for i in range(2, n+1):\\n            for j in range(6):  # current face\\n                for k in range(6):  # previous face\\n                    for c in range(1, rollMax[k]+1):\\n                        if j == k and c + 1 <= rollMax[j]:\\n                            dp[i][j][c+1] = (dp[i][j][c+1] + dp[i-1][j][c]) % MOD\\n                        elif j != k:\\n                            dp[i][j][1] = (dp[i][j][1] + dp[i-1][k][c]) % MOD\\n        \\n        res = 0\\n        for j in range(6):\\n            for c in range(1, rollMax[j]+1):\\n                res = (res + dp[n][j][c]) % MOD\\n        return res\\n\"",
  "1951_14631217_python": "\"class Solution(object):\\n    def findTheWinner(self, n, k):\\n        ans = 0\\n        for i in range(1, n + 1):\\n            ans = (ans + k) % i\\n        return ans + 1\\n\"",
  "2775_14631217_javascript": "\"function* fibGenerator() {\\n  let a = 0, b = 1;\\n  while (true) {\\n    yield a;\\n    [a, b] = [b, a + b];\\n  }\\n}\"",
  "553_14631217_python": "\"class Solution(object):\\n    def optimalDivision(self, nums):\\n        if not nums:\\n            return \\\"\\\"\\n        if len(nums) == 1:\\n            return str(nums[0])\\n        if len(nums) == 2:\\n            return \\\"%d/%d\\\" % (nums[0], nums[1])\\n        rest = \\\"/\\\".join(str(x) for x in nums[1:])\\n        return \\\"%d/(%s)\\\" % (nums[0], rest)\\n\"",
  "3206_14631217_python": "\"class Solution(object):\\n    def findIntersectionValues(self, nums1, nums2):\\n        \\\"\\\"\\\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        set2 = set(nums2)\\n        # Count how many in nums1 appear in nums2\\n        answer1 = sum(1 for x in nums1 if x in set2)\\n        \\n        set1 = set(nums1)\\n        # Count how many in nums2 appear in nums1\\n        answer2 = sum(1 for x in nums2 if x in set1)\\n        \\n        return [answer1, answer2]\\n\"",
  "1139_14631217_python-updated-time": "1746107647771",
  "3183_14631217_python": "\"class Solution(object):\\n    def findKOr(self, nums, k):\\n        ans = 0\\n        # For each bit position 0 through 30\\n        for bit in range(31):\\n            # Count how many numbers have this bit set\\n            if sum((num >> bit) & 1 for num in nums) >= k:\\n                ans |= 1 << bit\\n        return ans\"",
  "1005_14631217_python-updated-time": "1746039646455",
  "1030_14631217_python-updated-time": "1746040496215",
  "2646_14631217_python": "\"from collections import deque\\n\\nclass Solution(object):\\n    def kthLargestLevelSum(self, root, k):\\n        if not root:\\n            return -1\\n        \\n        queue = deque([root])\\n        level_sums = []\\n\\n        while queue:\\n            level_size = len(queue)\\n            level_sum = 0\\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            level_sums.append(level_sum)\\n        \\n        if len(level_sums) < k:\\n            return -1\\n        level_sums.sort(reverse=True)\\n        return level_sums[k-1]\\n\"",
  "2569_14631217_python": "\"class Solution:\\n    def beautifulPartitions(self, s, k, minLength):\\n        MOD = 10**9 + 7\\n        n = len(s)\\n        primes = set('2357')\\n\\n        # Quick sanity checks\\n        if s[0] not in primes or s[-1] in primes:\\n            return 0\\n\\n        # Precompute start/end validity arrays\\n        is_start = [c in primes for c in s]\\n        is_end   = [c not in primes for c in s]\\n\\n        # dp[i][j]: number of ways to partition s[i:] into exactly j pieces\\n        # We only need dp[*][j-1] to compute dp[*][j], so roll by j\\n        dp_prev = [0] * (n + 1)\\n        dp_prev[n] = 1  # base: one way to partition empty suffix into 0 pieces\\n\\n        for pieces in range(1, k + 1):\\n            # Build suffix-sum array of dp_prev[x] but only where x-1 is valid end\\n            # suf[i] = sum(dp_prev[x] for x=i..n if x>i and is_end[x-1])\\n            suf = [0] * (n + 2)\\n            for i in range(n, -1, -1):\\n                val = dp_prev[i] if (1 <= i <= n and is_end[i-1]) else 0\\n                suf[i] = (val + suf[i + 1]) % MOD\\n\\n            # Compute dp_curr\\n            dp_curr = [0] * (n + 1)\\n            for i in range(n):\\n                if is_start[i]:\\n                    j = i + minLength\\n                    if j <= n:\\n                        dp_curr[i] = suf[j]\\n            # dp_curr[n] stays zero for pieces>=1\\n            dp_prev = dp_curr\\n\\n        # Answer: ways to partition full string s[0:] into k pieces\\n        return dp_prev[0] % MOD\\n\"",
  "1728_14631217_python-updated-time": "1746444535032",
  "2187_14631217_python-updated-time": "1746720847728",
  "932_14631217_python": "\"class Solution(object):\\n    def isMonotonic(self, nums):\\n        inc = dec = True\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                dec = False\\n            if nums[i] < nums[i - 1]:\\n                inc = False\\n        return inc or dec\\n\"",
  "991_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def canReorderDoubled(self, arr):\\n        count = Counter(arr)\\n        \\n        for x in sorted(count, key=abs):\\n            if count[x] > count[2 * x]:\\n                return False\\n            count[2 * x] -= count[x]\\n        \\n        return True\\n\"",
  "1309_14631217_python-updated-time": "1746127456831",
  "3046_14631217_python": "\"class Solution(object):\\n    def minimumOperations(self, num):\\n        n = len(num)\\n        best = n\\n        for x, y in [('0','0'), ('2','5'), ('5','0'), ('7','5')]:\\n            j = num.rfind(y)\\n            if j == -1:\\n                continue\\n            i = num.rfind(x, 0, j)\\n            if i == -1:\\n                continue\\n            ops = (n - 1 - j) + (j - 1 - i)\\n            best = min(best, ops)\\n        if best == n:\\n            # no valid ending found: delete down to a single '0' or all digits\\n            if '0' in num:\\n                best = n - 1\\n            else:\\n                best = n\\n        return best\\n\"",
  "2518_14631217_python-updated-time": "1746967292626",
  "2657_14631217_python-updated-time": "1747066972820",
  "301_14631217_python-updated-time": "1745255639104",
  "2103_14631217_python": "\"class Solution:\\n    def findFarmland(self, land):\\n        m, n = len(land), len(land[0])\\n        res = []\\n\\n        def dfs(r, c):\\n            # Expand as far right and down as possible\\n            r2, c2 = r, c\\n            while r2 + 1 < m and land[r2 + 1][c] == 1:\\n                r2 += 1\\n            while c2 + 1 < n and land[r][c2 + 1] == 1:\\n                c2 += 1\\n\\n            # Mark the entire rectangle as visited\\n            for i in range(r, r2 + 1):\\n                for j in range(c, c2 + 1):\\n                    land[i][j] = 0\\n            return [r, c, r2, c2]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if land[i][j] == 1:\\n                    res.append(dfs(i, j))\\n\\n        return res\\n\"",
  "1436_14631217_python-updated-time": "1746261035912",
  "1938_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums):\\n        ans = 0\\n        prev = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] > prev:\\n                prev = nums[i]\\n            else:\\n                need = prev + 1\\n                ans += need - nums[i]\\n                prev = need\\n        return ans\\n\"",
  "2438_14631217_python": "\"class Solution(object):\\n    def closestMeetingNode(self, edges, node1, node2):\\n        def get_distances(start):\\n            dist = [-1] * len(edges)\\n            d = 0\\n            while start != -1 and dist[start] == -1:\\n                dist[start] = d\\n                d += 1\\n                start = edges[start]\\n            return dist\\n        \\n        dist1 = get_distances(node1)\\n        dist2 = get_distances(node2)\\n        min_dist = float('inf')\\n        result = -1\\n\\n        for i in range(len(edges)):\\n            if dist1[i] != -1 and dist2[i] != -1:\\n                max_dist = max(dist1[i], dist2[i])\\n                if max_dist < min_dist:\\n                    min_dist = max_dist\\n                    result = i\\n        return result\\n\"",
  "122_14631217_python": "\"class Solution(object):\\n    def maxProfit(self, prices):\\n        \\\"\\\"\\\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] > prices[i - 1]:\\n                profit += prices[i] - prices[i - 1]\\n        return profit\\n\"",
  "1792_14631217_python": "\"class Solution(object):\\n    def mostCompetitive(self, nums, k):\\n        stack = []\\n        to_remove = len(nums) - k\\n        for num in nums:\\n            while stack and to_remove > 0 and stack[-1] > num:\\n                stack.pop()\\n                to_remove -= 1\\n            stack.append(num)\\n        return stack[:k]\\n\"",
  "1848_14631217_python": "\"from collections import Counter\\n\\nclass Solution(object):\\n    def sumOfUnique(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = Counter(nums)\\n        return sum(num for num, freq in count.items() if freq == 1)\\n\"",
  "1670_14631217_mysql": "\"SELECT patient_id, patient_name, conditions\\nFROM Patients\\nWHERE CONCAT(' ', conditions, ' ') LIKE '% DIAB1%';\\n\"",
  "3584_14631217_python-updated-time": "1747574732743",
  "2299_14631217_python-updated-time": "1746803560338",
  "3810_14631217_python-updated-time": "1747816916514",
  "2812_14631217_python-updated-time": "1747222197952",
  "1217_14631217_python": "\"class Solution(object):\\n    def relativeSortArray(self, arr1, arr2):\\n        \\\"\\\"\\\"\\n        :type arr1: List[int]\\n        :type arr2: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        rank = {num: i for i, num in enumerate(arr2)}\\n        return sorted(arr1, key=lambda x: (rank.get(x, float('inf')), x))\\n\"",
  "104_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def maxDepth(self, root):\\n        \\\"\\\"\\\"\\n        :type root: Optional[TreeNode]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not root:\\n            return 0\\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\\n\"",
  "913_14631217_python": "\"import random\\n\\nclass Solution:\\n\\n    def __init__(self, m, n):\\n        self.m = m\\n        self.n = n\\n        self.total = m * n\\n        self.map = {}\\n\\n    def flip(self):\\n        r = random.randint(0, self.total - 1)\\n        self.total -= 1\\n        x = self.map.get(r, r)\\n        self.map[r] = self.map.get(self.total, self.total)\\n        return [x // self.n, x % self.n]\\n\\n    def reset(self):\\n        self.total = self.m * self.n\\n        self.map.clear()\\n\"",
  "3453_14631217_python": "\"class Solution(object):\\n    def validStrings(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        def dfs(prefix, last):\\n            if len(prefix) == n:\\n                res.append(prefix)\\n                return\\n            # always can add '1'\\n            dfs(prefix + '1', '1')\\n            # add '0' only if last wasn't '0'\\n            if last != '0':\\n                dfs(prefix + '0', '0')\\n        \\n        # start with first char '0' or '1'\\n        dfs(\\\"0\\\", \\\"0\\\")\\n        dfs(\\\"1\\\", \\\"1\\\")\\n        return res\\n\"",
  "1586_14631217_python": "\"class Solution(object):\\n    def longestSubarray(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left = 0\\n        zeros = 0\\n        max_len = 0\\n\\n        for right in range(len(nums)):\\n            if nums[right] == 0:\\n                zeros += 1\\n\\n            while zeros > 1:\\n                if nums[left] == 0:\\n                    zeros -= 1\\n                left += 1\\n\\n            # right - left + 1 is the current window size, but we must delete one element\\n            max_len = max(max_len, right - left)\\n\\n        return max_len\\n\"",
  "3619_14631217_python": "\"class Solution(object):\\n    def maxIncreasingSubarrays(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n\\n        # inc_end[i]: length of strictly increasing subarray ending at i\\n        inc_end = [1] * n\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                inc_end[i] = inc_end[i-1] + 1\\n\\n        # inc_start[i]: length of strictly increasing subarray starting at i\\n        inc_start = [1] * n\\n        for i in range(n-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                inc_start[i] = inc_start[i+1] + 1\\n\\n        max_k = 0\\n        # consider split between i-1 and i, for i in [1..n-1]\\n        for i in range(1, n):\\n            k = min(inc_end[i-1], inc_start[i])\\n            if k > max_k:\\n                max_k = k\\n\\n        return max_k\\n\"",
  "3515_14631217_python-updated-time": "1747488261249",
  "2373_14631217_python-updated-time": "1746881778252",
  "721_14631217_python": "\"class UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = {}\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            # Path compression\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        # Make sure both nodes are initialized\\n        if x not in self.parent:\\n            self.parent[x] = x\\n            self.rank[x] = 0\\n        if y not in self.parent:\\n            self.parent[y] = y\\n            self.rank[y] = 0\\n\\n        # Find roots\\n        rx, ry = self.find(x), self.find(y)\\n        if rx == ry:\\n            return\\n\\n        # Union by rank\\n        if self.rank[rx] < self.rank[ry]:\\n            self.parent[rx] = ry\\n        elif self.rank[rx] > self.rank[ry]:\\n            self.parent[ry] = rx\\n        else:\\n            self.parent[ry] = rx\\n            self.rank[rx] += 1\\n\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        uf = UnionFind()\\n        email_to_name = {}\\n\\n        # 1) Union emails in the same account\\n        for account in accounts:\\n            name = account[0]\\n            first_email = account[1]\\n            for email in account[1:]:\\n                # Map email to user name\\n                email_to_name[email] = name\\n                # Union this email with the first email in account\\n                uf.union(first_email, email)\\n\\n        # 2) Group emails by their root parent\\n        from collections import defaultdict\\n        groups = defaultdict(list)\\n        for email in email_to_name:\\n            root = uf.find(email)\\n            groups[root].append(email)\\n\\n        # 3) Build the merged account list\\n        result = []\\n        for root, emails in groups.items():\\n            name = email_to_name[root]\\n            emails.sort()\\n            result.append([name] + emails)\\n\\n        return result\\n\"",
  "1217_14631217_lang": "\"python\"",
  "3443_14631217_python": "\"class Solution(object):\\n    def maxTotalReward(self, rewardValues):\\n        \\\"\\\"\\\"\\n        :type rewardValues: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # 1) only distinct values matter (you can never take the same value twice,\\n        #    since after you pick v once, your sum >= v, so a second copy of v fails v > sum)\\n        vals = sorted(set(rewardValues))\\n        \\n        # 2) `can` as a bitset: bit s is 1 iff we can achieve a super-increasing sum = s\\n        can = 1  # only sum=0 is possible initially\\n        \\n        for v in vals:\\n            # keep only those achievable sums s < v\\n            mask = (1 << v) - 1\\n            reachable = can & mask\\n            # shifting them by +v gives new sums s+v\\n            can |= (reachable << v)\\n        \\n        # 3) the answer is the largest s for which bit s is set\\n        return can.bit_length() - 1\\n\"",
  "3229_14631217_python-updated-time": "1747318250864",
  "2104_14631217_python-updated-time": "1746717218381",
  "2586_14631217_python-updated-time": "1747058867897",
  "910_14631217_python-updated-time": "1746001655188",
  "3605_14631217_python-updated-time": "1747577627807",
  "794_14631217_python-updated-time": "1745877291289",
  "2648_14631217_python-updated-time": "1747066720244",
  "1103_14631217_python": "\"class Solution:\\n    def numMovesStones(self, a, b, c):\\n        x, y, z = sorted((a, b, c))\\n        # Minimum moves\\n        if y - x == 1 and z - y == 1:\\n            mn = 0\\n        elif y - x <= 2 or z - y <= 2:\\n            mn = 1\\n        else:\\n            mn = 2\\n        # Maximum moves\\n        mx = (y - x - 1) + (z - y - 1)\\n        return [mn, mx]\\n\"",
  "1434_14631217_python-updated-time": "1746260989483",
  "459_14631217_python-updated-time": "1745359512291",
  "3032_14631217_python-updated-time": "1747226461289",
  "3618_14631217_python-updated-time": "1747585511512",
  "1999_14631217_python": "\"class Solution:\\n    def checkZeroOnes(self, s):\\n        max1 = max0 = curr1 = curr0 = 0\\n        for ch in s:\\n            if ch == '1':\\n                curr1 += 1\\n                curr0 = 0\\n            else:\\n                curr0 += 1\\n                curr1 = 0\\n            max1 = max(max1, curr1)\\n            max0 = max(max0, curr0)\\n        return max1 > max0\\n\"",
  "221_14631217_python": "\"class Solution(object):\\n    def maximalSquare(self, matrix):\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        if not matrix or not matrix[0]:\\n            return 0\\n\\n        rows, cols = len(matrix), len(matrix[0])\\n        dp = [[0]*cols for _ in range(rows)]\\n        max_side = 0\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if matrix[i][j] == '1':\\n                    if i == 0 or j == 0:\\n                        dp[i][j] = 1\\n                    else:\\n                        dp[i][j] = min(\\n                            dp[i-1][j],      # top\\n                            dp[i][j-1],      # left\\n                            dp[i-1][j-1]     # top-left\\n                        ) + 1\\n                    max_side = max(max_side, dp[i][j])\\n\\n        return max_side * max_side\\n\"",
  "910_14631217_python": "\"class Solution(object):\\n    def nthMagicalNumber(self, n, a, b):\\n        from fractions import gcd\\n        MOD = 10**9 + 7\\n        lcm = a * b // gcd(a, b)\\n\\n        left, right = 1, n * min(a, b)\\n        while left < right:\\n            mid = (left + right) // 2\\n            count = mid // a + mid // b - mid // lcm\\n            if count < n:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left % MOD\\n\"",
  "229_14631217_python-updated-time": "1745247128153",
  "2692_14631217_python": "\"import heapq\\nimport math\\n\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        # Use max-heap by negating values\\n        heap = [-g for g in gifts]\\n        heapq.heapify(heap)\\n\\n        for _ in range(k):\\n            max_gift = -heapq.heappop(heap)\\n            reduced = int(math.sqrt(max_gift))\\n            heapq.heappush(heap, -reduced)\\n\\n        return -sum(heap)\\n\"",
  "3320_14631217_python": "\"class Solution(object):\\n    def maxOperations(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        S = nums[0] + nums[1]\\n        count = 0\\n        i = 0\\n        while i + 1 < n and nums[i] + nums[i+1] == S:\\n            count += 1\\n            i += 2\\n        return count\\n\"",
  "1001_14631217_python-updated-time": "1746038950746",
  "216_14631217_python-updated-time": "1745246311066",
  "3151_14631217_python": "\"class Solution(object):\\n    def minProcessingTime(self, processorTime, tasks):\\n        n = len(processorTime)\\n        processorTime.sort()\\n        tasks.sort(reverse=True)\\n        res = 0\\n        for i in range(n):\\n            finish_time = max(processorTime[i] + tasks[4*i + j] for j in range(4))\\n            res = max(res, finish_time)\\n        return res\\n\"",
  "109_14631217_python-updated-time": "1745081210766",
  "3241_14631217_python": "\"class Solution(object):\\n    def divideArray(self, nums, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n\\n        for i in range(0, n, 3):\\n            group = nums[i:i+3]\\n            if group[-1] - group[0] > k:\\n                return []\\n            res.append(group)\\n\\n        return res\\n\"",
  "1912_14631217_python-updated-time": "1746542557043",
  "3349_14631217_python-updated-time": "1747422458146",
  "2509_14631217_python": "\"class Solution:\\n    def minimizeXor(self, num1, num2):\\n        # Count how many 1-bits we need in x\\n        k = bin(num2).count('1')\\n        \\n        # Record positions of 1-bits and 0-bits in num1\\n        ones = []\\n        zeros = []\\n        for i in range(31, -1, -1):\\n            if (num1 >> i) & 1:\\n                ones.append(i)\\n            else:\\n                zeros.append(i)\\n        \\n        x = 0\\n        # Use as many 1-bits from num1's 1-positions (highest first)\\n        c1 = min(k, len(ones))\\n        for i in ones[:c1]:\\n            x |= 1 << i\\n        \\n        # Remaining ones go into zeros at the lowest positions\\n        rem = k - c1\\n        for i in sorted(zeros)[:rem]:\\n            x |= 1 << i\\n        \\n        return x\\n\"",
  "494_14631217_python": "\"class Solution:\\n    def findTargetSumWays(self, nums, target):\\n        memo = {}\\n\\n        def dfs(i, total):\\n            if i == len(nums):\\n                return 1 if total == target else 0\\n            if (i, total) in memo:\\n                return memo[(i, total)]\\n            count = dfs(i + 1, total + nums[i]) + dfs(i + 1, total - nums[i])\\n            memo[(i, total)] = count\\n            return count\\n\\n        return dfs(0, 0)\\n\"",
  "1716_14631217_python-updated-time": "1746438883730",
  "2863_14631217_javascript-updated-time": "1747220447865",
  "257_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \\\"\\\"\\\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        res = []\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            if not node.left and not node.right:\\n                res.append(path + str(node.val))\\n                return\\n            dfs(node.left, path + str(node.val) + \\\"->\\\")\\n            dfs(node.right, path + str(node.val) + \\\"->\\\")\\n        \\n        dfs(root, \\\"\\\")\\n        return res\\n\"",
  "1302_14631217_python": "\"class Solution(object):\\n    def makeFancyString(self, s):\\n        res = []\\n        prev = ''\\n        count = 0\\n        for c in s:\\n            if c == prev:\\n                count += 1\\n            else:\\n                prev = c\\n                count = 1\\n            if count <= 2:\\n                res.append(c)\\n        return \\\"\\\".join(res)\\n\"",
  "278_14631217_python": "\"# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\"",
  "167_14631217_python-updated-time": "1745091473931",
  "2148_14631217_python-updated-time": "1746719825872",
  "2163_14631217_python-updated-time": "1746720368359",
  "842_14631217_python": "\"class Solution(object):\\n    def flipgame(self, fronts, backs):\\n        same = set()\\n        for f, b in zip(fronts, backs):\\n            if f == b:\\n                same.add(f)\\n        \\n        ans = float('inf')\\n        for x in fronts + backs:\\n            if x not in same:\\n                ans = min(ans, x)\\n        \\n        return ans if ans != float('inf') else 0\\n\"",
  "1646_14631217_python": "\"class Solution(object):\\n    def findKthPositive(self, arr, k):\\n        \\\"\\\"\\\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        left, right = 0, len(arr) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            missing = arr[mid] - (mid + 1)\\n            if missing < k:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return left + k\\n\"",
  "3528_14631217_python": "\"class Solution(object):\\n    def findMaximumScore(self, nums):\\n        n = len(nums)\\n        # build tree size = next power of two ≥ n\\n        size = 1\\n        while size < n:\\n            size <<= 1\\n        N = size\\n        # arrays for lines: m_arr[k], b_arr[k] represent y = m*x + b at node k\\n        m_arr = [0] * (2 * N)\\n        b_arr = [-10**30] * (2 * N)\\n        NEG_INF = -10**30\\n\\n        # inline insertion of line (m_new, b_new)\\n        def insert_line(m_new, b_new):\\n            idx, l, r = 1, 0, N - 1\\n            while True:\\n                mid = (l + r) >> 1\\n                # if new line is better at x=mid, swap with stored\\n                if m_new * mid + b_new > m_arr[idx] * mid + b_arr[idx]:\\n                    m_arr[idx], m_new = m_new, m_arr[idx]\\n                    b_arr[idx], b_new = b_new, b_arr[idx]\\n                if l == r:\\n                    break\\n                # check left end\\n                if m_new * l + b_new > m_arr[idx] * l + b_arr[idx]:\\n                    idx <<= 1\\n                    r = mid\\n                # check right end\\n                elif m_new * r + b_new > m_arr[idx] * r + b_arr[idx]:\\n                    idx = idx * 2 + 1\\n                    l = mid + 1\\n                else:\\n                    break\\n\\n        # inline query at point x\\n        def query_x(x):\\n            idx, l, r = 1, 0, N - 1\\n            res = NEG_INF\\n            while True:\\n                val = m_arr[idx] * x + b_arr[idx]\\n                if val > res:\\n                    res = val\\n                if l == r:\\n                    return res\\n                mid = (l + r) >> 1\\n                if x <= mid:\\n                    idx <<= 1\\n                    r = mid\\n                else:\\n                    idx = idx * 2 + 1\\n                    l = mid + 1\\n\\n        # base case: dp[0] = 0, insert its line\\n        insert_line(nums[0], 0)\\n        dp = 0\\n\\n        for j in range(1, n):\\n            # dp[j] = max_i (nums[i]*j + dp[i] - i*nums[i])\\n            dp = query_x(j)\\n            # insert line for this j\\n            insert_line(nums[j], dp - j * nums[j])\\n\\n        return dp\\n\"",
  "3658_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def minDifference(self, nums):\\n        \\\"\\\"\\\"\\n        Return the smallest k such that all –1 positions can be replaced with two\\n        positive integers x and y so that every adjacent pair differs by ≤ k.\\n        \\\"\\\"\\\"\\n        INF = 4 * 10 ** 9\\n        n   = len(nums)\\n\\n        if all(v == -1 for v in nums):\\n            return 0                               # everything can be 1\\n\\n        # ------------------------------------------------------------------ #\\n        # Things that never change while we binary-search on k\\n        # ------------------------------------------------------------------ #\\n        fixed_pairs = [abs(nums[i] - nums[i + 1])\\n                       for i in range(n - 1)\\n                       if nums[i] != -1 and nums[i + 1] != -1]\\n\\n        # helper: build intervals [L,R] for every “-1” slot, or return None if impossible\\n        def build_intervals(k):\\n            L, R, idx_of = [], [], {}\\n            for i, v in enumerate(nums):\\n                if v != -1:\\n                    continue\\n                lo, hi = 1, INF\\n                if i and nums[i - 1] != -1:\\n                    lo = max(lo, nums[i - 1] - k)\\n                    hi = min(hi, nums[i - 1] + k)\\n                if i + 1 < n and nums[i + 1] != -1:\\n                    lo = max(lo, nums[i + 1] - k)\\n                    hi = min(hi, nums[i + 1] + k)\\n                if lo > hi:\\n                    return None\\n                idx_of[i] = len(L)\\n                L.append(lo)\\n                R.append(hi)\\n            return L, R, idx_of\\n\\n        # ------------------------------------------------------------------ #\\n        # 1) “no-mix” feasibility: every consecutive block of -1 takes ONE value\\n        # ------------------------------------------------------------------ #\\n        def no_mix_feasible(k, L, R, idx_of):\\n            blocks, i = [], 0\\n            while i < n:\\n                if nums[i] != -1:\\n                    i += 1\\n                    continue\\n                lo, hi, j = 1, INF, i\\n                while j < n and nums[j] == -1:\\n                    p = idx_of[j]\\n                    lo = max(lo, L[p])\\n                    hi = min(hi, R[p])\\n                    j += 1\\n                if lo > hi:                        # whole block impossible\\n                    return False\\n                blocks.append((lo, hi))\\n                i = j\\n\\n            if not blocks:                         # no “-1” at all\\n                return True\\n\\n            # classic “stab all intervals with ≤ 2 points” greedy\\n            blocks.sort(key=lambda x: x[1])\\n            used, ptr = 0, 0\\n            while ptr < len(blocks) and used < 2:\\n                p = blocks[ptr][1]                 # take right end\\n                used += 1\\n                ptr += 1\\n                while ptr < len(blocks) and blocks[ptr][0] <= p <= blocks[ptr][1]:\\n                    ptr += 1\\n            return ptr == len(blocks)\\n\\n        # ------------------------------------------------------------------ #\\n        # 2) “mix” feasibility: we may have x next to y (needs |x-y| ≤ k)\\n        # ------------------------------------------------------------------ #\\n        def mix_feasible(k, L, R, idx_of):\\n            m = len(L)\\n            if m == 0:\\n                return True                        # nothing to fill\\n\\n            # global intersection – if non-empty we’re done (x fills everything)\\n            gL = max(L); gR = min(R)\\n            if gL <= gR:\\n                return True\\n\\n            # ---- sort by L and by R once ----------------------------------\\n            order_L = sorted(range(m), key=lambda i: L[i])\\n            L_sorted  = [L[i] for i in order_L]\\n            R_by_L    = [R[i] for i in order_L]\\n\\n            suf_max_L = [0] * m\\n            suf_min_R = [0] * m\\n            suf_max_L[-1] = L_sorted[-1]\\n            suf_min_R[-1] = R_by_L[-1]\\n            for i in range(m - 2, -1, -1):\\n                suf_max_L[i] = max(suf_max_L[i + 1], L_sorted[i])\\n                suf_min_R[i] = min(suf_min_R[i + 1], R_by_L[i])\\n\\n            order_R = sorted(range(m), key=lambda i: R[i])\\n            R_sorted   = [R[i] for i in order_R]\\n            L_by_R     = [L[i] for i in order_R]\\n\\n            pre_max_L = [0] * m\\n            pre_max_L[0] = L_by_R[0]\\n            for i in range(1, m):\\n                pre_max_L[i] = max(pre_max_L[i - 1], L_by_R[i])\\n\\n            # ---- build “mixing active” events (+1 at start, -1 at end+1) ---\\n            mix_events = []\\n            for i in range(n - 1):\\n                if nums[i] == -1 and nums[i + 1] == -1:      # ← fixed line\\n                    a = idx_of[i]\\n                    b = idx_of[i + 1]\\n                    L1, R1 = L[a], R[a]\\n                    L2, R2 = L[b], R[b]\\n\\n                    lo_seg = (min(L1, L2), max(L1, L2) - 1)\\n                    if lo_seg[0] <= lo_seg[1]:\\n                        mix_events.append((lo_seg[0], 1))\\n                        mix_events.append((lo_seg[1] + 1, -1))\\n\\n                    hi_seg = (min(R1, R2) + 1, max(R1, R2))\\n                    if hi_seg[0] <= hi_seg[1]:\\n                        mix_events.append((hi_seg[0], 1))\\n                        mix_events.append((hi_seg[1] + 1, -1))\\n            mix_events.sort()\\n\\n            # ---- collect sweep coordinates ---------------------------------\\n            coords = {1}\\n            for v in L:\\n                coords.add(v)\\n            for v in R:\\n                if v < INF:\\n                    coords.add(v + 1)\\n            for c, _ in mix_events:\\n                coords.add(c)\\n            coords = sorted(coords)\\n\\n            pL = pR = 0\\n            mix_ptr = mix_cnt = 0\\n            len_L = len(L_sorted)\\n            len_R = len(R_sorted)\\n\\n            for ci in range(len(coords) - 1):\\n                x_min = coords[ci]\\n                x_max = coords[ci + 1] - 1\\n\\n                # advance pointers so that:\\n                #   L_sorted[:pL]  → L ≤ x_min\\n                #   R_sorted[:pR]  → R < x_min\\n                while pL < len_L and L_sorted[pL] <= x_min:\\n                    pL += 1\\n                while pR < len_R and R_sorted[pR] < x_min:\\n                    pR += 1\\n\\n                # apply every mix-event that starts exactly at x_min\\n                while mix_ptr < len(mix_events) and mix_events[mix_ptr][0] == x_min:\\n                    mix_cnt += mix_events[mix_ptr][1]\\n                    mix_ptr += 1\\n\\n                # L*  = max(L of L> x)  vs  max(L of R< x)\\n                g1_max = suf_max_L[pL] if pL < len_L else -1\\n                g2_max = pre_max_L[pR - 1] if pR else -1\\n                L_star = max(g1_max, g2_max)\\n\\n                # R*  = min(R of L> x)  vs  min(R of R< x)\\n                g1_min = suf_min_R[pL] if pL < len_L else INF\\n                g2_min = R_sorted[0]    if pR else INF\\n                R_star = min(g1_min, g2_min)\\n\\n                if L_star > R_star:          # intersection empty – impossible here\\n                    continue\\n\\n                if mix_cnt == 0:             # no x–y adjacency → feasible\\n                    return True\\n\\n                # need distance(x, [L*,R*]) ≤ k for *some* x in [x_min,x_max]\\n                if x_max < L_star:\\n                    d = L_star - x_max\\n                elif x_min > R_star:\\n                    d = x_min - R_star\\n                else:\\n                    d = 0\\n                if d <= k:\\n                    return True\\n\\n            return False                     # sweep finished, no luck\\n\\n        # ------------------------------------------------------------------ #\\n        # Feasibility wrapper for a given k\\n        # ------------------------------------------------------------------ #\\n        def feasible(k):\\n            if fixed_pairs and max(fixed_pairs) > k:\\n                return False\\n\\n            built = build_intervals(k)\\n            if built is None:\\n                return False\\n            L, R, idx_of = built\\n\\n            if no_mix_feasible(k, L, R, idx_of):\\n                return True\\n            return mix_feasible(k, L, R, idx_of)\\n\\n        # ------------------------------------------------------------------ #\\n        # Binary search on k\\n        # ------------------------------------------------------------------ #\\n        lo, hi, ans = 0, 2 * 10 ** 9, 2 * 10 ** 9\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if feasible(mid):\\n                ans, hi = mid, mid - 1\\n            else:\\n                lo = mid + 1\\n        return ans\\n\"",
  "2556_14631217_python": "\"class Solution:\\n    def convertTemperature(self, celsius):\\n        # Kelvin conversion\\n        kelvin = celsius + 273.15\\n        # Fahrenheit conversion\\n        fahrenheit = celsius * 1.8 + 32.0\\n        return [kelvin, fahrenheit]\\n\"",
  "979_14631217_python": "\"class Solution:\\n    def diStringMatch(self, s):\\n        low, high = 0, len(s)\\n        res = []\\n\\n        for char in s:\\n            if char == 'I':\\n                res.append(low)\\n                low += 1\\n            else:  # char == 'D'\\n                res.append(high)\\n                high -= 1\\n\\n        res.append(low)  # low == high at the end\\n        return res\\n\"",
  "3808_14631217_python": "\"class Solution(object):\\n    def longestPalindrome(self, s, t):\\n        s_N = len(s)\\n        t_N = len(t)\\n\\n        # Since s.length, t.length >= 1, min palindrome is 1 char\\n        max_overall_len = 1\\n        \\n        # --- Step 2: Precompute is_palindrome and find longest palindrome in s and t individually ---\\n        is_palindrome_s = [[False for _ in range(s_N)] for _ in range(s_N)]\\n        for length in range(1, s_N + 1):\\n            for r_idx in range(s_N - length + 1): # r_idx is start_idx\\n                c_idx = r_idx + length - 1 # c_idx is end_idx\\n                if length == 1:\\n                    is_palindrome_s[r_idx][c_idx] = True\\n                elif length == 2:\\n                    is_palindrome_s[r_idx][c_idx] = (s[r_idx] == s[c_idx])\\n                else:\\n                    is_palindrome_s[r_idx][c_idx] = (s[r_idx] == s[c_idx] and is_palindrome_s[r_idx+1][c_idx-1])\\n                \\n                if is_palindrome_s[r_idx][c_idx]:\\n                    max_overall_len = max(max_overall_len, length)\\n\\n        is_palindrome_t = [[False for _ in range(t_N)] for _ in range(t_N)]\\n        for length in range(1, t_N + 1):\\n            for r_idx in range(t_N - length + 1): # r_idx is start_idx\\n                c_idx = r_idx + length - 1 # c_idx is end_idx\\n                if length == 1:\\n                    is_palindrome_t[r_idx][c_idx] = True\\n                elif length == 2:\\n                    is_palindrome_t[r_idx][c_idx] = (t[r_idx] == t[c_idx])\\n                else:\\n                    is_palindrome_t[r_idx][c_idx] = (t[r_idx] == t[c_idx] and is_palindrome_t[r_idx+1][c_idx-1])\\n\\n                if is_palindrome_t[r_idx][c_idx]:\\n                    max_overall_len = max(max_overall_len, length)\\n        \\n        # --- Step 3: Precompute max_len_pal_s_starting_at ---\\n        max_len_pal_s_starting_at = [0] * (s_N + 1) # index s_N for empty palindrome (len 0)\\n        if s_N > 0: # Only if s is not empty\\n            for k in range(s_N):\\n                current_max_len_for_k = 0\\n                for x in range(k, s_N): # x is end_idx\\n                    if is_palindrome_s[k][x]:\\n                        current_max_len_for_k = max(current_max_len_for_k, x - k + 1)\\n                max_len_pal_s_starting_at[k] = current_max_len_for_k\\n        \\n        # --- Step 4: Precompute max_len_pal_t_ending_at ---\\n        # Array index `idx_fixed = original_end_idx + 1`. `idx_fixed = 0` for empty palindrome.\\n        max_len_pal_t_ending_at_fixed = [0] * (t_N + 1)\\n        if t_N > 0: # Only if t is not empty\\n            for k in range(t_N): # k is end_idx\\n                current_max_len_for_k = 0\\n                for x in range(k + 1): # x is start_idx\\n                    if is_palindrome_t[x][k]:\\n                        current_max_len_for_k = max(current_max_len_for_k, k - x + 1)\\n                max_len_pal_t_ending_at_fixed[k+1] = current_max_len_for_k\\n\\n        # --- Step 5: Reverse t ---\\n        t_r = t[::-1]\\n\\n        # --- Step 6: Compute LCP_lengths table ---\\n        LCP_lengths = [[0 for _ in range(t_N + 1)] for _ in range(s_N + 1)]\\n        if s_N > 0 and t_N > 0: # Only if both s and t_r (i.e. t) are non-empty\\n            for r_idx in range(s_N - 1, -1, -1): # start_idx in s\\n                for c_idx in range(t_N - 1, -1, -1): # start_idx in t_r\\n                    if s[r_idx] == t_r[c_idx]:\\n                        LCP_lengths[r_idx][c_idx] = LCP_lengths[r_idx+1][c_idx+1] + 1\\n                    # else, LCP_lengths[r_idx][c_idx] remains 0 (from initialization)\\n        \\n        # --- Step 7: Iterate, calculate, and update max_overall_len ---\\n        if s_N > 0 and t_N > 0: # Only if both s and t are non-empty for Case 3\\n            for r_idx in range(s_N): # r_idx is start index i of A in s\\n                for c_idx in range(t_N): # c_idx is start index j of A^rev in t_r\\n                    L = LCP_lengths[r_idx][c_idx]\\n                    if L == 0: # A must be non-empty\\n                        continue\\n\\n                    # Case 3a: W = A A_t^rev. Length = 2*L\\n                    max_overall_len = max(max_overall_len, 2 * L)\\n\\n                    # Case 3b: W = A P_s A_t^rev\\n                    # P_s starts at s[r_idx+L].\\n                    idx_ps_starts = r_idx + L \\n                    # max_len_pal_s_starting_at[s_N] is 0, handles P_s being empty.\\n                    len_ps = max_len_pal_s_starting_at[idx_ps_starts] \\n                    max_overall_len = max(max_overall_len, 2 * L + len_ps)\\n                    \\n                    # Case 3c: W = A P_t A_t^rev\\n                    # A_t in original t is t[t_N-c_idx-L ... t_N-c_idx-1]\\n                    # P_t ends at index (t_N-c_idx-L) - 1 in original t.\\n                    idx_pt_ends = t_N - c_idx - L - 1\\n                    # map to fixed array index: (idx_pt_ends) + 1.\\n                    # if idx_pt_ends = -1 (P_t empty), then fixed_idx = 0, gives len_pt=0.\\n                    len_pt = max_len_pal_t_ending_at_fixed[idx_pt_ends + 1]\\n                    max_overall_len = max(max_overall_len, 2 * L + len_pt)\\n                \\n        return max_overall_len\"",
  "3622_14631217_python": "\"class Solution(object):\\n    def maxFrequency(self, nums, k, numOperations):\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        mn = min(nums)\\n        mx = max(nums)\\n        low = mn - k\\n        high = mx + k\\n        size = high - low + 1\\n        offset = -low\\n        freq = [0] * size\\n        for v in nums:\\n            freq[v + offset] += 1\\n        ps = [0] * (size + 1)\\n        for i in range(size):\\n            ps[i+1] = ps[i] + freq[i]\\n        res = 0\\n        for i in range(size):\\n            base = freq[i]\\n            L = i - k\\n            if L < 0:\\n                L = 0\\n            R = i + k\\n            if R >= size:\\n                R = size - 1\\n            total = ps[R+1] - ps[L]\\n            cand = total - base\\n            cur = base + (cand if cand < numOperations else numOperations)\\n            if cur > res:\\n                res = cur\\n        return res\\n\"",
  "2869_14631217_python-updated-time": "1747222255349",
  "2595_14631217_python-updated-time": "1747059076969",
  "455_14631217_python": "\"class Solution:\\n    def findContentChildren(self, g, s):\\n        g.sort()\\n        s.sort()\\n        i = j = 0\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i += 1\\n            j += 1\\n        return i\\n\"",
  "515_14631217_python": "\"class Solution:\\n    def largestValues(self, root):\\n        if not root:\\n            return []\\n        \\n        from collections import deque\\n        queue = deque([root])\\n        result = []\\n\\n        while queue:\\n            level_size = len(queue)\\n            max_val = float('-inf')\\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                max_val = max(max_val, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            result.append(max_val)\\n        \\n        return result\\n\"",
  "40_14631217_python": "\"class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \\\"\\\"\\\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n        candidates.sort()\\n\\n        def backtrack(start, path, total):\\n            if total == target:\\n                res.append(list(path))\\n                return\\n            if total > target:\\n                return\\n\\n            prev = -1\\n            for i in range(start, len(candidates)):\\n                if candidates[i] == prev:\\n                    continue\\n                path.append(candidates[i])\\n                backtrack(i + 1, path, total + candidates[i])\\n                path.pop()\\n                prev = candidates[i]\\n\\n        backtrack(0, [], 0)\\n        return res\\n\"",
  "552_14631217_python-updated-time": "1745447381465",
  "773_14631217_python-updated-time": "1745447571414",
  "543_14631217_python-updated-time": "1745447021091",
  "3548_14631217_python": "\"class Solution(object):\\n    def countGoodIntegers(self, n, k):\\n        # Precompute factorials up to n\\n        fact = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            fact[i] = fact[i - 1] * i\\n\\n        signatures = set()\\n        half = n // 2\\n        prefix = [0] * half\\n\\n        def gen_prefix(pos):\\n            if pos == half:\\n                if n % 2 == 0:\\n                    # build even‐length palindrome\\n                    digits = prefix + prefix[::-1]\\n                    x_mod = 0\\n                    for d in digits:\\n                        x_mod = (x_mod * 10 + d) % k\\n                    if x_mod == 0:\\n                        cnt = [0] * 10\\n                        for d in digits:\\n                            cnt[d] += 1\\n                        signatures.add(tuple(cnt))\\n                else:\\n                    # build odd‐length palindromes with every possible middle digit\\n                    for mid in range(10):\\n                        digits = prefix + [mid] + prefix[::-1]\\n                        x_mod = 0\\n                        for d in digits:\\n                            x_mod = (x_mod * 10 + d) % k\\n                        if x_mod == 0:\\n                            cnt = [0] * 10\\n                            for d in digits:\\n                                cnt[d] += 1\\n                            signatures.add(tuple(cnt))\\n                return\\n\\n            # choose digit for prefix[pos]\\n            for d in range(1 if pos == 0 else 0, 10):\\n                prefix[pos] = d\\n                gen_prefix(pos + 1)\\n\\n        gen_prefix(0)\\n\\n        # For each valid digit‐count signature, count all n‐digit numbers\\n        # with that multiset (minus those with leading zero)\\n        ans = 0\\n        for cnt in signatures:\\n            # total permutations = n! / (Π cnt[d]!)\\n            total = fact[n]\\n            for c in cnt:\\n                total //= fact[c]\\n\\n            # subtract those that start with zero\\n            bad = 0\\n            if cnt[0] > 0:\\n                bad = fact[n - 1] // fact[cnt[0] - 1]\\n                for d in range(1, 10):\\n                    bad //= fact[cnt[d]]\\n\\n            ans += total - bad\\n\\n        return ans\\n\"",
  "600_14631217_python-updated-time": "1745448554848",
  "41_14631217_python": "\"class Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n        \\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        \\n        return n + 1\\n\"",
  "3143_14631217_python": "\"class Solution(object):\\n    def getLongestSubsequence(self, words, groups):\\n        \\\"\\\"\\\"\\n        :type words: List[str]\\n        :type groups: List[int]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        n = len(words)\\n        best = []\\n        # Try every index as the start of the subsequence\\n        for i in range(n):\\n            seq = [i]\\n            last = groups[i]\\n            for j in range(i+1, n):\\n                if groups[j] != last:\\n                    seq.append(j)\\n                    last = groups[j]\\n            if len(seq) > len(best):\\n                best = seq\\n        # Map indices back to words\\n        return [words[i] for i in best]\\n\"",
  "799_14631217_python-updated-time": "1745877445851",
  "3708_14631217_python-updated-time": "1747656462008",
  "2176_14631217_python-updated-time": "1746720312369",
  "2249_14631217_python-updated-time": "1746802304465",
  "3518_14631217_python-updated-time": "1747571831186",
  "539_14631217_python-updated-time": "1745446934003",
  "1720_14631217_python": "\"class Solution:\\n    def minOperations(self, logs):\\n        depth = 0\\n        for op in logs:\\n            if op == \\\"../\\\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif op == \\\"./\\\":\\n                continue\\n            else:\\n                # any \\\"x/\\\" entry\\n                depth += 1\\n        return depth\\n\"",
  "2724_14631217_python": "\"from collections import Counter, defaultdict\\n\\nclass Solution:\\n    def findMatrix(self, nums):\\n        freq = Counter(nums)\\n        max_rows = max(freq.values())\\n        result = [[] for _ in range(max_rows)]\\n\\n        position = defaultdict(int)\\n        for num in nums:\\n            row = position[num]\\n            result[row].append(num)\\n            position[num] += 1\\n\\n        return result\\n\"",
  "3189_14631217_python": "\"class Solution(object):\\n    def findChampion(self, n, edges):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        indegree = [0] * n\\n        for u, v in edges:\\n            indegree[v] += 1\\n\\n        # collect all teams with no incoming edges\\n        sources = [i for i in range(n) if indegree[i] == 0]\\n        # if exactly one, that's the unique champion; otherwise no unique champion\\n        return sources[0] if len(sources) == 1 else -1\"",
  "3747_14631217_python-updated-time": "1747658950412",
  "1020_14631217_python": "\"class Solution:\\n    def maxTurbulenceSize(self, arr):\\n        n = len(arr)\\n        if n < 2:\\n            return n\\n\\n        inc = dec = 1\\n        max_len = 1\\n\\n        for i in range(1, n):\\n            if arr[i] > arr[i - 1]:\\n                inc = dec + 1\\n                dec = 1\\n            elif arr[i] < arr[i - 1]:\\n                dec = inc + 1\\n                inc = 1\\n            else:\\n                inc = dec = 1\\n            max_len = max(max_len, inc, dec)\\n\\n        return max_len\\n\"",
  "627_14631217_mysql": "\"UPDATE Salary\\nSET sex = IF(sex = 'm', 'f', 'm');\\n\"",
  "2649_14631217_python": "\"class Solution(object):\\n    def coloredCells(self, n):\\n        return 2 * (n - 1) * n + 1\\n\"",
  "1016_14631217_python": "\"from collections import defaultdict\\n\\nclass Solution:\\n    def subarraysDivByK(self, nums, k):\\n        count = defaultdict(int)\\n        count[0] = 1  # prefix sum % k == 0 initially\\n        prefix = 0\\n        result = 0\\n\\n        for num in nums:\\n            prefix += num\\n            mod = prefix % k\\n            if mod < 0:\\n                mod += k  # ensure mod is non-negative\\n\\n            result += count[mod]\\n            count[mod] += 1\\n\\n        return result\\n\"",
  "3514_14631217_python": "\"class Solution(object):\\n    def shortestDistanceAfterQueries(self, n, queries):\\n        \\\"\\\"\\\"\\n        n ≤ 1e5 , q ≤ 1e5\\n        time   :  O( n + q · α(n) )      (α = inverse Ackermann ≈ 4)\\n        memory :  O( n )\\n        \\\"\\\"\\\"\\n\\n        # ------------------------------------------------------------------\\n        #  Disjoint-set of *interval starts*\\n        #    parent[i]   – representative (leftmost start) of the interval\\n        #    end[i]      – right end of that interval     (only valid for rep)\\n        #    next_start[i] – the next *start index* to the right (or n)\\n        #\\n        #  Initially we have chain edges only:\\n        #     intervals 0→1, 1→2, …, n-2→n-1       (n-1 intervals)\\n        # ------------------------------------------------------------------\\n        parent      = list(range(n))             # DSU parent\\n        end         = [i + 1 for i in range(n)]  # right ends\\n        end[-1]     = n - 1                      # last city has no edge\\n        next_start  = [i + 1 for i in range(n)]  # linked list of starts\\n        next_start[-1] = n                       # sentinel\\n\\n        # `reach[u]` = furthest city that *node u* can reach in one edge\\n        reach = end[:]                           # start with the chain edges\\n\\n        intervals = n - 1                        # current path length\\n\\n        # ---------- DSU find with path-compression -------------------------\\n        def find(x):\\n            while parent[x] != x:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n\\n        # ---------- next live interval start to the right of x -------------\\n        def next_live(x):\\n            y = next_start[x]\\n            while y < n and parent[y] != y:      # skip deleted starts\\n                next_start[x] = next_start[y]    # path-compression\\n                y = next_start[x]\\n            return y                             # n means “none”\\n\\n        # ---------------------- process every query ------------------------\\n        ans = []\\n        for u, v in queries:\\n\\n            # 1. If the shortcut does not improve reach[u] → nothing changes\\n            if v <= reach[u]:\\n                ans.append(intervals)\\n                continue\\n            reach[u] = v                         # store the new edge\\n\\n            # 2. Locate the interval that *contains* u  (its representative)\\n            s = find(u)\\n\\n            # 3. If the shortcut ends inside the same interval, only extend\\n            #    its right end; the number of intervals is unchanged.\\n            if v <= end[s]:\\n                end[s] = v\\n                ans.append(intervals)\\n                continue\\n\\n            # 4. Extend the interval’s right end to v and\\n            #    *merge* every following interval whose start < new end.\\n            end[s] = v\\n            t = next_live(s)\\n            while t < n and t < end[s]:\\n                #   merge interval t into s\\n                end[s]      = max(end[s], end[t])\\n                parent[t]   = s\\n                next_start[s] = next_start[t]    # splice t out of the list\\n                intervals  -= 1                  # one interval disappears\\n                t = next_live(s)                 # continue to the next start\\n\\n            ans.append(intervals)\\n\\n        return ans\\n\"",
  "2412_14631217_python-updated-time": "1746907300570",
  "2580_14631217_python-updated-time": "1747057608179",
  "1195_14631217_python-updated-time": "1746108435930",
  "2068_14631217_python": "\"# Definition of the trie node for bitwise operations\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.child0 = None\\n        self.child1 = None\\n        self.count = 0\\n\\nclass Solution(object):\\n    def maxGeneticDifference(self, parents, queries):\\n        import sys\\n        sys.setrecursionlimit(10**7)\\n\\n        n = len(parents)\\n        # Build adjacency list and find root\\n        children = [[] for _ in range(n)]\\n        root = -1\\n        for v, p in enumerate(parents):\\n            if p == -1:\\n                root = v\\n            else:\\n                children[p].append(v)\\n\\n        # Group queries by node\\n        qs = [[] for _ in range(n)]\\n        for i, (node, val) in enumerate(queries):\\n            qs[node].append((i, val))\\n\\n        ans = [0] * len(queries)\\n\\n        # Parameters for our bitwise trie\\n        MAXB = 18  # enough for values up to ~2*10^5\\n\\n        # Initialize the trie\\n        trie_root = TrieNode()\\n\\n        # Insert x into the trie\\n        def trie_insert(x):\\n            node = trie_root\\n            node.count += 1\\n            for b in range(MAXB - 1, -1, -1):\\n                bit = (x >> b) & 1\\n                if bit == 0:\\n                    if not node.child0:\\n                        node.child0 = TrieNode()\\n                    node = node.child0\\n                else:\\n                    if not node.child1:\\n                        node.child1 = TrieNode()\\n                    node = node.child1\\n                node.count += 1\\n\\n        # Delete x from the trie\\n        def trie_delete(x):\\n            node = trie_root\\n            node.count -= 1\\n            for b in range(MAXB - 1, -1, -1):\\n                bit = (x >> b) & 1\\n                if bit == 0:\\n                    node = node.child0\\n                else:\\n                    node = node.child1\\n                node.count -= 1\\n\\n        # Query max XOR with x over all values in the trie\\n        def trie_max_xor(x):\\n            node = trie_root\\n            res = 0\\n            for b in range(MAXB - 1, -1, -1):\\n                bit = (x >> b) & 1\\n                # prefer opposite bit if available\\n                if bit == 0:\\n                    if node.child1 and node.child1.count > 0:\\n                        res |= (1 << b)\\n                        node = node.child1\\n                    else:\\n                        node = node.child0\\n                else:\\n                    if node.child0 and node.child0.count > 0:\\n                        res |= (1 << b)\\n                        node = node.child0\\n                    else:\\n                        node = node.child1\\n            return res\\n\\n        # DFS to maintain the trie along the root→current path\\n        def dfs(u):\\n            # insert this node's value\\n            trie_insert(u)\\n            # answer this node's queries\\n            for qi, qv in qs[u]:\\n                ans[qi] = trie_max_xor(qv)\\n            # recurse children\\n            for v in children[u]:\\n                dfs(v)\\n            # on backtrack, remove this node's value\\n            trie_delete(u)\\n\\n        # run DFS from the root\\n        dfs(root)\\n        return ans\\n\"",
  "2677_14631217_python": "\"from collections import deque\\n\\nclass TreeNode(object):\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        if not root:\\n            return None\\n\\n        root.val = 0\\n        queue = deque([root])\\n\\n        while queue:\\n            next_level = []\\n            child_sum = 0\\n            parent_map = {}\\n\\n            for node in queue:\\n                if node.left:\\n                    next_level.append(node.left)\\n                    child_sum += node.left.val\\n                    parent_map[node.left] = node\\n                if node.right:\\n                    next_level.append(node.right)\\n                    child_sum += node.right.val\\n                    parent_map[node.right] = node\\n\\n            sibling_sum = {}\\n            for child, parent in parent_map.items():\\n                if parent not in sibling_sum:\\n                    s = 0\\n                    if parent.left:\\n                        s += parent.left.val\\n                    if parent.right:\\n                        s += parent.right.val\\n                    sibling_sum[parent] = s\\n\\n            for child in next_level:\\n                parent = parent_map[child]\\n                child.val = child_sum - sibling_sum[parent]\\n\\n            queue = deque(next_level)\\n\\n        return root\"",
  "602_14631217_mysql-updated-time": "1745448616309",
  "90_14631217_python": "\"class Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        result = []\\n        nums.sort()\\n        \\n        def backtrack(start, path):\\n            result.append(list(path))\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                path.append(nums[i])\\n                backtrack(i + 1, path)\\n                path.pop()\\n        \\n        backtrack(0, [])\\n        return result\\n\"",
  "1302_14631217_python-updated-time": "1746638924513",
  "2550_14631217_python-updated-time": "1746968353878",
  "172_14631217_python-updated-time": "1745092065837",
  "2373_14631217_python": "\"class Solution:\\n    def discountPrices(self, sentence, discount):\\n        parts = sentence.split(\\\" \\\")\\n        factor = (100 - discount) / 100.0\\n        \\n        for i, w in enumerate(parts):\\n            if len(w) >= 2 and w[0] == '$' and w[1:].isdigit():\\n                price = int(w[1:])\\n                new_price = price * factor\\n                # Use format() instead of f-string\\n                parts[i] = \\\"$\\\" + \\\"{:.2f}\\\".format(new_price)\\n        \\n        return \\\" \\\".join(parts)\\n\"",
  "1806_14631217_python-updated-time": "1746453065413",
  "2087_14631217_mysql": "\"SELECT\\n    s.user_id,\\n    -- If the user has no confirmation records, rate is 0.00\\n    IFNULL(\\n      ROUND(c.confirmed_count / c.total_count, 2),\\n      0.00\\n    ) AS confirmation_rate\\nFROM Signups AS s\\nLEFT JOIN (\\n    SELECT\\n        user_id,\\n        COUNT(*)           AS total_count,\\n        SUM(action = 'confirmed') AS confirmed_count\\n    FROM Confirmations\\n    GROUP BY user_id\\n) AS c\\n  ON s.user_id = c.user_id;\\n\"",
  "2838_14631217_python-updated-time": "1747140613089",
  "316_14631217_python": "\"class Solution(object):\\n    def removeDuplicateLetters(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        last_index = {c: i for i, c in enumerate(s)}\\n        stack = []\\n        seen = set()\\n        \\n        for i, c in enumerate(s):\\n            if c not in seen:\\n                while stack and c < stack[-1] and i < last_index[stack[-1]]:\\n                    seen.remove(stack.pop())\\n                stack.append(c)\\n                seen.add(c)\\n        \\n        return ''.join(stack)\\n\"",
  "2589_14631217_python-updated-time": "1747058037514",
  "423_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def originalDigits(self, s):\\n        count = Counter(s)\\n        out = [0] * 10\\n        \\n        out[0] = count['z']\\n        out[2] = count['w']\\n        out[4] = count['u']\\n        out[6] = count['x']\\n        out[8] = count['g']\\n        \\n        out[3] = count['h'] - out[8]\\n        out[5] = count['f'] - out[4]\\n        out[7] = count['s'] - out[6]\\n        \\n        out[1] = count['o'] - out[0] - out[2] - out[4]\\n        out[9] = count['i'] - out[5] - out[6] - out[8]\\n        \\n        res = []\\n        for i in range(10):\\n            res.append(str(i) * out[i])\\n        \\n        return ''.join(res)\\n\"",
  "2051_14631217_python-updated-time": "1746637736451",
  "227_14631217_python-updated-time": "1745246999908",
  "164_14631217_python-updated-time": "1745091351526",
  "2173_14631217_python": "\"class Solution(object):\\n    def countValidWords(self, sentence):\\n        \\\"\\\"\\\"\\n        :type sentence: str\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        def is_valid(tok):\\n            # Empty token not considered\\n            if not tok:\\n                return False\\n\\n            hyphens = 0\\n            punctuations = 0\\n            n = len(tok)\\n\\n            for i, ch in enumerate(tok):\\n                if ch.isdigit():\\n                    return False  # rule 1: no digits\\n\\n                if ch == '-':\\n                    hyphens += 1\\n                    # rule 2: at most one, and must be surrounded by letters\\n                    if hyphens > 1:\\n                        return False\\n                    if i == 0 or i == n - 1:\\n                        return False\\n                    if not (tok[i-1].isalpha() and tok[i+1].isalpha()):\\n                        return False\\n\\n                if ch in ('!', '.', ','):\\n                    punctuations += 1\\n                    # rule 3: at most one punctuation, and only at end\\n                    if punctuations > 1:\\n                        return False\\n                    if i != n - 1:\\n                        return False\\n\\n                # letters are always fine\\n\\n            return True\\n\\n        tokens = sentence.split()\\n        count = 0\\n        for tok in tokens:\\n            if is_valid(tok):\\n                count += 1\\n        return count\\n\"",
  "1461_14631217_python": "\"class Solution(object):\\n    def countOrders(self, n):\\n        MOD = 10**9 + 7\\n        res = 1\\n        for i in range(1, n + 1):\\n            res = res * i * (2 * i - 1) % MOD\\n        return res\\n\"",
  "2041_14631217_mysql-updated-time": "1746626530379",
  "1510_14631217_python-updated-time": "1746346250467",
  "3407_14631217_python-updated-time": "1747424450313",
  "2508_14631217_python-updated-time": "1746966982666",
  "1720_14631217_python-updated-time": "1746443717957",
  "2060_14631217_python": "\"# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def canMerge(self, trees):\\n        # Map root value to tree root\\n        root_map = {t.val: t for t in trees}\\n        n = len(trees)\\n\\n        # Compute indegree for each root based on child pointers\\n        indegree = {}\\n        for t in trees:\\n            for ch in (t.left, t.right):\\n                if ch and ch.val in root_map:\\n                    indegree[ch.val] = indegree.get(ch.val, 0) + 1\\n\\n        # Identify the unique starting root (indegree 0)\\n        start = None\\n        for t in trees:\\n            if indegree.get(t.val, 0) == 0:\\n                if start is not None:\\n                    return None\\n                start = t\\n        if start is None:\\n            return None\\n\\n        # Merge subtrees by attaching when encountering matching leaves\\n        used = set([start.val])\\n        def dfs(node):\\n            if not node:\\n                return\\n            if not node.left and not node.right:\\n                v = node.val\\n                if v in root_map and v not in used:\\n                    used.add(v)\\n                    sub = root_map[v]\\n                    node.left = sub.left\\n                    node.right = sub.right\\n            dfs(node.left)\\n            dfs(node.right)\\n\\n        dfs(start)\\n\\n        # All trees must be merged\\n        if len(used) != n:\\n            return None\\n\\n        # Validate BST property and count nodes by inorder traversal\\n        prev = float(\\\"-inf\\\")\\n        count = 0\\n        stack = []\\n        node = start\\n        while stack or node:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            if node.val <= prev:\\n                return None\\n            prev = node.val\\n            count += 1\\n            node = node.right\\n\\n        # Expected total nodes = sum of sizes minus (n-1) merges\\n        total_nodes = 0\\n        for t in trees:\\n            sz = 1\\n            if t.left: sz += 1\\n            if t.right: sz += 1\\n            total_nodes += sz\\n        total_nodes -= (n - 1)\\n\\n        if count != total_nodes:\\n            return None\\n\\n        return start\\n\"",
  "229_14631217_python": "\"class Solution(object):\\n    def majorityElement(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        if not nums:\\n            return []\\n        \\n        # First pass: find possible candidates\\n        count1, count2 = 0, 0\\n        candidate1, candidate2 = None, None\\n        \\n        for num in nums:\\n            if candidate1 == num:\\n                count1 += 1\\n            elif candidate2 == num:\\n                count2 += 1\\n            elif count1 == 0:\\n                candidate1, count1 = num, 1\\n            elif count2 == 0:\\n                candidate2, count2 = num, 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n        \\n        # Second pass: verify the candidates\\n        result = []\\n        n = len(nums)\\n        if nums.count(candidate1) > n // 3:\\n            result.append(candidate1)\\n        if candidate2 != candidate1 and nums.count(candidate2) > n // 3:\\n            result.append(candidate2)\\n        \\n        return result\\n\"",
  "3181_14631217_python": "\"class Solution:\\n    def leftmostBuildingQueries(self, heights, queries):\\n        n = len(heights)\\n        # build segment tree for range‐max\\n        size = 1\\n        while size < n:\\n            size <<= 1\\n        seg = [0] * (2*size)\\n        for i, h in enumerate(heights):\\n            seg[size+i] = h\\n        for i in range(size-1, 0, -1):\\n            seg[i] = max(seg[2*i], seg[2*i+1])\\n\\n        # find first index >= L with heights[idx] > H\\n        def find_first_greater(L, H, node, lo, hi):\\n            if hi < L or seg[node] <= H:\\n                return -1\\n            if lo == hi:\\n                return lo\\n            mid = (lo + hi) // 2\\n            res = find_first_greater(L, H, 2*node, lo, mid)\\n            if res != -1:\\n                return res\\n            return find_first_greater(L, H, 2*node+1, mid+1, hi)\\n\\n        ans = []\\n        for a, b in queries:\\n            if a == b:\\n                ans.append(a)\\n                continue\\n\\n            ha, hb = heights[a], heights[b]\\n            candidates = []\\n\\n            # Bob moves to Alice?\\n            if a > b and ha > hb:\\n                candidates.append(a)\\n            # Alice moves to Bob?\\n            if b > a and hb > ha:\\n                candidates.append(b)\\n\\n            # both must move forward\\n            L = max(a, b) + 1\\n            if L < n:\\n                k = find_first_greater(L, max(ha, hb), 1, 0, size-1)\\n                if 0 <= k < n:\\n                    candidates.append(k)\\n\\n            ans.append(min(candidates) if candidates else -1)\\n\\n        return ans\"",
  "2803_14631217_python": "\"import heapq\\n\\nclass Solution:\\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        # Build adjacency list\\n        adj = [[] for _ in range(n)]\\n        for idx, (u, v, w) in enumerate(edges):\\n            adj[u].append((v, idx))\\n            adj[v].append((u, idx))\\n\\n        INF = 10**18\\n        MAXW = 2 * 10**9\\n\\n        # 1) Compute the shortest distance if every –1 edge had weight = 1\\n        def dijkstra_min():\\n            dist = [INF] * n\\n            dist[source] = 0\\n            pq = [(0, source)]\\n            while pq:\\n                d, u = heapq.heappop(pq)\\n                if d > dist[u]:\\n                    continue\\n                for v, idx in adj[u]:\\n                    w = edges[idx][2]\\n                    cost = w if w != -1 else 1\\n                    nd = d + cost\\n                    if nd < dist[v]:\\n                        dist[v] = nd\\n                        heapq.heappush(pq, (nd, v))\\n            return dist\\n\\n        dist_min = dijkstra_min()[destination]\\n        if dist_min > target:\\n            return []  # even with all –1 set to 1, path too long\\n\\n        # 2) Compute the shortest distance if every –1 edge is unusable (weight = INF)\\n        def dijkstra_fixed(start):\\n            dist = [INF] * n\\n            dist[start] = 0\\n            pq = [(0, start)]\\n            while pq:\\n                d, u = heapq.heappop(pq)\\n                if d > dist[u]:\\n                    continue\\n                for v, idx in adj[u]:\\n                    w = edges[idx][2]\\n                    cost = w if w != -1 else INF\\n                    nd = d + cost\\n                    if nd < dist[v]:\\n                        dist[v] = nd\\n                        heapq.heappush(pq, (nd, v))\\n            return dist\\n\\n        dist_fixed = dijkstra_fixed(source)[destination]\\n        if dist_fixed < target:\\n            return []  # even ignoring –1 edges, path is too short\\n\\n        # 3) If fixed-only path equals target, assign all –1 edges to a large weight\\n        if dist_fixed == target:\\n            result = []\\n            for u, v, w in edges:\\n                if w == -1:\\n                    result.append([u, v, MAXW])\\n                else:\\n                    result.append([u, v, w])\\n            return result\\n\\n        # 4) Otherwise, we know dist_min <= target < dist_fixed.\\n        #    Compute dist_to_dest ignoring –1 edges for slack calculation.\\n        dist_to_dest = [INF] * n\\n        dist_to_dest[destination] = 0\\n        pq = [(0, destination)]\\n        while pq:\\n            d, u = heapq.heappop(pq)\\n            if d > dist_to_dest[u]:\\n                continue\\n            for v, idx in adj[u]:\\n                w = edges[idx][2]\\n                cost = w if w != -1 else INF\\n                nd = d + cost\\n                if nd < dist_to_dest[v]:\\n                    dist_to_dest[v] = nd\\n                    heapq.heappush(pq, (nd, v))\\n\\n        # 5) Run Dijkstra from source, dynamically assigning –1 edges to meet the target\\n        dist = [INF] * n\\n        dist[source] = 0\\n        assign = {}  # idx -> assigned weight for –1 edges\\n        pq = [(0, source)]\\n        while pq:\\n            d, u = heapq.heappop(pq)\\n            if d > dist[u]:\\n                continue\\n            for v, idx in adj[u]:\\n                orig = edges[idx][2]\\n                if orig != -1:\\n                    cost = orig\\n                else:\\n                    # choose x so that d + x + dist_to_dest[v] == target\\n                    slack = target - d - dist_to_dest[v]\\n                    cost = slack if slack > 1 else 1\\n                nd = d + cost\\n                if nd < dist[v] and nd <= target:\\n                    dist[v] = nd\\n                    heapq.heappush(pq, (nd, v))\\n                    if orig == -1:\\n                        assign[idx] = cost\\n\\n        if dist[destination] != target:\\n            return []  # could not make it exactly target\\n\\n        # 6) Build the answer, using assigned weights for used –1 edges,\\n        #    and MAXW for all other –1 edges\\n        result = []\\n        for idx, (u, v, w) in enumerate(edges):\\n            if w == -1:\\n                w_new = assign.get(idx, MAXW)\\n                result.append([u, v, w_new])\\n            else:\\n                result.append([u, v, w])\\n        return result\\n\"",
  "3768_14631217_python": "\"class Solution(object):\\n    def hasSameDigits(self, s):\\n        \\\"\\\"\\\"\\n        :type s: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        # convert to list of ints for faster arithmetic\\n        arr = list(map(int, s))\\n        # keep collapsing until length is 2\\n        while len(arr) > 2:\\n            # each new digit is sum of consecutive pair mod 10\\n            arr = [(arr[i] + arr[i+1]) % 10 for i in range(len(arr) - 1)]\\n        # check if the final two are equal\\n        return arr[0] == arr[1]\\n\"",
  "2726_14631217_python-updated-time": "1747134734949",
  "3271_14631217_python": "\"class Solution(object):\\n    def countOfPairs(self, n, x, y):\\n        res = [0] * n\\n        for i in range(1, n + 1):\\n            for j in range(1, n + 1):\\n                if i == j:\\n                    continue\\n                d1 = abs(i - j)\\n                d2 = abs(i - x) + 1 + abs(y - j)\\n                d3 = abs(i - y) + 1 + abs(x - j)\\n                d = min(d1, d2, d3)\\n                res[d - 1] += 1\\n        return res\\n\"",
  "839_14631217_python-updated-time": "1745878910472",
  "3550_14631217_python": "\"class Solution(object):\\n    def maximumValueSum(self, board):\\n        \\\"\\\"\\\"\\n        :type board: List[List[int]]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        m, n = len(board), len(board[0])\\n        \\n        # Precompute, for every pair of distinct rows (r1<r2),\\n        # an array best12[c]: the best sum of placing rooks in r1 and r2\\n        # on two distinct columns != c.\\n        best12 = {}\\n        for r1 in range(m):\\n            for r2 in range(r1+1, m):\\n                # Extract top-3 entries (value, col) from each row\\n                A = sorted(((board[r1][c], c) for c in range(n)),\\n                           reverse=True)[:3]\\n                B = sorted(((board[r2][c], c) for c in range(n)),\\n                           reverse=True)[:3]\\n                \\n                arr = [0]*n\\n                for forbid in range(n):\\n                    # build the filtered top-2 lists excluding 'forbid'\\n                    A2 = [(v,c) for v,c in A if c != forbid]\\n                    B2 = [(v,c) for v,c in B if c != forbid]\\n                    # must have at least two columns available overall\\n                    # and each list has length ≥ 2 since n ≥ 3\\n                    va1, i1 = A2[0]\\n                    vb1, j1 = B2[0]\\n                    if i1 != j1:\\n                        arr[forbid] = va1 + vb1\\n                    else:\\n                        va2, i2 = A2[1]\\n                        vb2, j2 = B2[1]\\n                        arr[forbid] = max(va1 + vb2, va2 + vb1)\\n                best12[(r1,r2)] = arr\\n        \\n        answer = -10**30\\n        # Now pick any 3 distinct rows r1<r2<r3.\\n        # For each column c3 assigned to r3, we can add best12[(r1,r2)][c3].\\n        for r1 in range(m):\\n            for r2 in range(r1+1, m):\\n                arr12 = best12[(r1,r2)]\\n                for r3 in range(r2+1, m):\\n                    # scan every possible column c3\\n                    row3 = board[r3]\\n                    best = -10**30\\n                    for c3 in range(n):\\n                        s = arr12[c3] + row3[c3]\\n                        if s > best:\\n                            best = s\\n                    if best > answer:\\n                        answer = best\\n        \\n        return answer\\n\"",
  "1621_14631217_python": "\"class Solution(object):\\n    def numSubseq(self, nums, target):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        MOD = 10**9 + 7\\n        nums.sort()\\n        n = len(nums)\\n\\n        # Precompute powers of 2\\n        pow2 = [1] * n\\n        for i in range(1, n):\\n            pow2[i] = (pow2[i - 1] * 2) % MOD\\n\\n        res = 0\\n        left, right = 0, n - 1\\n\\n        while left <= right:\\n            if nums[left] + nums[right] <= target:\\n                res = (res + pow2[right - left]) % MOD\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        return res\\n\"",
  "3414_14631217_python": "\"class Solution(object):\\n    def waysToReachStair(self, k):\\n        \\\"\\\"\\\"\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Helper to compute binomial coefficient C(n, r)\\n        def comb(n, r):\\n            if r < 0 or r > n:\\n                return 0\\n            # take advantage of symmetry\\n            r = min(r, n - r)\\n            res = 1\\n            for i in range(1, r+1):\\n                # multiply by (n−r+i) then divide by i,\\n                # doing integer arithmetic to stay exact\\n                res = res * (n - r + i) // i\\n            return res\\n\\n        ans = 0\\n        U = 0\\n        # We try using U upward‐moves in total.\\n        # They contribute sum_{j=0..U−1} 2^j = 2^U−1 upward steps,\\n        # and D downward moves subtracting 1 each.\\n        # Final position = 1 + (2^U−1) − D = 2^U − D must equal k,\\n        # so D = 2^U − k.  We only count it if 0 <= D <= U+1,\\n        # and choose positions for D non‐consecutive downs among U+1 slots:\\n        # C(U+1, D).  Once 2^U − k > U+1, no larger U can work.\\n        while True:\\n            D = (1 << U) - k\\n            if D > U + 1:\\n                break\\n            if D >= 0:\\n                ans += comb(U + 1, D)\\n            U += 1\\n\\n        return ans\\n\"",
  "3033_14631217_python": "\"class Solution(object):\\n    def minOperations(self, s1, s2, x):\\n       # Build list of mismatch positions\\n        d = [i for i, (a, b) in enumerate(zip(s1, s2)) if a != b]\\n        m = len(d)\\n        if m % 2:\\n            return -1\\n        \\n        # If no mismatches, cost is 0\\n        if m == 0:\\n            return 0\\n        \\n        # Precompute pairwise costs: cost to flip exactly positions i and j\\n        # via adjacent flips (distance) or via the x-cost op.\\n        # cost(i,j) = min(x, |d[j] - d[i]|)\\n        cost = [[0] * m for _ in range(m)]\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                dist = d[j] - d[i]\\n                cost[i][j] = cost[j][i] = min(x, dist)\\n        \\n        # dp[i][j] = minimum cost to perfectly match (clear) mismatches\\n        # in the subarray d[i..j], inclusive. Only defined when (j-i+1) is even.\\n        INF = 10**18\\n        dp = [[0] * m for _ in range(m)]\\n        \\n        # Initialize dp for all even-length segments\\n        # length = number of elements in segment\\n        for length in range(2, m+1, 2):\\n            for i in range(0, m - length + 1):\\n                j = i + length - 1\\n                # Option 1: pair ends (i, j) together\\n                best = dp[i+1][j-1] + cost[i][j]\\n                # Option 2: split the segment into two even parts at k\\n                # k runs over odd offsets so that both subsegments are even-length\\n                for k in range(i+1, j, 2):\\n                    val = dp[i][k] + dp[k+1][j]\\n                    if val < best:\\n                        best = val\\n                dp[i][j] = best\\n        \\n        return dp[0][m-1]\\n\"",
  "3572_14631217_python-updated-time": "1747572831404",
  "299_14631217_python-updated-time": "1745255588700",
  "2704_14631217_python-updated-time": "1747065421216",
  "942_14631217_python": "\"class Solution:\\n    def superpalindromesInRange(self, left, right):\\n        L, R = int(left), int(right)\\n        ans = 0\\n        limit = int(R**0.5) + 1\\n\\n        # odd-length palindromic roots\\n        for k in range(1, 100000):\\n            s = str(k)\\n            p = int(s + s[-2::-1])   # mirror all but the last digit\\n            if p > limit:\\n                break\\n            sq = p * p\\n            if L <= sq <= R and str(sq) == str(sq)[::-1]:\\n                ans += 1\\n\\n        # even-length palindromic roots\\n        for k in range(1, 100000):\\n            s = str(k)\\n            p = int(s + s[::-1])     # mirror the whole string\\n            if p > limit:\\n                break\\n            sq = p * p\\n            if L <= sq <= R and str(sq) == str(sq)[::-1]:\\n                ans += 1\\n\\n        return ans\\n\"",
  "858_14631217_python-updated-time": "1745879336184",
  "3475_14631217_python-updated-time": "1747485414249",
  "1679_14631217_python": "\"class Solution(object):\\n    def findLengthOfShortestSubarray(self, arr):\\n        n = len(arr)\\n        # find longest non-decreasing prefix\\n        left = 0\\n        while left + 1 < n and arr[left] <= arr[left+1]:\\n            left += 1\\n        if left == n - 1:\\n            return 0\\n        # find longest non-decreasing suffix\\n        right = n - 1\\n        while right - 1 >= 0 and arr[right-1] <= arr[right]:\\n            right -= 1\\n        # remove suffix or prefix entirely\\n        ans = min(n - 1 - left, right)\\n        # try merging prefix and suffix\\n        i, j = 0, right\\n        while i <= left and j < n:\\n            if arr[i] <= arr[j]:\\n                ans = min(ans, j - i - 1)\\n                i += 1\\n            else:\\n                j += 1\\n        return ans\\n\"",
  "2091_14631217_python": "\"from array import array\\n\\nclass Solution(object):\\n    def numberOfCombinations(self, num):\\n        mod = 10**9 + 7\\n        n = len(num)\\n        if n == 0 or num[0] == '0':\\n            return 0\\n\\n        # 1) Build LCP table (size (n+1)x(n+1)) using 16-bit ints\\n        #    lcp[i][j] = length of longest common prefix of num[i:] and num[j:]\\n        lcp = [array('H', [0]) * (n+1) for _ in range(n+1)]\\n        for i in range(n-1, -1, -1):\\n            row_i    = lcp[i]\\n            row_ip1  = lcp[i+1]\\n            num_i    = num[i]\\n            for j in range(n-1, -1, -1):\\n                if num_i == num[j]:\\n                    row_i[j] = row_ip1[j+1] + 1\\n\\n        def le(i, j, length):\\n            # return True if num[i:i+length] <= num[j:j+length]\\n            common = lcp[i][j]\\n            if common >= length:\\n                return True\\n            return num[i+common] < num[j+common]\\n\\n        # 2) prefix[i][k] = sum of dp[i][1..k], stored as 32-bit ints\\n        prefix = [array('I', [0]) * (n+1) for _ in range(n+1)]\\n\\n        # 3) Fill DP by increasing i = end of string\\n        for i in range(1, n+1):\\n            row_i = prefix[i]\\n            for length in range(1, i+1):\\n                j = i - length\\n                ways = 0\\n                if num[j] != '0':\\n                    if j == 0:\\n                        # the very first block\\n                        ways = 1\\n                    else:\\n                        # sum of all dp[j][ℓ'] for ℓ' < length\\n                        max_short = length - 1 if length - 1 <= j else j\\n                        ways = prefix[j][max_short]\\n                        # plus same-length case if non-decreasing\\n                        if j >= length and le(j-length, j, length):\\n                            dp_j_len = prefix[j][length] - prefix[j][length-1]\\n                            ways = (ways + dp_j_len) % mod\\n\\n                # build prefix sum for this row\\n                row_i[length] = (row_i[length-1] + ways) % mod\\n\\n        # answer is sum of dp[n][1..n], i.e. prefix[n][n]\\n        return prefix[n][n]\\n\"",
  "2197_14631217_python": "\"class Solution:\\n    def decodeCiphertext(self, encodedText, rows):\\n        \\\"\\\"\\\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \\\"\\\"\\\"\\n        if rows == 1 or not encodedText:\\n            return encodedText\\n        \\n        n = len(encodedText)\\n        cols = n // rows\\n        \\n        # 1) Build the matrix row-wise\\n        M = [list(encodedText[i*cols:(i+1)*cols]) for i in range(rows)]\\n        \\n        # 2) Read out along the slanted diagonals\\n        res = []\\n        for start_col in range(cols):\\n            r, c = 0, start_col\\n            while r < rows and c < cols:\\n                res.append(M[r][c])\\n                r += 1\\n                c += 1\\n        \\n        # 3) Strip any trailing spaces and return\\n        return \\\"\\\".join(res).rstrip()\\n\"",
  "1499_14631217_python": "\"import heapq\\n\\nclass Solution(object):\\n    def maxPerformance(self, n, speed, efficiency, k):\\n        MOD = 10**9 + 7\\n        engineers = sorted(zip(efficiency, speed), reverse=True)\\n        max_perf = total_speed = 0\\n        heap = []\\n\\n        for e, s in engineers:\\n            heapq.heappush(heap, s)\\n            total_speed += s\\n            if len(heap) > k:\\n                total_speed -= heapq.heappop(heap)\\n            max_perf = max(max_perf, total_speed * e)\\n\\n        return max_perf % MOD\\n\"",
  "1224_14631217_python": "\"class Solution:\\n    def minFallingPathSum(self, grid):\\n        n = len(grid)\\n        dp = grid[0][:]\\n\\n        for i in range(1, n):\\n            new_dp = [0] * n\\n            # Find the min and second min from the previous row\\n            min1, min2 = float('inf'), float('inf')\\n            idx1 = -1\\n\\n            for j in range(n):\\n                if dp[j] < min1:\\n                    min2 = min1\\n                    min1 = dp[j]\\n                    idx1 = j\\n                elif dp[j] < min2:\\n                    min2 = dp[j]\\n\\n            for j in range(n):\\n                if j == idx1:\\n                    new_dp[j] = grid[i][j] + min2\\n                else:\\n                    new_dp[j] = grid[i][j] + min1\\n\\n            dp = new_dp\\n\\n        return min(dp)\\n\"",
  "327_14631217_python-updated-time": "1745256384834",
  "1799_14631217_python": "\"from itertools import combinations\\n\\nclass Solution(object):\\n    def minimumIncompatibility(self, nums, k):\\n        n = len(nums)\\n        group = n // k\\n        # precompute valid subsets of size 'group' and their incompatibility\\n        subsets = {}\\n        for comb in combinations(range(n), group):\\n            seen = set()\\n            valid = True\\n            for i in comb:\\n                if nums[i] in seen:\\n                    valid = False\\n                    break\\n                seen.add(nums[i])\\n            if not valid:\\n                continue\\n            mask = 0\\n            for i in comb:\\n                mask |= 1 << i\\n            vals = [nums[i] for i in comb]\\n            subsets[mask] = max(vals) - min(vals)\\n\\n        full = (1 << n) - 1\\n        dp = {0: 0}\\n        for mask in range(full + 1):\\n            if mask not in dp:\\n                continue\\n            cnt = bin(mask).count('1')\\n            if cnt == n:\\n                continue\\n            if cnt % group != 0:\\n                continue\\n            base = dp[mask]\\n            for sm, inc in subsets.items():\\n                if mask & sm == 0:\\n                    nxt = mask | sm\\n                    dp[nxt] = min(dp.get(nxt, float('inf')), base + inc)\\n\\n        return dp.get(full, -1)\\n\"",
  "3840_14631217_python": "\"class SegmentTree:\\n    def __init__(self, data, k):\\n        \\\"\\\"\\\"\\n        data: list of initial values\\n        k: the modulus\\n        \\\"\\\"\\\"\\n        self.n = len(data)\\n        self.k = k\\n        self.size = 1\\n        while self.size < self.n:\\n            self.size *= 2\\n        # Each node stores (prod, cnt_list)\\n        # We'll use 1-indexed tree array of length 2*self.size\\n        self.tree = [None] * (2*self.size)\\n        # Build leaves\\n        for i in range(self.size):\\n            if i < self.n:\\n                pv = data[i] % k\\n                cnt = [0]*k\\n                cnt[pv] = 1\\n                self.tree[self.size + i] = (pv, cnt)\\n            else:\\n                # dummy beyond n: treat as empty segment (prod=1, no prefixes)\\n                self.tree[self.size + i] = (1, [0]*k)\\n        # Build internal nodes\\n        for idx in range(self.size-1, 0, -1):\\n            self.tree[idx] = self._merge(self.tree[2*idx], self.tree[2*idx+1])\\n\\n    def _merge(self, left, right):\\n        \\\"\\\"\\\"Merge two nodes (prodL, cntL), (prodR, cntR).\\\"\\\"\\\"\\n        prodL, cntL = left\\n        prodR, cntR = right\\n        k = self.k\\n        # combined product\\n        prod = (prodL * prodR) % k\\n        # combined counts\\n        cnt = [0]*k\\n        # 1) all prefixes entirely in L\\n        for t in range(k):\\n            cnt[t] += cntL[t]\\n        # 2) prefixes that cross into R:\\n        #    if a prefix of R has remainder b, \\n        #    when multiplied by whole-L, becomes (prodL * b)%k\\n        for b in range(k):\\n            if cntR[b]:\\n                t = (prodL * b) % k\\n                cnt[t] += cntR[b]\\n        return (prod, cnt)\\n\\n    def point_update(self, pos, value):\\n        \\\"\\\"\\\"\\n        Set data[pos] = value, and update up the tree.\\n        \\\"\\\"\\\"\\n        k = self.k\\n        i = self.size + pos\\n        pv = value % k\\n        cnt = [0]*k\\n        cnt[pv] = 1\\n        self.tree[i] = (pv, cnt)\\n        # climb\\n        i //= 2\\n        while i:\\n            self.tree[i] = self._merge(self.tree[2*i], self.tree[2*i+1])\\n            i //= 2\\n\\n    def range_query(self, left, right):\\n        \\\"\\\"\\\"\\n        Query the merged node for interval [left..right], inclusive.\\n        \\\"\\\"\\\"\\n        k = self.k\\n        # We'll merge from left to right, so we keep two accumulators:\\n        # one for the result built so far (res_prod, res_cnt),\\n        # initially empty segment: prod=1, cnt=zeros\\n        res_prod, res_cnt = 1, [0]*k\\n        # We'll do the standard two-pointer on the segment tree:\\n        l = left + self.size\\n        r = right + self.size\\n        # To preserve order, we need to collect the nodes in two lists:\\n        left_nodes = []\\n        right_nodes = []\\n        while l <= r:\\n            if (l & 1) == 1:\\n                left_nodes.append(l)\\n                l += 1\\n            if (r & 1) == 0:\\n                right_nodes.append(r)\\n                r -= 1\\n            l //= 2; r //= 2\\n        # First merge all left_nodes in order, then right_nodes in reverse order:\\n        for idx in left_nodes + right_nodes[::-1]:\\n            node_prod, node_cnt = self.tree[idx]\\n            # merge (res_prod, res_cnt) with this node:\\n            # new_prod = res_prod * node_prod\\n            new_cnt = [0]*k\\n            # prefixes entirely in accumulated\\n            for t in range(k):\\n                new_cnt[t] += res_cnt[t]\\n            # prefixes that cross into the new node:\\n            for b in range(k):\\n                if node_cnt[b]:\\n                    t = (res_prod * b) % k\\n                    new_cnt[t] += node_cnt[b]\\n            res_prod = (res_prod * node_prod) % k\\n            res_cnt = new_cnt\\n        return res_prod, res_cnt\\n\\nclass Solution(object):\\n    def resultArray(self, nums, k, queries):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        st = SegmentTree(nums, k)\\n        ans = []\\n        for idx, val, start, x in queries:\\n            # 1) persistent update\\n            st.point_update(idx, val)\\n            # 2) query suffix [start..n-1]\\n            _, cnt = st.range_query(start, len(nums)-1)\\n            # number of prefixes whose product ≡ x mod k\\n            ans.append(cnt[x])\\n        return ans\\n\"",
  "2836_14631217_python-updated-time": "1747220963660",
  "1603_14631217_python-updated-time": "1746432638611",
  "3025_14631217_python": "\"class Solution(object):\\n    def minOperations(self, nums, target):\\n        # Count of coins 2^k in nums\\n        cnt = [0] * 31\\n        for x in nums:\\n            k = x.bit_length() - 1\\n            cnt[k] += 1\\n\\n        ops = 0\\n        for i in range(31):\\n            if (target >> i) & 1:\\n                # we need one 2^i\\n                if cnt[i] > 0:\\n                    cnt[i] -= 1\\n                else:\\n                    # find next larger coin to split\\n                    j = i + 1\\n                    while j < 31 and cnt[j] == 0:\\n                        j += 1\\n                    if j == 31:\\n                        return -1\\n                    # split down from j to i\\n                    while j > i:\\n                        cnt[j] -= 1\\n                        cnt[j - 1] += 2\\n                        ops += 1\\n                        j -= 1\\n                    cnt[i] -= 1  # use the newly created 2^i\\n            # after satisfying bit i, merge surplus small coins upward\\n            if i < 30:\\n                cnt[i + 1] += cnt[i] // 2\\n\\n        return ops\\n\"",
  "2235_14631217_python": "\"class Solution:\\n    def capitalizeTitle(self, title):\\n        words = title.split()\\n        for i in range(len(words)):\\n            if len(words[i]) <= 2:\\n                words[i] = words[i].lower()\\n            else:\\n                words[i] = words[i][0].upper() + words[i][1:].lower()\\n        return ' '.join(words)\\n\"",
  "1611_14631217_python": "\"class Solution(object):\\n    def getFolderNames(self, names):\\n        \\\"\\\"\\\"\\n        :type names: List[str]\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        name_map = {}\\n        result = []\\n\\n        for name in names:\\n            if name not in name_map:\\n                name_map[name] = 1\\n                result.append(name)\\n            else:\\n                k = name_map[name]\\n                while True:\\n                    new_name = \\\"%s(%d)\\\" % (name, k)\\n                    if new_name not in name_map:\\n                        break\\n                    k += 1\\n                result.append(new_name)\\n                name_map[name] = k + 1\\n                name_map[new_name] = 1\\n\\n        return result\\n\"",
  "3298_14631217_python": "\"class Solution(object):\\n    def maxSelectedElements(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        dp = {}           # dp[v] = max run‐length ending at v\\n        ans = 0\\n        for x in nums:\\n            # lengths of the best run if we place this element at x or at x+1:\\n            without_bump = dp.get(x-1, 0) + 1\\n            with_bump    = dp.get(x,   0) + 1\\n\\n            # update dp[x]  (no bump)\\n            if without_bump > dp.get(x, 0):\\n                dp[x] = without_bump\\n            # update dp[x+1]  (bump by 1)\\n            if with_bump > dp.get(x+1, 0):\\n                dp[x+1] = with_bump\\n\\n            # track global best\\n            ans = max(ans, dp[x], dp[x+1])\\n\\n        return ans\\n\"",
  "2429_14631217_python-updated-time": "1746907864826",
  "1784_14631217_python": "\"class Solution:\\n    def minimumEffort(self, tasks):\\n        # Sort by (minimum - actual) descending\\n        tasks.sort(key=lambda t: t[1] - t[0], reverse=True)\\n        \\n        initial = 0\\n        curr = 0\\n        for actual, minimum in tasks:\\n            if curr < minimum:\\n                initial += (minimum - curr)\\n                curr = minimum\\n            curr -= actual\\n        \\n        return initial\\n\"",
  "3226_14631217_python": "\"class Solution(object):\\n    def numberGame(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \\\"\\\"\\\"\\n        nums.sort()\\n        arr = []\\n        while nums:\\n            # Alice removes min\\n            alice = nums.pop(0)\\n            # Bob removes new min\\n            bob = nums.pop(0)\\n            # Bob appends first, then Alice\\n            arr.append(bob)\\n            arr.append(alice)\\n        return arr\\n\"",
  "2575_14631217_python": "\"class Solution:\\n    def numberOfCuts(self, n):\\n        # Special case: one slice needs no cuts\\n        if n == 1:\\n            return 0\\n        # For even n, each diameter cut creates two slice boundaries\\n        if n % 2 == 0:\\n            return n // 2\\n        # For odd n > 1, only radial cuts are possible\\n        return n\\n\"",
  "2705_14631217_python-updated-time": "1747065632496",
  "864_14631217_python": "\"class Solution(object):\\n    def largestOverlap(self, img1, img2):\\n        n = len(img1)\\n        ones1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\\n        ones2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\\n\\n        counter = {}\\n        for (i1, j1) in ones1:\\n            for (i2, j2) in ones2:\\n                delta = (i2 - i1, j2 - j1)\\n                counter[delta] = counter.get(delta, 0) + 1\\n\\n        return max(counter.values() or [0])\\n\"",
  "1312_14631217_python": "\"class Solution(object):\\n    def digArtifacts(self, n, artifacts, dig):\\n        dug = set(map(tuple, dig))\\n        ans = 0\\n        for r1, c1, r2, c2 in artifacts:\\n            ok = True\\n            for r in xrange(r1, r2 + 1):\\n                for c in xrange(c1, c2 + 1):\\n                    if (r, c) not in dug:\\n                        ok = False\\n                        break\\n                if not ok:\\n                    break\\n            if ok:\\n                ans += 1\\n        return ans\\n\"",
  "916_14631217_python": "\"class Solution(object):\\n    def decodeAtIndex(self, s, k):\\n        size = 0\\n\\n        # First pass: compute the total length of the decoded string\\n        for ch in s:\\n            if ch.isdigit():\\n                size *= int(ch)\\n            else:\\n                size += 1\\n\\n        # Second pass: work backwards to find the k-th character\\n        for i in reversed(range(len(s))):\\n            ch = s[i]\\n            k %= size\\n            if k == 0 and ch.isalpha():\\n                return ch\\n            if ch.isdigit():\\n                size //= int(ch)\\n            else:\\n                size -= 1\\n\"",
  "1743_14631217_python": "\"class Solution:\\n    def countSubstrings(self, s, t):\\n        m, n = len(s), len(t)\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                mismatch = 0\\n                k = 0\\n                # Extend substring as long as we have at most one mismatch\\n                while i + k < m and j + k < n:\\n                    if s[i+k] != t[j+k]:\\n                        mismatch += 1\\n                    if mismatch > 1:\\n                        break\\n                    if mismatch == 1:\\n                        res += 1\\n                    k += 1\\n        return res\\n\"",
  "2543_14631217_python": "\"class Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        # Track per-creator data:\\n        # popularity[c] = total views\\n        # best_video[c] = (max_views, lex_smallest_id)\\n        popularity = {}\\n        best_video = {}\\n        \\n        for c, vid, v in zip(creators, ids, views):\\n            # Update total popularity\\n            popularity[c] = popularity.get(c, 0) + v\\n            \\n            # Update this creator's best video\\n            if c not in best_video:\\n                best_video[c] = (v, vid)\\n            else:\\n                mv, mid = best_video[c]\\n                if v > mv or (v == mv and vid < mid):\\n                    best_video[c] = (v, vid)\\n        \\n        # Find maximum popularity\\n        max_pop = max(popularity.values())\\n        \\n        # Collect all creators at that popularity\\n        ans = []\\n        for c, pop in popularity.items():\\n            if pop == max_pop:\\n                _, vid = best_video[c]\\n                ans.append([c, vid])\\n        \\n        return ans\\n\"",
  "451_14631217_python": "\"from collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, s):\\n        count = Counter(s)\\n        sorted_chars = sorted(count.items(), key=lambda x: -x[1])\\n        return ''.join(char * freq for char, freq in sorted_chars)\\n\"",
  "1965_14631217_python-updated-time": "1746544392184",
  "3070_14631217_pythondata": "\"import pandas as pd\\n\\ndef fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Given a DataFrame products with columns ['name', 'quantity', 'price'],\\n    fills missing values in 'quantity' with 0 and returns the DataFrame.\\n    \\\"\\\"\\\"\\n    products['quantity'] = products['quantity'].fillna(0).astype(int)\\n    return products\\n\"",
  "783_14631217_python": "\"class Solution(object):\\n    def searchBST(self, root, val):\\n        if not root:\\n            return None\\n        if root.val == val:\\n            return root\\n        elif val < root.val:\\n            return self.searchBST(root.left, val)\\n        else:\\n            return self.searchBST(root.right, val)\\n\"",
  "166_14631217_python-updated-time": "1745091436425",
  "1242_14631217_python-updated-time": "1746261101239",
  "1818_14631217_python-updated-time": "1746454125120",
  "3236_14631217_python": "\"class Solution(object):\\n    def missingInteger(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        # Find the longest sequential prefix\\n        total = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1] + 1:\\n                total += nums[i]\\n            else:\\n                break\\n\\n        # Use a set for fast lookup\\n        s = set(nums)\\n\\n        # Return the smallest x >= total that is not in the array\\n        while total in s:\\n            total += 1\\n        return total\\n\"",
  "2011_14631217_python-updated-time": "1746626265954",
  "118_14631217_python": "\"class Solution(object):\\n    def generate(self, numRows):\\n        \\\"\\\"\\\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \\\"\\\"\\\"\\n        res = []\\n        for i in range(numRows):\\n            row = [1] * (i + 1)\\n            for j in range(1, i):\\n                row[j] = res[i-1][j-1] + res[i-1][j]\\n            res.append(row)\\n        return res\\n\"",
  "404_14631217_python": "\"class Solution:\\n    def sumOfLeftLeaves(self, root):\\n        if not root:\\n            return 0\\n        \\n        total = 0\\n        if root.left:\\n            if not root.left.left and not root.left.right:\\n                total += root.left.val\\n            else:\\n                total += self.sumOfLeftLeaves(root.left)\\n        \\n        total += self.sumOfLeftLeaves(root.right)\\n        return total\\n\"",
  "3717_14631217_python": "\"import heapq\\nfrom collections import defaultdict\\n\\nclass SlidingMedian:\\n    \\\"\\\"\\\"Maintain median and total absolute‐deviation cost on a sliding window.\\\"\\\"\\\"\\n    def __init__(self):\\n        self.lo = []       # max‐heap (store negatives)\\n        self.hi = []       # min‐heap\\n        self.del_lo = defaultdict(int)\\n        self.del_hi = defaultdict(int)\\n        self.sz_lo = self.sz_hi = 0\\n        self.sum_lo = 0\\n        self.sum_hi = 0\\n\\n    def _prune(self, heap, to_del):\\n        while heap and to_del[heap[0]]>0:\\n            v = heap[0]\\n            to_del[v] -= 1\\n            heapq.heappop(heap)\\n\\n    def _rebalance(self):\\n        # want |lo| == |hi| or |lo| == |hi|+1\\n        if self.sz_lo > self.sz_hi + 1:\\n            v = -heapq.heappop(self.lo)\\n            self._prune(self.lo, self.del_lo)\\n            self.sum_lo -= v\\n            heapq.heappush(self.hi, v)\\n            self.sum_hi += v\\n            self.sz_lo -= 1\\n            self.sz_hi += 1\\n        elif self.sz_lo < self.sz_hi:\\n            v = heapq.heappop(self.hi)\\n            self._prune(self.hi, self.del_hi)\\n            self.sum_hi -= v\\n            heapq.heappush(self.lo, -v)\\n            self.sum_lo += v\\n            self.sz_hi -= 1\\n            self.sz_lo += 1\\n\\n    def add(self, x):\\n        if not self.lo or x <= -self.lo[0]:\\n            heapq.heappush(self.lo, -x)\\n            self.sum_lo += x\\n            self.sz_lo += 1\\n        else:\\n            heapq.heappush(self.hi, x)\\n            self.sum_hi += x\\n            self.sz_hi += 1\\n        self._rebalance()\\n\\n    def remove(self, x):\\n        # lazy‐delete x\\n        if x <= -self.lo[0]:\\n            self.del_lo[-x] += 1\\n            self.sum_lo -= x\\n            self.sz_lo -= 1\\n            self._prune(self.lo, self.del_lo)\\n        else:\\n            self.del_hi[x] += 1\\n            self.sum_hi -= x\\n            self.sz_hi -= 1\\n            self._prune(self.hi, self.del_hi)\\n        self._rebalance()\\n\\n    def cost(self):\\n        # median = -self.lo[0]\\n        med = -self.lo[0]\\n        # sum |v-med| = med*|lo| - sum_lo  +  sum_hi - med*|hi|\\n        return med*self.sz_lo - self.sum_lo + self.sum_hi - med*self.sz_hi\\n\\n\\nclass Solution(object):\\n    def minOperations(self, nums, x, k):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :type x: int\\n        :type k: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        m = n - x + 1\\n\\n        # 1) Sliding‐window cost[i] = min ops to make nums[i:i+x] all equal.\\n        slide = SlidingMedian()\\n        cost = [0]*m\\n\\n        # init window [0..x-1]\\n        for i in range(x):\\n            slide.add(nums[i])\\n        cost[0] = slide.cost()\\n\\n        for i in range(1, m):\\n            slide.remove(nums[i-1])\\n            slide.add(nums[i+x-1])\\n            cost[i] = slide.cost()\\n\\n        # 2) DP[j][i] = min cost to pick j windows among the first i (cost[0..i-1]).\\n        INF = 10**18\\n        prev = [0]*(m+1)      # dp[0][*] = 0\\n        curr = [INF]*(m+1)\\n\\n        for j in range(1, k+1):\\n            curr[0] = INF\\n            for i in range(1, m+1):\\n                # skip window i-1:\\n                res = curr[i-1]\\n                # take window i-1, previous j-1 windows end before i-x\\n                take = prev[max(0, i-x)] + cost[i-1]\\n                curr[i] = min(res, take)\\n            prev, curr = curr, prev\\n\\n        return prev[m]\\n\"",
  "3770_14631217_python": "\"class Solution(object):\\n    def generateString(self, str1, str2):\\n        n, m = len(str1), len(str2)\\n        L = n + m - 1\\n\\n        # 1) initialize word with None, then apply all 'T' constraints\\n        word = [None]*L\\n        for i, ch in enumerate(str1):\\n            if ch == 'T':\\n                for j, c in enumerate(str2):\\n                    pos = i + j\\n                    if word[pos] is None:\\n                        word[pos] = c\\n                    elif word[pos] != c:\\n                        return \\\"\\\"  # conflict\\n\\n        # 2) collect all F-window starts\\n        Fstarts = [i for i,ch in enumerate(str1) if ch=='F']\\n\\n        # 3) for each F-window, compute initial blanks & mismatch\\n        blanks   = {}\\n        mismatch = {}\\n        for i in Fstarts:\\n            b = 0\\n            mm = 0\\n            for j in range(m):\\n                c = word[i+j]\\n                if c is None:\\n                    b += 1\\n                elif c != str2[j]:\\n                    mm += 1\\n            # if fully forced match, impossible\\n            if b == 0 and mm == 0:\\n                return \\\"\\\"\\n            blanks[i], mismatch[i] = b, mm\\n\\n        # 4) precompute windows_of_pos\\n        windows_of_pos = [[] for _ in range(L)]\\n        for i in Fstarts:\\n            for j in range(m):\\n                windows_of_pos[i+j].append(i)\\n\\n        # 5) greedy fill remaining positions\\n        for p in range(L):\\n            if word[p] is not None:\\n                continue\\n            for c in \\\"abcdefghijklmnopqrstuvwxyz\\\":\\n                bad = False\\n                # test c for every F-window covering p\\n                for i in windows_of_pos[p]:\\n                    b = blanks[i]\\n                    mm = mismatch[i]\\n                    # if we would place c==str2[p-i] then we'd reduce blanks by 1\\n                    # and mismatch stays mm.  If that leaves b-1==0 and mm==0, full match!\\n                    if c == str2[p - i] and b == 1 and mm == 0:\\n                        bad = True\\n                        break\\n                if not bad:\\n                    # accept c\\n                    word[p] = c\\n                    for i in windows_of_pos[p]:\\n                        # update that window's blanks & mismatch\\n                        if c == str2[p - i]:\\n                            blanks[i] -= 1\\n                        else:\\n                            blanks[i] -= 1\\n                            mismatch[i] += 1\\n                    break\\n            else:\\n                # no letter worked\\n                return \\\"\\\"\\n\\n        # 6) final check (should already pass)\\n        for i in Fstarts:\\n            if blanks[i] == 0 and mismatch[i] == 0:\\n                return \\\"\\\"\\n\\n        return \\\"\\\".join(word)\\n\"",
  "2564_14631217_python-updated-time": "1746969203460"
}